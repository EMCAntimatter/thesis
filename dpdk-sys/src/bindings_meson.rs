#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

use crate::replacements::*;

/* automatically generated by rust-bindgen 0.59.2 */
#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const _PTHREAD_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &[u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _ALLOCA_H: u32 = 1;
pub const _CTYPE_H: u32 = 1;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const RTE_ARCH_X86: u32 = 1;
pub const RTE_ARCH_X86_64: u32 = 1;
pub const RTE_BASEBAND_ACC100: u32 = 1;
pub const RTE_BASEBAND_FPGA_5GNR_FEC: u32 = 1;
pub const RTE_BASEBAND_FPGA_LTE_FEC: u32 = 1;
pub const RTE_BASEBAND_LA12XX: u32 = 1;
pub const RTE_BASEBAND_NULL: u32 = 1;
pub const RTE_BASEBAND_TURBO_SW: u32 = 1;
pub const RTE_BUS_AUXILIARY: u32 = 1;
pub const RTE_BUS_DPAA: u32 = 1;
pub const RTE_BUS_FSLMC: u32 = 1;
pub const RTE_BUS_IFPGA: u32 = 1;
pub const RTE_BUS_PCI: u32 = 1;
pub const RTE_BUS_VDEV: u32 = 1;
pub const RTE_BUS_VMBUS: u32 = 1;
pub const RTE_CACHE_LINE_SIZE: u32 = 64;
pub const RTE_COMMON_CNXK: u32 = 1;
pub const RTE_COMMON_CPT: u32 = 1;
pub const RTE_COMMON_DPAAX: u32 = 1;
pub const RTE_COMMON_IAVF: u32 = 1;
pub const RTE_COMMON_MLX5: u32 = 1;
pub const RTE_COMMON_OCTEONTX: u32 = 1;
pub const RTE_COMMON_QAT: u32 = 1;
pub const RTE_COMMON_SFC_EFX: u32 = 1;
pub const RTE_COMPRESS_MLX5: u32 = 1;
pub const RTE_COMPRESS_OCTEONTX: u32 = 1;
pub const RTE_COMPRESS_ZLIB: u32 = 1;
pub const RTE_CRYPTO_BCMFS: u32 = 1;
pub const RTE_CRYPTO_CAAM_JR: u32 = 1;
pub const RTE_CRYPTO_CCP: u32 = 1;
pub const RTE_CRYPTO_CNXK: u32 = 1;
pub const RTE_CRYPTO_DPAA2_SEC: u32 = 1;
pub const RTE_CRYPTO_DPAA_SEC: u32 = 1;
pub const RTE_CRYPTO_MLX5: u32 = 1;
pub const RTE_CRYPTO_NITROX: u32 = 1;
pub const RTE_CRYPTO_NULL: u32 = 1;
pub const RTE_CRYPTO_OCTEONTX: u32 = 1;
pub const RTE_CRYPTO_OPENSSL: u32 = 1;
pub const RTE_CRYPTO_SCHEDULER: u32 = 1;
pub const RTE_CRYPTO_VIRTIO: u32 = 1;
pub const RTE_DMA_CNXK: u32 = 1;
pub const RTE_DMA_DPAA: u32 = 1;
pub const RTE_DMA_HISILICON: u32 = 1;
pub const RTE_DMA_IDXD: u32 = 1;
pub const RTE_DMA_IOAT: u32 = 1;
pub const RTE_DMA_SKELETON: u32 = 1;
pub const RTE_DRIVER_MEMPOOL_BUCKET_SIZE_KB: u32 = 64;
pub const RTE_EAL_NUMA_AWARE_HUGEPAGES: u32 = 1;
pub const RTE_EAL_PMD_PATH: &[u8; 47usize] = b"/usr/local/lib/x86_64-linux-gnu/dpdk/pmds-22.1\0";
pub const RTE_ENV_FREEBSD: u32 = 0;
pub const RTE_ENV_LINUX: u32 = 1;
pub const RTE_ENV_WINDOWS: u32 = 2;
pub const RTE_EVENT_CNXK: u32 = 1;
pub const RTE_EVENT_DLB2: u32 = 1;
pub const RTE_EVENT_DPAA: u32 = 1;
pub const RTE_EVENT_DPAA2: u32 = 1;
pub const RTE_EVENT_DSW: u32 = 1;
pub const RTE_EVENT_OCTEONTX: u32 = 1;
pub const RTE_EVENT_OPDL: u32 = 1;
pub const RTE_EVENT_SKELETON: u32 = 1;
pub const RTE_EVENT_SW: u32 = 1;
pub const RTE_EXEC_ENV: u32 = 1;
pub const RTE_EXEC_ENV_IS_FREEBSD: u32 = 0;
pub const RTE_EXEC_ENV_IS_LINUX: u32 = 1;
pub const RTE_EXEC_ENV_IS_WINDOWS: u32 = 0;
pub const RTE_EXEC_ENV_LINUX: u32 = 1;
pub const RTE_HAS_LIBNUMA: u32 = 1;
pub const RTE_HAS_LIBPCAP: u32 = 1;
pub const RTE_LIBRTE_BPF_ELF: u32 = 1;
pub const RTE_LIBRTE_VHOST_NUMA: u32 = 1;
pub const RTE_LIB_ACL: u32 = 1;
pub const RTE_LIB_BBDEV: u32 = 1;
pub const RTE_LIB_BITRATESTATS: u32 = 1;
pub const RTE_LIB_BPF: u32 = 1;
pub const RTE_LIB_CFGFILE: u32 = 1;
pub const RTE_LIB_CMDLINE: u32 = 1;
pub const RTE_LIB_COMPRESSDEV: u32 = 1;
pub const RTE_LIB_CRYPTODEV: u32 = 1;
pub const RTE_LIB_DISTRIBUTOR: u32 = 1;
pub const RTE_LIB_DMADEV: u32 = 1;
pub const RTE_LIB_EAL: u32 = 1;
pub const RTE_LIB_EFD: u32 = 1;
pub const RTE_LIB_ETHDEV: u32 = 1;
pub const RTE_LIB_EVENTDEV: u32 = 1;
pub const RTE_LIB_FIB: u32 = 1;
pub const RTE_LIB_FLOW_CLASSIFY: u32 = 1;
pub const RTE_LIB_GPUDEV: u32 = 1;
pub const RTE_LIB_GRAPH: u32 = 1;
pub const RTE_LIB_GRO: u32 = 1;
pub const RTE_LIB_GSO: u32 = 1;
pub const RTE_LIB_HASH: u32 = 1;
pub const RTE_LIB_IPSEC: u32 = 1;
pub const RTE_LIB_IP_FRAG: u32 = 1;
pub const RTE_LIB_JOBSTATS: u32 = 1;
pub const RTE_LIB_KNI: u32 = 1;
pub const RTE_LIB_KVARGS: u32 = 1;
pub const RTE_LIB_LATENCYSTATS: u32 = 1;
pub const RTE_LIB_LPM: u32 = 1;
pub const RTE_LIB_MBUF: u32 = 1;
pub const RTE_LIB_MEMBER: u32 = 1;
pub const RTE_LIB_MEMPOOL: u32 = 1;
pub const RTE_LIB_METER: u32 = 1;
pub const RTE_LIB_METRICS: u32 = 1;
pub const RTE_LIB_NET: u32 = 1;
pub const RTE_LIB_NODE: u32 = 1;
pub const RTE_LIB_PCAPNG: u32 = 1;
pub const RTE_LIB_PCI: u32 = 1;
pub const RTE_LIB_PDUMP: u32 = 1;
pub const RTE_LIB_PIPELINE: u32 = 1;
pub const RTE_LIB_PORT: u32 = 1;
pub const RTE_LIB_POWER: u32 = 1;
pub const RTE_LIB_RAWDEV: u32 = 1;
pub const RTE_LIB_RCU: u32 = 1;
pub const RTE_LIB_REGEXDEV: u32 = 1;
pub const RTE_LIB_REORDER: u32 = 1;
pub const RTE_LIB_RIB: u32 = 1;
pub const RTE_LIB_RING: u32 = 1;
pub const RTE_LIB_SCHED: u32 = 1;
pub const RTE_LIB_SECURITY: u32 = 1;
pub const RTE_LIB_STACK: u32 = 1;
pub const RTE_LIB_TABLE: u32 = 1;
pub const RTE_LIB_TELEMETRY: u32 = 1;
pub const RTE_LIB_TIMER: u32 = 1;
pub const RTE_LIB_VHOST: u32 = 1;
pub const RTE_MAX_ETHPORTS: u32 = 32;
pub const RTE_MAX_LCORE: u32 = 128;
pub const RTE_MAX_MEM_MB: u32 = 524288;
pub const RTE_MAX_NUMA_NODES: u32 = 32;
pub const RTE_MAX_VFIO_GROUPS: u32 = 64;
pub const RTE_MEMPOOL_BUCKET: u32 = 1;
pub const RTE_MEMPOOL_CNXK: u32 = 1;
pub const RTE_MEMPOOL_DPAA: u32 = 1;
pub const RTE_MEMPOOL_DPAA2: u32 = 1;
pub const RTE_MEMPOOL_OCTEONTX: u32 = 1;
pub const RTE_MEMPOOL_RING: u32 = 1;
pub const RTE_MEMPOOL_STACK: u32 = 1;
pub const RTE_NET_AF_PACKET: u32 = 1;
pub const RTE_NET_AF_XDP: u32 = 1;
pub const RTE_NET_ARK: u32 = 1;
pub const RTE_NET_ATLANTIC: u32 = 1;
pub const RTE_NET_AVP: u32 = 1;
pub const RTE_NET_AXGBE: u32 = 1;
pub const RTE_NET_BNX2X: u32 = 1;
pub const RTE_NET_BNXT: u32 = 1;
pub const RTE_NET_BOND: u32 = 1;
pub const RTE_NET_CNXK: u32 = 1;
pub const RTE_NET_CXGBE: u32 = 1;
pub const RTE_NET_DPAA: u32 = 1;
pub const RTE_NET_DPAA2: u32 = 1;
pub const RTE_NET_E1000: u32 = 1;
pub const RTE_NET_ENA: u32 = 1;
pub const RTE_NET_ENETC: u32 = 1;
pub const RTE_NET_ENETFEC: u32 = 1;
pub const RTE_NET_ENIC: u32 = 1;
pub const RTE_NET_FAILSAFE: u32 = 1;
pub const RTE_NET_FM10K: u32 = 1;
pub const RTE_NET_HINIC: u32 = 1;
pub const RTE_NET_HNS3: u32 = 1;
pub const RTE_NET_I40E: u32 = 1;
pub const RTE_NET_IAVF: u32 = 1;
pub const RTE_NET_ICE: u32 = 1;
pub const RTE_NET_IGC: u32 = 1;
pub const RTE_NET_IONIC: u32 = 1;
pub const RTE_NET_IXGBE: u32 = 1;
pub const RTE_NET_KNI: u32 = 1;
pub const RTE_NET_LIQUIDIO: u32 = 1;
pub const RTE_NET_MEMIF: u32 = 1;
pub const RTE_NET_MLX4: u32 = 1;
pub const RTE_NET_MLX5: u32 = 1;
pub const RTE_NET_NETVSC: u32 = 1;
pub const RTE_NET_NFP: u32 = 1;
pub const RTE_NET_NGBE: u32 = 1;
pub const RTE_NET_NULL: u32 = 1;
pub const RTE_NET_OCTEONTX: u32 = 1;
pub const RTE_NET_OCTEONTX_EP: u32 = 1;
pub const RTE_NET_PCAP: u32 = 1;
pub const RTE_NET_PFE: u32 = 1;
pub const RTE_NET_QEDE: u32 = 1;
pub const RTE_NET_RING: u32 = 1;
pub const RTE_NET_SFC: u32 = 1;
pub const RTE_NET_SOFTNIC: u32 = 1;
pub const RTE_NET_TAP: u32 = 1;
pub const RTE_NET_THUNDERX: u32 = 1;
pub const RTE_NET_TXGBE: u32 = 1;
pub const RTE_NET_VDEV_NETVSC: u32 = 1;
pub const RTE_NET_VHOST: u32 = 1;
pub const RTE_NET_VIRTIO: u32 = 1;
pub const RTE_NET_VMXNET3: u32 = 1;
pub const RTE_PORT_PCAP: u32 = 1;
pub const RTE_RAW_CNXK_BPHY: u32 = 1;
pub const RTE_RAW_CNXK_GPIO: u32 = 1;
pub const RTE_RAW_DPAA2_CMDIF: u32 = 1;
pub const RTE_RAW_DPAA2_QDMA: u32 = 1;
pub const RTE_RAW_NTB: u32 = 1;
pub const RTE_RAW_SKELETON: u32 = 1;
pub const RTE_REGEX_CN9K: u32 = 1;
pub const RTE_REGEX_MLX5: u32 = 1;
pub const RTE_TOOLCHAIN: &[u8; 4usize] = b"gcc\0";
pub const RTE_TOOLCHAIN_GCC: u32 = 1;
pub const RTE_USE_LIBBSD: u32 = 1;
pub const RTE_VDPA_IFC: u32 = 1;
pub const RTE_VDPA_MLX5: u32 = 1;
pub const RTE_VDPA_SFC: u32 = 1;
pub const RTE_VER_MINOR: u32 = 0;
pub const RTE_VER_MONTH: u32 = 3;
pub const RTE_VER_RELEASE: u32 = 99;
pub const RTE_VER_SUFFIX: &[u8; 1usize] = b"\0";
pub const RTE_VER_YEAR: u32 = 22;
pub const RTE_EXEC_ENV_LINUXAPP: u32 = 1;
pub const RTE_VER_PREFIX: &[u8; 5usize] = b"DPDK\0";
pub const RTE_MAX_HEAPS: u32 = 32;
pub const RTE_MAX_MEMSEG_LISTS: u32 = 128;
pub const RTE_MAX_MEMSEG_PER_LIST: u32 = 8192;
pub const RTE_MAX_MEM_MB_PER_LIST: u32 = 32768;
pub const RTE_MAX_MEMSEG_PER_TYPE: u32 = 32768;
pub const RTE_MAX_MEM_MB_PER_TYPE: u32 = 65536;
pub const RTE_MAX_MEMZONE: u32 = 2560;
pub const RTE_MAX_TAILQ: u32 = 32;
pub const RTE_BACKTRACE: u32 = 1;
pub const RTE_MAX_VFIO_CONTAINERS: u32 = 64;
pub const RTE_CONTIGMEM_MAX_NUM_BUFS: u32 = 64;
pub const RTE_CONTIGMEM_DEFAULT_NUM_BUFS: u32 = 1;
pub const RTE_CONTIGMEM_DEFAULT_BUF_SIZE: u32 = 536870912;
pub const RTE_MEMPOOL_CACHE_MAX_SIZE: u32 = 512;
pub const RTE_MBUF_DEFAULT_MEMPOOL_OPS: &[u8; 11usize] = b"ring_mp_mc\0";
pub const RTE_PKTMBUF_HEADROOM: u32 = 128;
pub const RTE_MAX_QUEUES_PER_PORT: u32 = 1024;
pub const RTE_ETHDEV_QUEUE_STAT_CNTRS: u32 = 16;
pub const RTE_ETHDEV_RXTX_CALLBACKS: u32 = 1;
pub const RTE_MAX_MULTI_HOST_CTRLS: u32 = 4;
pub const RTE_CRYPTO_MAX_DEVS: u32 = 64;
pub const RTE_CRYPTODEV_NAME_LEN: u32 = 64;
pub const RTE_CRYPTO_CALLBACKS: u32 = 1;
pub const RTE_COMPRESS_MAX_DEVS: u32 = 64;
pub const RTE_MAX_REGEXDEV_DEVS: u32 = 32;
pub const RTE_EVENT_MAX_DEVS: u32 = 16;
pub const RTE_EVENT_MAX_PORTS_PER_DEV: u32 = 255;
pub const RTE_EVENT_MAX_QUEUES_PER_DEV: u32 = 255;
pub const RTE_EVENT_TIMER_ADAPTER_NUM_MAX: u32 = 32;
pub const RTE_EVENT_ETH_INTR_RING_SIZE: u32 = 1024;
pub const RTE_EVENT_CRYPTO_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_EVENT_ETH_TX_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_RAWDEV_MAX_DEVS: u32 = 64;
pub const RTE_LIBRTE_IP_FRAG_MAX_FRAG: u32 = 8;
pub const RTE_MAX_LCORE_FREQS: u32 = 64;
pub const RTE_GRAPH_BURST_SIZE: u32 = 256;
pub const RTE_LIBRTE_GRAPH_STATS: u32 = 1;
pub const RTE_PMD_PACKET_PREFETCH: u32 = 1;
pub const RTE_PMD_QAT_MAX_PCI_DEVICES: u32 = 48;
pub const RTE_PMD_QAT_COMP_SGL_MAX_SEGMENTS: u32 = 16;
pub const RTE_PMD_QAT_COMP_IM_BUFFER_SIZE: u32 = 65536;
pub const RTE_MAX_VIRTIO_CRYPTO: u32 = 32;
pub const RTE_LIBRTE_DPAA_MAX_CRYPTODEV: u32 = 4;
pub const RTE_LIBRTE_FM10K_RX_OLFLAGS_ENABLE: u32 = 1;
pub const RTE_LIBRTE_HNS3_MAX_TQP_NUM_PER_PF: u32 = 256;
pub const RTE_LIBRTE_I40E_RX_ALLOW_BULK_ALLOC: u32 = 1;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_PF: u32 = 64;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VF: u32 = 4;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VM: u32 = 4;
pub const RTE_PMD_RING_MAX_RX_RINGS: u32 = 16;
pub const RTE_PMD_RING_MAX_TX_RINGS: u32 = 16;
pub const RTE_LIBRTE_QEDE_FW: &[u8; 1usize] = b"\0";
pub const RTE_CC_IS_GNU: u32 = 0;
pub const RTE_PRIORITY_LOG: u32 = 101;
pub const RTE_PRIORITY_BUS: u32 = 110;
pub const RTE_PRIORITY_CLASS: u32 = 120;
pub const RTE_PRIORITY_LAST: u32 = 65535;
pub const RTE_CACHE_LINE_MASK: u32 = 63;
pub const RTE_CACHE_LINE_SIZE_LOG2: u32 = 6;
pub const RTE_CACHE_LINE_MIN_SIZE: u32 = 64;
pub const RTE_LOGTYPE_EAL: u32 = 0;
pub const RTE_LOGTYPE_MALLOC: u32 = 1;
pub const RTE_LOGTYPE_RING: u32 = 2;
pub const RTE_LOGTYPE_MEMPOOL: u32 = 3;
pub const RTE_LOGTYPE_TIMER: u32 = 4;
pub const RTE_LOGTYPE_PMD: u32 = 5;
pub const RTE_LOGTYPE_HASH: u32 = 6;
pub const RTE_LOGTYPE_LPM: u32 = 7;
pub const RTE_LOGTYPE_KNI: u32 = 8;
pub const RTE_LOGTYPE_ACL: u32 = 9;
pub const RTE_LOGTYPE_POWER: u32 = 10;
pub const RTE_LOGTYPE_METER: u32 = 11;
pub const RTE_LOGTYPE_SCHED: u32 = 12;
pub const RTE_LOGTYPE_PORT: u32 = 13;
pub const RTE_LOGTYPE_TABLE: u32 = 14;
pub const RTE_LOGTYPE_PIPELINE: u32 = 15;
pub const RTE_LOGTYPE_MBUF: u32 = 16;
pub const RTE_LOGTYPE_CRYPTODEV: u32 = 17;
pub const RTE_LOGTYPE_EFD: u32 = 18;
pub const RTE_LOGTYPE_EVENTDEV: u32 = 19;
pub const RTE_LOGTYPE_GSO: u32 = 20;
pub const RTE_LOGTYPE_USER1: u32 = 24;
pub const RTE_LOGTYPE_USER2: u32 = 25;
pub const RTE_LOGTYPE_USER3: u32 = 26;
pub const RTE_LOGTYPE_USER4: u32 = 27;
pub const RTE_LOGTYPE_USER5: u32 = 28;
pub const RTE_LOGTYPE_USER6: u32 = 29;
pub const RTE_LOGTYPE_USER7: u32 = 30;
pub const RTE_LOGTYPE_USER8: u32 = 31;
pub const RTE_LOGTYPE_FIRST_EXT_ID: u32 = 32;
pub const RTE_LOG_EMERG: u32 = 1;
pub const RTE_LOG_ALERT: u32 = 2;
pub const RTE_LOG_CRIT: u32 = 3;
pub const RTE_LOG_ERR: u32 = 4;
pub const RTE_LOG_WARNING: u32 = 5;
pub const RTE_LOG_NOTICE: u32 = 6;
pub const RTE_LOG_INFO: u32 = 7;
pub const RTE_LOG_DEBUG: u32 = 8;
pub const RTE_LOG_MAX: u32 = 8;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const MPLOCKED: &[u8; 8usize] = b"lock ; \0";
pub const MS_PER_S: u32 = 1000;
pub const US_PER_S: u32 = 1000000;
pub const NS_PER_S: u32 = 1000000000;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const RTE_UUID_STRLEN: u32 = 37;
pub const __RTE_TRACE_EMIT_STRING_LEN_MAX: u32 = 32;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2usize] = b"l\0";
pub const PRId8: &[u8; 2usize] = b"d\0";
pub const PRId16: &[u8; 2usize] = b"d\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRId64: &[u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &[u8; 2usize] = b"d\0";
pub const PRIdFAST16: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &[u8; 3usize] = b"ld\0";
pub const PRIi8: &[u8; 2usize] = b"i\0";
pub const PRIi16: &[u8; 2usize] = b"i\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIi64: &[u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &[u8; 3usize] = b"li\0";
pub const PRIiFAST8: &[u8; 2usize] = b"i\0";
pub const PRIiFAST16: &[u8; 3usize] = b"li\0";
pub const PRIiFAST32: &[u8; 3usize] = b"li\0";
pub const PRIiFAST64: &[u8; 3usize] = b"li\0";
pub const PRIo8: &[u8; 2usize] = b"o\0";
pub const PRIo16: &[u8; 2usize] = b"o\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIo64: &[u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &[u8; 2usize] = b"o\0";
pub const PRIoFAST16: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &[u8; 3usize] = b"lo\0";
pub const PRIu8: &[u8; 2usize] = b"u\0";
pub const PRIu16: &[u8; 2usize] = b"u\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIu64: &[u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &[u8; 2usize] = b"u\0";
pub const PRIuFAST16: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &[u8; 3usize] = b"lu\0";
pub const PRIx8: &[u8; 2usize] = b"x\0";
pub const PRIx16: &[u8; 2usize] = b"x\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIx64: &[u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &[u8; 2usize] = b"x\0";
pub const PRIxFAST16: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &[u8; 3usize] = b"lx\0";
pub const PRIX8: &[u8; 2usize] = b"X\0";
pub const PRIX16: &[u8; 2usize] = b"X\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRIX64: &[u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &[u8; 2usize] = b"X\0";
pub const PRIXFAST16: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &[u8; 3usize] = b"lX\0";
pub const PRIdMAX: &[u8; 3usize] = b"ld\0";
pub const PRIiMAX: &[u8; 3usize] = b"li\0";
pub const PRIoMAX: &[u8; 3usize] = b"lo\0";
pub const PRIuMAX: &[u8; 3usize] = b"lu\0";
pub const PRIxMAX: &[u8; 3usize] = b"lx\0";
pub const PRIXMAX: &[u8; 3usize] = b"lX\0";
pub const PRIdPTR: &[u8; 3usize] = b"ld\0";
pub const PRIiPTR: &[u8; 3usize] = b"li\0";
pub const PRIoPTR: &[u8; 3usize] = b"lo\0";
pub const PRIuPTR: &[u8; 3usize] = b"lu\0";
pub const PRIxPTR: &[u8; 3usize] = b"lx\0";
pub const PRIXPTR: &[u8; 3usize] = b"lX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNd64: &[u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &[u8; 3usize] = b"ld\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNi64: &[u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &[u8; 3usize] = b"li\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3usize] = b"li\0";
pub const SCNiFAST32: &[u8; 3usize] = b"li\0";
pub const SCNiFAST64: &[u8; 3usize] = b"li\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNu64: &[u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &[u8; 3usize] = b"lu\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNo64: &[u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &[u8; 3usize] = b"lo\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNx64: &[u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &[u8; 3usize] = b"lx\0";
pub const SCNdMAX: &[u8; 3usize] = b"ld\0";
pub const SCNiMAX: &[u8; 3usize] = b"li\0";
pub const SCNoMAX: &[u8; 3usize] = b"lo\0";
pub const SCNuMAX: &[u8; 3usize] = b"lu\0";
pub const SCNxMAX: &[u8; 3usize] = b"lx\0";
pub const SCNdPTR: &[u8; 3usize] = b"ld\0";
pub const SCNiPTR: &[u8; 3usize] = b"li\0";
pub const SCNoPTR: &[u8; 3usize] = b"lo\0";
pub const SCNuPTR: &[u8; 3usize] = b"lu\0";
pub const SCNxPTR: &[u8; 3usize] = b"lx\0";
pub const _MM_FROUND_TO_NEAREST_INT: u32 = 0;
pub const _MM_FROUND_TO_NEG_INF: u32 = 1;
pub const _MM_FROUND_TO_POS_INF: u32 = 2;
pub const _MM_FROUND_TO_ZERO: u32 = 3;
pub const _MM_FROUND_CUR_DIRECTION: u32 = 4;
pub const _MM_FROUND_RAISE_EXC: u32 = 0;
pub const _MM_FROUND_NO_EXC: u32 = 8;
pub const _MM_FROUND_NINT: u32 = 0;
pub const _MM_FROUND_FLOOR: u32 = 1;
pub const _MM_FROUND_CEIL: u32 = 2;
pub const _MM_FROUND_TRUNC: u32 = 3;
pub const _MM_FROUND_RINT: u32 = 4;
pub const _MM_FROUND_NEARBYINT: u32 = 12;
pub const _SIDD_UBYTE_OPS: u32 = 0;
pub const _SIDD_UWORD_OPS: u32 = 1;
pub const _SIDD_SBYTE_OPS: u32 = 2;
pub const _SIDD_SWORD_OPS: u32 = 3;
pub const _SIDD_CMP_EQUAL_ANY: u32 = 0;
pub const _SIDD_CMP_RANGES: u32 = 4;
pub const _SIDD_CMP_EQUAL_EACH: u32 = 8;
pub const _SIDD_CMP_EQUAL_ORDERED: u32 = 12;
pub const _SIDD_POSITIVE_POLARITY: u32 = 0;
pub const _SIDD_NEGATIVE_POLARITY: u32 = 16;
pub const _SIDD_MASKED_POSITIVE_POLARITY: u32 = 32;
pub const _SIDD_MASKED_NEGATIVE_POLARITY: u32 = 48;
pub const _SIDD_LEAST_SIGNIFICANT: u32 = 0;
pub const _SIDD_MOST_SIGNIFICANT: u32 = 64;
pub const _SIDD_BIT_MASK: u32 = 0;
pub const _SIDD_UNIT_MASK: u32 = 64;
pub const _CMP_EQ_OQ: u32 = 0;
pub const _CMP_LT_OS: u32 = 1;
pub const _CMP_LE_OS: u32 = 2;
pub const _CMP_UNORD_Q: u32 = 3;
pub const _CMP_NEQ_UQ: u32 = 4;
pub const _CMP_NLT_US: u32 = 5;
pub const _CMP_NLE_US: u32 = 6;
pub const _CMP_ORD_Q: u32 = 7;
pub const _CMP_EQ_UQ: u32 = 8;
pub const _CMP_NGE_US: u32 = 9;
pub const _CMP_NGT_US: u32 = 10;
pub const _CMP_FALSE_OQ: u32 = 11;
pub const _CMP_NEQ_OQ: u32 = 12;
pub const _CMP_GE_OS: u32 = 13;
pub const _CMP_GT_OS: u32 = 14;
pub const _CMP_TRUE_UQ: u32 = 15;
pub const _CMP_EQ_OS: u32 = 16;
pub const _CMP_LT_OQ: u32 = 17;
pub const _CMP_LE_OQ: u32 = 18;
pub const _CMP_UNORD_S: u32 = 19;
pub const _CMP_NEQ_US: u32 = 20;
pub const _CMP_NLT_UQ: u32 = 21;
pub const _CMP_NLE_UQ: u32 = 22;
pub const _CMP_ORD_S: u32 = 23;
pub const _CMP_EQ_US: u32 = 24;
pub const _CMP_NGE_UQ: u32 = 25;
pub const _CMP_NGT_UQ: u32 = 26;
pub const _CMP_FALSE_OS: u32 = 27;
pub const _CMP_NEQ_OS: u32 = 28;
pub const _CMP_GE_OQ: u32 = 29;
pub const _CMP_GT_OQ: u32 = 30;
pub const _CMP_TRUE_US: u32 = 31;
pub const _XBEGIN_STARTED: i32 = -1;
pub const _XABORT_EXPLICIT: u32 = 1;
pub const _XABORT_RETRY: u32 = 2;
pub const _XABORT_CONFLICT: u32 = 4;
pub const _XABORT_CAPACITY: u32 = 8;
pub const _XABORT_DEBUG: u32 = 16;
pub const _XABORT_NESTED: u32 = 32;
pub const __PCONFIG_KEY_PROGRAM: u32 = 1;
pub const _ASSERT_H: u32 = 1;
pub const RTE_DEV_NAME_MAX_LEN: u32 = 64;
pub const RTE_MAGIC: u32 = 19820526;
pub const RTE_MAX_THREAD_NAME_LEN: u32 = 16;
pub const RTE_MP_MAX_FD_NUM: u32 = 8;
pub const RTE_MP_MAX_NAME_LEN: u32 = 64;
pub const RTE_MP_MAX_PARAM_LEN: u32 = 256;
pub const LCORE_ID_ANY: u32 = 4294967295;
pub const _RTE_RTM_H_: u32 = 1;
pub const RTE_XBEGIN_STARTED: i32 = -1;
pub const RTE_XABORT_EXPLICIT: u32 = 1;
pub const RTE_XABORT_RETRY: u32 = 2;
pub const RTE_XABORT_CONFLICT: u32 = 4;
pub const RTE_XABORT_CAPACITY: u32 = 8;
pub const RTE_XABORT_DEBUG: u32 = 16;
pub const RTE_XABORT_NESTED: u32 = 32;
pub const RTE_RTM_MAX_RETRIES: u32 = 20;
pub const RTE_XABORT_LOCK_BUSY: u32 = 255;
pub const RTE_FBARRAY_NAME_LEN: u32 = 64;
pub const RTE_PGSIZE_4K: u32 = 4096;
pub const RTE_PGSIZE_64K: u32 = 65536;
pub const RTE_PGSIZE_256K: u32 = 262144;
pub const RTE_PGSIZE_2M: u32 = 2097152;
pub const RTE_PGSIZE_16M: u32 = 16777216;
pub const RTE_PGSIZE_256M: u32 = 268435456;
pub const RTE_PGSIZE_512M: u32 = 536870912;
pub const RTE_PGSIZE_1G: u32 = 1073741824;
pub const RTE_PGSIZE_4G: u64 = 4294967296;
pub const RTE_PGSIZE_16G: u64 = 17179869184;
pub const SOCKET_ID_ANY: i32 = -1;
pub const RTE_MEM_EVENT_CALLBACK_NAME_LEN: u32 = 64;
pub const RTE_MEM_ALLOC_VALIDATOR_NAME_LEN: u32 = 64;
pub const ALIGNMENT_MASK: u32 = 31;
pub const RTE_BIG_ENDIAN: u32 = 1;
pub const RTE_LITTLE_ENDIAN: u32 = 2;
pub const RTE_BYTE_ORDER: u32 = 2;
pub const __ELASTERROR: u32 = 1000;
pub const RTE_ACL_MAX_CATEGORIES: u32 = 16;
pub const RTE_ACL_MAX_LEVELS: u32 = 64;
pub const RTE_ACL_MAX_FIELDS: u32 = 64;
pub const RTE_ACL_NAMESIZE: u32 = 32;
pub const RTE_MEMZONE_2MB: u32 = 1;
pub const RTE_MEMZONE_1GB: u32 = 2;
pub const RTE_MEMZONE_16MB: u32 = 256;
pub const RTE_MEMZONE_16GB: u32 = 512;
pub const RTE_MEMZONE_256KB: u32 = 65536;
pub const RTE_MEMZONE_256MB: u32 = 131072;
pub const RTE_MEMZONE_512MB: u32 = 262144;
pub const RTE_MEMZONE_4GB: u32 = 524288;
pub const RTE_MEMZONE_SIZE_HINT_ONLY: u32 = 4;
pub const RTE_MEMZONE_IOVA_CONTIG: u32 = 1048576;
pub const RTE_MEMZONE_NAMESIZE: u32 = 32;
pub const RTE_TAILQ_RING_NAME: &[u8; 9usize] = b"RTE_RING\0";
pub const RTE_RING_MZ_PREFIX: &[u8; 4usize] = b"RG_\0";
pub const RING_F_SP_ENQ: u32 = 1;
pub const RING_F_SC_DEQ: u32 = 2;
pub const RING_F_EXACT_SZ: u32 = 4;
pub const RTE_RING_SZ_MASK: u32 = 2147483647;
pub const RING_F_MP_RTS_ENQ: u32 = 8;
pub const RING_F_MC_RTS_DEQ: u32 = 16;
pub const RING_F_MP_HTS_ENQ: u32 = 32;
pub const RING_F_MC_HTS_DEQ: u32 = 64;
pub const RTE_MEMPOOL_HEADER_COOKIE1: i64 = -4982197544707871147;
pub const RTE_MEMPOOL_HEADER_COOKIE2: i64 = -941548164385788331;
pub const RTE_MEMPOOL_TRAILER_COOKIE: i64 = -5921418378119291987;
pub const RTE_MEMPOOL_MZ_PREFIX: &[u8; 4usize] = b"MP_\0";
pub const RTE_MEMPOOL_MZ_FORMAT: &[u8; 6usize] = b"MP_%s\0";
pub const RTE_MEMPOOL_ALIGN: u32 = 64;
pub const RTE_MEMPOOL_ALIGN_MASK: u32 = 63;
pub const RTE_MEMPOOL_F_NO_SPREAD: u32 = 1;
pub const MEMPOOL_F_NO_SPREAD: u32 = 1;
pub const RTE_MEMPOOL_F_NO_CACHE_ALIGN: u32 = 2;
pub const MEMPOOL_F_NO_CACHE_ALIGN: u32 = 2;
pub const RTE_MEMPOOL_F_SP_PUT: u32 = 4;
pub const MEMPOOL_F_SP_PUT: u32 = 4;
pub const RTE_MEMPOOL_F_SC_GET: u32 = 8;
pub const MEMPOOL_F_SC_GET: u32 = 8;
pub const RTE_MEMPOOL_F_POOL_CREATED: u32 = 16;
pub const RTE_MEMPOOL_F_NO_IOVA_CONTIG: u32 = 32;
pub const MEMPOOL_F_NO_IOVA_CONTIG: u32 = 32;
pub const RTE_MEMPOOL_F_NON_IO: u32 = 64;
pub const RTE_MEMPOOL_VALID_USER_FLAGS: u32 = 47;
pub const RTE_MEMPOOL_OPS_NAMESIZE: u32 = 32;
pub const RTE_MEMPOOL_POPULATE_F_ALIGN_OBJ: u32 = 1;
pub const RTE_MEMPOOL_MAX_OPS_IDX: u32 = 16;
pub const RTE_PTYPE_UNKNOWN: u32 = 0;
pub const RTE_PTYPE_L2_ETHER: u32 = 1;
pub const RTE_PTYPE_L2_ETHER_TIMESYNC: u32 = 2;
pub const RTE_PTYPE_L2_ETHER_ARP: u32 = 3;
pub const RTE_PTYPE_L2_ETHER_LLDP: u32 = 4;
pub const RTE_PTYPE_L2_ETHER_NSH: u32 = 5;
pub const RTE_PTYPE_L2_ETHER_VLAN: u32 = 6;
pub const RTE_PTYPE_L2_ETHER_QINQ: u32 = 7;
pub const RTE_PTYPE_L2_ETHER_PPPOE: u32 = 8;
pub const RTE_PTYPE_L2_ETHER_FCOE: u32 = 9;
pub const RTE_PTYPE_L2_ETHER_MPLS: u32 = 10;
pub const RTE_PTYPE_L2_MASK: u32 = 15;
pub const RTE_PTYPE_L3_IPV4: u32 = 16;
pub const RTE_PTYPE_L3_IPV4_EXT: u32 = 48;
pub const RTE_PTYPE_L3_IPV6: u32 = 64;
pub const RTE_PTYPE_L3_IPV4_EXT_UNKNOWN: u32 = 144;
pub const RTE_PTYPE_L3_IPV6_EXT: u32 = 192;
pub const RTE_PTYPE_L3_IPV6_EXT_UNKNOWN: u32 = 224;
pub const RTE_PTYPE_L3_MASK: u32 = 240;
pub const RTE_PTYPE_L4_TCP: u32 = 256;
pub const RTE_PTYPE_L4_UDP: u32 = 512;
pub const RTE_PTYPE_L4_FRAG: u32 = 768;
pub const RTE_PTYPE_L4_SCTP: u32 = 1024;
pub const RTE_PTYPE_L4_ICMP: u32 = 1280;
pub const RTE_PTYPE_L4_NONFRAG: u32 = 1536;
pub const RTE_PTYPE_L4_IGMP: u32 = 1792;
pub const RTE_PTYPE_L4_MASK: u32 = 3840;
pub const RTE_PTYPE_TUNNEL_IP: u32 = 4096;
pub const RTE_PTYPE_TUNNEL_GRE: u32 = 8192;
pub const RTE_PTYPE_TUNNEL_VXLAN: u32 = 12288;
pub const RTE_PTYPE_TUNNEL_NVGRE: u32 = 16384;
pub const RTE_PTYPE_TUNNEL_GENEVE: u32 = 20480;
pub const RTE_PTYPE_TUNNEL_GRENAT: u32 = 24576;
pub const RTE_PTYPE_TUNNEL_GTPC: u32 = 28672;
pub const RTE_PTYPE_TUNNEL_GTPU: u32 = 32768;
pub const RTE_PTYPE_TUNNEL_ESP: u32 = 36864;
pub const RTE_PTYPE_TUNNEL_L2TP: u32 = 40960;
pub const RTE_PTYPE_TUNNEL_VXLAN_GPE: u32 = 45056;
pub const RTE_PTYPE_TUNNEL_MPLS_IN_GRE: u32 = 49152;
pub const RTE_PTYPE_TUNNEL_MPLS_IN_UDP: u32 = 53248;
pub const RTE_PTYPE_TUNNEL_MASK: u32 = 61440;
pub const RTE_PTYPE_INNER_L2_ETHER: u32 = 65536;
pub const RTE_PTYPE_INNER_L2_ETHER_VLAN: u32 = 131072;
pub const RTE_PTYPE_INNER_L2_ETHER_QINQ: u32 = 196608;
pub const RTE_PTYPE_INNER_L2_MASK: u32 = 983040;
pub const RTE_PTYPE_INNER_L3_IPV4: u32 = 1048576;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT: u32 = 2097152;
pub const RTE_PTYPE_INNER_L3_IPV6: u32 = 3145728;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT_UNKNOWN: u32 = 4194304;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT: u32 = 5242880;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT_UNKNOWN: u32 = 6291456;
pub const RTE_PTYPE_INNER_L3_MASK: u32 = 15728640;
pub const RTE_PTYPE_INNER_L4_TCP: u32 = 16777216;
pub const RTE_PTYPE_INNER_L4_UDP: u32 = 33554432;
pub const RTE_PTYPE_INNER_L4_FRAG: u32 = 50331648;
pub const RTE_PTYPE_INNER_L4_SCTP: u32 = 67108864;
pub const RTE_PTYPE_INNER_L4_ICMP: u32 = 83886080;
pub const RTE_PTYPE_INNER_L4_NONFRAG: u32 = 100663296;
pub const RTE_PTYPE_INNER_L4_MASK: u32 = 251658240;
pub const RTE_PTYPE_ALL_MASK: u32 = 268435455;
pub const RTE_MBUF_F_RX_VLAN: u32 = 1;
pub const RTE_MBUF_F_RX_RSS_HASH: u32 = 2;
pub const RTE_MBUF_F_RX_FDIR: u32 = 4;
pub const RTE_MBUF_F_RX_OUTER_IP_CKSUM_BAD: u32 = 32;
pub const RTE_MBUF_F_RX_VLAN_STRIPPED: u32 = 64;
pub const RTE_MBUF_F_RX_IP_CKSUM_MASK: u32 = 144;
pub const RTE_MBUF_F_RX_IP_CKSUM_UNKNOWN: u32 = 0;
pub const RTE_MBUF_F_RX_IP_CKSUM_BAD: u32 = 16;
pub const RTE_MBUF_F_RX_IP_CKSUM_GOOD: u32 = 128;
pub const RTE_MBUF_F_RX_IP_CKSUM_NONE: u32 = 144;
pub const RTE_MBUF_F_RX_L4_CKSUM_MASK: u32 = 264;
pub const RTE_MBUF_F_RX_L4_CKSUM_UNKNOWN: u32 = 0;
pub const RTE_MBUF_F_RX_L4_CKSUM_BAD: u32 = 8;
pub const RTE_MBUF_F_RX_L4_CKSUM_GOOD: u32 = 256;
pub const RTE_MBUF_F_RX_L4_CKSUM_NONE: u32 = 264;
pub const RTE_MBUF_F_RX_IEEE1588_PTP: u32 = 512;
pub const RTE_MBUF_F_RX_IEEE1588_TMST: u32 = 1024;
pub const RTE_MBUF_F_RX_FDIR_ID: u32 = 8192;
pub const RTE_MBUF_F_RX_FDIR_FLX: u32 = 16384;
pub const RTE_MBUF_F_RX_QINQ_STRIPPED: u32 = 32768;
pub const RTE_MBUF_F_RX_LRO: u32 = 65536;
pub const RTE_MBUF_F_RX_SEC_OFFLOAD: u32 = 262144;
pub const RTE_MBUF_F_RX_SEC_OFFLOAD_FAILED: u32 = 524288;
pub const RTE_MBUF_F_RX_QINQ: u32 = 1048576;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_MASK: u32 = 6291456;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_UNKNOWN: u32 = 0;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_BAD: u32 = 2097152;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_GOOD: u32 = 4194304;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_INVALID: u32 = 6291456;
pub const RTE_MBUF_F_FIRST_FREE: u32 = 8388608;
pub const RTE_MBUF_F_LAST_FREE: u64 = 1099511627776;
pub const RTE_MBUF_F_TX_OUTER_UDP_CKSUM: u64 = 2199023255552;
pub const RTE_MBUF_F_TX_UDP_SEG: u64 = 4398046511104;
pub const RTE_MBUF_F_TX_SEC_OFFLOAD: u64 = 8796093022208;
pub const RTE_MBUF_F_TX_MACSEC: u64 = 17592186044416;
pub const RTE_MBUF_F_TX_TUNNEL_VXLAN: u64 = 35184372088832;
pub const RTE_MBUF_F_TX_TUNNEL_GRE: u64 = 70368744177664;
pub const RTE_MBUF_F_TX_TUNNEL_IPIP: u64 = 105553116266496;
pub const RTE_MBUF_F_TX_TUNNEL_GENEVE: u64 = 140737488355328;
pub const RTE_MBUF_F_TX_TUNNEL_MPLSINUDP: u64 = 175921860444160;
pub const RTE_MBUF_F_TX_TUNNEL_VXLAN_GPE: u64 = 211106232532992;
pub const RTE_MBUF_F_TX_TUNNEL_GTP: u64 = 246290604621824;
pub const RTE_MBUF_F_TX_TUNNEL_ESP: u64 = 281474976710656;
pub const RTE_MBUF_F_TX_TUNNEL_IP: u64 = 457396837154816;
pub const RTE_MBUF_F_TX_TUNNEL_UDP: u64 = 492581209243648;
pub const RTE_MBUF_F_TX_TUNNEL_MASK: u64 = 527765581332480;
pub const RTE_MBUF_F_TX_QINQ: u64 = 562949953421312;
pub const RTE_MBUF_F_TX_TCP_SEG: u64 = 1125899906842624;
pub const RTE_MBUF_F_TX_IEEE1588_TMST: u64 = 2251799813685248;
pub const RTE_MBUF_F_TX_L4_NO_CKSUM: u32 = 0;
pub const RTE_MBUF_F_TX_TCP_CKSUM: u64 = 4503599627370496;
pub const RTE_MBUF_F_TX_SCTP_CKSUM: u64 = 9007199254740992;
pub const RTE_MBUF_F_TX_UDP_CKSUM: u64 = 13510798882111488;
pub const RTE_MBUF_F_TX_L4_MASK: u64 = 13510798882111488;
pub const RTE_MBUF_F_TX_IP_CKSUM: u64 = 18014398509481984;
pub const RTE_MBUF_F_TX_IPV4: u64 = 36028797018963968;
pub const RTE_MBUF_F_TX_IPV6: u64 = 72057594037927936;
pub const RTE_MBUF_F_TX_VLAN: u64 = 144115188075855872;
pub const RTE_MBUF_F_TX_OUTER_IP_CKSUM: u64 = 288230376151711744;
pub const RTE_MBUF_F_TX_OUTER_IPV4: u64 = 576460752303423488;
pub const RTE_MBUF_F_TX_OUTER_IPV6: u64 = 1152921504606846976;
pub const RTE_MBUF_F_TX_OFFLOAD_MASK: u64 = 2305840810190438400;
pub const RTE_MBUF_F_EXTERNAL: u64 = 2305843009213693952;
pub const RTE_MBUF_F_INDIRECT: u64 = 4611686018427387904;
pub const RTE_MBUF_PRIV_ALIGN: u32 = 8;
pub const RTE_MBUF_DEFAULT_DATAROOM: u32 = 2048;
pub const RTE_MBUF_DEFAULT_BUF_SIZE: u32 = 2176;
pub const RTE_MBUF_MAX_NB_SEGS: u32 = 65535;
pub const RTE_MBUF_PORT_INVALID: u32 = 65535;
pub const MBUF_INVALID_PORT: u32 = 65535;
pub const RTE_PKTMBUF_POOL_F_PINNED_EXT_BUF: u32 = 1;
pub const RTE_BBDEV_TURBO_C_SUBBLOCK: u32 = 32;
pub const RTE_BBDEV_TURBO_MAX_TB_SIZE: u32 = 391656;
pub const RTE_BBDEV_TURBO_MAX_CB_SIZE: u32 = 6144;
pub const RTE_BBDEV_LDPC_MAX_CB_SIZE: u32 = 8448;
pub const RTE_BBDEV_LDPC_MIN_CB_SIZE: u32 = 40;
pub const RTE_BBDEV_LDPC_E_MAX_MBUF: u32 = 64000;
pub const RTE_BBDEV_TURBO_MIN_CB_SIZE: u32 = 40;
pub const RTE_BBDEV_TURBO_MAX_KW: u32 = 18528;
pub const RTE_BBDEV_TURBO_MAX_CODE_BLOCKS: u32 = 64;
pub const RTE_BBDEV_LDPC_MAX_CODE_BLOCKS: u32 = 256;
pub const RTE_BBDEV_MAX_DEVS: u32 = 128;
pub const RTE_BBDEV_NAME_MAX_LEN: u32 = 64;
pub const RTE_BBDEV_DEFAULT_MAX_NB_QUEUES: u32 = 128;
pub const RTE_BBDEV_QUEUE_SIZE_LIMIT: u32 = 16384;
pub const RTE_BITMAP_SLAB_BIT_SIZE: u32 = 64;
pub const RTE_BITMAP_SLAB_BIT_SIZE_LOG2: u32 = 6;
pub const RTE_BITMAP_SLAB_BIT_MASK: u32 = 63;
pub const RTE_BITMAP_CL_BIT_SIZE: u32 = 512;
pub const RTE_BITMAP_CL_BIT_SIZE_LOG2: u32 = 9;
pub const RTE_BITMAP_CL_BIT_MASK: u32 = 511;
pub const RTE_BITMAP_CL_SLAB_SIZE: u32 = 8;
pub const RTE_BITMAP_CL_SLAB_SIZE_LOG2: u32 = 3;
pub const RTE_BITMAP_CL_SLAB_MASK: u32 = 7;
pub const CFG_NAME_LEN: u32 = 64;
pub const CFG_VALUE_LEN: u32 = 256;
pub const CFG_DEFAULT_COMMENT_CHARACTER: u8 = 59u8;
pub const RTE_COMP_FF_STATEFUL_COMPRESSION: u32 = 1;
pub const RTE_COMP_FF_STATEFUL_DECOMPRESSION: u32 = 2;
pub const RTE_COMP_FF_OOP_SGL_IN_SGL_OUT: u32 = 4;
pub const RTE_COMP_FF_OOP_SGL_IN_LB_OUT: u32 = 8;
pub const RTE_COMP_FF_OOP_LB_IN_SGL_OUT: u32 = 16;
pub const RTE_COMP_FF_ADLER32_CHECKSUM: u32 = 32;
pub const RTE_COMP_FF_CRC32_CHECKSUM: u32 = 64;
pub const RTE_COMP_FF_CRC32_ADLER32_CHECKSUM: u32 = 128;
pub const RTE_COMP_FF_MULTI_PKT_CHECKSUM: u32 = 256;
pub const RTE_COMP_FF_SHA1_HASH: u32 = 512;
pub const RTE_COMP_FF_SHA2_SHA256_HASH: u32 = 1024;
pub const RTE_COMP_FF_NONCOMPRESSED_BLOCKS: u32 = 2048;
pub const RTE_COMP_FF_SHAREABLE_PRIV_XFORM: u32 = 4096;
pub const RTE_COMP_FF_HUFFMAN_FIXED: u32 = 8192;
pub const RTE_COMP_FF_HUFFMAN_DYNAMIC: u32 = 16384;
pub const RTE_COMP_LEVEL_PMD_DEFAULT: i32 = -1;
pub const RTE_COMP_LEVEL_NONE: u32 = 0;
pub const RTE_COMP_LEVEL_MIN: u32 = 1;
pub const RTE_COMP_LEVEL_MAX: u32 = 9;
pub const RTE_COMPDEV_FF_HW_ACCELERATED: u32 = 1;
pub const RTE_COMPDEV_FF_CPU_SSE: u32 = 2;
pub const RTE_COMPDEV_FF_CPU_AVX: u32 = 4;
pub const RTE_COMPDEV_FF_CPU_AVX2: u32 = 8;
pub const RTE_COMPDEV_FF_CPU_AVX512: u32 = 16;
pub const RTE_COMPDEV_FF_CPU_NEON: u32 = 32;
pub const RTE_COMPDEV_FF_OP_DONE_IN_DEQUEUE: u32 = 64;
pub const RTE_DEVARGS_KEY_BUS: &[u8; 4usize] = b"bus\0";
pub const RTE_DEVARGS_KEY_CLASS: &[u8; 6usize] = b"class\0";
pub const RTE_DEVARGS_KEY_DRIVER: &[u8; 7usize] = b"driver\0";
pub const RTE_ETH_MODULE_SFF_8079: u32 = 1;
pub const RTE_ETH_MODULE_SFF_8079_LEN: u32 = 256;
pub const RTE_ETH_MODULE_SFF_8472: u32 = 2;
pub const RTE_ETH_MODULE_SFF_8472_LEN: u32 = 512;
pub const RTE_ETH_MODULE_SFF_8636: u32 = 3;
pub const RTE_ETH_MODULE_SFF_8636_LEN: u32 = 256;
pub const RTE_ETH_MODULE_SFF_8636_MAX_LEN: u32 = 640;
pub const RTE_ETH_MODULE_SFF_8436: u32 = 4;
pub const RTE_ETH_MODULE_SFF_8436_LEN: u32 = 256;
pub const RTE_ETH_MODULE_SFF_8436_MAX_LEN: u32 = 640;
pub const RTE_DMADEV_DEFAULT_MAX: u32 = 64;
pub const RTE_DMA_ALL_VCHAN: u32 = 65535;
pub const RTE_INTR_EVENT_ADD: u32 = 1;
pub const RTE_INTR_EVENT_DEL: u32 = 2;
pub const RTE_EPOLL_PER_THREAD: i32 = -1;
pub const RTE_MAX_RXTX_INTR_VEC_ID: u32 = 512;
pub const RTE_INTR_VEC_ZERO_OFFSET: u32 = 0;
pub const RTE_INTR_VEC_RXTX_OFFSET: u32 = 1;
pub const RTE_ECPRI_REV_UP_TO_20: u32 = 1;
pub const RTE_ECPRI_MSG_TYPE_IQ_DATA: u32 = 0;
pub const RTE_ECPRI_MSG_TYPE_BIT_SEQ: u32 = 1;
pub const RTE_ECPRI_MSG_TYPE_RTC_CTRL: u32 = 2;
pub const RTE_ECPRI_MSG_TYPE_GEN_DATA: u32 = 3;
pub const RTE_ECPRI_MSG_TYPE_RM_ACC: u32 = 4;
pub const RTE_ECPRI_MSG_TYPE_DLY_MSR: u32 = 5;
pub const RTE_ECPRI_MSG_TYPE_RMT_RST: u32 = 6;
pub const RTE_ECPRI_MSG_TYPE_EVT_IND: u32 = 7;
pub const RTE_ECPRI_MSG_TYPE_IWF_UP: u32 = 8;
pub const RTE_ECPRI_MSG_TYPE_IWF_OPT: u32 = 9;
pub const RTE_ECPRI_MSG_TYPE_IWF_MAP: u32 = 10;
pub const RTE_ECPRI_MSG_TYPE_IWF_DCTRL: u32 = 11;
pub const RTE_ECPRI_EVT_IND_FAULT_IND: u32 = 0;
pub const RTE_ECPRI_EVT_IND_FAULT_ACK: u32 = 1;
pub const RTE_ECPRI_EVT_IND_NTFY_IND: u32 = 2;
pub const RTE_ECPRI_EVT_IND_SYNC_REQ: u32 = 3;
pub const RTE_ECPRI_EVT_IND_SYNC_ACK: u32 = 4;
pub const RTE_ECPRI_EVT_IND_SYNC_END: u32 = 5;
pub const RTE_EFD_VALUE_NUM_BITS: u32 = 8;
pub const EFD_TARGET_GROUP_NUM_RULES: u32 = 22;
pub const EFD_MAX_GROUP_NUM_RULES: u32 = 28;
pub const EFD_MIN_BALANCED_NUM_RULES: u32 = 5;
pub const RTE_EFD_BURST_MAX: u32 = 32;
pub const RTE_EFD_NAMESIZE: u32 = 32;
pub const EFD_LOOKUPTBL_SHIFT: u32 = 28;
pub const RTE_EFD_UPDATE_WARN_GROUP_FULL: u32 = 1;
pub const RTE_EFD_UPDATE_NO_CHANGE: u32 = 2;
pub const RTE_EFD_UPDATE_FAILED: u32 = 3;
pub const RTE_L2TPV2_MSG_TYPE_CONTROL: u32 = 51202;
pub const RTE_L2TPV2_MSG_TYPE_DATA: u32 = 2;
pub const RTE_L2TPV2_MSG_TYPE_DATA_L: u32 = 16386;
pub const RTE_L2TPV2_MSG_TYPE_DATA_S: u32 = 2050;
pub const RTE_L2TPV2_MSG_TYPE_DATA_O: u32 = 514;
pub const RTE_L2TPV2_MSG_TYPE_DATA_L_S: u32 = 18434;
pub const RTE_L2TPV2_MSG_TYPE_DATA_L_O: u32 = 16898;
pub const RTE_L2TPV2_MSG_TYPE_DATA_S_O: u32 = 2562;
pub const RTE_L2TPV2_MSG_TYPE_DATA_L_S_O: u32 = 18946;
pub const RTE_ETHER_ADDR_LEN: u32 = 6;
pub const RTE_ETHER_TYPE_LEN: u32 = 2;
pub const RTE_ETHER_CRC_LEN: u32 = 4;
pub const RTE_ETHER_HDR_LEN: u32 = 14;
pub const RTE_ETHER_MIN_LEN: u32 = 64;
pub const RTE_ETHER_MAX_LEN: u32 = 1518;
pub const RTE_ETHER_MTU: u32 = 1500;
pub const RTE_VLAN_HLEN: u32 = 4;
pub const RTE_ETHER_MAX_VLAN_FRAME_LEN: u32 = 1522;
pub const RTE_ETHER_MAX_JUMBO_FRAME_LEN: u32 = 16128;
pub const RTE_ETHER_MAX_VLAN_ID: u32 = 4095;
pub const RTE_ETHER_MIN_MTU: u32 = 68;
pub const RTE_ETHER_LOCAL_ADMIN_ADDR: u32 = 2;
pub const RTE_ETHER_GROUP_ADDR: u32 = 1;
pub const RTE_ETHER_ADDR_PRT_FMT: &[u8; 30usize] = b"%02X:%02X:%02X:%02X:%02X:%02X\0";
pub const RTE_ETHER_ADDR_FMT_SIZE: u32 = 18;
pub const RTE_ETHER_TYPE_IPV4: u32 = 2048;
pub const RTE_ETHER_TYPE_IPV6: u32 = 34525;
pub const RTE_ETHER_TYPE_ARP: u32 = 2054;
pub const RTE_ETHER_TYPE_RARP: u32 = 32821;
pub const RTE_ETHER_TYPE_VLAN: u32 = 33024;
pub const RTE_ETHER_TYPE_QINQ: u32 = 34984;
pub const RTE_ETHER_TYPE_QINQ1: u32 = 37120;
pub const RTE_ETHER_TYPE_QINQ2: u32 = 37376;
pub const RTE_ETHER_TYPE_QINQ3: u32 = 37632;
pub const RTE_ETHER_TYPE_PPPOE_DISCOVERY: u32 = 34915;
pub const RTE_ETHER_TYPE_PPPOE_SESSION: u32 = 34916;
pub const RTE_ETHER_TYPE_ETAG: u32 = 35135;
pub const RTE_ETHER_TYPE_1588: u32 = 35063;
pub const RTE_ETHER_TYPE_SLOW: u32 = 34825;
pub const RTE_ETHER_TYPE_TEB: u32 = 25944;
pub const RTE_ETHER_TYPE_LLDP: u32 = 35020;
pub const RTE_ETHER_TYPE_MPLS: u32 = 34887;
pub const RTE_ETHER_TYPE_MPLSM: u32 = 34888;
pub const RTE_ETHER_TYPE_ECPRI: u32 = 44798;
pub const RTE_POWER_MONITOR_OPAQUE_SZ: u32 = 4;
pub const RTE_ETH_LINK_SPEED_AUTONEG: u32 = 0;
pub const RTE_ETH_SPEED_NUM_NONE: u32 = 0;
pub const RTE_ETH_SPEED_NUM_10M: u32 = 10;
pub const RTE_ETH_SPEED_NUM_100M: u32 = 100;
pub const RTE_ETH_SPEED_NUM_1G: u32 = 1000;
pub const RTE_ETH_SPEED_NUM_2_5G: u32 = 2500;
pub const RTE_ETH_SPEED_NUM_5G: u32 = 5000;
pub const RTE_ETH_SPEED_NUM_10G: u32 = 10000;
pub const RTE_ETH_SPEED_NUM_20G: u32 = 20000;
pub const RTE_ETH_SPEED_NUM_25G: u32 = 25000;
pub const RTE_ETH_SPEED_NUM_40G: u32 = 40000;
pub const RTE_ETH_SPEED_NUM_50G: u32 = 50000;
pub const RTE_ETH_SPEED_NUM_56G: u32 = 56000;
pub const RTE_ETH_SPEED_NUM_100G: u32 = 100000;
pub const RTE_ETH_SPEED_NUM_200G: u32 = 200000;
pub const RTE_ETH_SPEED_NUM_UNKNOWN: u32 = 4294967295;
pub const RTE_ETH_LINK_HALF_DUPLEX: u32 = 0;
pub const RTE_ETH_LINK_FULL_DUPLEX: u32 = 1;
pub const RTE_ETH_LINK_DOWN: u32 = 0;
pub const RTE_ETH_LINK_UP: u32 = 1;
pub const RTE_ETH_LINK_FIXED: u32 = 0;
pub const RTE_ETH_LINK_AUTONEG: u32 = 1;
pub const RTE_ETH_LINK_MAX_STR_LEN: u32 = 40;
pub const RTE_ETH_FLOW_UNKNOWN: u32 = 0;
pub const RTE_ETH_FLOW_RAW: u32 = 1;
pub const RTE_ETH_FLOW_IPV4: u32 = 2;
pub const RTE_ETH_FLOW_FRAG_IPV4: u32 = 3;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_TCP: u32 = 4;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_UDP: u32 = 5;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_SCTP: u32 = 6;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_OTHER: u32 = 7;
pub const RTE_ETH_FLOW_IPV6: u32 = 8;
pub const RTE_ETH_FLOW_FRAG_IPV6: u32 = 9;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_TCP: u32 = 10;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_UDP: u32 = 11;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_SCTP: u32 = 12;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_OTHER: u32 = 13;
pub const RTE_ETH_FLOW_L2_PAYLOAD: u32 = 14;
pub const RTE_ETH_FLOW_IPV6_EX: u32 = 15;
pub const RTE_ETH_FLOW_IPV6_TCP_EX: u32 = 16;
pub const RTE_ETH_FLOW_IPV6_UDP_EX: u32 = 17;
pub const RTE_ETH_FLOW_PORT: u32 = 18;
pub const RTE_ETH_FLOW_VXLAN: u32 = 19;
pub const RTE_ETH_FLOW_GENEVE: u32 = 20;
pub const RTE_ETH_FLOW_NVGRE: u32 = 21;
pub const RTE_ETH_FLOW_VXLAN_GPE: u32 = 22;
pub const RTE_ETH_FLOW_GTPU: u32 = 23;
pub const RTE_ETH_FLOW_MAX: u32 = 24;
pub const RTE_ETH_RSS_RETA_SIZE_64: u32 = 64;
pub const RTE_ETH_RSS_RETA_SIZE_128: u32 = 128;
pub const RTE_ETH_RSS_RETA_SIZE_256: u32 = 256;
pub const RTE_ETH_RSS_RETA_SIZE_512: u32 = 512;
pub const RTE_ETH_RETA_GROUP_SIZE: u32 = 64;
pub const RTE_ETH_VMDQ_MAX_VLAN_FILTERS: u32 = 64;
pub const RTE_ETH_DCB_NUM_USER_PRIORITIES: u32 = 8;
pub const RTE_ETH_VMDQ_DCB_NUM_QUEUES: u32 = 128;
pub const RTE_ETH_DCB_NUM_QUEUES: u32 = 128;
pub const RTE_ETH_VLAN_STRIP_OFFLOAD: u32 = 1;
pub const RTE_ETH_VLAN_FILTER_OFFLOAD: u32 = 2;
pub const RTE_ETH_VLAN_EXTEND_OFFLOAD: u32 = 4;
pub const RTE_ETH_QINQ_STRIP_OFFLOAD: u32 = 8;
pub const RTE_ETH_VLAN_STRIP_MASK: u32 = 1;
pub const RTE_ETH_VLAN_FILTER_MASK: u32 = 2;
pub const RTE_ETH_VLAN_EXTEND_MASK: u32 = 4;
pub const RTE_ETH_QINQ_STRIP_MASK: u32 = 8;
pub const RTE_ETH_VLAN_ID_MAX: u32 = 4095;
pub const RTE_ETH_NUM_RECEIVE_MAC_ADDR: u32 = 128;
pub const RTE_ETH_VMDQ_NUM_UC_HASH_ARRAY: u32 = 128;
pub const RTE_ETH_MAX_HAIRPIN_PEERS: u32 = 32;
pub const RTE_ARP_HRD_ETHER: u32 = 1;
pub const RTE_ARP_OP_REQUEST: u32 = 1;
pub const RTE_ARP_OP_REPLY: u32 = 2;
pub const RTE_ARP_OP_REVREQUEST: u32 = 3;
pub const RTE_ARP_OP_REVREPLY: u32 = 4;
pub const RTE_ARP_OP_INVREQUEST: u32 = 8;
pub const RTE_ARP_OP_INVREPLY: u32 = 9;
pub const RTE_IP_ICMP_ECHO_REPLY: u32 = 0;
pub const RTE_IP_ICMP_ECHO_REQUEST: u32 = 8;
pub const _SYS_SOCKET_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MAX: u32 = 45;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MAX: u32 = 45;
pub const SOL_RAW: u32 = 255;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOMAXCONN: u32 = 4096;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const __BITS_PER_LONG: u32 = 64;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP: u32 = 35078;
pub const SIOCGSTAMPNS: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO_OLD: u32 = 20;
pub const SO_SNDTIMEO_OLD: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_MARK: u32 = 36;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_TIMESTAMP_OLD: u32 = 29;
pub const SO_TIMESTAMPNS_OLD: u32 = 35;
pub const SO_TIMESTAMPING_OLD: u32 = 37;
pub const SO_TIMESTAMP_NEW: u32 = 63;
pub const SO_TIMESTAMPNS_NEW: u32 = 64;
pub const SO_TIMESTAMPING_NEW: u32 = 65;
pub const SO_RCVTIMEO_NEW: u32 = 66;
pub const SO_SNDTIMEO_NEW: u32 = 67;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const SO_TIMESTAMP: u32 = 29;
pub const SO_TIMESTAMPNS: u32 = 35;
pub const SO_TIMESTAMPING: u32 = 37;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_SNDTIMEO: u32 = 21;
pub const SCM_TIMESTAMP: u32 = 29;
pub const SCM_TIMESTAMPNS: u32 = 35;
pub const SCM_TIMESTAMPING: u32 = 37;
pub const __osockaddr_defined: u32 = 1;
pub const _NETINET_IN_H: u32 = 1;
pub const __USE_KERNEL_IPV6_DEFS: u32 = 0;
pub const IP_OPTIONS: u32 = 4;
pub const IP_HDRINCL: u32 = 3;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IP_RECVOPTS: u32 = 6;
pub const IP_RETOPTS: u32 = 7;
pub const IP_MULTICAST_IF: u32 = 32;
pub const IP_MULTICAST_TTL: u32 = 33;
pub const IP_MULTICAST_LOOP: u32 = 34;
pub const IP_ADD_MEMBERSHIP: u32 = 35;
pub const IP_DROP_MEMBERSHIP: u32 = 36;
pub const IP_UNBLOCK_SOURCE: u32 = 37;
pub const IP_BLOCK_SOURCE: u32 = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 40;
pub const IP_MSFILTER: u32 = 41;
pub const MCAST_JOIN_GROUP: u32 = 42;
pub const MCAST_BLOCK_SOURCE: u32 = 43;
pub const MCAST_UNBLOCK_SOURCE: u32 = 44;
pub const MCAST_LEAVE_GROUP: u32 = 45;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 47;
pub const MCAST_MSFILTER: u32 = 48;
pub const IP_MULTICAST_ALL: u32 = 49;
pub const IP_UNICAST_IF: u32 = 50;
pub const MCAST_EXCLUDE: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const IP_ROUTER_ALERT: u32 = 5;
pub const IP_PKTINFO: u32 = 8;
pub const IP_PKTOPTIONS: u32 = 9;
pub const IP_PMTUDISC: u32 = 10;
pub const IP_MTU_DISCOVER: u32 = 10;
pub const IP_RECVERR: u32 = 11;
pub const IP_RECVTTL: u32 = 12;
pub const IP_RECVTOS: u32 = 13;
pub const IP_MTU: u32 = 14;
pub const IP_FREEBIND: u32 = 15;
pub const IP_IPSEC_POLICY: u32 = 16;
pub const IP_XFRM_POLICY: u32 = 17;
pub const IP_PASSSEC: u32 = 18;
pub const IP_TRANSPARENT: u32 = 19;
pub const IP_ORIGDSTADDR: u32 = 20;
pub const IP_RECVORIGDSTADDR: u32 = 20;
pub const IP_MINTTL: u32 = 21;
pub const IP_NODEFRAG: u32 = 22;
pub const IP_CHECKSUM: u32 = 23;
pub const IP_BIND_ADDRESS_NO_PORT: u32 = 24;
pub const IP_RECVFRAGSIZE: u32 = 25;
pub const IP_PMTUDISC_DONT: u32 = 0;
pub const IP_PMTUDISC_WANT: u32 = 1;
pub const IP_PMTUDISC_DO: u32 = 2;
pub const IP_PMTUDISC_PROBE: u32 = 3;
pub const IP_PMTUDISC_INTERFACE: u32 = 4;
pub const IP_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IP: u32 = 0;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MAX_MEMBERSHIPS: u32 = 20;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_JOIN_GROUP: u32 = 20;
pub const IPV6_LEAVE_GROUP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_MULTICAST_ALL: u32 = 29;
pub const IPV6_ROUTER_ALERT_ISOLATE: u32 = 30;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_HDRINCL: u32 = 36;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_AUTOFLOWLABEL: u32 = 70;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ORIGDSTADDR: u32 = 74;
pub const IPV6_RECVORIGDSTADDR: u32 = 74;
pub const IPV6_TRANSPARENT: u32 = 75;
pub const IPV6_UNICAST_IF: u32 = 76;
pub const IPV6_RECVFRAGSIZE: u32 = 77;
pub const IPV6_FREEBIND: u32 = 78;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_RXHOPOPTS: u32 = 54;
pub const IPV6_RXDSTOPTS: u32 = 59;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const _ARPA_INET_H: u32 = 1;
pub const __NETINET_IP_H: u32 = 1;
pub const IP_RF: u32 = 32768;
pub const IP_DF: u32 = 16384;
pub const IP_MF: u32 = 8192;
pub const IP_OFFMASK: u32 = 8191;
pub const IPVERSION: u32 = 4;
pub const IP_MAXPACKET: u32 = 65535;
pub const IPTOS_ECN_MASK: u32 = 3;
pub const IPTOS_ECN_NOT_ECT: u32 = 0;
pub const IPTOS_ECN_ECT1: u32 = 1;
pub const IPTOS_ECN_ECT0: u32 = 2;
pub const IPTOS_ECN_CE: u32 = 3;
pub const IPTOS_DSCP_MASK: u32 = 252;
pub const IPTOS_DSCP_AF11: u32 = 40;
pub const IPTOS_DSCP_AF12: u32 = 48;
pub const IPTOS_DSCP_AF13: u32 = 56;
pub const IPTOS_DSCP_AF21: u32 = 72;
pub const IPTOS_DSCP_AF22: u32 = 80;
pub const IPTOS_DSCP_AF23: u32 = 88;
pub const IPTOS_DSCP_AF31: u32 = 104;
pub const IPTOS_DSCP_AF32: u32 = 112;
pub const IPTOS_DSCP_AF33: u32 = 120;
pub const IPTOS_DSCP_AF41: u32 = 136;
pub const IPTOS_DSCP_AF42: u32 = 144;
pub const IPTOS_DSCP_AF43: u32 = 152;
pub const IPTOS_DSCP_EF: u32 = 184;
pub const IPTOS_CLASS_MASK: u32 = 224;
pub const IPTOS_CLASS_CS0: u32 = 0;
pub const IPTOS_CLASS_CS1: u32 = 32;
pub const IPTOS_CLASS_CS2: u32 = 64;
pub const IPTOS_CLASS_CS3: u32 = 96;
pub const IPTOS_CLASS_CS4: u32 = 128;
pub const IPTOS_CLASS_CS5: u32 = 160;
pub const IPTOS_CLASS_CS6: u32 = 192;
pub const IPTOS_CLASS_CS7: u32 = 224;
pub const IPTOS_CLASS_DEFAULT: u32 = 0;
pub const IPTOS_TOS_MASK: u32 = 30;
pub const IPTOS_LOWDELAY: u32 = 16;
pub const IPTOS_THROUGHPUT: u32 = 8;
pub const IPTOS_RELIABILITY: u32 = 4;
pub const IPTOS_LOWCOST: u32 = 2;
pub const IPTOS_MINCOST: u32 = 2;
pub const IPTOS_PREC_MASK: u32 = 224;
pub const IPTOS_PREC_NETCONTROL: u32 = 224;
pub const IPTOS_PREC_INTERNETCONTROL: u32 = 192;
pub const IPTOS_PREC_CRITIC_ECP: u32 = 160;
pub const IPTOS_PREC_FLASHOVERRIDE: u32 = 128;
pub const IPTOS_PREC_FLASH: u32 = 96;
pub const IPTOS_PREC_IMMEDIATE: u32 = 64;
pub const IPTOS_PREC_PRIORITY: u32 = 32;
pub const IPTOS_PREC_ROUTINE: u32 = 0;
pub const IPOPT_COPY: u32 = 128;
pub const IPOPT_CLASS_MASK: u32 = 96;
pub const IPOPT_NUMBER_MASK: u32 = 31;
pub const IPOPT_CONTROL: u32 = 0;
pub const IPOPT_RESERVED1: u32 = 32;
pub const IPOPT_DEBMEAS: u32 = 64;
pub const IPOPT_MEASUREMENT: u32 = 64;
pub const IPOPT_RESERVED2: u32 = 96;
pub const IPOPT_EOL: u32 = 0;
pub const IPOPT_END: u32 = 0;
pub const IPOPT_NOP: u32 = 1;
pub const IPOPT_NOOP: u32 = 1;
pub const IPOPT_RR: u32 = 7;
pub const IPOPT_TS: u32 = 68;
pub const IPOPT_TIMESTAMP: u32 = 68;
pub const IPOPT_SECURITY: u32 = 130;
pub const IPOPT_SEC: u32 = 130;
pub const IPOPT_LSRR: u32 = 131;
pub const IPOPT_SATID: u32 = 136;
pub const IPOPT_SID: u32 = 136;
pub const IPOPT_SSRR: u32 = 137;
pub const IPOPT_RA: u32 = 148;
pub const IPOPT_OPTVAL: u32 = 0;
pub const IPOPT_OLEN: u32 = 1;
pub const IPOPT_OFFSET: u32 = 2;
pub const IPOPT_MINOFF: u32 = 4;
pub const MAX_IPOPTLEN: u32 = 40;
pub const IPOPT_TS_TSONLY: u32 = 0;
pub const IPOPT_TS_TSANDADDR: u32 = 1;
pub const IPOPT_TS_PRESPEC: u32 = 3;
pub const IPOPT_SECUR_UNCLASS: u32 = 0;
pub const IPOPT_SECUR_CONFID: u32 = 61749;
pub const IPOPT_SECUR_EFTO: u32 = 30874;
pub const IPOPT_SECUR_MMMM: u32 = 48205;
pub const IPOPT_SECUR_RESTR: u32 = 44819;
pub const IPOPT_SECUR_SECRET: u32 = 55176;
pub const IPOPT_SECUR_TOPSECRET: u32 = 27589;
pub const MAXTTL: u32 = 255;
pub const IPDEFTTL: u32 = 64;
pub const IPFRAGTTL: u32 = 60;
pub const IPTTLDEC: u32 = 1;
pub const IP_MSS: u32 = 576;
pub const _NETINET_IP6_H: u32 = 1;
pub const IP6F_OFF_MASK: u32 = 63743;
pub const IP6F_RESERVED_MASK: u32 = 1536;
pub const IP6F_MORE_FRAG: u32 = 256;
pub const IP6OPT_TYPE_SKIP: u32 = 0;
pub const IP6OPT_TYPE_DISCARD: u32 = 64;
pub const IP6OPT_TYPE_FORCEICMP: u32 = 128;
pub const IP6OPT_TYPE_ICMP: u32 = 192;
pub const IP6OPT_TYPE_MUTABLE: u32 = 32;
pub const IP6OPT_PAD1: u32 = 0;
pub const IP6OPT_PADN: u32 = 1;
pub const IP6OPT_JUMBO: u32 = 194;
pub const IP6OPT_NSAP_ADDR: u32 = 195;
pub const IP6OPT_TUNNEL_LIMIT: u32 = 4;
pub const IP6OPT_ROUTER_ALERT: u32 = 5;
pub const IP6OPT_JUMBO_LEN: u32 = 6;
pub const IP6_ALERT_MLD: u32 = 0;
pub const IP6_ALERT_RSVP: u32 = 256;
pub const IP6_ALERT_AN: u32 = 512;
pub const RTE_IPV4_MAX_PKT_LEN: u32 = 65535;
pub const RTE_IPV4_HDR_IHL_MASK: u32 = 15;
pub const RTE_IPV4_IHL_MULTIPLIER: u32 = 4;
pub const RTE_IPV4_HDR_DSCP_MASK: u32 = 252;
pub const RTE_IPV4_HDR_ECN_MASK: u32 = 3;
pub const RTE_IPV4_HDR_ECN_CE: u32 = 3;
pub const RTE_IPV4_HDR_DF_SHIFT: u32 = 14;
pub const RTE_IPV4_HDR_MF_SHIFT: u32 = 13;
pub const RTE_IPV4_HDR_FO_SHIFT: u32 = 3;
pub const RTE_IPV4_HDR_DF_FLAG: u32 = 16384;
pub const RTE_IPV4_HDR_MF_FLAG: u32 = 8192;
pub const RTE_IPV4_HDR_OFFSET_MASK: u32 = 8191;
pub const RTE_IPV4_HDR_OFFSET_UNITS: u32 = 8;
pub const RTE_IPV4_MIN_IHL: u32 = 5;
pub const RTE_IPV4_VHL_DEF: u32 = 69;
pub const RTE_IPV6_HDR_FL_SHIFT: u32 = 0;
pub const RTE_IPV6_HDR_TC_SHIFT: u32 = 20;
pub const RTE_IPV6_HDR_FL_MASK: u32 = 1048575;
pub const RTE_IPV6_HDR_TC_MASK: u32 = 267386880;
pub const RTE_IPV6_HDR_DSCP_MASK: u32 = 264241152;
pub const RTE_IPV6_HDR_ECN_MASK: u32 = 3145728;
pub const RTE_IPV6_HDR_ECN_CE: u32 = 3145728;
pub const RTE_IPV6_MIN_MTU: u32 = 1280;
pub const RTE_IPV6_EHDR_MF_SHIFT: u32 = 0;
pub const RTE_IPV6_EHDR_MF_MASK: u32 = 1;
pub const RTE_IPV6_EHDR_FO_SHIFT: u32 = 3;
pub const RTE_IPV6_EHDR_FO_MASK: i32 = -8;
pub const RTE_IPV6_EHDR_FO_ALIGN: u32 = 8;
pub const RTE_IPV6_FRAG_USED_MASK: i32 = -7;
pub const RTE_TCP_CWR_FLAG: u32 = 128;
pub const RTE_TCP_ECE_FLAG: u32 = 64;
pub const RTE_TCP_URG_FLAG: u32 = 32;
pub const RTE_TCP_ACK_FLAG: u32 = 16;
pub const RTE_TCP_PSH_FLAG: u32 = 8;
pub const RTE_TCP_RST_FLAG: u32 = 4;
pub const RTE_TCP_SYN_FLAG: u32 = 2;
pub const RTE_TCP_FIN_FLAG: u32 = 1;
pub const RTE_VXLAN_DEFAULT_PORT: u32 = 4789;
pub const RTE_VXLAN_GPE_DEFAULT_PORT: u32 = 4790;
pub const RTE_VXLAN_GPE_TYPE_IPV4: u32 = 1;
pub const RTE_VXLAN_GPE_TYPE_IPV6: u32 = 2;
pub const RTE_VXLAN_GPE_TYPE_ETH: u32 = 3;
pub const RTE_VXLAN_GPE_TYPE_NSH: u32 = 4;
pub const RTE_VXLAN_GPE_TYPE_MPLS: u32 = 5;
pub const RTE_VXLAN_GPE_TYPE_GBP: u32 = 6;
pub const RTE_VXLAN_GPE_TYPE_VBNG: u32 = 7;
pub const RTE_MBUF_DYN_NAMESIZE: u32 = 64;
pub const RTE_MBUF_DYNFIELD_METADATA_NAME: &[u8; 27usize] = b"rte_flow_dynfield_metadata\0";
pub const RTE_MBUF_DYNFLAG_METADATA_NAME: &[u8; 26usize] = b"rte_flow_dynflag_metadata\0";
pub const RTE_MBUF_DYNFIELD_TIMESTAMP_NAME: &[u8; 23usize] = b"rte_dynfield_timestamp\0";
pub const RTE_MBUF_DYNFLAG_RX_TIMESTAMP_NAME: &[u8; 25usize] = b"rte_dynflag_rx_timestamp\0";
pub const RTE_MBUF_DYNFLAG_TX_TIMESTAMP_NAME: &[u8; 25usize] = b"rte_dynflag_tx_timestamp\0";
pub const RTE_MBUF_DYNFIELD_IP_REASSEMBLY_NAME: &[u8; 27usize] = b"rte_dynfield_ip_reassembly\0";
pub const RTE_MBUF_DYNFLAG_IP_REASSEMBLY_INCOMPLETE_NAME: &[u8; 37usize] =
    b"rte_dynflag_ip_reassembly_incomplete\0";
pub const RTE_GTP_TYPE_IPV4: u32 = 64;
pub const RTE_GTP_TYPE_IPV6: u32 = 96;
pub const RTE_GTPC_UDP_PORT: u32 = 2123;
pub const RTE_GTPU_UDP_PORT: u32 = 2152;
pub const RTE_NTUPLE_FLAGS_DST_IP: u32 = 1;
pub const RTE_NTUPLE_FLAGS_SRC_IP: u32 = 2;
pub const RTE_NTUPLE_FLAGS_DST_PORT: u32 = 4;
pub const RTE_NTUPLE_FLAGS_SRC_PORT: u32 = 8;
pub const RTE_NTUPLE_FLAGS_PROTO: u32 = 16;
pub const RTE_NTUPLE_FLAGS_TCP_FLAG: u32 = 32;
pub const RTE_5TUPLE_FLAGS: u32 = 31;
pub const RTE_2TUPLE_FLAGS: u32 = 20;
pub const RTE_NTUPLE_TCP_FLAGS_MASK: u32 = 63;
pub const RTE_ETH_FDIR_MAX_FLEXLEN: u32 = 16;
pub const RTE_ETH_INSET_SIZE_MAX: u32 = 128;
pub const RTE_ETH_DEV_FALLBACK_RX_RINGSIZE: u32 = 512;
pub const RTE_ETH_DEV_FALLBACK_TX_RINGSIZE: u32 = 512;
pub const RTE_ETH_DEV_FALLBACK_RX_NBQUEUES: u32 = 1;
pub const RTE_ETH_DEV_FALLBACK_TX_NBQUEUES: u32 = 1;
pub const RTE_ETH_DEV_SWITCH_DOMAIN_ID_INVALID: u32 = 65535;
pub const RTE_ETH_QUEUE_STATE_STOPPED: u32 = 0;
pub const RTE_ETH_QUEUE_STATE_STARTED: u32 = 1;
pub const RTE_ETH_QUEUE_STATE_HAIRPIN: u32 = 2;
pub const RTE_ETH_BURST_MODE_INFO_SIZE: u32 = 1024;
pub const RTE_ETH_XSTATS_NAME_SIZE: u32 = 64;
pub const RTE_ETH_DCB_NUM_TCS: u32 = 8;
pub const RTE_ETH_MAX_VMDQ_POOL: u32 = 64;
pub const RTE_ETH_ALL: u32 = 32;
pub const RTE_ETH_NAME_MAX_LEN: u32 = 64;
pub const RTE_ETH_DEV_NO_OWNER: u32 = 0;
pub const RTE_ETH_MAX_OWNER_NAME_LEN: u32 = 64;
pub const RTE_ETH_RX_DESC_AVAIL: u32 = 0;
pub const RTE_ETH_RX_DESC_DONE: u32 = 1;
pub const RTE_ETH_RX_DESC_UNAVAIL: u32 = 2;
pub const RTE_ETH_TX_DESC_FULL: u32 = 0;
pub const RTE_ETH_TX_DESC_DONE: u32 = 1;
pub const RTE_ETH_TX_DESC_UNAVAIL: u32 = 2;
pub const RTE_EVENT_DEV_CAP_QUEUE_QOS: u32 = 1;
pub const RTE_EVENT_DEV_CAP_EVENT_QOS: u32 = 2;
pub const RTE_EVENT_DEV_CAP_DISTRIBUTED_SCHED: u32 = 4;
pub const RTE_EVENT_DEV_CAP_QUEUE_ALL_TYPES: u32 = 8;
pub const RTE_EVENT_DEV_CAP_BURST_MODE: u32 = 16;
pub const RTE_EVENT_DEV_CAP_IMPLICIT_RELEASE_DISABLE: u32 = 32;
pub const RTE_EVENT_DEV_CAP_NONSEQ_MODE: u32 = 64;
pub const RTE_EVENT_DEV_CAP_RUNTIME_PORT_LINK: u32 = 128;
pub const RTE_EVENT_DEV_CAP_MULTIPLE_QUEUE_PORT: u32 = 256;
pub const RTE_EVENT_DEV_CAP_CARRY_FLOW_ID: u32 = 512;
pub const RTE_EVENT_DEV_CAP_MAINTENANCE_FREE: u32 = 1024;
pub const RTE_EVENT_DEV_PRIORITY_HIGHEST: u32 = 0;
pub const RTE_EVENT_DEV_PRIORITY_NORMAL: u32 = 128;
pub const RTE_EVENT_DEV_PRIORITY_LOWEST: u32 = 255;
pub const RTE_EVENT_DEV_ATTR_PORT_COUNT: u32 = 0;
pub const RTE_EVENT_DEV_ATTR_QUEUE_COUNT: u32 = 1;
pub const RTE_EVENT_DEV_ATTR_STARTED: u32 = 2;
pub const RTE_EVENT_DEV_CFG_PER_DEQUEUE_TIMEOUT: u32 = 1;
pub const RTE_EVENT_QUEUE_CFG_ALL_TYPES: u32 = 1;
pub const RTE_EVENT_QUEUE_CFG_SINGLE_LINK: u32 = 2;
pub const RTE_EVENT_QUEUE_ATTR_PRIORITY: u32 = 0;
pub const RTE_EVENT_QUEUE_ATTR_NB_ATOMIC_FLOWS: u32 = 1;
pub const RTE_EVENT_QUEUE_ATTR_NB_ATOMIC_ORDER_SEQUENCES: u32 = 2;
pub const RTE_EVENT_QUEUE_ATTR_EVENT_QUEUE_CFG: u32 = 3;
pub const RTE_EVENT_QUEUE_ATTR_SCHEDULE_TYPE: u32 = 4;
pub const RTE_EVENT_PORT_CFG_DISABLE_IMPL_REL: u32 = 1;
pub const RTE_EVENT_PORT_CFG_SINGLE_LINK: u32 = 2;
pub const RTE_EVENT_PORT_CFG_HINT_PRODUCER: u32 = 4;
pub const RTE_EVENT_PORT_CFG_HINT_CONSUMER: u32 = 8;
pub const RTE_EVENT_PORT_CFG_HINT_WORKER: u32 = 16;
pub const RTE_EVENT_PORT_ATTR_ENQ_DEPTH: u32 = 0;
pub const RTE_EVENT_PORT_ATTR_DEQ_DEPTH: u32 = 1;
pub const RTE_EVENT_PORT_ATTR_NEW_EVENT_THRESHOLD: u32 = 2;
pub const RTE_EVENT_PORT_ATTR_IMPLICIT_RELEASE_DISABLE: u32 = 3;
pub const RTE_SCHED_TYPE_ORDERED: u32 = 0;
pub const RTE_SCHED_TYPE_ATOMIC: u32 = 1;
pub const RTE_SCHED_TYPE_PARALLEL: u32 = 2;
pub const RTE_EVENT_TYPE_ETHDEV: u32 = 0;
pub const RTE_EVENT_TYPE_CRYPTODEV: u32 = 1;
pub const RTE_EVENT_TYPE_TIMER: u32 = 2;
pub const RTE_EVENT_TYPE_CPU: u32 = 3;
pub const RTE_EVENT_TYPE_ETH_RX_ADAPTER: u32 = 4;
pub const RTE_EVENT_TYPE_VECTOR: u32 = 8;
pub const RTE_EVENT_TYPE_ETHDEV_VECTOR: u32 = 8;
pub const RTE_EVENT_TYPE_CPU_VECTOR: u32 = 11;
pub const RTE_EVENT_TYPE_ETH_RX_ADAPTER_VECTOR: u32 = 12;
pub const RTE_EVENT_TYPE_MAX: u32 = 16;
pub const RTE_EVENT_OP_NEW: u32 = 0;
pub const RTE_EVENT_OP_FORWARD: u32 = 1;
pub const RTE_EVENT_OP_RELEASE: u32 = 2;
pub const RTE_EVENT_ETH_RX_ADAPTER_CAP_INTERNAL_PORT: u32 = 1;
pub const RTE_EVENT_ETH_RX_ADAPTER_CAP_MULTI_EVENTQ: u32 = 2;
pub const RTE_EVENT_ETH_RX_ADAPTER_CAP_OVERRIDE_FLOW_ID: u32 = 4;
pub const RTE_EVENT_ETH_RX_ADAPTER_CAP_EVENT_VECTOR: u32 = 8;
pub const RTE_EVENT_TIMER_ADAPTER_CAP_INTERNAL_PORT: u32 = 1;
pub const RTE_EVENT_TIMER_ADAPTER_CAP_PERIODIC: u32 = 2;
pub const RTE_EVENT_CRYPTO_ADAPTER_CAP_INTERNAL_PORT_OP_NEW: u32 = 1;
pub const RTE_EVENT_CRYPTO_ADAPTER_CAP_INTERNAL_PORT_OP_FWD: u32 = 2;
pub const RTE_EVENT_CRYPTO_ADAPTER_CAP_INTERNAL_PORT_QP_EV_BIND: u32 = 4;
pub const RTE_EVENT_CRYPTO_ADAPTER_CAP_SESSION_PRIVATE_DATA: u32 = 8;
pub const RTE_EVENT_ETH_TX_ADAPTER_CAP_INTERNAL_PORT: u32 = 1;
pub const RTE_EVENT_ETH_TX_ADAPTER_CAP_EVENT_VECTOR: u32 = 2;
pub const RTE_EVENT_DEV_XSTATS_NAME_SIZE: u32 = 64;
pub const RTE_EVENT_DEV_MAINT_OP_FLUSH: u32 = 1;
pub const RTE_SERVICE_NAME_MAX: u32 = 32;
pub const RTE_SERVICE_CAP_MT_SAFE: u32 = 1;
pub const RTE_SERVICE_ATTR_CYCLES: u32 = 0;
pub const RTE_SERVICE_ATTR_CALL_COUNT: u32 = 1;
pub const RTE_SERVICE_LCORE_ATTR_LOOPS: u32 = 0;
pub const RTE_EVENT_ETH_RX_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_EVENT_ETH_RX_ADAPTER_QUEUE_FLOW_ID_VALID: u32 = 1;
pub const RTE_EVENT_ETH_RX_ADAPTER_QUEUE_EVENT_VECTOR: u32 = 2;
pub const RTE_EVENT_ETH_TX_ADAPTER_ENQUEUE_SAME_DEST: u32 = 1;
pub const RTE_TAILQ_EVENT_RING_NAME: &[u8; 15usize] = b"RTE_EVENT_RING\0";
pub const RTE_EVENT_TIMER_ADAPTER_F_ADJUST_RES: u32 = 1;
pub const RTE_EVENT_TIMER_ADAPTER_F_SP_PUT: u32 = 2;
pub const RTE_EVENT_TIMER_ADAPTER_F_PERIODIC: u32 = 4;
pub const CRC32_SW: u32 = 1;
pub const CRC32_SSE42: u32 = 2;
pub const CRC32_x64: u32 = 4;
pub const CRC32_SSE42_x64: u32 = 6;
pub const CRC32_ARM64: u32 = 8;
pub const RTE_JHASH_GOLDEN_RATIO: u32 = 3735928559;
pub const RTE_FBK_HASH_INIT_VAL_DEFAULT: u32 = 4294967295;
pub const RTE_FBK_HASH_ENTRIES_MAX: u32 = 1048576;
pub const RTE_FBK_HASH_ENTRIES_PER_BUCKET_MAX: u32 = 256;
pub const RTE_FBK_HASH_NAMESIZE: u32 = 32;
pub const RTE_FIB6_IPV6_ADDR_SIZE: u32 = 16;
pub const RTE_FIB6_MAXDEPTH: u32 = 128;
pub const RTE_FIB_MAXDEPTH: u32 = 32;
pub const RTE_GRAPH_NAMESIZE: u32 = 64;
pub const RTE_NODE_NAMESIZE: u32 = 64;
pub const RTE_GRAPH_OFF_INVALID: u32 = 4294967295;
pub const RTE_NODE_ID_INVALID: u32 = 4294967295;
pub const RTE_EDGE_ID_INVALID: u32 = 65535;
pub const RTE_GRAPH_ID_INVALID: u32 = 65535;
pub const RTE_GRAPH_FENCE: i64 = -2401053092306725256;
pub const RTE_GRAPH_BURST_SIZE_LOG2: u32 = 8;
pub const RTE_NODE_SOURCE_F: u32 = 1;
pub const RTE_NODE_CTX_SZ: u32 = 16;
pub const __RTE_QSBR_THRID_INDEX_SHIFT: u32 = 6;
pub const __RTE_QSBR_THRID_MASK: u32 = 63;
pub const RTE_QSBR_THRID_INVALID: u32 = 4294967295;
pub const __RTE_QSBR_CNT_THR_OFFLINE: u32 = 0;
pub const __RTE_QSBR_CNT_INIT: u32 = 1;
pub const RTE_RCU_QSBR_DQ_MT_UNSAFE: u32 = 1;
pub const RTE_HASH_ENTRIES_MAX: u32 = 1073741824;
pub const RTE_HASH_NAMESIZE: u32 = 32;
pub const RTE_HASH_LOOKUP_BULK_MAX: u32 = 64;
pub const RTE_HASH_LOOKUP_MULTI_MAX: u32 = 64;
pub const RTE_HASH_EXTRA_FLAGS_TRANS_MEM_SUPPORT: u32 = 1;
pub const RTE_HASH_EXTRA_FLAGS_MULTI_WRITER_ADD: u32 = 2;
pub const RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY: u32 = 4;
pub const RTE_HASH_EXTRA_FLAGS_EXT_TABLE: u32 = 8;
pub const RTE_HASH_EXTRA_FLAGS_NO_FREE_ON_DEL: u32 = 16;
pub const RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF: u32 = 32;
pub const RTE_IP_FRAG_DEATH_ROW_LEN: u32 = 32;
pub const RTE_IP_FRAG_DEATH_ROW_MBUF_LEN: u32 = 288;
pub const IP_FRAG_DEATH_ROW_LEN: u32 = 32;
pub const IP_FRAG_DEATH_ROW_MBUF_LEN: u32 = 288;
pub const RTE_JOBSTATS_NAMESIZE: u32 = 32;
pub const RTE_KEEPALIVE_MAXCORES: u32 = 128;
pub const RTE_PCI_CFG_SPACE_SIZE: u32 = 256;
pub const RTE_PCI_CFG_SPACE_EXP_SIZE: u32 = 4096;
pub const RTE_PCI_VENDOR_ID: u32 = 0;
pub const RTE_PCI_DEVICE_ID: u32 = 2;
pub const RTE_PCI_COMMAND: u32 = 4;
pub const RTE_PCI_COMMAND_MASTER: u32 = 4;
pub const RTE_PCI_EXP_DEVCTL: u32 = 8;
pub const RTE_PCI_EXT_CAP_ID_ERR: u32 = 1;
pub const RTE_PCI_EXT_CAP_ID_DSN: u32 = 3;
pub const RTE_PCI_EXT_CAP_ID_SRIOV: u32 = 16;
pub const RTE_PCI_SRIOV_CAP: u32 = 4;
pub const RTE_PCI_SRIOV_CTRL: u32 = 8;
pub const RTE_PCI_SRIOV_INITIAL_VF: u32 = 12;
pub const RTE_PCI_SRIOV_TOTAL_VF: u32 = 14;
pub const RTE_PCI_SRIOV_NUM_VF: u32 = 16;
pub const RTE_PCI_SRIOV_FUNC_LINK: u32 = 18;
pub const RTE_PCI_SRIOV_VF_OFFSET: u32 = 20;
pub const RTE_PCI_SRIOV_VF_STRIDE: u32 = 22;
pub const RTE_PCI_SRIOV_VF_DID: u32 = 26;
pub const RTE_PCI_SRIOV_SUP_PGSIZE: u32 = 28;
pub const PCI_PRI_FMT: &[u8; 18usize] = b"%.4x:%.2x:%.2x.%x\0";
pub const PCI_SHORT_PRI_FMT: &[u8; 13usize] = b"%.2x:%.2x.%x\0";
pub const PCI_FMT_NVAL: u32 = 4;
pub const PCI_RESOURCE_FMT_NVAL: u32 = 3;
pub const PCI_MAX_RESOURCE: u32 = 6;
pub const RTE_PCI_ANY_ID: u32 = 65535;
pub const RTE_CLASS_ANY_ID: u32 = 16777215;
pub const RTE_KNI_NAMESIZE: u32 = 16;
pub const KNI_DEVICE: &[u8; 4usize] = b"kni\0";
pub const RTE_KVARGS_MAX: u32 = 32;
pub const RTE_KVARGS_PAIRS_DELIM: &[u8; 2usize] = b",\0";
pub const RTE_KVARGS_KV_DELIM: &[u8; 2usize] = b"=\0";
pub const RTE_METRICS_MAX_NAME_LEN: u32 = 64;
pub const RTE_METRICS_MAX_METRICS: u32 = 256;
pub const RTE_METRICS_GLOBAL: i32 = -1;
pub const RTE_LPM6_MAX_DEPTH: u32 = 128;
pub const RTE_LPM6_IPV6_ADDR_SIZE: u32 = 16;
pub const RTE_LPM6_NAMESIZE: u32 = 32;
pub const RTE_LPM_NAMESIZE: u32 = 32;
pub const RTE_LPM_MAX_DEPTH: u32 = 32;
pub const RTE_LPM_TBL24_NUM_ENTRIES: u32 = 16777216;
pub const RTE_LPM_TBL8_GROUP_NUM_ENTRIES: u32 = 256;
pub const RTE_LPM_MAX_TBL8_NUM_GROUPS: u32 = 16777216;
pub const RTE_LPM_TBL8_NUM_GROUPS: u32 = 256;
pub const RTE_LPM_TBL8_NUM_ENTRIES: u32 = 65536;
pub const RTE_LPM_VALID_EXT_ENTRY_BITMASK: u32 = 50331648;
pub const RTE_LPM_LOOKUP_SUCCESS: u32 = 16777216;
pub const RTE_LPM_RCU_DQ_RECLAIM_MAX: u32 = 16;
pub const RTE_TABLE_HASH_LRU_STRATEGY: u32 = 2;
pub const RTE_MEMBER_NO_MATCH: u32 = 0;
pub const RTE_MEMBER_ENTRIES_MAX: u32 = 1073741824;
pub const RTE_MEMBER_LOOKUP_BULK_MAX: u32 = 64;
pub const RTE_MEMBER_BUCKET_ENTRIES: u32 = 16;
pub const RTE_MEMBER_NAMESIZE: u32 = 32;
pub const RTE_ETHTYPE_FLAGS_MAC: u32 = 1;
pub const RTE_ETHTYPE_FLAGS_DROP: u32 = 2;
pub const RTE_ETH_TUNNEL_FILTER_OMAC: u32 = 1;
pub const RTE_ETH_TUNNEL_FILTER_OIP: u32 = 2;
pub const RTE_ETH_TUNNEL_FILTER_TENID: u32 = 4;
pub const RTE_ETH_TUNNEL_FILTER_IMAC: u32 = 8;
pub const RTE_ETH_TUNNEL_FILTER_IVLAN: u32 = 16;
pub const RTE_ETH_TUNNEL_FILTER_IIP: u32 = 32;
pub const RTE_ETH_TUNNEL_FILTER_IMAC_IVLAN: u32 = 24;
pub const RTE_ETH_TUNNEL_FILTER_IMAC_IVLAN_TENID: u32 = 28;
pub const RTE_ETH_TUNNEL_FILTER_IMAC_TENID: u32 = 12;
pub const RTE_ETH_TUNNEL_FILTER_OMAC_TENID_IMAC: u32 = 13;
pub const RTE_INTR_MODE_NONE_NAME: &[u8; 5usize] = b"none\0";
pub const RTE_INTR_MODE_LEGACY_NAME: &[u8; 7usize] = b"legacy\0";
pub const RTE_INTR_MODE_MSI_NAME: &[u8; 4usize] = b"msi\0";
pub const RTE_INTR_MODE_MSIX_NAME: &[u8; 5usize] = b"msix\0";
pub const BPF_LD: u32 = 0;
pub const BPF_LDX: u32 = 1;
pub const BPF_ST: u32 = 2;
pub const BPF_STX: u32 = 3;
pub const BPF_ALU: u32 = 4;
pub const BPF_JMP: u32 = 5;
pub const BPF_RET: u32 = 6;
pub const BPF_MISC: u32 = 7;
pub const EBPF_ALU64: u32 = 7;
pub const BPF_W: u32 = 0;
pub const BPF_H: u32 = 8;
pub const BPF_B: u32 = 16;
pub const EBPF_DW: u32 = 24;
pub const BPF_IMM: u32 = 0;
pub const BPF_ABS: u32 = 32;
pub const BPF_IND: u32 = 64;
pub const BPF_MEM: u32 = 96;
pub const BPF_LEN: u32 = 128;
pub const BPF_MSH: u32 = 160;
pub const EBPF_XADD: u32 = 192;
pub const BPF_ADD: u32 = 0;
pub const BPF_SUB: u32 = 16;
pub const BPF_MUL: u32 = 32;
pub const BPF_DIV: u32 = 48;
pub const BPF_OR: u32 = 64;
pub const BPF_AND: u32 = 80;
pub const BPF_LSH: u32 = 96;
pub const BPF_RSH: u32 = 112;
pub const BPF_NEG: u32 = 128;
pub const BPF_MOD: u32 = 144;
pub const BPF_XOR: u32 = 160;
pub const EBPF_MOV: u32 = 176;
pub const EBPF_ARSH: u32 = 192;
pub const EBPF_END: u32 = 208;
pub const BPF_JA: u32 = 0;
pub const BPF_JEQ: u32 = 16;
pub const BPF_JGT: u32 = 32;
pub const BPF_JGE: u32 = 48;
pub const BPF_JSET: u32 = 64;
pub const EBPF_JNE: u32 = 80;
pub const EBPF_JSGT: u32 = 96;
pub const EBPF_JSGE: u32 = 112;
pub const EBPF_CALL: u32 = 128;
pub const EBPF_EXIT: u32 = 144;
pub const EBPF_JLT: u32 = 160;
pub const EBPF_JLE: u32 = 176;
pub const EBPF_JSLT: u32 = 192;
pub const EBPF_JSLE: u32 = 208;
pub const BPF_K: u32 = 0;
pub const BPF_X: u32 = 8;
pub const EBPF_TO_LE: u32 = 0;
pub const EBPF_TO_BE: u32 = 8;
pub const RTE_PDUMP_ALL_QUEUES: u32 = 65535;
pub const RTE_DQ_THRESHOLD: u32 = 16384;
pub const RTE_DQ_WEIGHT: f64 = 0.25;
pub const RTE_ALPHA: f64 = 0.125;
pub const RTE_BETA: f64 = 1.25;
pub const RTE_RAND_MAX: i32 = -1;
pub const RTE_PORT_IN_BURST_SIZE_MAX: u32 = 64;
pub const RTE_PIPELINE_TABLE_MAX: u32 = 64;
pub const RTE_PIPELINE_PORT_IN_MAX: u32 = 64;
pub const RTE_PIPELINE_PORT_OUT_MAX: u32 = 64;
pub const RTE_PORT_IN_ACTION_FLTR_KEY_SIZE: u32 = 16;
pub const RTE_PORT_IN_ACTION_LB_KEY_SIZE_MIN: u32 = 8;
pub const RTE_PORT_IN_ACTION_LB_KEY_SIZE_MAX: u32 = 64;
pub const RTE_PORT_IN_ACTION_LB_TABLE_SIZE: u32 = 16;
pub const RTE_RED_SCALING: u32 = 10;
pub const RTE_RED_S: u32 = 4194304;
pub const RTE_RED_MAX_TH_MAX: u32 = 1023;
pub const RTE_RED_WQ_LOG2_MIN: u32 = 1;
pub const RTE_RED_WQ_LOG2_MAX: u32 = 12;
pub const RTE_RED_MAXP_INV_MIN: u32 = 1;
pub const RTE_RED_MAXP_INV_MAX: u32 = 255;
pub const RTE_RED_2POW16: u32 = 65536;
pub const RTE_RED_WQ_LOG2_NUM: u32 = 12;
pub const RTE_SCHED_QUEUES_PER_PIPE: u32 = 16;
pub const RTE_SCHED_BE_QUEUES_PER_PIPE: u32 = 4;
pub const RTE_SCHED_FRAME_OVERHEAD_DEFAULT: u32 = 24;
pub const RTE_RAWDEV_NAME_MAX_LEN: u32 = 64;
pub const RTE_RAW_DEV_XSTATS_NAME_SIZE: u32 = 64;
pub const RTE_RAWDEV_DETACHED: u32 = 0;
pub const RTE_RAWDEV_ATTACHED: u32 = 1;
pub const RTE_REGEXDEV_NAME_MAX_LEN: u32 = 64;
pub const RTE_REGEXDEV_CAPA_RUNTIME_COMPILATION_F: u32 = 1;
pub const RTE_REGEXDEV_CAPA_SUPP_PCRE_START_ANCHOR_F: u32 = 2;
pub const RTE_REGEXDEV_CAPA_SUPP_PCRE_ATOMIC_GROUPING_F: u32 = 4;
pub const RTE_REGEXDEV_SUPP_PCRE_BACKTRACKING_CTRL_F: u32 = 8;
pub const RTE_REGEXDEV_SUPP_PCRE_CALLOUTS_F: u32 = 16;
pub const RTE_REGEXDEV_SUPP_PCRE_BACKREFERENCE_F: u32 = 32;
pub const RTE_REGEXDEV_SUPP_PCRE_GREEDY_F: u32 = 64;
pub const RTE_REGEXDEV_SUPP_PCRE_MATCH_ALL_F: u32 = 128;
pub const RTE_REGEXDEV_SUPP_PCRE_LOOKAROUND_ASRT_F: u32 = 256;
pub const RTE_REGEXDEV_SUPP_PCRE_MATCH_POINT_RST_F: u32 = 512;
pub const RTE_REGEXDEV_SUPP_NEWLINE_CONVENTIONS_F: u32 = 1024;
pub const RTE_REGEXDEV_SUPP_PCRE_NEWLINE_SEQ_F: u32 = 2048;
pub const RTE_REGEXDEV_SUPP_PCRE_POSSESSIVE_QUALIFIERS_F: u32 = 4096;
pub const RTE_REGEXDEV_SUPP_PCRE_SUBROUTINE_REFERENCES_F: u32 = 8192;
pub const RTE_REGEXDEV_SUPP_PCRE_UTF_8_F: u32 = 16384;
pub const RTE_REGEXDEV_SUPP_PCRE_UTF_16_F: u32 = 32768;
pub const RTE_REGEXDEV_SUPP_PCRE_UTF_32_F: u32 = 65536;
pub const RTE_REGEXDEV_SUPP_PCRE_WORD_BOUNDARY_F: u32 = 131072;
pub const RTE_REGEXDEV_SUPP_PCRE_FORWARD_REFERENCES_F: u32 = 262144;
pub const RTE_REGEXDEV_SUPP_MATCH_AS_END_F: u32 = 524288;
pub const RTE_REGEXDEV_SUPP_CROSS_BUFFER_F: u32 = 1048576;
pub const RTE_REGEXDEV_SUPP_MATCH_ALL_F: u32 = 2097152;
pub const RTE_REGEXDEV_CAPA_QUEUE_PAIR_OOS_F: u32 = 4194304;
pub const RTE_REGEX_PCRE_RULE_ALLOW_EMPTY_F: u32 = 1;
pub const RTE_REGEX_PCRE_RULE_ANCHORED_F: u32 = 2;
pub const RTE_REGEX_PCRE_RULE_CASELESS_F: u32 = 4;
pub const RTE_REGEX_PCRE_RULE_DOTALL_F: u32 = 8;
pub const RTE_REGEX_PCRE_RULE_DUPNAMES_F: u32 = 16;
pub const RTE_REGEX_PCRE_RULE_EXTENDED_F: u32 = 32;
pub const RTE_REGEX_PCRE_RULE_MATCH_UNSET_BACKREF_F: u32 = 64;
pub const RTE_REGEX_PCRE_RULE_MULTILINE_F: u32 = 128;
pub const RTE_REGEX_PCRE_RULE_NO_AUTO_CAPTURE_F: u32 = 256;
pub const RTE_REGEX_PCRE_RULE_UCP_F: u32 = 512;
pub const RTE_REGEX_PCRE_RULE_UNGREEDY_F: u32 = 1024;
pub const RTE_REGEX_PCRE_RULE_UTF_F: u32 = 2048;
pub const RTE_REGEX_PCRE_RULE_NEVER_BACKSLASH_C_F: u32 = 4096;
pub const RTE_REGEXDEV_CFG_CROSS_BUFFER_SCAN_F: u32 = 1;
pub const RTE_REGEXDEV_CFG_MATCH_AS_END_F: u32 = 2;
pub const RTE_REGEXDEV_CFG_MATCH_ALL_F: u32 = 4;
pub const RTE_REGEX_QUEUE_PAIR_CFG_OOS_F: u32 = 1;
pub const RTE_REGEXDEV_XSTATS_NAME_SIZE: u32 = 64;
pub const RTE_REGEX_OPS_REQ_GROUP_ID0_VALID_F: u32 = 1;
pub const RTE_REGEX_OPS_REQ_GROUP_ID1_VALID_F: u32 = 2;
pub const RTE_REGEX_OPS_REQ_GROUP_ID2_VALID_F: u32 = 4;
pub const RTE_REGEX_OPS_REQ_GROUP_ID3_VALID_F: u32 = 8;
pub const RTE_REGEX_OPS_REQ_STOP_ON_MATCH_F: u32 = 16;
pub const RTE_REGEX_OPS_REQ_MATCH_HIGH_PRIORITY_F: u32 = 32;
pub const RTE_REGEX_OPS_RSP_PMI_SOJ_F: u32 = 1;
pub const RTE_REGEX_OPS_RSP_PMI_EOJ_F: u32 = 2;
pub const RTE_REGEX_OPS_RSP_MAX_SCAN_TIMEOUT_F: u32 = 4;
pub const RTE_REGEX_OPS_RSP_MAX_MATCH_F: u32 = 8;
pub const RTE_REGEX_OPS_RSP_MAX_PREFIX_F: u32 = 16;
pub const RTE_REGEX_OPS_RSP_RESOURCE_LIMIT_REACHED_F: u32 = 16;
pub const RTE_RIB6_IPV6_ADDR_SIZE: u32 = 16;
pub const RTE_TAILQ_STACK_NAME: &[u8; 10usize] = b"RTE_STACK\0";
pub const RTE_STACK_MZ_PREFIX: &[u8; 5usize] = b"STK_\0";
pub const RTE_STACK_F_LF: u32 = 1;
pub const RTE_TAILQ_NAMESIZE: u32 = 32;
pub const RTE_TEL_MAX_STRING_LEN: u32 = 128;
pub const RTE_TEL_MAX_SINGLE_STRING_LEN: u32 = 8192;
pub const RTE_TEL_MAX_DICT_ENTRIES: u32 = 256;
pub const RTE_TEL_MAX_ARRAY_ENTRIES: u32 = 512;
pub const NSEC_PER_SEC: u32 = 1000000000;
pub const RTE_TIMER_STOP: u32 = 0;
pub const RTE_TIMER_PENDING: u32 = 1;
pub const RTE_TIMER_RUNNING: u32 = 2;
pub const RTE_TIMER_CONFIG: u32 = 3;
pub const RTE_TIMER_NO_OWNER: i32 = -2;
pub const MAX_SKIPLIST_DEPTH: u32 = 10;
pub const RTE_TM_ETH_FRAMING_OVERHEAD: u32 = 20;
pub const RTE_TM_ETH_FRAMING_OVERHEAD_FCS: u32 = 24;
pub const RTE_TM_WRED_PROFILE_ID_NONE: u32 = 4294967295;
pub const RTE_TM_SHAPER_PROFILE_ID_NONE: u32 = 4294967295;
pub const RTE_TM_NODE_ID_NULL: u32 = 4294967295;
pub const RTE_TM_NODE_LEVEL_ID_ANY: u32 = 4294967295;
pub const LINUX_VERSION_CODE: u32 = 330346;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const VFIO_API_VERSION: u32 = 0;
pub const VFIO_TYPE1_IOMMU: u32 = 1;
pub const VFIO_SPAPR_TCE_IOMMU: u32 = 2;
pub const VFIO_TYPE1v2_IOMMU: u32 = 3;
pub const VFIO_DMA_CC_IOMMU: u32 = 4;
pub const VFIO_EEH: u32 = 5;
pub const VFIO_TYPE1_NESTING_IOMMU: u32 = 6;
pub const VFIO_SPAPR_TCE_v2_IOMMU: u32 = 7;
pub const VFIO_NOIOMMU_IOMMU: u32 = 8;
pub const VFIO_TYPE: u8 = 59u8;
pub const VFIO_BASE: u32 = 100;
pub const VFIO_GROUP_FLAGS_VIABLE: u32 = 1;
pub const VFIO_GROUP_FLAGS_CONTAINER_SET: u32 = 2;
pub const VFIO_DEVICE_FLAGS_RESET: u32 = 1;
pub const VFIO_DEVICE_FLAGS_PCI: u32 = 2;
pub const VFIO_DEVICE_FLAGS_PLATFORM: u32 = 4;
pub const VFIO_DEVICE_FLAGS_AMBA: u32 = 8;
pub const VFIO_DEVICE_FLAGS_CCW: u32 = 16;
pub const VFIO_DEVICE_FLAGS_AP: u32 = 32;
pub const VFIO_DEVICE_FLAGS_FSL_MC: u32 = 64;
pub const VFIO_DEVICE_FLAGS_CAPS: u32 = 128;
pub const VFIO_DEVICE_API_PCI_STRING: &[u8; 9usize] = b"vfio-pci\0";
pub const VFIO_DEVICE_API_PLATFORM_STRING: &[u8; 14usize] = b"vfio-platform\0";
pub const VFIO_DEVICE_API_AMBA_STRING: &[u8; 10usize] = b"vfio-amba\0";
pub const VFIO_DEVICE_API_CCW_STRING: &[u8; 9usize] = b"vfio-ccw\0";
pub const VFIO_DEVICE_API_AP_STRING: &[u8; 8usize] = b"vfio-ap\0";
pub const VFIO_DEVICE_INFO_CAP_ZPCI_BASE: u32 = 1;
pub const VFIO_DEVICE_INFO_CAP_ZPCI_GROUP: u32 = 2;
pub const VFIO_DEVICE_INFO_CAP_ZPCI_UTIL: u32 = 3;
pub const VFIO_DEVICE_INFO_CAP_ZPCI_PFIP: u32 = 4;
pub const VFIO_REGION_INFO_FLAG_READ: u32 = 1;
pub const VFIO_REGION_INFO_FLAG_WRITE: u32 = 2;
pub const VFIO_REGION_INFO_FLAG_MMAP: u32 = 4;
pub const VFIO_REGION_INFO_FLAG_CAPS: u32 = 8;
pub const VFIO_REGION_INFO_CAP_SPARSE_MMAP: u32 = 1;
pub const VFIO_REGION_INFO_CAP_TYPE: u32 = 2;
pub const VFIO_REGION_TYPE_PCI_VENDOR_TYPE: u32 = 2147483648;
pub const VFIO_REGION_TYPE_PCI_VENDOR_MASK: u32 = 65535;
pub const VFIO_REGION_TYPE_GFX: u32 = 1;
pub const VFIO_REGION_TYPE_CCW: u32 = 2;
pub const VFIO_REGION_TYPE_MIGRATION: u32 = 3;
pub const VFIO_REGION_SUBTYPE_INTEL_IGD_OPREGION: u32 = 1;
pub const VFIO_REGION_SUBTYPE_INTEL_IGD_HOST_CFG: u32 = 2;
pub const VFIO_REGION_SUBTYPE_INTEL_IGD_LPC_CFG: u32 = 3;
pub const VFIO_REGION_SUBTYPE_NVIDIA_NVLINK2_RAM: u32 = 1;
pub const VFIO_REGION_SUBTYPE_IBM_NVLINK2_ATSD: u32 = 1;
pub const VFIO_REGION_SUBTYPE_GFX_EDID: u32 = 1;
pub const VFIO_DEVICE_GFX_LINK_STATE_UP: u32 = 1;
pub const VFIO_DEVICE_GFX_LINK_STATE_DOWN: u32 = 2;
pub const VFIO_REGION_SUBTYPE_CCW_ASYNC_CMD: u32 = 1;
pub const VFIO_REGION_SUBTYPE_CCW_SCHIB: u32 = 2;
pub const VFIO_REGION_SUBTYPE_CCW_CRW: u32 = 3;
pub const VFIO_REGION_SUBTYPE_MIGRATION: u32 = 1;
pub const VFIO_DEVICE_STATE_STOP: u32 = 0;
pub const VFIO_DEVICE_STATE_RUNNING: u32 = 1;
pub const VFIO_DEVICE_STATE_SAVING: u32 = 2;
pub const VFIO_DEVICE_STATE_RESUMING: u32 = 4;
pub const VFIO_DEVICE_STATE_MASK: u32 = 7;
pub const VFIO_REGION_INFO_CAP_MSIX_MAPPABLE: u32 = 3;
pub const VFIO_REGION_INFO_CAP_NVLINK2_SSATGT: u32 = 4;
pub const VFIO_REGION_INFO_CAP_NVLINK2_LNKSPD: u32 = 5;
pub const VFIO_IRQ_INFO_EVENTFD: u32 = 1;
pub const VFIO_IRQ_INFO_MASKABLE: u32 = 2;
pub const VFIO_IRQ_INFO_AUTOMASKED: u32 = 4;
pub const VFIO_IRQ_INFO_NORESIZE: u32 = 8;
pub const VFIO_IRQ_SET_DATA_NONE: u32 = 1;
pub const VFIO_IRQ_SET_DATA_BOOL: u32 = 2;
pub const VFIO_IRQ_SET_DATA_EVENTFD: u32 = 4;
pub const VFIO_IRQ_SET_ACTION_MASK: u32 = 8;
pub const VFIO_IRQ_SET_ACTION_UNMASK: u32 = 16;
pub const VFIO_IRQ_SET_ACTION_TRIGGER: u32 = 32;
pub const VFIO_IRQ_SET_DATA_TYPE_MASK: u32 = 7;
pub const VFIO_IRQ_SET_ACTION_TYPE_MASK: u32 = 56;
pub const VFIO_GFX_PLANE_TYPE_PROBE: u32 = 1;
pub const VFIO_GFX_PLANE_TYPE_DMABUF: u32 = 2;
pub const VFIO_GFX_PLANE_TYPE_REGION: u32 = 4;
pub const VFIO_DEVICE_IOEVENTFD_8: u32 = 1;
pub const VFIO_DEVICE_IOEVENTFD_16: u32 = 2;
pub const VFIO_DEVICE_IOEVENTFD_32: u32 = 4;
pub const VFIO_DEVICE_IOEVENTFD_64: u32 = 8;
pub const VFIO_DEVICE_IOEVENTFD_SIZE_MASK: u32 = 15;
pub const VFIO_DEVICE_FEATURE_MASK: u32 = 65535;
pub const VFIO_DEVICE_FEATURE_GET: u32 = 65536;
pub const VFIO_DEVICE_FEATURE_SET: u32 = 131072;
pub const VFIO_DEVICE_FEATURE_PROBE: u32 = 262144;
pub const VFIO_DEVICE_FEATURE_PCI_VF_TOKEN: u32 = 0;
pub const VFIO_IOMMU_INFO_PGSIZES: u32 = 1;
pub const VFIO_IOMMU_INFO_CAPS: u32 = 2;
pub const VFIO_IOMMU_TYPE1_INFO_CAP_IOVA_RANGE: u32 = 1;
pub const VFIO_IOMMU_TYPE1_INFO_CAP_MIGRATION: u32 = 2;
pub const VFIO_IOMMU_TYPE1_INFO_DMA_AVAIL: u32 = 3;
pub const VFIO_DMA_MAP_FLAG_READ: u32 = 1;
pub const VFIO_DMA_MAP_FLAG_WRITE: u32 = 2;
pub const VFIO_DMA_UNMAP_FLAG_GET_DIRTY_BITMAP: u32 = 1;
pub const VFIO_IOMMU_DIRTY_PAGES_FLAG_START: u32 = 1;
pub const VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP: u32 = 2;
pub const VFIO_IOMMU_DIRTY_PAGES_FLAG_GET_BITMAP: u32 = 4;
pub const VFIO_IOMMU_SPAPR_INFO_DDW: u32 = 1;
pub const VFIO_EEH_PE_DISABLE: u32 = 0;
pub const VFIO_EEH_PE_ENABLE: u32 = 1;
pub const VFIO_EEH_PE_UNFREEZE_IO: u32 = 2;
pub const VFIO_EEH_PE_UNFREEZE_DMA: u32 = 3;
pub const VFIO_EEH_PE_GET_STATE: u32 = 4;
pub const VFIO_EEH_PE_STATE_NORMAL: u32 = 0;
pub const VFIO_EEH_PE_STATE_RESET: u32 = 1;
pub const VFIO_EEH_PE_STATE_STOPPED: u32 = 2;
pub const VFIO_EEH_PE_STATE_STOPPED_DMA: u32 = 4;
pub const VFIO_EEH_PE_STATE_UNAVAIL: u32 = 5;
pub const VFIO_EEH_PE_RESET_DEACTIVATE: u32 = 5;
pub const VFIO_EEH_PE_RESET_HOT: u32 = 6;
pub const VFIO_EEH_PE_RESET_FUNDAMENTAL: u32 = 7;
pub const VFIO_EEH_PE_CONFIGURE: u32 = 8;
pub const VFIO_EEH_PE_INJECT_ERR: u32 = 9;
pub const VFIO_DIR: &[u8; 10usize] = b"/dev/vfio\0";
pub const VFIO_CONTAINER_PATH: &[u8; 15usize] = b"/dev/vfio/vfio\0";
pub const VFIO_GROUP_FMT: &[u8; 13usize] = b"/dev/vfio/%u\0";
pub const VFIO_NOIOMMU_GROUP_FMT: &[u8; 21usize] = b"/dev/vfio/noiommu-%u\0";
pub const VFIO_NOIOMMU_MODE: &[u8; 55usize] =
    b"/sys/module/vfio/parameters/enable_unsafe_noiommu_mode\0";
pub const RTE_VFIO_NOIOMMU: u32 = 8;
pub const RTE_VFIO_INFO_FLAG_CAPS: u32 = 8;
pub const RTE_VFIO_CAP_MSIX_MAPPABLE: u32 = 3;
pub const RTE_VFIO_DEFAULT_CONTAINER_FD: i32 = -1;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type size_t = ::std::os::raw::c_ulong;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
extern "C" {
    pub fn __sched_cpucount(__setsize: size_t, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: size_t) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type clock_t = __clock_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_1 = _bindgen_ty_1::PTHREAD_CREATE_JOINABLE;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_1 = _bindgen_ty_1::PTHREAD_CREATE_DETACHED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_1 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1,
}
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_TIMED_NP;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_RECURSIVE_NP;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_ERRORCHECK_NP;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_ADAPTIVE_NP;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_TIMED_NP;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_RECURSIVE_NP;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_ERRORCHECK_NP;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_TIMED_NP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_2 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
}
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_3 = _bindgen_ty_3::PTHREAD_MUTEX_STALLED;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_3 = _bindgen_ty_3::PTHREAD_MUTEX_STALLED;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_3 = _bindgen_ty_3::PTHREAD_MUTEX_ROBUST;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_3 = _bindgen_ty_3::PTHREAD_MUTEX_ROBUST;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_3 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_ROBUST = 1,
}
pub const PTHREAD_PRIO_NONE: _bindgen_ty_4 = _bindgen_ty_4::PTHREAD_PRIO_NONE;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_4 = _bindgen_ty_4::PTHREAD_PRIO_INHERIT;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_4 = _bindgen_ty_4::PTHREAD_PRIO_PROTECT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_4 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2,
}
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_5 =
    _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_READER_NP;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_5 =
    _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_WRITER_NP;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_5 =
    _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_5 = _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_READER_NP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_5 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
}
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_6 = _bindgen_ty_6::PTHREAD_INHERIT_SCHED;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_6 = _bindgen_ty_6::PTHREAD_EXPLICIT_SCHED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_6 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1,
}
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_7 = _bindgen_ty_7::PTHREAD_SCOPE_SYSTEM;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_7 = _bindgen_ty_7::PTHREAD_SCOPE_PROCESS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_7 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1,
}
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_8 = _bindgen_ty_8::PTHREAD_PROCESS_PRIVATE;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_8 = _bindgen_ty_8::PTHREAD_PROCESS_SHARED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_8 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_9 = _bindgen_ty_9::PTHREAD_CANCEL_ENABLE;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_9 = _bindgen_ty_9::PTHREAD_CANCEL_DISABLE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_9 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1,
}
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_10 = _bindgen_ty_10::PTHREAD_CANCEL_DEFERRED;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_10 = _bindgen_ty_10::PTHREAD_CANCEL_ASYNCHRONOUS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_10 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1,
}
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum idtype_t {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2,
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub const _ISupper: _bindgen_ty_11 = _bindgen_ty_11::_ISupper;
pub const _ISlower: _bindgen_ty_11 = _bindgen_ty_11::_ISlower;
pub const _ISalpha: _bindgen_ty_11 = _bindgen_ty_11::_ISalpha;
pub const _ISdigit: _bindgen_ty_11 = _bindgen_ty_11::_ISdigit;
pub const _ISxdigit: _bindgen_ty_11 = _bindgen_ty_11::_ISxdigit;
pub const _ISspace: _bindgen_ty_11 = _bindgen_ty_11::_ISspace;
pub const _ISprint: _bindgen_ty_11 = _bindgen_ty_11::_ISprint;
pub const _ISgraph: _bindgen_ty_11 = _bindgen_ty_11::_ISgraph;
pub const _ISblank: _bindgen_ty_11 = _bindgen_ty_11::_ISblank;
pub const _IScntrl: _bindgen_ty_11 = _bindgen_ty_11::_IScntrl;
pub const _ISpunct: _bindgen_ty_11 = _bindgen_ty_11::_ISpunct;
pub const _ISalnum: _bindgen_ty_11 = _bindgen_ty_11::_ISalnum;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_11 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8,
}
extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
pub type unaligned_uint64_t = u64;
pub type unaligned_uint32_t = u32;
pub type unaligned_uint16_t = u16;
#[doc = " Physical address"]
pub type phys_addr_t = u64;
#[doc = " IO virtual address type."]
#[doc = " When the physical addressing mode (IOVA as PA) is in use,"]
#[doc = " the translation from an IO virtual address (IOVA) to a physical address"]
#[doc = " is a direct mapping, i.e. the same value."]
#[doc = " Otherwise, in virtual mode (IOVA as VA), an IOMMU may do the translation."]
pub type rte_iova_t = u64;
#[doc = " Generic marker for any place in a structure."]
pub type RTE_MARKER = [*mut ::std::os::raw::c_void; 0usize];
#[doc = " Marker for 1B alignment in a structure."]
pub type RTE_MARKER8 = [u8; 0usize];
#[doc = " Marker for 2B alignment in a structure."]
pub type RTE_MARKER16 = [u16; 0usize];
#[doc = " Marker for 4B alignment in a structure."]
pub type RTE_MARKER32 = [u32; 0usize];
#[doc = " Marker for 8B alignment in a structure."]
pub type RTE_MARKER64 = [u64; 0usize];
extern "C" {
    #[doc = " Function to terminate the application immediately, printing an error"]
    #[doc = " message and returning the exit_code back to the shell."]
    #[doc = ""]
    #[doc = " This function never returns"]
    #[doc = ""]
    #[doc = " @param exit_code"]
    #[doc = "     The exit code to be returned by the application"]
    #[doc = " @param format"]
    #[doc = "     The format string to be used for printing the message. This can include"]
    #[doc = "     printf format characters which will be expanded using any further parameters"]
    #[doc = "     to the function."]
    pub fn rte_exit(exit_code: ::std::os::raw::c_int, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Change the stream that will be used by the logging system."]
    #[doc = ""]
    #[doc = " This can be done at any time. The f argument represents the stream"]
    #[doc = " to be used to send the logs. If f is NULL, the default output is"]
    #[doc = " used (stderr)."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   Pointer to the stream."]
    #[doc = " @return"]
    #[doc = "   - 0 on success."]
    #[doc = "   - Negative on error."]
    pub fn rte_openlog_stream(f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the stream used by the logging system (see rte_openlog_stream()"]
    #[doc = " to change it)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Pointer to the stream."]
    pub fn rte_log_get_stream() -> *mut FILE;
}
extern "C" {
    #[doc = " Set the global log level."]
    #[doc = ""]
    #[doc = " After this call, logs with a level lower or equal than the level"]
    #[doc = " passed as argument will be displayed."]
    #[doc = ""]
    #[doc = " @param level"]
    #[doc = "   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8)."]
    pub fn rte_log_set_global_level(level: u32);
}
extern "C" {
    #[doc = " Get the global log level."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The current global log level."]
    pub fn rte_log_get_global_level() -> u32;
}
extern "C" {
    #[doc = " Get the log level for a given type."]
    #[doc = ""]
    #[doc = " @param logtype"]
    #[doc = "   The log type identifier."]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative value if logtype is invalid."]
    pub fn rte_log_get_level(logtype: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " For a given `logtype`, check if a log with `loglevel` can be printed."]
    #[doc = ""]
    #[doc = " @param logtype"]
    #[doc = "   The log type identifier"]
    #[doc = " @param loglevel"]
    #[doc = "   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8)."]
    #[doc = " @return"]
    #[doc = " Returns 'true' if log can be printed and 'false' if it can't."]
    pub fn rte_log_can_log(logtype: u32, loglevel: u32) -> bool;
}
extern "C" {
    #[doc = " Set the log level for a given type based on globbing pattern."]
    #[doc = ""]
    #[doc = " @param pattern"]
    #[doc = "   The globbing pattern identifying the log type."]
    #[doc = " @param level"]
    #[doc = "   The level to be set."]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative value if level is invalid."]
    pub fn rte_log_set_level_pattern(
        pattern: *const ::std::os::raw::c_char,
        level: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the log level for a given type based on regular expression."]
    #[doc = ""]
    #[doc = " @param regex"]
    #[doc = "   The regular expression identifying the log type."]
    #[doc = " @param level"]
    #[doc = "   The level to be set."]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative value if level is invalid."]
    pub fn rte_log_set_level_regexp(
        regex: *const ::std::os::raw::c_char,
        level: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the log level for a given type."]
    #[doc = ""]
    #[doc = " @param logtype"]
    #[doc = "   The log type identifier."]
    #[doc = " @param level"]
    #[doc = "   The level to be set."]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative value if logtype or level is invalid."]
    pub fn rte_log_set_level(logtype: u32, level: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current loglevel for the message being processed."]
    #[doc = ""]
    #[doc = " Before calling the user-defined stream for logging, the log"]
    #[doc = " subsystem sets a per-lcore variable containing the loglevel and the"]
    #[doc = " logtype of the message being processed. This information can be"]
    #[doc = " accessed by the user-defined log output function through this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The loglevel of the message being processed."]
    pub fn rte_log_cur_msg_loglevel() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current logtype for the message being processed."]
    #[doc = ""]
    #[doc = " Before calling the user-defined stream for logging, the log"]
    #[doc = " subsystem sets a per-lcore variable containing the loglevel and the"]
    #[doc = " logtype of the message being processed. This information can be"]
    #[doc = " accessed by the user-defined log output function through this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The logtype of the message being processed."]
    pub fn rte_log_cur_msg_logtype() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a dynamic log type"]
    #[doc = ""]
    #[doc = " If a log is already registered with the same type, the returned value"]
    #[doc = " is the same than the previous one."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The string identifying the log type."]
    #[doc = " @return"]
    #[doc = "   - >0: success, the returned value is the log type identifier."]
    #[doc = "   - (-ENOMEM): cannot allocate memory."]
    pub fn rte_log_register(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a dynamic log type and try to pick its level from EAL options"]
    #[doc = ""]
    #[doc = " rte_log_register() is called inside. If successful, the function tries"]
    #[doc = " to search for matching regexp in the list of EAL log level options and"]
    #[doc = " pick the level from the last matching entry. If nothing can be applied"]
    #[doc = " from the list, the level will be set to the user-defined default value."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "    Name for the log type to be registered"]
    #[doc = " @param level_def"]
    #[doc = "    Fallback level to be set if the global list has no matching options"]
    #[doc = " @return"]
    #[doc = "    - >=0: the newly registered log type"]
    #[doc = "    - <0: rte_log_register() error value"]
    pub fn rte_log_register_type_and_pick_level(
        name: *const ::std::os::raw::c_char,
        level_def: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Dump name of each logtype, one per line."]
    #[doc = ""]
    #[doc = " @param out"]
    #[doc = "   Stream where the list is sent."]
    #[doc = " @param prefix"]
    #[doc = "   String preceding each logtype in the output."]
    pub fn rte_log_list_types(out: *mut FILE, prefix: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Dump log information."]
    #[doc = ""]
    #[doc = " Dump the global level and the registered log types."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   The output stream where the dump should be sent."]
    pub fn rte_log_dump(f: *mut FILE);
}
extern "C" {
    #[doc = " Generates a log message."]
    #[doc = ""]
    #[doc = " The message will be sent in the stream defined by the previous call"]
    #[doc = " to rte_openlog_stream()."]
    #[doc = ""]
    #[doc = " The level argument determines if the log should be displayed or"]
    #[doc = " not, depending on the loglevel settings."]
    #[doc = ""]
    #[doc = " The preferred alternative is the RTE_LOG() because it adds the"]
    #[doc = " level and type in the logged string."]
    #[doc = ""]
    #[doc = " @param level"]
    #[doc = "   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8)."]
    #[doc = " @param logtype"]
    #[doc = "   The log type, for example, RTE_LOGTYPE_EAL."]
    #[doc = " @param format"]
    #[doc = "   The format string, as in printf(3), followed by the variable arguments"]
    #[doc = "   required by the format."]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - Negative on error."]
    pub fn rte_log(
        level: u32,
        logtype: u32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generates a log message."]
    #[doc = ""]
    #[doc = " The message will be sent in the stream defined by the previous call"]
    #[doc = " to rte_openlog_stream()."]
    #[doc = ""]
    #[doc = " The level argument determines if the log should be displayed or"]
    #[doc = " not, depending on the loglevel settings. A trailing"]
    #[doc = " newline may be added if needed."]
    #[doc = ""]
    #[doc = " The preferred alternative is the RTE_LOG() because it adds the"]
    #[doc = " level and type in the logged string."]
    #[doc = ""]
    #[doc = " @param level"]
    #[doc = "   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8)."]
    #[doc = " @param logtype"]
    #[doc = "   The log type, for example, RTE_LOGTYPE_EAL."]
    #[doc = " @param format"]
    #[doc = "   The format string, as in printf(3), followed by the variable arguments"]
    #[doc = "   required by the format."]
    #[doc = " @param ap"]
    #[doc = "   The va_list of the variable arguments required by the format."]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - Negative on error."]
    pub fn rte_vlog(
        level: u32,
        logtype: u32,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump the stack of the calling core to the console."]
    pub fn rte_dump_stack();
}
extern "C" {
    pub fn __rte_panic(
        funcname: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __m128_u = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
extern "C" {
    pub fn _mm_sfence();
}
extern "C" {
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _mm_setcsr(__i: ::std::os::raw::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __m128d_u = [f64; 2usize];
pub type __m128i_u = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
extern "C" {
    pub fn _mm_clflush(__p: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _mm_lfence();
}
extern "C" {
    pub fn _mm_mfence();
}
extern "C" {
    pub fn _mm_pause();
}
#[doc = " The atomic counter structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_atomic16_t {
    #[doc = "< An internal counter value."]
    pub cnt: i16,
}
#[doc = " The atomic counter structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_atomic32_t {
    #[doc = "< An internal counter value."]
    pub cnt: i32,
}
#[doc = " The atomic counter structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_atomic64_t {
    #[doc = "< Internal counter value."]
    pub cnt: i64,
}
#[doc = " 128-bit integer structure."]
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct rte_int128_t {
    pub __bindgen_anon_1: rte_int128_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union rte_int128_t__bindgen_ty_1 {
    pub val: [u64; 2usize],
    pub int128: i128,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum timer_source {
    EAL_TIMER_TSC = 0,
    EAL_TIMER_HPET = 1,
}
extern "C" {
    pub static mut eal_timer_source: timer_source;
}
extern "C" {
    #[doc = " Get the measured frequency of the RDTSC counter"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The TSC frequency for this lcore"]
    pub fn rte_get_tsc_hz() -> u64;
}
extern "C" {
    #[doc = " Wait at least us microseconds."]
    #[doc = " This function can be replaced with user-defined function."]
    #[doc = " @see rte_delay_us_callback_register"]
    #[doc = ""]
    #[doc = " @param us"]
    #[doc = "   The number of microseconds to wait."]
    pub static mut rte_delay_us:
        ::std::option::Option<unsafe extern "C" fn(us: ::std::os::raw::c_uint)>;
}
extern "C" {
    #[doc = " Blocking delay function."]
    #[doc = ""]
    #[doc = " @param us"]
    #[doc = "   Number of microseconds to wait."]
    pub fn rte_delay_us_block(us: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Delay function that uses system sleep."]
    #[doc = " Does not block the CPU core."]
    #[doc = ""]
    #[doc = " @param us"]
    #[doc = "   Number of microseconds to wait."]
    pub fn rte_delay_us_sleep(us: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Replace rte_delay_us with user defined function."]
    #[doc = ""]
    #[doc = " @param userfunc"]
    #[doc = "   User function which replaces rte_delay_us. rte_delay_us_block restores"]
    #[doc = "   builtin block delay function."]
    pub fn rte_delay_us_callback_register(
        userfunc: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_uint)>,
    );
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Takes string \"string\" parameter and splits it at character \"delim\""]
    #[doc = " up to maxtokens-1 times - to give \"maxtokens\" resulting tokens. Like"]
    #[doc = " strtok or strsep functions, this modifies its input string, by replacing"]
    #[doc = " instances of \"delim\" with '\\\\0'. All resultant tokens are returned in the"]
    #[doc = " \"tokens\" array which must have enough entries to hold \"maxtokens\"."]
    #[doc = ""]
    #[doc = " @param string"]
    #[doc = "   The input string to be split into tokens"]
    #[doc = ""]
    #[doc = " @param stringlen"]
    #[doc = "   The max length of the input buffer"]
    #[doc = ""]
    #[doc = " @param tokens"]
    #[doc = "   The array to hold the pointers to the tokens in the string"]
    #[doc = ""]
    #[doc = " @param maxtokens"]
    #[doc = "   The number of elements in the tokens array. At most, maxtokens-1 splits"]
    #[doc = "   of the string will be done."]
    #[doc = ""]
    #[doc = " @param delim"]
    #[doc = "   The character on which the split of the data will be done"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The number of tokens in the tokens array."]
    pub fn rte_strsplit(
        string: *mut ::std::os::raw::c_char,
        stringlen: ::std::os::raw::c_int,
        tokens: *mut *mut ::std::os::raw::c_char,
        maxtokens: ::std::os::raw::c_int,
        delim: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlcpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        siz: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn strlcat(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        siz: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn strnstr(
        str_: *const ::std::os::raw::c_char,
        find: *const ::std::os::raw::c_char,
        str_len: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strmode(mode: mode_t, str_: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Copy string src to buffer dst of size dsize."]
    #[doc = " At most dsize-1 chars will be copied."]
    #[doc = " Always NUL-terminates, unless (dsize == 0)."]
    #[doc = ""]
    #[doc = " @param dst"]
    #[doc = "   The destination string."]
    #[doc = ""]
    #[doc = " @param src"]
    #[doc = "   The input string to be copied."]
    #[doc = ""]
    #[doc = " @param dsize"]
    #[doc = "   Length in bytes of the destination buffer."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The number of bytes copied (terminating NUL-byte excluded) on success."]
    #[doc = "   -E2BIG if the destination buffer is too small."]
    #[doc = "   rte_errno is set."]
    pub fn rte_strscpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dsize: size_t,
    ) -> ssize_t;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[doc = " Struct describing a Universal Unique Identifier"]
pub type rte_uuid_t = [::std::os::raw::c_uchar; 16usize];
extern "C" {
    #[doc = " Test if UUID is all zeros."]
    #[doc = ""]
    #[doc = " @param uu"]
    #[doc = "    The uuid to check."]
    #[doc = " @return"]
    #[doc = "    true if uuid is NULL value, false otherwise"]
    pub fn rte_uuid_is_null(uu: *mut ::std::os::raw::c_uchar) -> bool;
}
extern "C" {
    #[doc = " Compare two UUID's"]
    #[doc = ""]
    #[doc = " @param a"]
    #[doc = "    A UUID to compare"]
    #[doc = " @param b"]
    #[doc = "    A UUID to compare"]
    #[doc = " @return"]
    #[doc = "   returns an integer less than, equal to, or greater than zero if UUID a is"]
    #[doc = "   is less than, equal, or greater than UUID b."]
    pub fn rte_uuid_compare(
        a: *mut ::std::os::raw::c_uchar,
        b: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Extract UUID from string"]
    #[doc = ""]
    #[doc = " @param in"]
    #[doc = "    Pointer to string of characters to convert"]
    #[doc = " @param uu"]
    #[doc = "    Destination UUID"]
    #[doc = " @return"]
    #[doc = "    Returns 0 on success, and -1 if string is not a valid UUID."]
    pub fn rte_uuid_parse(
        in_: *const ::std::os::raw::c_char,
        uu: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_uuid_unparse(
        uu: *mut ::std::os::raw::c_uchar,
        out: *mut ::std::os::raw::c_char,
        len: size_t,
    );
}
#[doc = " The tracepoint object."]
pub type rte_trace_point_t = u64;
extern "C" {
    #[doc = " Enable recording events of the given tracepoint in the trace buffer."]
    #[doc = ""]
    #[doc = " @param tp"]
    #[doc = "   The tracepoint object to enable."]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - (-ERANGE): Trace object is not registered."]
    pub fn rte_trace_point_enable(tp: *mut rte_trace_point_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disable recording events of the given tracepoint in the trace buffer."]
    #[doc = ""]
    #[doc = " @param tp"]
    #[doc = "   The tracepoint object to disable."]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - (-ERANGE): Trace object is not registered."]
    pub fn rte_trace_point_disable(tp: *mut rte_trace_point_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test if recording events from the given tracepoint is enabled."]
    #[doc = ""]
    #[doc = " @param tp"]
    #[doc = "    The tracepoint object."]
    #[doc = " @return"]
    #[doc = "    true if tracepoint is enabled, false otherwise."]
    pub fn rte_trace_point_is_enabled(tp: *mut rte_trace_point_t) -> bool;
}
extern "C" {
    #[doc = " Lookup a tracepoint object from its name."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the tracepoint."]
    #[doc = " @return"]
    #[doc = "   The tracepoint object or NULL if not found."]
    pub fn rte_trace_point_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_trace_point_t;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = ""]
    #[doc = " Allocate trace memory buffer per thread."]
    #[doc = ""]
    pub fn __rte_trace_mem_per_thread_alloc();
}
extern "C" {
    #[doc = " @internal"]
    #[doc = ""]
    #[doc = " Helper function to emit field."]
    #[doc = ""]
    #[doc = " @param sz"]
    #[doc = "   The tracepoint size."]
    #[doc = " @param field"]
    #[doc = "   The name of the trace event."]
    #[doc = " @param type"]
    #[doc = "   The datatype of the trace event as string."]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - <0: Failure."]
    pub fn __rte_trace_point_emit_field(
        sz: size_t,
        field: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @internal"]
    #[doc = ""]
    #[doc = " Helper function to register a dynamic tracepoint."]
    #[doc = " Use RTE_TRACE_POINT_REGISTER macro for tracepoint registration."]
    #[doc = ""]
    #[doc = " @param trace"]
    #[doc = "   The tracepoint object created using RTE_TRACE_POINT_REGISTER."]
    #[doc = " @param name"]
    #[doc = "   The name of the tracepoint object."]
    #[doc = " @param register_fn"]
    #[doc = "   Trace registration function."]
    #[doc = " @return"]
    #[doc = "   - 0: Successfully registered the tracepoint."]
    #[doc = "   - <0: Failure to register the tracepoint."]
    pub fn __rte_trace_point_register(
        trace: *mut rte_trace_point_t,
        name: *const ::std::os::raw::c_char,
        register_fn: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut per_lcore_trace_point_sz: ::std::os::raw::c_int;
}
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
#[doc = " 64 bits vector size to use with unsigned 8 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v64u8_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v64u8_t = [u8; 8usize];
#[doc = " 64 bits vector size to use with unsigned 16 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v64u16_t){ a0, a1, a2, a3 }"]
pub type rte_v64u16_t = [u16; 4usize];
#[doc = " 64 bits vector size to use with unsigned 32 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v64u32_t){ a0, a1 }"]
pub type rte_v64u32_t = [u32; 2usize];
#[doc = " 128 bits vector size to use with unsigned 8 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128u8_t){ a00, a01, a02, a03, a04, a05, a06, a07,"]
#[doc = "                     a08, a09, a10, a11, a12, a13, a14, a15 }"]
pub type rte_v128u8_t = [u8; 16usize];
#[doc = " 128 bits vector size to use with unsigned 16 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128u16_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v128u16_t = [u16; 8usize];
#[doc = " 128 bits vector size to use with unsigned 32 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128u32_t){ a0, a1, a2, a3 }"]
pub type rte_v128u32_t = [u32; 4usize];
#[doc = " 128 bits vector size to use with unsigned 64 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128u64_t){ a0, a1 }"]
pub type rte_v128u64_t = [u64; 2usize];
#[doc = " 256 bits vector size to use with unsigned 8 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256u8_t){ a00, a01, a02, a03, a04, a05, a06, a07,"]
#[doc = "                     a08, a09, a10, a11, a12, a13, a14, a15,"]
#[doc = "                     a16, a17, a18, a19, a20, a21, a22, a23,"]
#[doc = "                     a24, a25, a26, a27, a28, a29, a30, a31 }"]
pub type rte_v256u8_t = [u8; 32usize];
#[doc = " 256 bits vector size to use with unsigned 16 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256u16_t){ a00, a01, a02, a03, a04, a05, a06, a07,"]
#[doc = "                      a08, a09, a10, a11, a12, a13, a14, a15 }"]
pub type rte_v256u16_t = [u16; 16usize];
#[doc = " 256 bits vector size to use with unsigned 32 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256u32_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v256u32_t = [u32; 8usize];
#[doc = " 256 bits vector size to use with unsigned 64 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256u64_t){ a0, a1, a2, a3 }"]
pub type rte_v256u64_t = [u64; 4usize];
#[doc = " 64 bits vector size to use with 8 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v64s8_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v64s8_t = [i8; 8usize];
#[doc = " 64 bits vector size to use with 16 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v64s16_t){ a0, a1, a2, a3 }"]
pub type rte_v64s16_t = [i16; 4usize];
#[doc = " 64 bits vector size to use with 32 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v64s32_t){ a0, a1 }"]
pub type rte_v64s32_t = [i32; 2usize];
#[doc = " 128 bits vector size to use with 8 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128s8_t){ a00, a01, a02, a03, a04, a05, a06, a07,"]
#[doc = "                     a08, a09, a10, a11, a12, a13, a14, a15 }"]
pub type rte_v128s8_t = [i8; 16usize];
#[doc = " 128 bits vector size to use with 16 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128s16_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v128s16_t = [i16; 8usize];
#[doc = " 128 bits vector size to use with 32 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128s32_t){ a0, a1, a2, a3 }"]
pub type rte_v128s32_t = [i32; 4usize];
#[doc = " 128 bits vector size to use with 64 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128s64_t){ a1, a2 }"]
pub type rte_v128s64_t = [i64; 2usize];
#[doc = " 256 bits vector size to use with 8 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256s8_t){ a00, a01, a02, a03, a04, a05, a06, a07,"]
#[doc = "                     a08, a09, a10, a11, a12, a13, a14, a15,"]
#[doc = "                     a16, a17, a18, a19, a20, a21, a22, a23,"]
#[doc = "                     a24, a25, a26, a27, a28, a29, a30, a31 }"]
pub type rte_v256s8_t = [i8; 32usize];
#[doc = " 256 bits vector size to use with 16 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256s16_t){ a00, a01, a02, a03, a04, a05, a06, a07,"]
#[doc = "                      a08, a09, a10, a11, a12, a13, a14, a15 }"]
pub type rte_v256s16_t = [i16; 16usize];
#[doc = " 256 bits vector size to use with 32 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256s32_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v256s32_t = [i32; 8usize];
#[doc = " 256 bits vector size to use with 64 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256s64_t){ a0, a1, a2, a3 }"]
pub type rte_v256s64_t = [i64; 4usize];
#[repr(u32)]
#[doc = " The max SIMD bitwidth value to limit vector path selection."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_vect_max_simd {
    RTE_VECT_SIMD_DISABLED = 64,
    RTE_VECT_SIMD_128 = 128,
    #[doc = "< Limits path selection to AVX2 or below."]
    RTE_VECT_SIMD_256 = 256,
    #[doc = "< Limits path selection to AVX512 or below."]
    RTE_VECT_SIMD_512 = 512,
    RTE_VECT_SIMD_MAX = 32768,
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Get the supported SIMD bitwidth."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   uint16_t bitwidth."]
    pub fn rte_vect_get_max_simd_bitwidth() -> u16;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Set the supported SIMD bitwidth."]
    #[doc = " This API should only be called once at initialization, before EAL init."]
    #[doc = ""]
    #[doc = " @param bitwidth"]
    #[doc = "   uint16_t bitwidth."]
    #[doc = " @return"]
    #[doc = "   - 0 on success."]
    #[doc = "   - -EINVAL on invalid bitwidth parameter."]
    #[doc = "   - -EPERM if bitwidth is forced."]
    pub fn rte_vect_set_max_simd_bitwidth(bitwidth: u16) -> ::std::os::raw::c_int;
}
pub type __v4df = [f64; 4usize];
pub type __v8sf = [f32; 8usize];
pub type __v4di = [::std::os::raw::c_longlong; 4usize];
pub type __v8si = [::std::os::raw::c_int; 8usize];
pub type __v16hi = [::std::os::raw::c_short; 16usize];
pub type __v32qi = [::std::os::raw::c_char; 32usize];
pub type __v4du = [::std::os::raw::c_ulonglong; 4usize];
pub type __v8su = [::std::os::raw::c_uint; 8usize];
pub type __v16hu = [::std::os::raw::c_ushort; 16usize];
pub type __v32qu = [::std::os::raw::c_uchar; 32usize];
pub type __v32qs = [::std::os::raw::c_schar; 32usize];
pub type __m256 = [f32; 8usize];
pub type __m256d = [f64; 4usize];
pub type __m256i = [::std::os::raw::c_longlong; 4usize];
pub type __m256_u = [f32; 8usize];
pub type __m256d_u = [f64; 4usize];
pub type __m256i_u = [::std::os::raw::c_longlong; 4usize];
pub type __v64qi = [::std::os::raw::c_char; 64usize];
pub type __v32hi = [::std::os::raw::c_short; 32usize];
pub type __v8df = [f64; 8usize];
pub type __v16sf = [f32; 16usize];
pub type __v8di = [::std::os::raw::c_longlong; 8usize];
pub type __v16si = [::std::os::raw::c_int; 16usize];
pub type __v64qu = [::std::os::raw::c_uchar; 64usize];
pub type __v32hu = [::std::os::raw::c_ushort; 32usize];
pub type __v8du = [::std::os::raw::c_ulonglong; 8usize];
pub type __v16su = [::std::os::raw::c_uint; 16usize];
pub type __m512 = [f32; 16usize];
pub type __m512d = [f64; 8usize];
pub type __m512i = [::std::os::raw::c_longlong; 8usize];
pub type __m512_u = [f32; 16usize];
pub type __m512d_u = [f64; 8usize];
pub type __m512i_u = [::std::os::raw::c_longlong; 8usize];
pub type __mmask8 = ::std::os::raw::c_uchar;
pub type __mmask16 = ::std::os::raw::c_ushort;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MM_CMPINT_ENUM {
    _MM_CMPINT_EQ = 0,
    _MM_CMPINT_LT = 1,
    _MM_CMPINT_LE = 2,
    _MM_CMPINT_UNUSED = 3,
    _MM_CMPINT_NE = 4,
    _MM_CMPINT_NLT = 5,
    _MM_CMPINT_NLE = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MM_PERM_ENUM {
    _MM_PERM_AAAA = 0,
    _MM_PERM_AAAB = 1,
    _MM_PERM_AAAC = 2,
    _MM_PERM_AAAD = 3,
    _MM_PERM_AABA = 4,
    _MM_PERM_AABB = 5,
    _MM_PERM_AABC = 6,
    _MM_PERM_AABD = 7,
    _MM_PERM_AACA = 8,
    _MM_PERM_AACB = 9,
    _MM_PERM_AACC = 10,
    _MM_PERM_AACD = 11,
    _MM_PERM_AADA = 12,
    _MM_PERM_AADB = 13,
    _MM_PERM_AADC = 14,
    _MM_PERM_AADD = 15,
    _MM_PERM_ABAA = 16,
    _MM_PERM_ABAB = 17,
    _MM_PERM_ABAC = 18,
    _MM_PERM_ABAD = 19,
    _MM_PERM_ABBA = 20,
    _MM_PERM_ABBB = 21,
    _MM_PERM_ABBC = 22,
    _MM_PERM_ABBD = 23,
    _MM_PERM_ABCA = 24,
    _MM_PERM_ABCB = 25,
    _MM_PERM_ABCC = 26,
    _MM_PERM_ABCD = 27,
    _MM_PERM_ABDA = 28,
    _MM_PERM_ABDB = 29,
    _MM_PERM_ABDC = 30,
    _MM_PERM_ABDD = 31,
    _MM_PERM_ACAA = 32,
    _MM_PERM_ACAB = 33,
    _MM_PERM_ACAC = 34,
    _MM_PERM_ACAD = 35,
    _MM_PERM_ACBA = 36,
    _MM_PERM_ACBB = 37,
    _MM_PERM_ACBC = 38,
    _MM_PERM_ACBD = 39,
    _MM_PERM_ACCA = 40,
    _MM_PERM_ACCB = 41,
    _MM_PERM_ACCC = 42,
    _MM_PERM_ACCD = 43,
    _MM_PERM_ACDA = 44,
    _MM_PERM_ACDB = 45,
    _MM_PERM_ACDC = 46,
    _MM_PERM_ACDD = 47,
    _MM_PERM_ADAA = 48,
    _MM_PERM_ADAB = 49,
    _MM_PERM_ADAC = 50,
    _MM_PERM_ADAD = 51,
    _MM_PERM_ADBA = 52,
    _MM_PERM_ADBB = 53,
    _MM_PERM_ADBC = 54,
    _MM_PERM_ADBD = 55,
    _MM_PERM_ADCA = 56,
    _MM_PERM_ADCB = 57,
    _MM_PERM_ADCC = 58,
    _MM_PERM_ADCD = 59,
    _MM_PERM_ADDA = 60,
    _MM_PERM_ADDB = 61,
    _MM_PERM_ADDC = 62,
    _MM_PERM_ADDD = 63,
    _MM_PERM_BAAA = 64,
    _MM_PERM_BAAB = 65,
    _MM_PERM_BAAC = 66,
    _MM_PERM_BAAD = 67,
    _MM_PERM_BABA = 68,
    _MM_PERM_BABB = 69,
    _MM_PERM_BABC = 70,
    _MM_PERM_BABD = 71,
    _MM_PERM_BACA = 72,
    _MM_PERM_BACB = 73,
    _MM_PERM_BACC = 74,
    _MM_PERM_BACD = 75,
    _MM_PERM_BADA = 76,
    _MM_PERM_BADB = 77,
    _MM_PERM_BADC = 78,
    _MM_PERM_BADD = 79,
    _MM_PERM_BBAA = 80,
    _MM_PERM_BBAB = 81,
    _MM_PERM_BBAC = 82,
    _MM_PERM_BBAD = 83,
    _MM_PERM_BBBA = 84,
    _MM_PERM_BBBB = 85,
    _MM_PERM_BBBC = 86,
    _MM_PERM_BBBD = 87,
    _MM_PERM_BBCA = 88,
    _MM_PERM_BBCB = 89,
    _MM_PERM_BBCC = 90,
    _MM_PERM_BBCD = 91,
    _MM_PERM_BBDA = 92,
    _MM_PERM_BBDB = 93,
    _MM_PERM_BBDC = 94,
    _MM_PERM_BBDD = 95,
    _MM_PERM_BCAA = 96,
    _MM_PERM_BCAB = 97,
    _MM_PERM_BCAC = 98,
    _MM_PERM_BCAD = 99,
    _MM_PERM_BCBA = 100,
    _MM_PERM_BCBB = 101,
    _MM_PERM_BCBC = 102,
    _MM_PERM_BCBD = 103,
    _MM_PERM_BCCA = 104,
    _MM_PERM_BCCB = 105,
    _MM_PERM_BCCC = 106,
    _MM_PERM_BCCD = 107,
    _MM_PERM_BCDA = 108,
    _MM_PERM_BCDB = 109,
    _MM_PERM_BCDC = 110,
    _MM_PERM_BCDD = 111,
    _MM_PERM_BDAA = 112,
    _MM_PERM_BDAB = 113,
    _MM_PERM_BDAC = 114,
    _MM_PERM_BDAD = 115,
    _MM_PERM_BDBA = 116,
    _MM_PERM_BDBB = 117,
    _MM_PERM_BDBC = 118,
    _MM_PERM_BDBD = 119,
    _MM_PERM_BDCA = 120,
    _MM_PERM_BDCB = 121,
    _MM_PERM_BDCC = 122,
    _MM_PERM_BDCD = 123,
    _MM_PERM_BDDA = 124,
    _MM_PERM_BDDB = 125,
    _MM_PERM_BDDC = 126,
    _MM_PERM_BDDD = 127,
    _MM_PERM_CAAA = 128,
    _MM_PERM_CAAB = 129,
    _MM_PERM_CAAC = 130,
    _MM_PERM_CAAD = 131,
    _MM_PERM_CABA = 132,
    _MM_PERM_CABB = 133,
    _MM_PERM_CABC = 134,
    _MM_PERM_CABD = 135,
    _MM_PERM_CACA = 136,
    _MM_PERM_CACB = 137,
    _MM_PERM_CACC = 138,
    _MM_PERM_CACD = 139,
    _MM_PERM_CADA = 140,
    _MM_PERM_CADB = 141,
    _MM_PERM_CADC = 142,
    _MM_PERM_CADD = 143,
    _MM_PERM_CBAA = 144,
    _MM_PERM_CBAB = 145,
    _MM_PERM_CBAC = 146,
    _MM_PERM_CBAD = 147,
    _MM_PERM_CBBA = 148,
    _MM_PERM_CBBB = 149,
    _MM_PERM_CBBC = 150,
    _MM_PERM_CBBD = 151,
    _MM_PERM_CBCA = 152,
    _MM_PERM_CBCB = 153,
    _MM_PERM_CBCC = 154,
    _MM_PERM_CBCD = 155,
    _MM_PERM_CBDA = 156,
    _MM_PERM_CBDB = 157,
    _MM_PERM_CBDC = 158,
    _MM_PERM_CBDD = 159,
    _MM_PERM_CCAA = 160,
    _MM_PERM_CCAB = 161,
    _MM_PERM_CCAC = 162,
    _MM_PERM_CCAD = 163,
    _MM_PERM_CCBA = 164,
    _MM_PERM_CCBB = 165,
    _MM_PERM_CCBC = 166,
    _MM_PERM_CCBD = 167,
    _MM_PERM_CCCA = 168,
    _MM_PERM_CCCB = 169,
    _MM_PERM_CCCC = 170,
    _MM_PERM_CCCD = 171,
    _MM_PERM_CCDA = 172,
    _MM_PERM_CCDB = 173,
    _MM_PERM_CCDC = 174,
    _MM_PERM_CCDD = 175,
    _MM_PERM_CDAA = 176,
    _MM_PERM_CDAB = 177,
    _MM_PERM_CDAC = 178,
    _MM_PERM_CDAD = 179,
    _MM_PERM_CDBA = 180,
    _MM_PERM_CDBB = 181,
    _MM_PERM_CDBC = 182,
    _MM_PERM_CDBD = 183,
    _MM_PERM_CDCA = 184,
    _MM_PERM_CDCB = 185,
    _MM_PERM_CDCC = 186,
    _MM_PERM_CDCD = 187,
    _MM_PERM_CDDA = 188,
    _MM_PERM_CDDB = 189,
    _MM_PERM_CDDC = 190,
    _MM_PERM_CDDD = 191,
    _MM_PERM_DAAA = 192,
    _MM_PERM_DAAB = 193,
    _MM_PERM_DAAC = 194,
    _MM_PERM_DAAD = 195,
    _MM_PERM_DABA = 196,
    _MM_PERM_DABB = 197,
    _MM_PERM_DABC = 198,
    _MM_PERM_DABD = 199,
    _MM_PERM_DACA = 200,
    _MM_PERM_DACB = 201,
    _MM_PERM_DACC = 202,
    _MM_PERM_DACD = 203,
    _MM_PERM_DADA = 204,
    _MM_PERM_DADB = 205,
    _MM_PERM_DADC = 206,
    _MM_PERM_DADD = 207,
    _MM_PERM_DBAA = 208,
    _MM_PERM_DBAB = 209,
    _MM_PERM_DBAC = 210,
    _MM_PERM_DBAD = 211,
    _MM_PERM_DBBA = 212,
    _MM_PERM_DBBB = 213,
    _MM_PERM_DBBC = 214,
    _MM_PERM_DBBD = 215,
    _MM_PERM_DBCA = 216,
    _MM_PERM_DBCB = 217,
    _MM_PERM_DBCC = 218,
    _MM_PERM_DBCD = 219,
    _MM_PERM_DBDA = 220,
    _MM_PERM_DBDB = 221,
    _MM_PERM_DBDC = 222,
    _MM_PERM_DBDD = 223,
    _MM_PERM_DCAA = 224,
    _MM_PERM_DCAB = 225,
    _MM_PERM_DCAC = 226,
    _MM_PERM_DCAD = 227,
    _MM_PERM_DCBA = 228,
    _MM_PERM_DCBB = 229,
    _MM_PERM_DCBC = 230,
    _MM_PERM_DCBD = 231,
    _MM_PERM_DCCA = 232,
    _MM_PERM_DCCB = 233,
    _MM_PERM_DCCC = 234,
    _MM_PERM_DCCD = 235,
    _MM_PERM_DCDA = 236,
    _MM_PERM_DCDB = 237,
    _MM_PERM_DCDC = 238,
    _MM_PERM_DCDD = 239,
    _MM_PERM_DDAA = 240,
    _MM_PERM_DDAB = 241,
    _MM_PERM_DDAC = 242,
    _MM_PERM_DDAD = 243,
    _MM_PERM_DDBA = 244,
    _MM_PERM_DDBB = 245,
    _MM_PERM_DDBC = 246,
    _MM_PERM_DDBD = 247,
    _MM_PERM_DDCA = 248,
    _MM_PERM_DDCB = 249,
    _MM_PERM_DDCC = 250,
    _MM_PERM_DDCD = 251,
    _MM_PERM_DDDA = 252,
    _MM_PERM_DDDB = 253,
    _MM_PERM_DDDC = 254,
    _MM_PERM_DDDD = 255,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MM_MANTISSA_NORM_ENUM {
    _MM_MANT_NORM_1_2 = 0,
    _MM_MANT_NORM_p5_2 = 1,
    _MM_MANT_NORM_p5_1 = 2,
    _MM_MANT_NORM_p75_1p5 = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MM_MANTISSA_SIGN_ENUM {
    _MM_MANT_SIGN_src = 0,
    _MM_MANT_SIGN_zero = 1,
    _MM_MANT_SIGN_nan = 2,
}
pub type __v2hi = [::std::os::raw::c_short; 2usize];
pub type __v4qi = [::std::os::raw::c_char; 4usize];
pub type __v2qi = [::std::os::raw::c_char; 2usize];
pub type __mmask32 = ::std::os::raw::c_uint;
pub type __mmask64 = ::std::os::raw::c_ulonglong;
pub type __m512bh = [::std::os::raw::c_short; 32usize];
pub type __m256bh = [::std::os::raw::c_short; 16usize];
pub type __bfloat16 = ::std::os::raw::c_ushort;
pub type __m128bh = [::std::os::raw::c_short; 8usize];
pub type xmm_t = __m128i;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union rte_xmm {
    pub x: xmm_t,
    pub u8_: [u8; 16usize],
    pub u16_: [u16; 8usize],
    pub u32_: [u32; 4usize],
    pub u64_: [u64; 2usize],
    pub pd: [f64; 2usize],
}
pub type rte_xmm_t = rte_xmm;
pub type ymm_t = __m256i;
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub union rte_ymm {
    pub y: ymm_t,
    pub x: [xmm_t; 2usize],
    pub u8_: [u8; 32usize],
    pub u16_: [u16; 16usize],
    pub u32_: [u32; 8usize],
    pub u64_: [u64; 4usize],
    pub pd: [f64; 4usize],
}
pub type rte_ymm_t = rte_ymm;
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    );
}
#[doc = " The rte_rwlock_t type."]
#[doc = ""]
#[doc = " cnt is -1 when write lock is held, and > 0 when read locks are held."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_rwlock_t {
    #[doc = "< -1 when W lock held, > 0 when R locks held."]
    pub cnt: i32,
}
#[repr(u32)]
#[doc = " The device event type."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_dev_event_type {
    #[doc = "< device being added"]
    RTE_DEV_EVENT_ADD = 0,
    #[doc = "< device being removed"]
    RTE_DEV_EVENT_REMOVE = 1,
    #[doc = "< max value of this enum"]
    RTE_DEV_EVENT_MAX = 2,
}
pub type rte_dev_event_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        device_name: *const ::std::os::raw::c_char,
        event: rte_dev_event_type,
        cb_arg: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(u32)]
#[doc = " Device policies."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_dev_policy {
    RTE_DEV_ALLOWED = 0,
    RTE_DEV_BLOCKED = 1,
}
#[doc = " A generic memory resource representation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mem_resource {
    #[doc = "< Physical address, 0 if not resource."]
    pub phys_addr: u64,
    #[doc = "< Length of the resource."]
    pub len: u64,
    #[doc = "< Virtual address, NULL when not mapped."]
    pub addr: *mut ::std::os::raw::c_void,
}
#[doc = " A structure describing a device driver."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_driver {
    #[doc = "< Next in list."]
    pub next: rte_driver__bindgen_ty_1,
    #[doc = "< Driver name."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Driver alias."]
    pub alias: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_driver__bindgen_ty_1 {
    pub tqe_next: *mut rte_driver,
    pub tqe_prev: *mut *mut rte_driver,
}
#[doc = " A structure describing a generic device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_device {
    #[doc = "< Next device"]
    pub next: rte_device__bindgen_ty_1,
    #[doc = "< Device name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Driver assigned after probing"]
    pub driver: *const rte_driver,
    #[doc = "< Bus handle assigned on scan"]
    pub bus: *const rte_bus,
    #[doc = "< NUMA node connection"]
    pub numa_node: ::std::os::raw::c_int,
    #[doc = "< Arguments for latest probing"]
    pub devargs: *mut rte_devargs,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_device__bindgen_ty_1 {
    pub tqe_next: *mut rte_device,
    pub tqe_prev: *mut *mut rte_device,
}
extern "C" {
    #[doc = " Query status of a device."]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "   Generic device pointer."]
    #[doc = " @return"]
    #[doc = "   (int)true if already probed successfully, 0 otherwise."]
    pub fn rte_dev_is_probed(dev: *const rte_device) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Hotplug add a given device to a specific bus."]
    #[doc = ""]
    #[doc = " In multi-process, it will request other processes to add the same device."]
    #[doc = " A failure, in any process, will rollback the action"]
    #[doc = ""]
    #[doc = " @param busname"]
    #[doc = "   The bus name the device is added to."]
    #[doc = " @param devname"]
    #[doc = "   The device name. Based on this device name, eal will identify a driver"]
    #[doc = "   capable of handling it and pass it to the driver probing function."]
    #[doc = " @param drvargs"]
    #[doc = "   Device arguments to be passed to the driver."]
    #[doc = " @return"]
    #[doc = "   0 on success, negative on error."]
    pub fn rte_eal_hotplug_add(
        busname: *const ::std::os::raw::c_char,
        devname: *const ::std::os::raw::c_char,
        drvargs: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add matching devices."]
    #[doc = ""]
    #[doc = " In multi-process, it will request other processes to add the same device."]
    #[doc = " A failure, in any process, will rollback the action"]
    #[doc = ""]
    #[doc = " @param devargs"]
    #[doc = "   Device arguments including bus, class and driver properties."]
    #[doc = " @return"]
    #[doc = "   0 on success, negative on error."]
    pub fn rte_dev_probe(devargs: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Hotplug remove a given device from a specific bus."]
    #[doc = ""]
    #[doc = " In multi-process, it will request other processes to remove the same device."]
    #[doc = " A failure, in any process, will rollback the action"]
    #[doc = ""]
    #[doc = " @param busname"]
    #[doc = "   The bus name the device is removed from."]
    #[doc = " @param devname"]
    #[doc = "   The device name being removed."]
    #[doc = " @return"]
    #[doc = "   0 on success, negative on error."]
    pub fn rte_eal_hotplug_remove(
        busname: *const ::std::os::raw::c_char,
        devname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove one device."]
    #[doc = ""]
    #[doc = " In multi-process, it will request other processes to remove the same device."]
    #[doc = " A failure, in any process, will rollback the action"]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "   Data structure of the device to remove."]
    #[doc = " @return"]
    #[doc = "   0 on success, negative on error."]
    pub fn rte_dev_remove(dev: *mut rte_device) -> ::std::os::raw::c_int;
}
#[doc = " Device comparison function."]
#[doc = ""]
#[doc = " This type of function is used to compare an rte_device with arbitrary"]
#[doc = " data."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Device handle."]
#[doc = ""]
#[doc = " @param data"]
#[doc = "   Data to compare against. The type of this parameter is determined by"]
#[doc = "   the kind of comparison performed by the function."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   0 if the device matches the data."]
#[doc = "   !0 if the device does not match."]
#[doc = "   <0 if ordering is possible and the device is lower than the data."]
#[doc = "   >0 if ordering is possible and the device is greater than the data."]
pub type rte_dev_cmp_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *const rte_device,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Iteration context."]
#[doc = ""]
#[doc = " This context carries over the current iteration state."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_dev_iterator {
    #[doc = "< device string."]
    pub dev_str: *const ::std::os::raw::c_char,
    #[doc = "< bus-related part of device string."]
    pub bus_str: *const ::std::os::raw::c_char,
    #[doc = "< class-related part of device string."]
    pub cls_str: *const ::std::os::raw::c_char,
    #[doc = "< bus handle."]
    pub bus: *mut rte_bus,
    #[doc = "< class handle."]
    pub cls: *mut rte_class,
    #[doc = "< current position."]
    pub device: *mut rte_device,
    #[doc = "< additional specialized context."]
    pub class_device: *mut ::std::os::raw::c_void,
}
#[doc = " Device iteration function."]
#[doc = ""]
#[doc = " Find the next device matching properties passed in parameters."]
#[doc = " The function takes an additional ``start`` parameter, that is"]
#[doc = " used as starting context when relevant."]
#[doc = ""]
#[doc = " The function returns the current element in the iteration."]
#[doc = " This return value will potentially be used as a start parameter"]
#[doc = " in subsequent calls to the function."]
#[doc = ""]
#[doc = " The additional iterator parameter is only there if a specific"]
#[doc = " implementation needs additional context. It must not be modified by"]
#[doc = " the iteration function itself."]
#[doc = ""]
#[doc = " @param start"]
#[doc = "   Starting iteration context."]
#[doc = ""]
#[doc = " @param devstr"]
#[doc = "   Device description string."]
#[doc = ""]
#[doc = " @param it"]
#[doc = "   Device iterator."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   The address of the current element matching the device description"]
#[doc = "   string."]
pub type rte_dev_iterate_t = ::std::option::Option<
    unsafe extern "C" fn(
        start: *const ::std::os::raw::c_void,
        devstr: *const ::std::os::raw::c_char,
        it: *const rte_dev_iterator,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    #[doc = " Initializes a device iterator."]
    #[doc = ""]
    #[doc = " This iterator allows accessing a list of devices matching a criteria."]
    #[doc = " The device matching is made among all buses and classes currently registered,"]
    #[doc = " filtered by the device description given as parameter."]
    #[doc = ""]
    #[doc = " This function will not allocate any memory. It is safe to stop the"]
    #[doc = " iteration at any moment and let the iterator go out of context."]
    #[doc = ""]
    #[doc = " @param it"]
    #[doc = "   Device iterator handle."]
    #[doc = ""]
    #[doc = " @param str"]
    #[doc = "   Device description string."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on successful initialization."]
    #[doc = "   <0 on error."]
    pub fn rte_dev_iterator_init(
        it: *mut rte_dev_iterator,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iterates on a device iterator."]
    #[doc = ""]
    #[doc = " Generates a new rte_device handle corresponding to the next element"]
    #[doc = " in the list described in comprehension by the iterator."]
    #[doc = ""]
    #[doc = " The next object is returned, and the iterator is updated."]
    #[doc = ""]
    #[doc = " @param it"]
    #[doc = "   Device iterator handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   An rte_device handle if found."]
    #[doc = "   NULL if an error occurred (rte_errno is set)."]
    #[doc = "   NULL if no device could be found (rte_errno is not set)."]
    pub fn rte_dev_iterator_next(it: *mut rte_dev_iterator) -> *mut rte_device;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " It registers the callback for the specific device."]
    #[doc = " Multiple callbacks can be registered at the same time."]
    #[doc = ""]
    #[doc = " @param device_name"]
    #[doc = "  The device name, that is the param name of the struct rte_device,"]
    #[doc = "  null value means for all devices."]
    #[doc = " @param cb_fn"]
    #[doc = "  callback address."]
    #[doc = " @param cb_arg"]
    #[doc = "  address of parameter for callback."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_dev_event_callback_register(
        device_name: *const ::std::os::raw::c_char,
        cb_fn: rte_dev_event_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " It unregisters the callback according to the specified device."]
    #[doc = ""]
    #[doc = " @param device_name"]
    #[doc = "  The device name, that is the param name of the struct rte_device,"]
    #[doc = "  null value means for all devices and their callbacks."]
    #[doc = " @param cb_fn"]
    #[doc = "  callback address."]
    #[doc = " @param cb_arg"]
    #[doc = "  address of parameter for callback, (void *)-1 means to remove all"]
    #[doc = "  registered which has the same callback address."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, return the number of callback entities removed."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_dev_event_callback_unregister(
        device_name: *const ::std::os::raw::c_char,
        cb_fn: rte_dev_event_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Executes all the user application registered callbacks for"]
    #[doc = " the specific device."]
    #[doc = ""]
    #[doc = " @param device_name"]
    #[doc = "  The device name."]
    #[doc = " @param event"]
    #[doc = "  the device event type."]
    pub fn rte_dev_event_callback_process(
        device_name: *const ::std::os::raw::c_char,
        event: rte_dev_event_type,
    );
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Start the device event monitoring."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_dev_event_monitor_start() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Stop the device event monitoring."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_dev_event_monitor_stop() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Enable hotplug handling for devices."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_dev_hotplug_handle_enable() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Disable hotplug handling for devices."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_dev_hotplug_handle_disable() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Device level DMA map function."]
    #[doc = " After a successful call, the memory segment will be mapped to the"]
    #[doc = " given device."]
    #[doc = ""]
    #[doc = " @note: Memory must be registered in advance using rte_extmem_* APIs."]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "\tDevice pointer."]
    #[doc = " @param addr"]
    #[doc = "\tVirtual address to map."]
    #[doc = " @param iova"]
    #[doc = "\tIOVA address to map."]
    #[doc = " @param len"]
    #[doc = "\tLength of the memory segment being mapped."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\t0 if mapping was successful."]
    #[doc = "\tNegative value and rte_errno is set otherwise."]
    pub fn rte_dev_dma_map(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Device level DMA unmap function."]
    #[doc = " After a successful call, the memory segment will no longer be"]
    #[doc = " accessible by the given device."]
    #[doc = ""]
    #[doc = " @note: Memory must be registered in advance using rte_extmem_* APIs."]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "\tDevice pointer."]
    #[doc = " @param addr"]
    #[doc = "\tVirtual address to unmap."]
    #[doc = " @param iova"]
    #[doc = "\tIOVA address to unmap."]
    #[doc = " @param len"]
    #[doc = "\tLength of the memory segment being mapped."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\t0 if un-mapping was successful."]
    #[doc = "\tNegative value and rte_errno is set otherwise."]
    pub fn rte_dev_dma_unmap(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Double linked list of buses"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bus_list {
    pub tqh_first: *mut rte_bus,
    pub tqh_last: *mut *mut rte_bus,
}
#[repr(u32)]
#[doc = " IOVA mapping mode."]
#[doc = ""]
#[doc = " IOVA mapping mode is iommu programming mode of a device."]
#[doc = " That device (for example: IOMMU backed DMA device) based"]
#[doc = " on rte_iova_mode will generate physical or virtual address."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_iova_mode {
    RTE_IOVA_DC = 0,
    RTE_IOVA_PA = 1,
    RTE_IOVA_VA = 2,
}
#[doc = " Bus specific scan for devices attached on the bus."]
#[doc = " For each bus object, the scan would be responsible for finding devices and"]
#[doc = " adding them to its private device list."]
#[doc = ""]
#[doc = " A bus should mandatorily implement this method."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 for successful scan"]
#[doc = "\t<0 for unsuccessful scan with error value"]
pub type rte_bus_scan_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
#[doc = " Implementation specific probe function which is responsible for linking"]
#[doc = " devices on that bus with applicable drivers."]
#[doc = ""]
#[doc = " This is called while iterating over each registered bus."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 for successful probe"]
#[doc = "\t!0 for any error while probing"]
pub type rte_bus_probe_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
#[doc = " Device iterator to find a device on a bus."]
#[doc = ""]
#[doc = " This function returns an rte_device if one of those held by the bus"]
#[doc = " matches the data passed as parameter."]
#[doc = ""]
#[doc = " If the comparison function returns zero this function should stop iterating"]
#[doc = " over any more devices. To continue a search the device of a previous search"]
#[doc = " can be passed via the start parameter."]
#[doc = ""]
#[doc = " @param cmp"]
#[doc = "\tComparison function."]
#[doc = ""]
#[doc = " @param data"]
#[doc = "\tData to compare each device against."]
#[doc = ""]
#[doc = " @param start"]
#[doc = "\tstarting point for the iteration"]
#[doc = ""]
#[doc = " @return"]
#[doc = "\tThe first device matching the data, NULL if none exists."]
pub type rte_bus_find_device_t = ::std::option::Option<
    unsafe extern "C" fn(
        start: *const rte_device,
        cmp: rte_dev_cmp_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut rte_device,
>;
#[doc = " Implementation specific probe function which is responsible for linking"]
#[doc = " devices on that bus with applicable drivers."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "\tDevice pointer that was returned by a previous call to find_device."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 on success."]
#[doc = "\t!0 on error."]
pub type rte_bus_plug_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device) -> ::std::os::raw::c_int>;
#[doc = " Implementation specific remove function which is responsible for unlinking"]
#[doc = " devices on that bus from assigned driver."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "\tDevice pointer that was returned by a previous call to find_device."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 on success."]
#[doc = "\t!0 on error."]
pub type rte_bus_unplug_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device) -> ::std::os::raw::c_int>;
#[doc = " Bus specific parsing function."]
#[doc = " Validates the syntax used in the textual representation of a device,"]
#[doc = " If the syntax is valid and ``addr`` is not NULL, writes the bus-specific"]
#[doc = " device representation to ``addr``."]
#[doc = ""]
#[doc = " @param[in] name"]
#[doc = "\tdevice textual description"]
#[doc = ""]
#[doc = " @param[out] addr"]
#[doc = "\tdevice information location address, into which parsed info"]
#[doc = "\tshould be written. If NULL, nothing should be written, which"]
#[doc = "\tis not an error."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 if parsing was successful."]
#[doc = "\t!0 for any error."]
pub type rte_bus_parse_t = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        addr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Parse bus part of the device arguments."]
#[doc = ""]
#[doc = " The field name of the struct rte_devargs will be set."]
#[doc = ""]
#[doc = " @param da"]
#[doc = "\tPointer to the devargs to parse."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 on successful parsing, otherwise rte_errno is set."]
#[doc = "\t-EINVAL: on parsing error."]
#[doc = "\t-ENODEV: if no key matching a device argument is specified."]
#[doc = "\t-E2BIG: device name is too long."]
pub type rte_bus_devargs_parse_t =
    ::std::option::Option<unsafe extern "C" fn(da: *mut rte_devargs) -> ::std::os::raw::c_int>;
#[doc = " Device level DMA map function."]
#[doc = " After a successful call, the memory segment will be mapped to the"]
#[doc = " given device."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "\tDevice pointer."]
#[doc = " @param addr"]
#[doc = "\tVirtual address to map."]
#[doc = " @param iova"]
#[doc = "\tIOVA address to map."]
#[doc = " @param len"]
#[doc = "\tLength of the memory segment being mapped."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 if mapping was successful."]
#[doc = "\tNegative value and rte_errno is set otherwise."]
pub type rte_dev_dma_map_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: size_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Device level DMA unmap function."]
#[doc = " After a successful call, the memory segment will no longer be"]
#[doc = " accessible by the given device."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "\tDevice pointer."]
#[doc = " @param addr"]
#[doc = "\tVirtual address to unmap."]
#[doc = " @param iova"]
#[doc = "\tIOVA address to unmap."]
#[doc = " @param len"]
#[doc = "\tLength of the memory segment being mapped."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 if un-mapping was successful."]
#[doc = "\tNegative value and rte_errno is set otherwise."]
pub type rte_dev_dma_unmap_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: size_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Implement a specific hot-unplug handler, which is responsible for"]
#[doc = " handle the failure when device be hot-unplugged. When the event of"]
#[doc = " hot-unplug be detected, it could call this function to handle"]
#[doc = " the hot-unplug failure and avoid app crash."]
#[doc = " @param dev"]
#[doc = "\tPointer of the device structure."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 on success."]
#[doc = "\t!0 on error."]
pub type rte_bus_hot_unplug_handler_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device) -> ::std::os::raw::c_int>;
#[doc = " Implement a specific sigbus handler, which is responsible for handling"]
#[doc = " the sigbus error which is either original memory error, or specific memory"]
#[doc = " error that caused of device be hot-unplugged. When sigbus error be captured,"]
#[doc = " it could call this function to handle sigbus error."]
#[doc = " @param failure_addr"]
#[doc = "\tPointer of the fault address of the sigbus error."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 for success handle the sigbus for hot-unplug."]
#[doc = "\t1 for not process it, because it is a generic sigbus error."]
#[doc = "\t-1 for failed to handle the sigbus for hot-unplug."]
pub type rte_bus_sigbus_handler_t = ::std::option::Option<
    unsafe extern "C" fn(failure_addr: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(u32)]
#[doc = " Bus scan policies"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_bus_scan_mode {
    RTE_BUS_SCAN_UNDEFINED = 0,
    RTE_BUS_SCAN_ALLOWLIST = 1,
    RTE_BUS_SCAN_BLOCKLIST = 2,
}
#[doc = " A structure used to configure bus operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bus_conf {
    #[doc = "< Scan policy."]
    pub scan_mode: rte_bus_scan_mode,
}
#[doc = " Get common iommu class of the all the devices on the bus. The bus may"]
#[doc = " check that those devices are attached to iommu driver."]
#[doc = " If no devices are attached to the bus. The bus may return with don't care"]
#[doc = " (_DC) value."]
#[doc = " Otherwise, The bus will return appropriate _pa or _va iova mode."]
#[doc = ""]
#[doc = " @return"]
#[doc = "      enum rte_iova_mode value."]
pub type rte_bus_get_iommu_class_t = ::std::option::Option<unsafe extern "C" fn() -> rte_iova_mode>;
#[doc = " A structure describing a generic bus."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bus {
    #[doc = "< Next bus object in linked list"]
    pub next: rte_bus__bindgen_ty_1,
    #[doc = "< Name of the bus"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Scan for devices attached to bus"]
    pub scan: rte_bus_scan_t,
    #[doc = "< Probe devices on bus"]
    pub probe: rte_bus_probe_t,
    #[doc = "< Find a device on the bus"]
    pub find_device: rte_bus_find_device_t,
    #[doc = "< Probe single device for drivers"]
    pub plug: rte_bus_plug_t,
    #[doc = "< Remove single device from driver"]
    pub unplug: rte_bus_unplug_t,
    #[doc = "< Parse a device name"]
    pub parse: rte_bus_parse_t,
    #[doc = "< Parse bus devargs"]
    pub devargs_parse: rte_bus_devargs_parse_t,
    #[doc = "< DMA map for device in the bus"]
    pub dma_map: rte_dev_dma_map_t,
    #[doc = "< DMA unmap for device in the bus"]
    pub dma_unmap: rte_dev_dma_unmap_t,
    #[doc = "< Bus configuration"]
    pub conf: rte_bus_conf,
    #[doc = "< Get iommu class"]
    pub get_iommu_class: rte_bus_get_iommu_class_t,
    #[doc = "< Device iterator."]
    pub dev_iterate: rte_dev_iterate_t,
    pub hot_unplug_handler: rte_bus_hot_unplug_handler_t,
    pub sigbus_handler: rte_bus_sigbus_handler_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bus__bindgen_ty_1 {
    pub tqe_next: *mut rte_bus,
    pub tqe_prev: *mut *mut rte_bus,
}
extern "C" {
    #[doc = " Register a Bus handler."]
    #[doc = ""]
    #[doc = " @param bus"]
    #[doc = "   A pointer to a rte_bus structure describing the bus"]
    #[doc = "   to be registered."]
    pub fn rte_bus_register(bus: *mut rte_bus);
}
extern "C" {
    #[doc = " Unregister a Bus handler."]
    #[doc = ""]
    #[doc = " @param bus"]
    #[doc = "   A pointer to a rte_bus structure describing the bus"]
    #[doc = "   to be unregistered."]
    pub fn rte_bus_unregister(bus: *mut rte_bus);
}
extern "C" {
    #[doc = " Scan all the buses."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 in case of success in scanning all buses"]
    #[doc = "  !0 in case of failure to scan"]
    pub fn rte_bus_scan() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " For each device on the buses, perform a driver 'match' and call the"]
    #[doc = " driver-specific probe for device initialization."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\t 0 for successful match/probe"]
    #[doc = "\t!0 otherwise"]
    pub fn rte_bus_probe() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump information of all the buses registered with EAL."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "\t A valid and open output stream handle"]
    pub fn rte_bus_dump(f: *mut FILE);
}
#[doc = " Bus comparison function."]
#[doc = ""]
#[doc = " @param bus"]
#[doc = "\tBus under test."]
#[doc = ""]
#[doc = " @param data"]
#[doc = "\tData to compare against."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 if the bus matches the data."]
#[doc = "\t!0 if the bus does not match."]
#[doc = "\t<0 if ordering is possible and the bus is lower than the data."]
#[doc = "\t>0 if ordering is possible and the bus is greater than the data."]
pub type rte_bus_cmp_t = ::std::option::Option<
    unsafe extern "C" fn(
        bus: *const rte_bus,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Bus iterator to find a particular bus."]
    #[doc = ""]
    #[doc = " This function compares each registered bus to find one that matches"]
    #[doc = " the data passed as parameter."]
    #[doc = ""]
    #[doc = " If the comparison function returns zero this function will stop iterating"]
    #[doc = " over any more buses. To continue a search the bus of a previous search can"]
    #[doc = " be passed via the start parameter."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "\tStarting point for the iteration."]
    #[doc = ""]
    #[doc = " @param cmp"]
    #[doc = "\tComparison function."]
    #[doc = ""]
    #[doc = " @param data"]
    #[doc = "\t Data to pass to comparison function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\t A pointer to a rte_bus structure or NULL in case no bus matches"]
    pub fn rte_bus_find(
        start: *const rte_bus,
        cmp: rte_bus_cmp_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut rte_bus;
}
extern "C" {
    #[doc = " Find the registered bus for a particular device."]
    pub fn rte_bus_find_by_device(dev: *const rte_device) -> *mut rte_bus;
}
extern "C" {
    #[doc = " Find the registered bus for a given name."]
    pub fn rte_bus_find_by_name(busname: *const ::std::os::raw::c_char) -> *mut rte_bus;
}
extern "C" {
    #[doc = " Get the common iommu class of devices bound on to buses available in the"]
    #[doc = " system. RTE_IOVA_DC means that no preference has been expressed."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     enum rte_iova_mode value."]
    pub fn rte_bus_get_iommu_class() -> rte_iova_mode;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_intr_mode {
    RTE_INTR_MODE_NONE = 0,
    RTE_INTR_MODE_LEGACY = 1,
    RTE_INTR_MODE_MSI = 2,
    RTE_INTR_MODE_MSIX = 3,
}
#[repr(i32)]
#[doc = " The type of process in a linux, multi-process setup"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_proc_type_t {
    RTE_PROC_AUTO = -1,
    RTE_PROC_PRIMARY = 0,
    RTE_PROC_SECONDARY = 1,
    RTE_PROC_INVALID = 2,
}
extern "C" {
    #[doc = " Get the process type in a multi-process setup"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The process type"]
    pub fn rte_eal_process_type() -> rte_proc_type_t;
}
extern "C" {
    #[doc = " Request iopl privilege for all RPL."]
    #[doc = ""]
    #[doc = " This function should be called by pmds which need access to ioports."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - On success, returns 0."]
    #[doc = "   - On failure, returns -1."]
    pub fn rte_eal_iopl_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize the Environment Abstraction Layer (EAL)."]
    #[doc = ""]
    #[doc = " This function is to be executed on the MAIN lcore only, as soon"]
    #[doc = " as possible in the application's main() function."]
    #[doc = " It puts the WORKER lcores in the WAIT state."]
    #[doc = ""]
    #[doc = " @param argc"]
    #[doc = "   A non-negative value.  If it is greater than 0, the array members"]
    #[doc = "   for argv[0] through argv[argc] (non-inclusive) shall contain pointers"]
    #[doc = "   to strings."]
    #[doc = " @param argv"]
    #[doc = "   An array of strings.  The contents of the array, as well as the strings"]
    #[doc = "   which are pointed to by the array, may be modified by this function."]
    #[doc = " @return"]
    #[doc = "   - On success, the number of parsed arguments, which is greater or"]
    #[doc = "     equal to zero. After the call to rte_eal_init(),"]
    #[doc = "     all arguments argv[x] with x < ret may have been modified by this"]
    #[doc = "     function call and should not be further interpreted by the"]
    #[doc = "     application.  The EAL does not take any ownership of the memory used"]
    #[doc = "     for either the argv array, or its members."]
    #[doc = "   - On failure, -1 and rte_errno is set to a value indicating the cause"]
    #[doc = "     for failure.  In some instances, the application will need to be"]
    #[doc = "     restarted as part of clearing the issue."]
    #[doc = ""]
    #[doc = "   Error codes returned via rte_errno:"]
    #[doc = "     EACCES indicates a permissions issue."]
    #[doc = ""]
    #[doc = "     EAGAIN indicates either a bus or system resource was not available,"]
    #[doc = "            setup may be attempted again."]
    #[doc = ""]
    #[doc = "     EALREADY indicates that the rte_eal_init function has already been"]
    #[doc = "              called, and cannot be called again."]
    #[doc = ""]
    #[doc = "     EFAULT indicates the tailq configuration name was not found in"]
    #[doc = "            memory configuration."]
    #[doc = ""]
    #[doc = "     EINVAL indicates invalid parameters were passed as argv/argc."]
    #[doc = ""]
    #[doc = "     ENOMEM indicates failure likely caused by an out-of-memory condition."]
    #[doc = ""]
    #[doc = "     ENODEV indicates memory setup issues."]
    #[doc = ""]
    #[doc = "     ENOTSUP indicates that the EAL cannot initialize on this system."]
    #[doc = ""]
    #[doc = "     EPROTO indicates that the PCI bus is either not present, or is not"]
    #[doc = "            readable by the eal."]
    #[doc = ""]
    #[doc = "     ENOEXEC indicates that a service core failed to launch successfully."]
    pub fn rte_eal_init(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clean up the Environment Abstraction Layer (EAL)"]
    #[doc = ""]
    #[doc = " This function must be called to release any internal resources that EAL has"]
    #[doc = " allocated during rte_eal_init(). After this call, no DPDK function calls may"]
    #[doc = " be made. It is expected that common usage of this function is to call it"]
    #[doc = " just before terminating the process."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 Successfully released all internal EAL resources."]
    #[doc = "  - -EFAULT There was an error in releasing all resources."]
    pub fn rte_eal_cleanup() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if a primary process is currently alive"]
    #[doc = ""]
    #[doc = " This function returns true when a primary process is currently"]
    #[doc = " active."]
    #[doc = ""]
    #[doc = " @param config_file_path"]
    #[doc = "   The config_file_path argument provided should point at the location"]
    #[doc = "   that the primary process will create its config file. If NULL, the default"]
    #[doc = "   config file path is used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - If alive, returns 1."]
    #[doc = "  - If dead, returns 0."]
    pub fn rte_eal_primary_proc_alive(
        config_file_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disable multiprocess."]
    #[doc = ""]
    #[doc = " This function can be called to indicate that multiprocess won't be used for"]
    #[doc = " the rest of the application life."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - true if called from a primary process that had no secondary processes"]
    #[doc = "     attached,"]
    #[doc = "   - false, otherwise."]
    pub fn rte_mp_disable() -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mp_msg {
    pub name: [::std::os::raw::c_char; 64usize],
    pub len_param: ::std::os::raw::c_int,
    pub num_fds: ::std::os::raw::c_int,
    pub param: [u8; 256usize],
    pub fds: [::std::os::raw::c_int; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mp_reply {
    pub nb_sent: ::std::os::raw::c_int,
    pub nb_received: ::std::os::raw::c_int,
    pub msgs: *mut rte_mp_msg,
}
#[doc = " Action function typedef used by other components."]
#[doc = ""]
#[doc = " As we create  socket channel for primary/secondary communication, use"]
#[doc = " this function typedef to register action for coming messages."]
#[doc = ""]
#[doc = " @note When handling IPC request callbacks, the reply must be sent even in"]
#[doc = "   cases of error handling. Simply returning success or failure will *not*"]
#[doc = "   send a response to the requestor."]
#[doc = "   Implementation of error signalling mechanism is up to the application."]
#[doc = ""]
#[doc = " @note No memory allocations should take place inside the callback."]
pub type rte_mp_t = ::std::option::Option<
    unsafe extern "C" fn(
        msg: *const rte_mp_msg,
        peer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Asynchronous reply function typedef used by other components."]
#[doc = ""]
#[doc = " As we create socket channel for primary/secondary communication, use"]
#[doc = " this function typedef to register action for coming responses to asynchronous"]
#[doc = " requests."]
#[doc = ""]
#[doc = " @note When handling IPC request callbacks, the reply must be sent even in"]
#[doc = "   cases of error handling. Simply returning success or failure will *not*"]
#[doc = "   send a response to the requestor."]
#[doc = "   Implementation of error signalling mechanism is up to the application."]
#[doc = ""]
#[doc = " @note No memory allocations should take place inside the callback."]
pub type rte_mp_async_reply_t = ::std::option::Option<
    unsafe extern "C" fn(
        request: *const rte_mp_msg,
        reply: *const rte_mp_reply,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Register an action function for primary/secondary communication."]
    #[doc = ""]
    #[doc = " Call this function to register an action, if the calling component wants"]
    #[doc = " to response the messages from the corresponding component in its primary"]
    #[doc = " process or secondary processes."]
    #[doc = ""]
    #[doc = " @note IPC may be unsupported in certain circumstances, so caller should check"]
    #[doc = "    for ENOTSUP error."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name argument plays as the nonredundant key to find the action."]
    #[doc = ""]
    #[doc = " @param action"]
    #[doc = "   The action argument is the function pointer to the action function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 on success."]
    #[doc = "  - (<0) on failure."]
    pub fn rte_mp_action_register(
        name: *const ::std::os::raw::c_char,
        action: rte_mp_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unregister an action function for primary/secondary communication."]
    #[doc = ""]
    #[doc = " Call this function to unregister an action  if the calling component does"]
    #[doc = " not want to response the messages from the corresponding component in its"]
    #[doc = " primary process or secondary processes."]
    #[doc = ""]
    #[doc = " @note IPC may be unsupported in certain circumstances, so caller should check"]
    #[doc = "    for ENOTSUP error."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name argument plays as the nonredundant key to find the action."]
    #[doc = ""]
    pub fn rte_mp_action_unregister(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Send a message to the peer process."]
    #[doc = ""]
    #[doc = " This function will send a message which will be responded by the action"]
    #[doc = " identified by name in the peer process."]
    #[doc = ""]
    #[doc = " @param msg"]
    #[doc = "   The msg argument contains the customized message."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, return 0."]
    #[doc = "  - On failure, return -1, and the reason will be stored in rte_errno."]
    pub fn rte_mp_sendmsg(msg: *mut rte_mp_msg) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a request to the peer process and expect a reply."]
    #[doc = ""]
    #[doc = " This function sends a request message to the peer process, and will"]
    #[doc = " block until receiving reply message from the peer process."]
    #[doc = ""]
    #[doc = " @note The caller is responsible to free reply->replies."]
    #[doc = ""]
    #[doc = " @note This API must not be used inside memory-related or IPC callbacks, and"]
    #[doc = "   no memory allocations should take place inside such callback."]
    #[doc = ""]
    #[doc = " @note IPC may be unsupported in certain circumstances, so caller should check"]
    #[doc = "    for ENOTSUP error."]
    #[doc = ""]
    #[doc = " @param req"]
    #[doc = "   The req argument contains the customized request message."]
    #[doc = ""]
    #[doc = " @param reply"]
    #[doc = "   The reply argument will be for storing all the replied messages;"]
    #[doc = "   the caller is responsible for free reply->msgs."]
    #[doc = ""]
    #[doc = " @param ts"]
    #[doc = "   The ts argument specifies how long we can wait for the peer(s) to reply."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, return 0."]
    #[doc = "  - On failure, return -1, and the reason will be stored in rte_errno."]
    pub fn rte_mp_request_sync(
        req: *mut rte_mp_msg,
        reply: *mut rte_mp_reply,
        ts: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a request to the peer process and expect a reply in a separate callback."]
    #[doc = ""]
    #[doc = " This function sends a request message to the peer process, and will not"]
    #[doc = " block. Instead, reply will be received in a separate callback."]
    #[doc = ""]
    #[doc = " @note IPC may be unsupported in certain circumstances, so caller should check"]
    #[doc = "    for ENOTSUP error."]
    #[doc = ""]
    #[doc = " @param req"]
    #[doc = "   The req argument contains the customized request message."]
    #[doc = ""]
    #[doc = " @param ts"]
    #[doc = "   The ts argument specifies how long we can wait for the peer(s) to reply."]
    #[doc = ""]
    #[doc = " @param clb"]
    #[doc = "   The callback to trigger when all responses for this request have arrived."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, return 0."]
    #[doc = "  - On failure, return -1, and the reason will be stored in rte_errno."]
    pub fn rte_mp_request_async(
        req: *mut rte_mp_msg,
        ts: *const timespec,
        clb: rte_mp_async_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a reply to the peer process."]
    #[doc = ""]
    #[doc = " This function will send a reply message in response to a request message"]
    #[doc = " received previously."]
    #[doc = ""]
    #[doc = " @note When handling IPC request callbacks, the reply must be sent even in"]
    #[doc = "   cases of error handling. Simply returning success or failure will *not*"]
    #[doc = "   send a response to the requestor."]
    #[doc = "   Implementation of error signalling mechanism is up to the application."]
    #[doc = ""]
    #[doc = " @param msg"]
    #[doc = "   The msg argument contains the customized message."]
    #[doc = ""]
    #[doc = " @param peer"]
    #[doc = "   The peer argument is the pointer to the peer socket path."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, return 0."]
    #[doc = "  - On failure, return -1, and the reason will be stored in rte_errno."]
    pub fn rte_mp_reply(
        msg: *mut rte_mp_msg,
        peer: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Usage function typedef used by the application usage function."]
#[doc = ""]
#[doc = " Use this function typedef to define and call rte_set_application_usage_hook()"]
#[doc = " routine."]
pub type rte_usage_hook_t =
    ::std::option::Option<unsafe extern "C" fn(prgname: *const ::std::os::raw::c_char)>;
extern "C" {
    #[doc = " Add application usage routine callout from the eal_usage() routine."]
    #[doc = ""]
    #[doc = " This function allows the application to include its usage message"]
    #[doc = " in the EAL system usage message. The routine rte_set_application_usage_hook()"]
    #[doc = " needs to be called before the rte_eal_init() routine in the application."]
    #[doc = ""]
    #[doc = " This routine is optional for the application and will behave as if the set"]
    #[doc = " routine was never called as the default behavior."]
    #[doc = ""]
    #[doc = " @param usage_func"]
    #[doc = "   The func argument is a function pointer to the application usage routine."]
    #[doc = "   Called function is defined using rte_usage_hook_t typedef, which is of"]
    #[doc = "   the form void rte_usage_func(const char * prgname)."]
    #[doc = ""]
    #[doc = "   Calling this routine with a NULL value will reset the usage hook routine and"]
    #[doc = "   return the current value, which could be NULL."]
    #[doc = " @return"]
    #[doc = "   - Returns the current value of the rte_application_usage pointer to allow"]
    #[doc = "     the caller to daisy chain the usage routines if needing more then one."]
    pub fn rte_set_application_usage_hook(usage_func: rte_usage_hook_t) -> rte_usage_hook_t;
}
extern "C" {
    #[doc = " Whether EAL is using huge pages (disabled by --no-huge option)."]
    #[doc = " The no-huge mode is not compatible with all drivers or features."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Nonzero if hugepages are enabled."]
    pub fn rte_eal_has_hugepages() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Whether EAL is using PCI bus."]
    #[doc = " Disabled by --no-pci option."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Nonzero if the PCI bus is enabled."]
    pub fn rte_eal_has_pci() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Whether the EAL was asked to create UIO device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Nonzero if true."]
    pub fn rte_eal_create_uio_dev() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The user-configured vfio interrupt mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Interrupt mode configured with the command line,"]
    #[doc = "   RTE_INTR_MODE_NONE by default."]
    pub fn rte_eal_vfio_intr_mode() -> rte_intr_mode;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Copy the user-configured vfio VF token."]
    #[doc = ""]
    #[doc = " @param vf_token"]
    #[doc = "   vfio VF token configured with the command line is copied"]
    #[doc = "   into this parameter, zero uuid by default."]
    pub fn rte_eal_vfio_get_vf_token(vf_token: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    #[doc = " A wrap API for syscall gettid."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   On success, returns the thread ID of calling process."]
    #[doc = "   It is always successful."]
    pub fn rte_sys_gettid() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the OS-specific EAL base address."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    The base address."]
    pub fn rte_eal_get_baseaddr() -> u64;
}
extern "C" {
    #[doc = " Get the iova mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   enum rte_iova_mode value."]
    pub fn rte_eal_iova_mode() -> rte_iova_mode;
}
extern "C" {
    #[doc = " Get user provided pool ops name for mbuf"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   returns user provided pool ops name."]
    pub fn rte_eal_mbuf_user_pool_ops() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the runtime directory of DPDK"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  The runtime directory path of DPDK"]
    pub fn rte_eal_get_runtime_dir() -> *const ::std::os::raw::c_char;
}
#[repr(u32)]
#[doc = " State of an lcore."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_lcore_state_t {
    WAIT = 0,
    RUNNING = 1,
}
#[doc = " Definition of a remote launch function."]
pub type lcore_function_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Launch a function on another lcore."]
    #[doc = ""]
    #[doc = " To be executed on the MAIN lcore only."]
    #[doc = ""]
    #[doc = " Sends a message to a worker lcore (identified by the worker_id) that"]
    #[doc = " is in the WAIT state (this is true after the first call to"]
    #[doc = " rte_eal_init()). This can be checked by first calling"]
    #[doc = " rte_eal_wait_lcore(worker_id)."]
    #[doc = ""]
    #[doc = " When the remote lcore receives the message, it switches to"]
    #[doc = " the RUNNING state, then calls the function f with argument arg. Once the"]
    #[doc = " execution is done, the remote lcore switches to WAIT state and"]
    #[doc = " the return value of f is stored in a local variable to be read using"]
    #[doc = " rte_eal_wait_lcore()."]
    #[doc = ""]
    #[doc = " The MAIN lcore returns as soon as the message is sent and knows"]
    #[doc = " nothing about the completion of f."]
    #[doc = ""]
    #[doc = " Note: This function is not designed to offer optimum"]
    #[doc = " performance. It is just a practical way to launch a function on"]
    #[doc = " another lcore at initialization time."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   The function to be called."]
    #[doc = " @param arg"]
    #[doc = "   The argument for the function."]
    #[doc = " @param worker_id"]
    #[doc = "   The identifier of the lcore on which the function should be executed."]
    #[doc = " @return"]
    #[doc = "   - 0: Success. Execution of function f started on the remote lcore."]
    #[doc = "   - (-EBUSY): The remote lcore is not in a WAIT state."]
    pub fn rte_eal_remote_launch(
        f: lcore_function_t,
        arg: *mut ::std::os::raw::c_void,
        worker_id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " This enum indicates whether the main core must execute the handler"]
#[doc = " launched on all logical cores."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_rmt_call_main_t {
    #[doc = "< lcore handler not executed by main core."]
    SKIP_MAIN = 0,
    #[doc = "< lcore handler executed by main core."]
    CALL_MAIN = 1,
}
extern "C" {
    #[doc = " Launch a function on all lcores."]
    #[doc = ""]
    #[doc = " Check that each WORKER lcore is in a WAIT state, then call"]
    #[doc = " rte_eal_remote_launch() for each lcore."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   The function to be called."]
    #[doc = " @param arg"]
    #[doc = "   The argument for the function."]
    #[doc = " @param call_main"]
    #[doc = "   If call_main set to SKIP_MAIN, the MAIN lcore does not call"]
    #[doc = "   the function. If call_main is set to CALL_MAIN, the function"]
    #[doc = "   is also called on main before returning. In any case, the main"]
    #[doc = "   lcore returns as soon as it finished its job and knows nothing"]
    #[doc = "   about the completion of f on the other lcores."]
    #[doc = " @return"]
    #[doc = "   - 0: Success. Execution of function f started on all remote lcores."]
    #[doc = "   - (-EBUSY): At least one remote lcore is not in a WAIT state. In this"]
    #[doc = "     case, no message is sent to any of the lcores."]
    pub fn rte_eal_mp_remote_launch(
        f: lcore_function_t,
        arg: *mut ::std::os::raw::c_void,
        call_main: rte_rmt_call_main_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the state of the lcore identified by worker_id."]
    #[doc = ""]
    #[doc = " To be executed on the MAIN lcore only."]
    #[doc = ""]
    #[doc = " @param worker_id"]
    #[doc = "   The identifier of the lcore."]
    #[doc = " @return"]
    #[doc = "   The state of the lcore."]
    pub fn rte_eal_get_lcore_state(worker_id: ::std::os::raw::c_uint) -> rte_lcore_state_t;
}
extern "C" {
    #[doc = " Wait until an lcore finishes its job."]
    #[doc = ""]
    #[doc = " To be executed on the MAIN lcore only."]
    #[doc = ""]
    #[doc = " If the lcore identified by the worker_id is in RUNNING state, wait until"]
    #[doc = " the lcore finishes its job and moves to the WAIT state."]
    #[doc = ""]
    #[doc = " @param worker_id"]
    #[doc = "   The identifier of the lcore."]
    #[doc = " @return"]
    #[doc = "   - 0: If the remote launch function was never called on the lcore"]
    #[doc = "     identified by the worker_id."]
    #[doc = "   - The value that was returned by the previous remote launch"]
    #[doc = "     function call."]
    pub fn rte_eal_wait_lcore(worker_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait until all lcores finish their jobs."]
    #[doc = ""]
    #[doc = " To be executed on the MAIN lcore only. Issue an"]
    #[doc = " rte_eal_wait_lcore() for every lcore. The return values are"]
    #[doc = " ignored."]
    #[doc = ""]
    #[doc = " After a call to rte_eal_mp_wait_lcore(), the caller can assume"]
    #[doc = " that all worker lcores are in a WAIT state."]
    pub fn rte_eal_mp_wait_lcore();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eal_tls_key {
    _unused: [u8; 0],
}
#[doc = " TLS key type, an opaque pointer."]
pub type rte_thread_key = *mut eal_tls_key;
extern "C" {
    #[doc = " Create a TLS data key visible to all threads in the process."]
    #[doc = " the created key is later used to get/set a value."]
    #[doc = " and optional destructor can be set to be called when a thread exits."]
    #[doc = ""]
    #[doc = " @param key"]
    #[doc = "   Pointer to store the allocated key."]
    #[doc = " @param destructor"]
    #[doc = "   The function to be called when the thread exits."]
    #[doc = "   Ignored on Windows OS."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   On success, zero."]
    #[doc = "   On failure, a negative number and an error number is set in rte_errno."]
    #[doc = "   rte_errno can be: ENOMEM  - Memory allocation error."]
    #[doc = "                     ENOEXEC - Specific OS error."]
    pub fn rte_thread_key_create(
        key: *mut rte_thread_key,
        destructor: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete a TLS data key visible to all threads in the process."]
    #[doc = ""]
    #[doc = " @param key"]
    #[doc = "   The key allocated by rte_thread_key_create()."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   On success, zero."]
    #[doc = "   On failure, a negative number and an error number is set in rte_errno."]
    #[doc = "   rte_errno can be: EINVAL  - Invalid parameter passed."]
    #[doc = "                     ENOEXEC - Specific OS error."]
    pub fn rte_thread_key_delete(key: rte_thread_key) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set value bound to the TLS key on behalf of the calling thread."]
    #[doc = ""]
    #[doc = " @param key"]
    #[doc = "   The key allocated by rte_thread_key_create()."]
    #[doc = " @param value"]
    #[doc = "   The value bound to the rte_thread_key key for the calling thread."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   On success, zero."]
    #[doc = "   On failure, a negative number and an error number is set in rte_errno."]
    #[doc = "   rte_errno can be: EINVAL  - Invalid parameter passed."]
    #[doc = "                     ENOEXEC - Specific OS error."]
    pub fn rte_thread_value_set(
        key: rte_thread_key,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get value bound to the TLS key on behalf of the calling thread."]
    #[doc = ""]
    #[doc = " @param key"]
    #[doc = "   The key allocated by rte_thread_key_create()."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   On success, value data pointer (can also be NULL)."]
    #[doc = "   On failure, NULL and an error number is set in rte_errno."]
    #[doc = "   rte_errno can be: EINVAL  - Invalid parameter passed."]
    #[doc = "                     ENOEXEC - Specific OS error."]
    pub fn rte_thread_value_get(key: rte_thread_key) -> *mut ::std::os::raw::c_void;
}
#[repr(u32)]
#[doc = " The lcore role (used in RTE or not)."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_lcore_role_t {
    ROLE_RTE = 0,
    ROLE_OFF = 1,
    ROLE_SERVICE = 2,
    ROLE_NON_EAL = 3,
}
extern "C" {
    #[doc = " Get a lcore's role."]
    #[doc = ""]
    #[doc = " @param lcore_id"]
    #[doc = "   The identifier of the lcore, which MUST be between 0 and RTE_MAX_LCORE-1."]
    #[doc = " @return"]
    #[doc = "   The role of the lcore."]
    pub fn rte_eal_lcore_role(lcore_id: ::std::os::raw::c_uint) -> rte_lcore_role_t;
}
extern "C" {
    #[doc = " Test if the core supplied has a specific role"]
    #[doc = ""]
    #[doc = " @param lcore_id"]
    #[doc = "   The identifier of the lcore, which MUST be between 0 and"]
    #[doc = "   RTE_MAX_LCORE-1."]
    #[doc = " @param role"]
    #[doc = "   The role to be checked against."]
    #[doc = " @return"]
    #[doc = "   Boolean value: positive if test is true; otherwise returns 0."]
    pub fn rte_lcore_has_role(
        lcore_id: ::std::os::raw::c_uint,
        role: rte_lcore_role_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the id of the main lcore"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   the id of the main lcore"]
    pub fn rte_get_main_lcore() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the number of execution units (lcores) on the system."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   the number of execution units (lcores) on the system."]
    pub fn rte_lcore_count() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the index of the lcore starting from zero."]
    #[doc = ""]
    #[doc = " When option -c or -l is given, the index corresponds"]
    #[doc = " to the order in the list."]
    #[doc = " For example:"]
    #[doc = " -c 0x30, lcore 4 has index 0, and 5 has index 1."]
    #[doc = " -l 22,18 lcore 22 has index 0, and 18 has index 1."]
    #[doc = ""]
    #[doc = " @param lcore_id"]
    #[doc = "   The targeted lcore, or -1 for the current one."]
    #[doc = " @return"]
    #[doc = "   The relative index, or -1 if not enabled."]
    pub fn rte_lcore_index(lcore_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the ID of the physical socket of the logical core we are"]
    #[doc = " running on."]
    #[doc = " @return"]
    #[doc = "   the ID of current lcoreid's physical socket"]
    pub fn rte_socket_id() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return number of physical sockets detected on the system."]
    #[doc = ""]
    #[doc = " Note that number of nodes may not be correspondent to their physical id's:"]
    #[doc = " for example, a system may report two socket id's, but the actual socket id's"]
    #[doc = " may be 0 and 8."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   the number of physical sockets as recognized by EAL"]
    pub fn rte_socket_count() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return socket id with a particular index."]
    #[doc = ""]
    #[doc = " This will return socket id at a particular position in list of all detected"]
    #[doc = " physical socket id's. For example, on a machine with sockets [0, 8], passing"]
    #[doc = " 1 as a parameter will return 8."]
    #[doc = ""]
    #[doc = " @param idx"]
    #[doc = "   index of physical socket id to return"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - physical socket id as recognized by EAL"]
    #[doc = "   - -1 on error, with errno set to EINVAL"]
    pub fn rte_socket_id_by_idx(idx: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the ID of the physical socket of the specified lcore"]
    #[doc = ""]
    #[doc = " @param lcore_id"]
    #[doc = "   the targeted lcore, which MUST be between 0 and RTE_MAX_LCORE-1."]
    #[doc = " @return"]
    #[doc = "   the ID of lcoreid's physical socket"]
    pub fn rte_lcore_to_socket_id(lcore_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Return the id of the lcore on a socket starting from zero."]
    #[doc = ""]
    #[doc = " @param lcore_id"]
    #[doc = "   The targeted lcore, or -1 for the current one."]
    #[doc = " @return"]
    #[doc = "   The relative index, or -1 if not enabled."]
    pub fn rte_lcore_to_cpu_id(lcore_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test if an lcore is enabled."]
    #[doc = ""]
    #[doc = " @param lcore_id"]
    #[doc = "   The identifier of the lcore, which MUST be between 0 and"]
    #[doc = "   RTE_MAX_LCORE-1."]
    #[doc = " @return"]
    #[doc = "   True if the given lcore is enabled; false otherwise."]
    pub fn rte_lcore_is_enabled(lcore_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the next enabled lcore ID."]
    #[doc = ""]
    #[doc = " @param i"]
    #[doc = "   The current lcore (reference)."]
    #[doc = " @param skip_main"]
    #[doc = "   If true, do not return the ID of the main lcore."]
    #[doc = " @param wrap"]
    #[doc = "   If true, go back to 0 when RTE_MAX_LCORE is reached; otherwise,"]
    #[doc = "   return RTE_MAX_LCORE."]
    #[doc = " @return"]
    #[doc = "   The next lcore_id or RTE_MAX_LCORE if not found."]
    pub fn rte_get_next_lcore(
        i: ::std::os::raw::c_uint,
        skip_main: ::std::os::raw::c_int,
        wrap: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
#[doc = " Callback prototype for initializing lcores."]
#[doc = ""]
#[doc = " @param lcore_id"]
#[doc = "   The lcore to consider."]
#[doc = " @param arg"]
#[doc = "   An opaque pointer passed at callback registration."]
#[doc = " @return"]
#[doc = "   - -1 when refusing this operation,"]
#[doc = "   - 0 otherwise."]
pub type rte_lcore_init_cb = ::std::option::Option<
    unsafe extern "C" fn(
        lcore_id: ::std::os::raw::c_uint,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Callback prototype for uninitializing lcores."]
#[doc = ""]
#[doc = " @param lcore_id"]
#[doc = "   The lcore to consider."]
#[doc = " @param arg"]
#[doc = "   An opaque pointer passed at callback registration."]
pub type rte_lcore_uninit_cb = ::std::option::Option<
    unsafe extern "C" fn(lcore_id: ::std::os::raw::c_uint, arg: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Register callbacks invoked when initializing and uninitializing a lcore."]
    #[doc = ""]
    #[doc = " This function calls the init callback with all initialized lcores."]
    #[doc = " Any error reported by the init callback triggers a rollback calling the"]
    #[doc = " uninit callback for each lcore."]
    #[doc = " If this step succeeds, the callbacks are put in the lcore callbacks list"]
    #[doc = " that will get called for each lcore allocation/release."]
    #[doc = ""]
    #[doc = " Note: callbacks execution is serialised under a write lock protecting the"]
    #[doc = " lcores and callbacks list."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   A name serving as a small description for this callback."]
    #[doc = " @param init"]
    #[doc = "   The callback invoked when a lcore_id is initialized."]
    #[doc = "   init can be NULL."]
    #[doc = " @param uninit"]
    #[doc = "   The callback invoked when a lcore_id is uninitialized."]
    #[doc = "   uninit can be NULL."]
    #[doc = " @param arg"]
    #[doc = "   An optional argument that gets passed to the callback when it gets"]
    #[doc = "   invoked."]
    #[doc = " @return"]
    #[doc = "   On success, returns an opaque pointer for the registered object."]
    #[doc = "   On failure (either memory allocation issue in the function itself or an"]
    #[doc = "   error is returned by the init callback itself), returns NULL."]
    pub fn rte_lcore_callback_register(
        name: *const ::std::os::raw::c_char,
        init: rte_lcore_init_cb,
        uninit: rte_lcore_uninit_cb,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Unregister callbacks previously registered with rte_lcore_callback_register."]
    #[doc = ""]
    #[doc = " This function calls the uninit callback with all initialized lcores."]
    #[doc = " The callbacks are then removed from the lcore callbacks list."]
    #[doc = ""]
    #[doc = " @param handle"]
    #[doc = "   The handle pointer returned by a former successful call to"]
    #[doc = "   rte_lcore_callback_register."]
    pub fn rte_lcore_callback_unregister(handle: *mut ::std::os::raw::c_void);
}
#[doc = " Callback prototype for iterating over lcores."]
#[doc = ""]
#[doc = " @param lcore_id"]
#[doc = "   The lcore to consider."]
#[doc = " @param arg"]
#[doc = "   An opaque pointer coming from the caller."]
#[doc = " @return"]
#[doc = "   - 0 lets the iteration continue."]
#[doc = "   - !0 makes the iteration stop."]
pub type rte_lcore_iterate_cb = ::std::option::Option<
    unsafe extern "C" fn(
        lcore_id: ::std::os::raw::c_uint,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Iterate on all active lcores (ROLE_RTE, ROLE_SERVICE and ROLE_NON_EAL)."]
    #[doc = " No modification on the lcore states is allowed in the callback."]
    #[doc = ""]
    #[doc = " Note: as opposed to init/uninit callbacks, iteration callbacks can be"]
    #[doc = " invoked in parallel as they are run under a read lock protecting the lcores"]
    #[doc = " and callbacks list."]
    #[doc = ""]
    #[doc = " @param cb"]
    #[doc = "   The callback that gets passed each lcore."]
    #[doc = " @param arg"]
    #[doc = "   An opaque pointer passed to cb."]
    #[doc = " @return"]
    #[doc = "   Same return code as the callback last invocation (see rte_lcore_iterate_cb"]
    #[doc = "   description)."]
    pub fn rte_lcore_iterate(
        cb: rte_lcore_iterate_cb,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " List all lcores."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   The output stream where the dump should be sent."]
    pub fn rte_lcore_dump(f: *mut FILE);
}
extern "C" {
    #[doc = " Set thread names."]
    #[doc = ""]
    #[doc = " @note It fails with glibc < 2.12."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "   Thread id."]
    #[doc = " @param name"]
    #[doc = "   Thread name to set."]
    #[doc = " @return"]
    #[doc = "   On success, return 0; otherwise return a negative value."]
    pub fn rte_thread_setname(
        id: pthread_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get thread name."]
    #[doc = ""]
    #[doc = " @note It fails with glibc < 2.12."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "   Thread id."]
    #[doc = " @param name"]
    #[doc = "   Thread name to set."]
    #[doc = " @param len"]
    #[doc = "   Thread name buffer length."]
    #[doc = " @return"]
    #[doc = "   On success, return 0; otherwise return a negative value."]
    pub fn rte_thread_getname(
        id: pthread_t,
        name: *mut ::std::os::raw::c_char,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register current non-EAL thread as a lcore."]
    #[doc = ""]
    #[doc = " @note This API is not compatible with the multi-process feature:"]
    #[doc = " - if a primary process registers a non-EAL thread, then no secondary process"]
    #[doc = "   will initialise."]
    #[doc = " - if a secondary process initialises successfully, trying to register a"]
    #[doc = "   non-EAL thread from either primary or secondary processes will always end"]
    #[doc = "   up with the thread getting LCORE_ID_ANY as lcore."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   On success, return 0; otherwise return -1 with rte_errno set."]
    pub fn rte_thread_register() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unregister current thread and release lcore if one was associated."]
    pub fn rte_thread_unregister();
}
extern "C" {
    #[doc = " Create a control thread."]
    #[doc = ""]
    #[doc = " Creates a control thread with the given name and attributes. The"]
    #[doc = " affinity of the new thread is based on the CPU affinity retrieved"]
    #[doc = " at the time rte_eal_init() was called, the dataplane and service"]
    #[doc = " lcores are then excluded. If setting the name of the thread fails,"]
    #[doc = " the error is ignored and a debug message is logged."]
    #[doc = ""]
    #[doc = " @param thread"]
    #[doc = "   Filled with the thread id of the new created thread."]
    #[doc = " @param name"]
    #[doc = "   The name of the control thread (max 16 characters including '\\0')."]
    #[doc = " @param attr"]
    #[doc = "   Attributes for the new thread."]
    #[doc = " @param start_routine"]
    #[doc = "   Function to be executed by the new thread."]
    #[doc = " @param arg"]
    #[doc = "   Argument passed to start_routine."]
    #[doc = " @return"]
    #[doc = "   On success, returns 0; on error, it returns a negative value"]
    #[doc = "   corresponding to the error number."]
    pub fn rte_ctrl_thread_create(
        thread: *mut pthread_t,
        name: *const ::std::os::raw::c_char,
        attr: *const pthread_attr_t,
        start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " The rte_spinlock_t type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_spinlock_t {
    #[doc = "< lock status 0 = unlocked, 1 = locked"]
    pub locked: ::std::os::raw::c_int,
}
#[doc = " The rte_spinlock_recursive_t type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_spinlock_recursive_t {
    #[doc = "< the actual spinlock"]
    pub sl: rte_spinlock_t,
    #[doc = "< core id using lock, -1 for unused"]
    pub user: ::std::os::raw::c_int,
    #[doc = "< count of time this lock has been called"]
    pub count: ::std::os::raw::c_int,
}
#[repr(u32)]
#[doc = " Enumeration of all CPU features supported"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_cpu_flag_t {
    #[doc = "< SSE3"]
    RTE_CPUFLAG_SSE3 = 0,
    #[doc = "< PCLMULQDQ"]
    RTE_CPUFLAG_PCLMULQDQ = 1,
    #[doc = "< DTES64"]
    RTE_CPUFLAG_DTES64 = 2,
    #[doc = "< MONITOR"]
    RTE_CPUFLAG_MONITOR = 3,
    #[doc = "< DS_CPL"]
    RTE_CPUFLAG_DS_CPL = 4,
    #[doc = "< VMX"]
    RTE_CPUFLAG_VMX = 5,
    #[doc = "< SMX"]
    RTE_CPUFLAG_SMX = 6,
    #[doc = "< EIST"]
    RTE_CPUFLAG_EIST = 7,
    #[doc = "< TM2"]
    RTE_CPUFLAG_TM2 = 8,
    #[doc = "< SSSE3"]
    RTE_CPUFLAG_SSSE3 = 9,
    #[doc = "< CNXT_ID"]
    RTE_CPUFLAG_CNXT_ID = 10,
    #[doc = "< FMA"]
    RTE_CPUFLAG_FMA = 11,
    #[doc = "< CMPXCHG16B"]
    RTE_CPUFLAG_CMPXCHG16B = 12,
    #[doc = "< XTPR"]
    RTE_CPUFLAG_XTPR = 13,
    #[doc = "< PDCM"]
    RTE_CPUFLAG_PDCM = 14,
    #[doc = "< PCID"]
    RTE_CPUFLAG_PCID = 15,
    #[doc = "< DCA"]
    RTE_CPUFLAG_DCA = 16,
    #[doc = "< SSE4_1"]
    RTE_CPUFLAG_SSE4_1 = 17,
    #[doc = "< SSE4_2"]
    RTE_CPUFLAG_SSE4_2 = 18,
    #[doc = "< X2APIC"]
    RTE_CPUFLAG_X2APIC = 19,
    #[doc = "< MOVBE"]
    RTE_CPUFLAG_MOVBE = 20,
    #[doc = "< POPCNT"]
    RTE_CPUFLAG_POPCNT = 21,
    #[doc = "< TSC_DEADLINE"]
    RTE_CPUFLAG_TSC_DEADLINE = 22,
    #[doc = "< AES"]
    RTE_CPUFLAG_AES = 23,
    #[doc = "< XSAVE"]
    RTE_CPUFLAG_XSAVE = 24,
    #[doc = "< OSXSAVE"]
    RTE_CPUFLAG_OSXSAVE = 25,
    #[doc = "< AVX"]
    RTE_CPUFLAG_AVX = 26,
    #[doc = "< F16C"]
    RTE_CPUFLAG_F16C = 27,
    #[doc = "< RDRAND"]
    RTE_CPUFLAG_RDRAND = 28,
    #[doc = "< Running in a VM"]
    RTE_CPUFLAG_HYPERVISOR = 29,
    #[doc = "< FPU"]
    RTE_CPUFLAG_FPU = 30,
    #[doc = "< VME"]
    RTE_CPUFLAG_VME = 31,
    #[doc = "< DE"]
    RTE_CPUFLAG_DE = 32,
    #[doc = "< PSE"]
    RTE_CPUFLAG_PSE = 33,
    #[doc = "< TSC"]
    RTE_CPUFLAG_TSC = 34,
    #[doc = "< MSR"]
    RTE_CPUFLAG_MSR = 35,
    #[doc = "< PAE"]
    RTE_CPUFLAG_PAE = 36,
    #[doc = "< MCE"]
    RTE_CPUFLAG_MCE = 37,
    #[doc = "< CX8"]
    RTE_CPUFLAG_CX8 = 38,
    #[doc = "< APIC"]
    RTE_CPUFLAG_APIC = 39,
    #[doc = "< SEP"]
    RTE_CPUFLAG_SEP = 40,
    #[doc = "< MTRR"]
    RTE_CPUFLAG_MTRR = 41,
    #[doc = "< PGE"]
    RTE_CPUFLAG_PGE = 42,
    #[doc = "< MCA"]
    RTE_CPUFLAG_MCA = 43,
    #[doc = "< CMOV"]
    RTE_CPUFLAG_CMOV = 44,
    #[doc = "< PAT"]
    RTE_CPUFLAG_PAT = 45,
    #[doc = "< PSE36"]
    RTE_CPUFLAG_PSE36 = 46,
    #[doc = "< PSN"]
    RTE_CPUFLAG_PSN = 47,
    #[doc = "< CLFSH"]
    RTE_CPUFLAG_CLFSH = 48,
    #[doc = "< DS"]
    RTE_CPUFLAG_DS = 49,
    #[doc = "< ACPI"]
    RTE_CPUFLAG_ACPI = 50,
    #[doc = "< MMX"]
    RTE_CPUFLAG_MMX = 51,
    #[doc = "< FXSR"]
    RTE_CPUFLAG_FXSR = 52,
    #[doc = "< SSE"]
    RTE_CPUFLAG_SSE = 53,
    #[doc = "< SSE2"]
    RTE_CPUFLAG_SSE2 = 54,
    #[doc = "< SS"]
    RTE_CPUFLAG_SS = 55,
    #[doc = "< HTT"]
    RTE_CPUFLAG_HTT = 56,
    #[doc = "< TM"]
    RTE_CPUFLAG_TM = 57,
    #[doc = "< PBE"]
    RTE_CPUFLAG_PBE = 58,
    #[doc = "< DIGTEMP"]
    RTE_CPUFLAG_DIGTEMP = 59,
    #[doc = "< TRBOBST"]
    RTE_CPUFLAG_TRBOBST = 60,
    #[doc = "< ARAT"]
    RTE_CPUFLAG_ARAT = 61,
    #[doc = "< PLN"]
    RTE_CPUFLAG_PLN = 62,
    #[doc = "< ECMD"]
    RTE_CPUFLAG_ECMD = 63,
    #[doc = "< PTM"]
    RTE_CPUFLAG_PTM = 64,
    #[doc = "< MPERF_APERF_MSR"]
    RTE_CPUFLAG_MPERF_APERF_MSR = 65,
    #[doc = "< ACNT2"]
    RTE_CPUFLAG_ACNT2 = 66,
    #[doc = "< ENERGY_EFF"]
    RTE_CPUFLAG_ENERGY_EFF = 67,
    #[doc = "< FSGSBASE"]
    RTE_CPUFLAG_FSGSBASE = 68,
    #[doc = "< BMI1"]
    RTE_CPUFLAG_BMI1 = 69,
    #[doc = "< Hardware Lock elision"]
    RTE_CPUFLAG_HLE = 70,
    #[doc = "< AVX2"]
    RTE_CPUFLAG_AVX2 = 71,
    #[doc = "< SMEP"]
    RTE_CPUFLAG_SMEP = 72,
    #[doc = "< BMI2"]
    RTE_CPUFLAG_BMI2 = 73,
    #[doc = "< ERMS"]
    RTE_CPUFLAG_ERMS = 74,
    #[doc = "< INVPCID"]
    RTE_CPUFLAG_INVPCID = 75,
    #[doc = "< Transactional memory"]
    RTE_CPUFLAG_RTM = 76,
    #[doc = "< AVX512F"]
    RTE_CPUFLAG_AVX512F = 77,
    #[doc = "< RDSEED instruction"]
    RTE_CPUFLAG_RDSEED = 78,
    #[doc = "< LAHF_SAHF"]
    RTE_CPUFLAG_LAHF_SAHF = 79,
    #[doc = "< LZCNT"]
    RTE_CPUFLAG_LZCNT = 80,
    #[doc = "< SYSCALL"]
    RTE_CPUFLAG_SYSCALL = 81,
    #[doc = "< XD"]
    RTE_CPUFLAG_XD = 82,
    #[doc = "< 1GB_PG"]
    RTE_CPUFLAG_1GB_PG = 83,
    #[doc = "< RDTSCP"]
    RTE_CPUFLAG_RDTSCP = 84,
    #[doc = "< EM64T"]
    RTE_CPUFLAG_EM64T = 85,
    #[doc = "< INVTSC"]
    RTE_CPUFLAG_INVTSC = 86,
    #[doc = "< AVX512 Doubleword and Quadword"]
    RTE_CPUFLAG_AVX512DQ = 87,
    #[doc = "< AVX512 Integer Fused Multiply-Add"]
    RTE_CPUFLAG_AVX512IFMA = 88,
    #[doc = "< AVX512 Conflict Detection"]
    RTE_CPUFLAG_AVX512CD = 89,
    #[doc = "< AVX512 Byte and Word"]
    RTE_CPUFLAG_AVX512BW = 90,
    #[doc = "< AVX512 Vector Length"]
    RTE_CPUFLAG_AVX512VL = 91,
    #[doc = "< AVX512 Vector Bit Manipulation"]
    RTE_CPUFLAG_AVX512VBMI = 92,
    #[doc = "< AVX512 Vector Bit Manipulation 2"]
    RTE_CPUFLAG_AVX512VBMI2 = 93,
    #[doc = "< Galois Field New Instructions"]
    RTE_CPUFLAG_GFNI = 94,
    #[doc = "< Vector AES"]
    RTE_CPUFLAG_VAES = 95,
    #[doc = "< Vector Carry-less Multiply"]
    RTE_CPUFLAG_VPCLMULQDQ = 96,
    RTE_CPUFLAG_AVX512VNNI = 97,
    #[doc = "< AVX512 Bit Algorithms"]
    RTE_CPUFLAG_AVX512BITALG = 98,
    #[doc = "< AVX512 Vector Popcount"]
    RTE_CPUFLAG_AVX512VPOPCNTDQ = 99,
    #[doc = "< Cache Line Demote"]
    RTE_CPUFLAG_CLDEMOTE = 100,
    #[doc = "< Direct Store Instructions"]
    RTE_CPUFLAG_MOVDIRI = 101,
    #[doc = "< Direct Store Instructions 64B"]
    RTE_CPUFLAG_MOVDIR64B = 102,
    #[doc = "< AVX512 Two Register Intersection"]
    RTE_CPUFLAG_AVX512VP2INTERSECT = 103,
    #[doc = "< UMONITOR/UMWAIT/TPAUSE"]
    RTE_CPUFLAG_WAITPKG = 104,
    #[doc = "< This should always be the last!"]
    RTE_CPUFLAG_NUMFLAGS = 105,
}
#[doc = " Structure used to describe platform-specific intrinsics that may or may not"]
#[doc = " be supported at runtime."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_cpu_intrinsics {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl rte_cpu_intrinsics {
    #[inline]
    pub fn power_monitor(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_power_monitor(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn power_pause(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_power_pause(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn power_monitor_multi(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_power_monitor_multi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        power_monitor: u32,
        power_pause: u32,
        power_monitor_multi: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let power_monitor: u32 = unsafe { ::std::mem::transmute(power_monitor) };
            power_monitor as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let power_pause: u32 = unsafe { ::std::mem::transmute(power_pause) };
            power_pause as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let power_monitor_multi: u32 = unsafe { ::std::mem::transmute(power_monitor_multi) };
            power_monitor_multi as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Check CPU support for various intrinsics at runtime."]
    #[doc = ""]
    #[doc = " @param intrinsics"]
    #[doc = "     Pointer to a structure to be filled."]
    pub fn rte_cpu_get_intrinsics_support(intrinsics: *mut rte_cpu_intrinsics);
}
extern "C" {
    #[doc = " Get name of CPU flag"]
    #[doc = ""]
    #[doc = " @param feature"]
    #[doc = "     CPU flag ID"]
    #[doc = " @return"]
    #[doc = "     flag name"]
    #[doc = "     NULL if flag ID is invalid"]
    pub fn rte_cpu_get_flag_name(feature: rte_cpu_flag_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Function for checking a CPU flag availability"]
    #[doc = ""]
    #[doc = " @param feature"]
    #[doc = "     CPU flag to query CPU for"]
    #[doc = " @return"]
    #[doc = "     1 if flag is available"]
    #[doc = "     0 if flag is not available"]
    #[doc = "     -ENOENT if flag is invalid"]
    pub fn rte_cpu_get_flag_enabled(feature: rte_cpu_flag_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function checks that the currently used CPU supports the CPU features"]
    #[doc = " that were specified at compile time. It is called automatically within the"]
    #[doc = " EAL, so does not need to be used by applications.  This version returns a"]
    #[doc = " result so that decisions may be made (for instance, graceful shutdowns)."]
    pub fn rte_cpu_is_supported() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function attempts to retrieve a value from the auxiliary vector."]
    #[doc = " If it is unsuccessful, the result will be 0, and errno will be set."]
    #[doc = ""]
    #[doc = " @return A value from the auxiliary vector.  When the value is 0, check"]
    #[doc = " errno to determine if an error occurred."]
    pub fn rte_cpu_getauxval(type_: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " This function retrieves a value from the auxiliary vector, and compares it"]
    #[doc = " as a string against the value retrieved."]
    #[doc = ""]
    #[doc = " @return The result of calling strcmp() against the value retrieved from"]
    #[doc = " the auxiliary vector.  When the value is 0 (meaning a match is found),"]
    #[doc = " check errno to determine if an error occurred."]
    pub fn rte_cpu_strcmp_auxval(
        type_: ::std::os::raw::c_ulong,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut rte_rtm_supported: u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_fbarray {
    #[doc = "< name associated with an array"]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< number of entries stored"]
    pub count: ::std::os::raw::c_uint,
    #[doc = "< current length of the array"]
    pub len: ::std::os::raw::c_uint,
    #[doc = "< size of each element"]
    pub elt_sz: ::std::os::raw::c_uint,
    #[doc = "< data pointer"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< multiprocess lock"]
    pub rwlock: rte_rwlock_t,
}
extern "C" {
    #[doc = " Set up ``rte_fbarray`` structure and allocate underlying resources."]
    #[doc = ""]
    #[doc = " Call this function to correctly set up ``rte_fbarray`` and allocate"]
    #[doc = " underlying files that will be backing the data in the current process. Note"]
    #[doc = " that in order to use and share ``rte_fbarray`` between multiple processes,"]
    #[doc = " data pointed to by ``arr`` pointer must itself be allocated in shared memory."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Unique name to be assigned to this array."]
    #[doc = ""]
    #[doc = " @param len"]
    #[doc = "   Number of elements initially available in the array."]
    #[doc = ""]
    #[doc = " @param elt_sz"]
    #[doc = "   Size of each element."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_init(
        arr: *mut rte_fbarray,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
        elt_sz: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attach to a file backing an already allocated and correctly set up"]
    #[doc = " ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " Call this function to attach to file that will be backing the data in the"]
    #[doc = " current process. The structure must have been previously correctly set up"]
    #[doc = " with a call to ``rte_fbarray_init()``. Calls to ``rte_fbarray_attach()`` are"]
    #[doc = " usually meant to be performed in a multiprocessing scenario, with data"]
    #[doc = " pointed to by ``arr`` pointer allocated in shared memory."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up rte_fbarray structure."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_attach(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Deallocate resources for an already allocated and correctly set up"]
    #[doc = " ``rte_fbarray`` structure, and remove the underlying file."]
    #[doc = ""]
    #[doc = " Call this function to deallocate all resources associated with an"]
    #[doc = " ``rte_fbarray`` structure within the current process. This will also"]
    #[doc = " zero-fill data pointed to by ``arr`` pointer and remove the underlying file"]
    #[doc = " backing the data, so it is expected that by the time this function is called,"]
    #[doc = " all other processes have detached from this ``rte_fbarray``."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_destroy(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Deallocate resources for an already allocated and correctly set up"]
    #[doc = " ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " Call this function to deallocate all resources associated with an"]
    #[doc = " ``rte_fbarray`` structure within current process."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_detach(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get pointer to element residing at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param idx"]
    #[doc = "   Index of an element to get a pointer to."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-NULL pointer on success."]
    #[doc = "  - NULL on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_get(
        arr: *const rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Find index of a specified element within the array."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param elt"]
    #[doc = "   Pointer to element to find index to."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_idx(
        arr: *const rte_fbarray,
        elt: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Mark specified element as used."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param idx"]
    #[doc = "   Element index to mark as used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_set_used(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Mark specified element as free."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param idx"]
    #[doc = "   Element index to mark as free."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_set_free(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check whether element at specified index is marked as used."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param idx"]
    #[doc = "   Element index to check as used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 1 if element is used."]
    #[doc = "  - 0 if element is unused."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_is_used(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find index of next free element, starting at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_next_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find index of next used element, starting at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_next_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find index of next chunk of ``n`` free elements, starting at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @param n"]
    #[doc = "   Number of free elements to look for."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_next_n_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find index of next chunk of ``n`` used elements, starting at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @param n"]
    #[doc = "   Number of used elements to look for."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_next_n_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find how many more free entries there are, starting at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_contig_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find how many more used entries there are, starting at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_contig_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find index of previous free element, starting at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_prev_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find index of previous used element, starting at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_prev_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find lowest start index of chunk of ``n`` free elements, down from specified"]
    #[doc = " index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @param n"]
    #[doc = "   Number of free elements to look for."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_prev_n_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find lowest start index of chunk of ``n`` used elements, down from specified"]
    #[doc = " index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @param n"]
    #[doc = "   Number of used elements to look for."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_prev_n_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find how many more free entries there are before specified index (like"]
    #[doc = " ``rte_fbarray_find_contig_free`` but going in reverse)."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_rev_contig_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find how many more used entries there are before specified index (like"]
    #[doc = " ``rte_fbarray_find_contig_used`` but going in reverse)."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_rev_contig_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find index of biggest chunk of free elements, starting at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_biggest_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find index of biggest chunk of used elements, starting at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_biggest_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find index of biggest chunk of free elements before a specified index (like"]
    #[doc = " ``rte_fbarray_find_biggest_free``, but going in reverse)."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_rev_biggest_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find index of biggest chunk of used elements before a specified index (like"]
    #[doc = " ``rte_fbarray_find_biggest_used``, but going in reverse)."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_rev_biggest_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump ``rte_fbarray`` metadata."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   File object to dump information into."]
    pub fn rte_fbarray_dump_metadata(arr: *mut rte_fbarray, f: *mut FILE);
}
#[doc = " Physical memory segment descriptor."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memseg {
    #[doc = "< Start IO address."]
    pub iova: rte_iova_t,
    pub __bindgen_anon_1: rte_memseg__bindgen_ty_1,
    #[doc = "< Length of the segment."]
    pub len: size_t,
    #[doc = "< The pagesize of underlying memory"]
    pub hugepage_sz: u64,
    #[doc = "< NUMA socket ID."]
    pub socket_id: i32,
    #[doc = "< Number of channels."]
    pub nchannel: u32,
    #[doc = "< Number of ranks."]
    pub nrank: u32,
    #[doc = "< Memseg-specific flags"]
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg__bindgen_ty_1 {
    #[doc = "< Start virtual address."]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< Makes sure addr is always 64 bits"]
    pub addr_64: u64,
}
#[doc = " memseg list is a special case as we need to store a bunch of other data"]
#[doc = " together with the array itself."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_memseg_list {
    pub __bindgen_anon_1: rte_memseg_list__bindgen_ty_1,
    #[doc = "< Page size for all memsegs in this list."]
    pub page_sz: u64,
    #[doc = "< Socket ID for all memsegs in this list."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< version number for multiprocess sync."]
    pub version: u32,
    #[doc = "< Length of memory area covered by this memseg list."]
    pub len: size_t,
    #[doc = "< 1 if this list points to external memory"]
    pub external: ::std::os::raw::c_uint,
    #[doc = "< 1 if this list points to a heap"]
    pub heap: ::std::os::raw::c_uint,
    pub memseg_arr: rte_fbarray,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg_list__bindgen_ty_1 {
    pub base_va: *mut ::std::os::raw::c_void,
    pub addr_64: u64,
}
extern "C" {
    #[doc = " Lock page in physical memory and prevent from swapping."]
    #[doc = ""]
    #[doc = " @param virt"]
    #[doc = "   The virtual address."]
    #[doc = " @return"]
    #[doc = "   0 on success, negative on error."]
    pub fn rte_mem_lock_page(virt: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get physical address of any mapped virtual address in the current process."]
    #[doc = " It is found by browsing the /proc/self/pagemap special file."]
    #[doc = " The page must be locked."]
    #[doc = ""]
    #[doc = " @param virt"]
    #[doc = "   The virtual address."]
    #[doc = " @return"]
    #[doc = "   The physical address or RTE_BAD_IOVA on error."]
    pub fn rte_mem_virt2phy(virt: *const ::std::os::raw::c_void) -> phys_addr_t;
}
extern "C" {
    #[doc = " Get IO virtual address of any mapped virtual address in the current process."]
    #[doc = ""]
    #[doc = " @note This function will not check internal page table. Instead, in IOVA as"]
    #[doc = "       PA mode, it will fall back to getting real physical address (which may"]
    #[doc = "       not match the expected IOVA, such as what was specified for external"]
    #[doc = "       memory)."]
    #[doc = ""]
    #[doc = " @param virt"]
    #[doc = "   The virtual address."]
    #[doc = " @return"]
    #[doc = "   The IO address or RTE_BAD_IOVA on error."]
    pub fn rte_mem_virt2iova(virt: *const ::std::os::raw::c_void) -> rte_iova_t;
}
extern "C" {
    #[doc = " Get virtual memory address corresponding to iova address."]
    #[doc = ""]
    #[doc = " @note This function read-locks the memory hotplug subsystem, and thus cannot"]
    #[doc = "       be used within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @param iova"]
    #[doc = "   The iova address."]
    #[doc = " @return"]
    #[doc = "   Virtual address corresponding to iova address (or NULL if address does not"]
    #[doc = "   exist within DPDK memory map)."]
    pub fn rte_mem_iova2virt(iova: rte_iova_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get memseg to which a particular virtual address belongs."]
    #[doc = ""]
    #[doc = " @param virt"]
    #[doc = "   The virtual address."]
    #[doc = " @param msl"]
    #[doc = "   The memseg list in which to look up based on ``virt`` address"]
    #[doc = "   (can be NULL)."]
    #[doc = " @return"]
    #[doc = "   Memseg pointer on success, or NULL on error."]
    pub fn rte_mem_virt2memseg(
        virt: *const ::std::os::raw::c_void,
        msl: *const rte_memseg_list,
    ) -> *mut rte_memseg;
}
extern "C" {
    #[doc = " Get memseg list corresponding to virtual memory address."]
    #[doc = ""]
    #[doc = " @param virt"]
    #[doc = "   The virtual address."]
    #[doc = " @return"]
    #[doc = "   Memseg list to which this virtual address belongs to."]
    pub fn rte_mem_virt2memseg_list(virt: *const ::std::os::raw::c_void) -> *mut rte_memseg_list;
}
#[doc = " Memseg walk function prototype."]
#[doc = ""]
#[doc = " Returning 0 will continue walk"]
#[doc = " Returning 1 will stop the walk"]
#[doc = " Returning -1 will stop the walk and report error"]
pub type rte_memseg_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        ms: *const rte_memseg,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Memseg contig walk function prototype. This will trigger a callback on every"]
#[doc = " VA-contiguous area starting at memseg ``ms``, so total valid VA space at each"]
#[doc = " callback call will be [``ms->addr``, ``ms->addr + len``)."]
#[doc = ""]
#[doc = " Returning 0 will continue walk"]
#[doc = " Returning 1 will stop the walk"]
#[doc = " Returning -1 will stop the walk and report error"]
pub type rte_memseg_contig_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        ms: *const rte_memseg,
        len: size_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Memseg list walk function prototype. This will trigger a callback on every"]
#[doc = " allocated memseg list."]
#[doc = ""]
#[doc = " Returning 0 will continue walk"]
#[doc = " Returning 1 will stop the walk"]
#[doc = " Returning -1 will stop the walk and report error"]
pub type rte_memseg_list_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Walk list of all memsegs."]
    #[doc = ""]
    #[doc = " @note This function read-locks the memory hotplug subsystem, and thus cannot"]
    #[doc = "       be used within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @note This function will also walk through externally allocated segments. It"]
    #[doc = "       is up to the user to decide whether to skip through these segments."]
    #[doc = ""]
    #[doc = " @param func"]
    #[doc = "   Iterator function"]
    #[doc = " @param arg"]
    #[doc = "   Argument passed to iterator"]
    #[doc = " @return"]
    #[doc = "   0 if walked over the entire list"]
    #[doc = "   1 if stopped by the user"]
    #[doc = "   -1 if user function reported error"]
    pub fn rte_memseg_walk(
        func: rte_memseg_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Walk each VA-contiguous area."]
    #[doc = ""]
    #[doc = " @note This function read-locks the memory hotplug subsystem, and thus cannot"]
    #[doc = "       be used within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @note This function will also walk through externally allocated segments. It"]
    #[doc = "       is up to the user to decide whether to skip through these segments."]
    #[doc = ""]
    #[doc = " @param func"]
    #[doc = "   Iterator function"]
    #[doc = " @param arg"]
    #[doc = "   Argument passed to iterator"]
    #[doc = " @return"]
    #[doc = "   0 if walked over the entire list"]
    #[doc = "   1 if stopped by the user"]
    #[doc = "   -1 if user function reported error"]
    pub fn rte_memseg_contig_walk(
        func: rte_memseg_contig_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Walk each allocated memseg list."]
    #[doc = ""]
    #[doc = " @note This function read-locks the memory hotplug subsystem, and thus cannot"]
    #[doc = "       be used within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @note This function will also walk through externally allocated segments. It"]
    #[doc = "       is up to the user to decide whether to skip through these segments."]
    #[doc = ""]
    #[doc = " @param func"]
    #[doc = "   Iterator function"]
    #[doc = " @param arg"]
    #[doc = "   Argument passed to iterator"]
    #[doc = " @return"]
    #[doc = "   0 if walked over the entire list"]
    #[doc = "   1 if stopped by the user"]
    #[doc = "   -1 if user function reported error"]
    pub fn rte_memseg_list_walk(
        func: rte_memseg_list_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Walk list of all memsegs without performing any locking."]
    #[doc = ""]
    #[doc = " @note This function does not perform any locking, and is only safe to call"]
    #[doc = "       from within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @param func"]
    #[doc = "   Iterator function"]
    #[doc = " @param arg"]
    #[doc = "   Argument passed to iterator"]
    #[doc = " @return"]
    #[doc = "   0 if walked over the entire list"]
    #[doc = "   1 if stopped by the user"]
    #[doc = "   -1 if user function reported error"]
    pub fn rte_memseg_walk_thread_unsafe(
        func: rte_memseg_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Walk each VA-contiguous area without performing any locking."]
    #[doc = ""]
    #[doc = " @note This function does not perform any locking, and is only safe to call"]
    #[doc = "       from within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @param func"]
    #[doc = "   Iterator function"]
    #[doc = " @param arg"]
    #[doc = "   Argument passed to iterator"]
    #[doc = " @return"]
    #[doc = "   0 if walked over the entire list"]
    #[doc = "   1 if stopped by the user"]
    #[doc = "   -1 if user function reported error"]
    pub fn rte_memseg_contig_walk_thread_unsafe(
        func: rte_memseg_contig_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Walk each allocated memseg list without performing any locking."]
    #[doc = ""]
    #[doc = " @note This function does not perform any locking, and is only safe to call"]
    #[doc = "       from within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @param func"]
    #[doc = "   Iterator function"]
    #[doc = " @param arg"]
    #[doc = "   Argument passed to iterator"]
    #[doc = " @return"]
    #[doc = "   0 if walked over the entire list"]
    #[doc = "   1 if stopped by the user"]
    #[doc = "   -1 if user function reported error"]
    pub fn rte_memseg_list_walk_thread_unsafe(
        func: rte_memseg_list_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return file descriptor associated with a particular memseg (if available)."]
    #[doc = ""]
    #[doc = " @note This function read-locks the memory hotplug subsystem, and thus cannot"]
    #[doc = "       be used within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @note This returns an internal file descriptor. Performing any operations on"]
    #[doc = "       this file descriptor is inherently dangerous, so it should be treated"]
    #[doc = "       as read-only for all intents and purposes."]
    #[doc = ""]
    #[doc = " @param ms"]
    #[doc = "   A pointer to memseg for which to get file descriptor."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Valid file descriptor in case of success."]
    #[doc = "   -1 in case of error, with ``rte_errno`` set to the following values:"]
    #[doc = "     - EINVAL  - ``ms`` pointer was NULL or did not point to a valid memseg"]
    #[doc = "     - ENODEV  - ``ms`` fd is not available"]
    #[doc = "     - ENOENT  - ``ms`` is an unused segment"]
    #[doc = "     - ENOTSUP - segment fd's are not supported"]
    pub fn rte_memseg_get_fd(ms: *const rte_memseg) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return file descriptor associated with a particular memseg (if available)."]
    #[doc = ""]
    #[doc = " @note This function does not perform any locking, and is only safe to call"]
    #[doc = "       from within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @note This returns an internal file descriptor. Performing any operations on"]
    #[doc = "       this file descriptor is inherently dangerous, so it should be treated"]
    #[doc = "       as read-only for all intents and purposes."]
    #[doc = ""]
    #[doc = " @param ms"]
    #[doc = "   A pointer to memseg for which to get file descriptor."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Valid file descriptor in case of success."]
    #[doc = "   -1 in case of error, with ``rte_errno`` set to the following values:"]
    #[doc = "     - EINVAL  - ``ms`` pointer was NULL or did not point to a valid memseg"]
    #[doc = "     - ENODEV  - ``ms`` fd is not available"]
    #[doc = "     - ENOENT  - ``ms`` is an unused segment"]
    #[doc = "     - ENOTSUP - segment fd's are not supported"]
    pub fn rte_memseg_get_fd_thread_unsafe(ms: *const rte_memseg) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get offset into segment file descriptor associated with a particular memseg"]
    #[doc = " (if available)."]
    #[doc = ""]
    #[doc = " @note This function read-locks the memory hotplug subsystem, and thus cannot"]
    #[doc = "       be used within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @param ms"]
    #[doc = "   A pointer to memseg for which to get file descriptor."]
    #[doc = " @param offset"]
    #[doc = "   A pointer to offset value where the result will be stored."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Valid file descriptor in case of success."]
    #[doc = "   -1 in case of error, with ``rte_errno`` set to the following values:"]
    #[doc = "     - EINVAL  - ``ms`` pointer was NULL or did not point to a valid memseg"]
    #[doc = "     - EINVAL  - ``offset`` pointer was NULL"]
    #[doc = "     - ENODEV  - ``ms`` fd is not available"]
    #[doc = "     - ENOENT  - ``ms`` is an unused segment"]
    #[doc = "     - ENOTSUP - segment fd's are not supported"]
    pub fn rte_memseg_get_fd_offset(
        ms: *const rte_memseg,
        offset: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get offset into segment file descriptor associated with a particular memseg"]
    #[doc = " (if available)."]
    #[doc = ""]
    #[doc = " @note This function does not perform any locking, and is only safe to call"]
    #[doc = "       from within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @param ms"]
    #[doc = "   A pointer to memseg for which to get file descriptor."]
    #[doc = " @param offset"]
    #[doc = "   A pointer to offset value where the result will be stored."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Valid file descriptor in case of success."]
    #[doc = "   -1 in case of error, with ``rte_errno`` set to the following values:"]
    #[doc = "     - EINVAL  - ``ms`` pointer was NULL or did not point to a valid memseg"]
    #[doc = "     - EINVAL  - ``offset`` pointer was NULL"]
    #[doc = "     - ENODEV  - ``ms`` fd is not available"]
    #[doc = "     - ENOENT  - ``ms`` is an unused segment"]
    #[doc = "     - ENOTSUP - segment fd's are not supported"]
    pub fn rte_memseg_get_fd_offset_thread_unsafe(
        ms: *const rte_memseg,
        offset: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register external memory chunk with DPDK."]
    #[doc = ""]
    #[doc = " @note Using this API is mutually exclusive with ``rte_malloc`` family of"]
    #[doc = "   API's."]
    #[doc = ""]
    #[doc = " @note This API will not perform any DMA mapping. It is expected that user"]
    #[doc = "   will do that themselves."]
    #[doc = ""]
    #[doc = " @note Before accessing this memory in other processes, it needs to be"]
    #[doc = "   attached in each of those processes by calling ``rte_extmem_attach`` in"]
    #[doc = "   each other process."]
    #[doc = ""]
    #[doc = " @param va_addr"]
    #[doc = "   Start of virtual area to register. Must be aligned by ``page_sz``."]
    #[doc = " @param len"]
    #[doc = "   Length of virtual area to register. Must be aligned by ``page_sz``."]
    #[doc = " @param iova_addrs"]
    #[doc = "   Array of page IOVA addresses corresponding to each page in this memory"]
    #[doc = "   area. Can be NULL, in which case page IOVA addresses will be set to"]
    #[doc = "   RTE_BAD_IOVA."]
    #[doc = " @param n_pages"]
    #[doc = "   Number of elements in the iova_addrs array. Ignored if  ``iova_addrs``"]
    #[doc = "   is NULL."]
    #[doc = " @param page_sz"]
    #[doc = "   Page size of the underlying memory"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - -1 in case of error, with rte_errno set to one of the following:"]
    #[doc = "     EINVAL - one of the parameters was invalid"]
    #[doc = "     EEXIST - memory chunk is already registered"]
    #[doc = "     ENOSPC - no more space in internal config to store a new memory chunk"]
    pub fn rte_extmem_register(
        va_addr: *mut ::std::os::raw::c_void,
        len: size_t,
        iova_addrs: *mut rte_iova_t,
        n_pages: ::std::os::raw::c_uint,
        page_sz: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unregister external memory chunk with DPDK."]
    #[doc = ""]
    #[doc = " @note Using this API is mutually exclusive with ``rte_malloc`` family of"]
    #[doc = "   API's."]
    #[doc = ""]
    #[doc = " @note This API will not perform any DMA unmapping. It is expected that user"]
    #[doc = "   will do that themselves."]
    #[doc = ""]
    #[doc = " @note Before calling this function, all other processes must call"]
    #[doc = "   ``rte_extmem_detach`` to detach from the memory area."]
    #[doc = ""]
    #[doc = " @param va_addr"]
    #[doc = "   Start of virtual area to unregister"]
    #[doc = " @param len"]
    #[doc = "   Length of virtual area to unregister"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - -1 in case of error, with rte_errno set to one of the following:"]
    #[doc = "     EINVAL - one of the parameters was invalid"]
    #[doc = "     ENOENT - memory chunk was not found"]
    pub fn rte_extmem_unregister(
        va_addr: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attach to external memory chunk registered in another process."]
    #[doc = ""]
    #[doc = " @note Using this API is mutually exclusive with ``rte_malloc`` family of"]
    #[doc = "   API's."]
    #[doc = ""]
    #[doc = " @note This API will not perform any DMA mapping. It is expected that user"]
    #[doc = "   will do that themselves."]
    #[doc = ""]
    #[doc = " @param va_addr"]
    #[doc = "   Start of virtual area to register"]
    #[doc = " @param len"]
    #[doc = "   Length of virtual area to register"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - -1 in case of error, with rte_errno set to one of the following:"]
    #[doc = "     EINVAL - one of the parameters was invalid"]
    #[doc = "     ENOENT - memory chunk was not found"]
    pub fn rte_extmem_attach(
        va_addr: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Detach from external memory chunk registered in another process."]
    #[doc = ""]
    #[doc = " @note Using this API is mutually exclusive with ``rte_malloc`` family of"]
    #[doc = "   API's."]
    #[doc = ""]
    #[doc = " @note This API will not perform any DMA unmapping. It is expected that user"]
    #[doc = "   will do that themselves."]
    #[doc = ""]
    #[doc = " @param va_addr"]
    #[doc = "   Start of virtual area to unregister"]
    #[doc = " @param len"]
    #[doc = "   Length of virtual area to unregister"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - -1 in case of error, with rte_errno set to one of the following:"]
    #[doc = "     EINVAL - one of the parameters was invalid"]
    #[doc = "     ENOENT - memory chunk was not found"]
    pub fn rte_extmem_detach(
        va_addr: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump the physical memory layout to a file."]
    #[doc = ""]
    #[doc = " @note This function read-locks the memory hotplug subsystem, and thus cannot"]
    #[doc = "       be used within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_dump_physmem_layout(f: *mut FILE);
}
extern "C" {
    #[doc = " Get the total amount of available physical memory."]
    #[doc = ""]
    #[doc = " @note This function read-locks the memory hotplug subsystem, and thus cannot"]
    #[doc = "       be used within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    The total amount of available physical memory in bytes."]
    pub fn rte_eal_get_physmem_size() -> u64;
}
extern "C" {
    #[doc = " Get the number of memory channels."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The number of memory channels on the system. The value is 0 if unknown"]
    #[doc = "   or not the same on all devices."]
    pub fn rte_memory_get_nchannel() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the number of memory ranks."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The number of memory ranks on the system. The value is 0 if unknown or"]
    #[doc = "   not the same on all devices."]
    pub fn rte_memory_get_nrank() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Check if all currently allocated memory segments are compliant with"]
    #[doc = " supplied DMA address width."]
    #[doc = ""]
    #[doc = "  @param maskbits"]
    #[doc = "    Address width to check against."]
    pub fn rte_mem_check_dma_mask(maskbits: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if all currently allocated memory segments are compliant with"]
    #[doc = " supplied DMA address width. This function will use"]
    #[doc = " rte_memseg_walk_thread_unsafe instead of rte_memseg_walk implying"]
    #[doc = " memory_hotplug_lock will not be acquired avoiding deadlock during"]
    #[doc = " memory initialization."]
    #[doc = ""]
    #[doc = " This function is just for EAL core memory internal use. Drivers should"]
    #[doc = " use the previous rte_mem_check_dma_mask."]
    #[doc = ""]
    #[doc = "  @param maskbits"]
    #[doc = "    Address width to check against."]
    pub fn rte_mem_check_dma_mask_thread_unsafe(maskbits: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set dma mask to use once memory initialization is done. Previous functions"]
    #[doc = "  rte_mem_check_dma_mask and rte_mem_check_dma_mask_thread_unsafe can not be"]
    #[doc = "  used safely until memory has been initialized."]
    pub fn rte_mem_set_dma_mask(maskbits: u8);
}
extern "C" {
    #[doc = " Drivers based on uio will not load unless physical"]
    #[doc = " addresses are obtainable. It is only possible to get"]
    #[doc = " physical addresses when running as a privileged user."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   1 if the system is able to obtain physical addresses."]
    #[doc = "   0 if using DMA addresses through an IOMMU."]
    pub fn rte_eal_using_phys_addrs() -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " Enum indicating which kind of memory event has happened. Used by callbacks to"]
#[doc = " distinguish between memory allocations and deallocations."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_mem_event {
    #[doc = "< Allocation event."]
    RTE_MEM_EVENT_ALLOC = 0,
    #[doc = "< Deallocation event."]
    RTE_MEM_EVENT_FREE = 1,
}
#[doc = " Function typedef used to register callbacks for memory events."]
pub type rte_mem_event_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        event_type: rte_mem_event,
        addr: *const ::std::os::raw::c_void,
        len: size_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Function used to register callbacks for memory events."]
    #[doc = ""]
    #[doc = " @note callbacks will happen while memory hotplug subsystem is write-locked,"]
    #[doc = "       therefore some functions (e.g. `rte_memseg_walk()`) will cause a"]
    #[doc = "       deadlock when called from within such callbacks."]
    #[doc = ""]
    #[doc = " @note mem event callbacks not being supported is an expected error condition,"]
    #[doc = "       so user code needs to handle this situation. In these cases, return"]
    #[doc = "       value will be -1, and rte_errno will be set to ENOTSUP."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Name associated with specified callback to be added to the list."]
    #[doc = ""]
    #[doc = " @param clb"]
    #[doc = "   Callback function pointer."]
    #[doc = ""]
    #[doc = " @param arg"]
    #[doc = "   Argument to pass to the callback."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on successful callback register"]
    #[doc = "   -1 on unsuccessful callback register, with rte_errno value indicating"]
    #[doc = "   reason for failure."]
    pub fn rte_mem_event_callback_register(
        name: *const ::std::os::raw::c_char,
        clb: rte_mem_event_callback_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function used to unregister callbacks for memory events."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Name associated with specified callback to be removed from the list."]
    #[doc = ""]
    #[doc = " @param arg"]
    #[doc = "   Argument to look for among callbacks with specified callback name."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on successful callback unregister"]
    #[doc = "   -1 on unsuccessful callback unregister, with rte_errno value indicating"]
    #[doc = "   reason for failure."]
    pub fn rte_mem_event_callback_unregister(
        name: *const ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Function typedef used to register memory allocation validation callbacks."]
#[doc = ""]
#[doc = " Returning 0 will allow allocation attempt to continue. Returning -1 will"]
#[doc = " prevent allocation from succeeding."]
pub type rte_mem_alloc_validator_t = ::std::option::Option<
    unsafe extern "C" fn(
        socket_id: ::std::os::raw::c_int,
        cur_limit: size_t,
        new_len: size_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @brief Register validator callback for memory allocations."]
    #[doc = ""]
    #[doc = " Callbacks registered by this function will be called right before memory"]
    #[doc = " allocator is about to trigger allocation of more pages from the system if"]
    #[doc = " said allocation will bring total memory usage above specified limit on"]
    #[doc = " specified socket. User will be able to cancel pending allocation if callback"]
    #[doc = " returns -1."]
    #[doc = ""]
    #[doc = " @note callbacks will happen while memory hotplug subsystem is write-locked,"]
    #[doc = "       therefore some functions (e.g. `rte_memseg_walk()`) will cause a"]
    #[doc = "       deadlock when called from within such callbacks."]
    #[doc = ""]
    #[doc = " @note validator callbacks not being supported is an expected error condition,"]
    #[doc = "       so user code needs to handle this situation. In these cases, return"]
    #[doc = "       value will be -1, and rte_errno will be set to ENOTSUP."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Name associated with specified callback to be added to the list."]
    #[doc = ""]
    #[doc = " @param clb"]
    #[doc = "   Callback function pointer."]
    #[doc = ""]
    #[doc = " @param socket_id"]
    #[doc = "   Socket ID on which to watch for allocations."]
    #[doc = ""]
    #[doc = " @param limit"]
    #[doc = "   Limit above which to trigger callbacks."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on successful callback register"]
    #[doc = "   -1 on unsuccessful callback register, with rte_errno value indicating"]
    #[doc = "   reason for failure."]
    pub fn rte_mem_alloc_validator_register(
        name: *const ::std::os::raw::c_char,
        clb: rte_mem_alloc_validator_t,
        socket_id: ::std::os::raw::c_int,
        limit: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Unregister validator callback for memory allocations."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Name associated with specified callback to be removed from the list."]
    #[doc = ""]
    #[doc = " @param socket_id"]
    #[doc = "   Socket ID on which to watch for allocations."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on successful callback unregister"]
    #[doc = "   -1 on unsuccessful callback unregister, with rte_errno value indicating"]
    #[doc = "   reason for failure."]
    pub fn rte_mem_alloc_validator_unregister(
        name: *const ::std::os::raw::c_char,
        socket_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type rte_be16_t = u16;
pub type rte_be32_t = u32;
pub type rte_be64_t = u64;
pub type rte_le16_t = u16;
pub type rte_le32_t = u32;
pub type rte_le64_t = u64;
#[doc = "  Structure to hold heap statistics obtained from rte_malloc_get_socket_stats function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_malloc_socket_stats {
    #[doc = "< Total bytes on heap"]
    pub heap_totalsz_bytes: size_t,
    #[doc = "< Total free bytes on heap"]
    pub heap_freesz_bytes: size_t,
    #[doc = "< Size in bytes of largest free block"]
    pub greatest_free_size: size_t,
    #[doc = "< Number of free elements on heap"]
    pub free_count: ::std::os::raw::c_uint,
    #[doc = "< Number of allocated elements on heap"]
    pub alloc_count: ::std::os::raw::c_uint,
    #[doc = "< Total allocated bytes on heap"]
    pub heap_allocsz_bytes: size_t,
}
extern "C" {
    #[doc = " This function allocates memory from the huge-page area of memory. The memory"]
    #[doc = " is not cleared. In NUMA systems, the memory allocated resides on the same"]
    #[doc = " NUMA socket as the core that calls this function."]
    #[doc = ""]
    #[doc = " @param type"]
    #[doc = "   A string identifying the type of allocated objects (useful for debug"]
    #[doc = "   purposes, such as identifying the cause of a memory leak). Can be NULL."]
    #[doc = " @param size"]
    #[doc = "   Size (in bytes) to be allocated."]
    #[doc = " @param align"]
    #[doc = "   If 0, the return is a pointer that is suitably aligned for any kind of"]
    #[doc = "   variable (in the same manner as malloc())."]
    #[doc = "   Otherwise, the return is a pointer that is a multiple of *align*. In"]
    #[doc = "   this case, it must be a power of two. (Minimum alignment is the"]
    #[doc = "   cacheline size, i.e. 64-bytes)"]
    #[doc = " @return"]
    #[doc = "   - NULL on error. Not enough memory, or invalid arguments (size is 0,"]
    #[doc = "     align is not a power of two)."]
    #[doc = "   - Otherwise, the pointer to the allocated object."]
    pub fn rte_malloc(
        type_: *const ::std::os::raw::c_char,
        size: size_t,
        align: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate zeroed memory from the heap."]
    #[doc = ""]
    #[doc = " Equivalent to rte_malloc() except that the memory zone is"]
    #[doc = " initialised with zeros. In NUMA systems, the memory allocated resides on the"]
    #[doc = " same NUMA socket as the core that calls this function."]
    #[doc = ""]
    #[doc = " @param type"]
    #[doc = "   A string identifying the type of allocated objects (useful for debug"]
    #[doc = "   purposes, such as identifying the cause of a memory leak). Can be NULL."]
    #[doc = " @param size"]
    #[doc = "   Size (in bytes) to be allocated."]
    #[doc = " @param align"]
    #[doc = "   If 0, the return is a pointer that is suitably aligned for any kind of"]
    #[doc = "   variable (in the same manner as malloc())."]
    #[doc = "   Otherwise, the return is a pointer that is a multiple of *align*. In"]
    #[doc = "   this case, it must obviously be a power of two. (Minimum alignment is the"]
    #[doc = "   cacheline size, i.e. 64-bytes)"]
    #[doc = " @return"]
    #[doc = "   - NULL on error. Not enough memory, or invalid arguments (size is 0,"]
    #[doc = "     align is not a power of two)."]
    #[doc = "   - Otherwise, the pointer to the allocated object."]
    pub fn rte_zmalloc(
        type_: *const ::std::os::raw::c_char,
        size: size_t,
        align: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Replacement function for calloc(), using huge-page memory. Memory area is"]
    #[doc = " initialised with zeros. In NUMA systems, the memory allocated resides on the"]
    #[doc = " same NUMA socket as the core that calls this function."]
    #[doc = ""]
    #[doc = " @param type"]
    #[doc = "   A string identifying the type of allocated objects (useful for debug"]
    #[doc = "   purposes, such as identifying the cause of a memory leak). Can be NULL."]
    #[doc = " @param num"]
    #[doc = "   Number of elements to be allocated."]
    #[doc = " @param size"]
    #[doc = "   Size (in bytes) of a single element."]
    #[doc = " @param align"]
    #[doc = "   If 0, the return is a pointer that is suitably aligned for any kind of"]
    #[doc = "   variable (in the same manner as malloc())."]
    #[doc = "   Otherwise, the return is a pointer that is a multiple of *align*. In"]
    #[doc = "   this case, it must obviously be a power of two. (Minimum alignment is the"]
    #[doc = "   cacheline size, i.e. 64-bytes)"]
    #[doc = " @return"]
    #[doc = "   - NULL on error. Not enough memory, or invalid arguments (size is 0,"]
    #[doc = "     align is not a power of two)."]
    #[doc = "   - Otherwise, the pointer to the allocated object."]
    pub fn rte_calloc(
        type_: *const ::std::os::raw::c_char,
        num: size_t,
        size: size_t,
        align: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Replacement function for realloc(), using huge-page memory. Reserved area"]
    #[doc = " memory is resized, preserving contents. In NUMA systems, the new area"]
    #[doc = " may not reside on the same NUMA node as the old one."]
    #[doc = ""]
    #[doc = " @param ptr"]
    #[doc = "   Pointer to already allocated memory"]
    #[doc = " @param size"]
    #[doc = "   Size (in bytes) of new area. If this is 0, memory is freed."]
    #[doc = " @param align"]
    #[doc = "   If 0, the return is a pointer that is suitably aligned for any kind of"]
    #[doc = "   variable (in the same manner as malloc())."]
    #[doc = "   Otherwise, the return is a pointer that is a multiple of *align*. In"]
    #[doc = "   this case, it must obviously be a power of two. (Minimum alignment is the"]
    #[doc = "   cacheline size, i.e. 64-bytes)"]
    #[doc = " @return"]
    #[doc = "   - NULL on error. Not enough memory, or invalid arguments (size is 0,"]
    #[doc = "     align is not a power of two)."]
    #[doc = "   - Otherwise, the pointer to the reallocated memory."]
    pub fn rte_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
        align: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Replacement function for realloc(), using huge-page memory. Reserved area"]
    #[doc = " memory is resized, preserving contents. In NUMA systems, the new area"]
    #[doc = " resides on requested NUMA socket."]
    #[doc = ""]
    #[doc = " @param ptr"]
    #[doc = "   Pointer to already allocated memory"]
    #[doc = " @param size"]
    #[doc = "   Size (in bytes) of new area. If this is 0, memory is freed."]
    #[doc = " @param align"]
    #[doc = "   If 0, the return is a pointer that is suitably aligned for any kind of"]
    #[doc = "   variable (in the same manner as malloc())."]
    #[doc = "   Otherwise, the return is a pointer that is a multiple of *align*. In"]
    #[doc = "   this case, it must obviously be a power of two. (Minimum alignment is the"]
    #[doc = "   cacheline size, i.e. 64-bytes)"]
    #[doc = " @param socket"]
    #[doc = "   NUMA socket to allocate memory on."]
    #[doc = " @return"]
    #[doc = "   - NULL on error. Not enough memory, or invalid arguments (size is 0,"]
    #[doc = "     align is not a power of two)."]
    #[doc = "   - Otherwise, the pointer to the reallocated memory."]
    pub fn rte_realloc_socket(
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
        align: ::std::os::raw::c_uint,
        socket: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " This function allocates memory from the huge-page area of memory. The memory"]
    #[doc = " is not cleared."]
    #[doc = ""]
    #[doc = " @param type"]
    #[doc = "   A string identifying the type of allocated objects (useful for debug"]
    #[doc = "   purposes, such as identifying the cause of a memory leak). Can be NULL."]
    #[doc = " @param size"]
    #[doc = "   Size (in bytes) to be allocated."]
    #[doc = " @param align"]
    #[doc = "   If 0, the return is a pointer that is suitably aligned for any kind of"]
    #[doc = "   variable (in the same manner as malloc())."]
    #[doc = "   Otherwise, the return is a pointer that is a multiple of *align*. In"]
    #[doc = "   this case, it must be a power of two. (Minimum alignment is the"]
    #[doc = "   cacheline size, i.e. 64-bytes)"]
    #[doc = " @param socket"]
    #[doc = "   NUMA socket to allocate memory on. If SOCKET_ID_ANY is used, this function"]
    #[doc = "   will behave the same as rte_malloc()."]
    #[doc = " @return"]
    #[doc = "   - NULL on error. Not enough memory, or invalid arguments (size is 0,"]
    #[doc = "     align is not a power of two)."]
    #[doc = "   - Otherwise, the pointer to the allocated object."]
    pub fn rte_malloc_socket(
        type_: *const ::std::os::raw::c_char,
        size: size_t,
        align: ::std::os::raw::c_uint,
        socket: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate zeroed memory from the heap."]
    #[doc = ""]
    #[doc = " Equivalent to rte_malloc() except that the memory zone is"]
    #[doc = " initialised with zeros."]
    #[doc = ""]
    #[doc = " @param type"]
    #[doc = "   A string identifying the type of allocated objects (useful for debug"]
    #[doc = "   purposes, such as identifying the cause of a memory leak). Can be NULL."]
    #[doc = " @param size"]
    #[doc = "   Size (in bytes) to be allocated."]
    #[doc = " @param align"]
    #[doc = "   If 0, the return is a pointer that is suitably aligned for any kind of"]
    #[doc = "   variable (in the same manner as malloc())."]
    #[doc = "   Otherwise, the return is a pointer that is a multiple of *align*. In"]
    #[doc = "   this case, it must obviously be a power of two. (Minimum alignment is the"]
    #[doc = "   cacheline size, i.e. 64-bytes)"]
    #[doc = " @param socket"]
    #[doc = "   NUMA socket to allocate memory on. If SOCKET_ID_ANY is used, this function"]
    #[doc = "   will behave the same as rte_zmalloc()."]
    #[doc = " @return"]
    #[doc = "   - NULL on error. Not enough memory, or invalid arguments (size is 0,"]
    #[doc = "     align is not a power of two)."]
    #[doc = "   - Otherwise, the pointer to the allocated object."]
    pub fn rte_zmalloc_socket(
        type_: *const ::std::os::raw::c_char,
        size: size_t,
        align: ::std::os::raw::c_uint,
        socket: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Replacement function for calloc(), using huge-page memory. Memory area is"]
    #[doc = " initialised with zeros."]
    #[doc = ""]
    #[doc = " @param type"]
    #[doc = "   A string identifying the type of allocated objects (useful for debug"]
    #[doc = "   purposes, such as identifying the cause of a memory leak). Can be NULL."]
    #[doc = " @param num"]
    #[doc = "   Number of elements to be allocated."]
    #[doc = " @param size"]
    #[doc = "   Size (in bytes) of a single element."]
    #[doc = " @param align"]
    #[doc = "   If 0, the return is a pointer that is suitably aligned for any kind of"]
    #[doc = "   variable (in the same manner as malloc())."]
    #[doc = "   Otherwise, the return is a pointer that is a multiple of *align*. In"]
    #[doc = "   this case, it must obviously be a power of two. (Minimum alignment is the"]
    #[doc = "   cacheline size, i.e. 64-bytes)"]
    #[doc = " @param socket"]
    #[doc = "   NUMA socket to allocate memory on. If SOCKET_ID_ANY is used, this function"]
    #[doc = "   will behave the same as rte_calloc()."]
    #[doc = " @return"]
    #[doc = "   - NULL on error. Not enough memory, or invalid arguments (size is 0,"]
    #[doc = "     align is not a power of two)."]
    #[doc = "   - Otherwise, the pointer to the allocated object."]
    pub fn rte_calloc_socket(
        type_: *const ::std::os::raw::c_char,
        num: size_t,
        size: size_t,
        align: ::std::os::raw::c_uint,
        socket: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Frees the memory space pointed to by the provided pointer."]
    #[doc = ""]
    #[doc = " This pointer must have been returned by a previous call to"]
    #[doc = " rte_malloc(), rte_zmalloc(), rte_calloc() or rte_realloc(). The behaviour of"]
    #[doc = " rte_free() is undefined if the pointer does not match this requirement."]
    #[doc = ""]
    #[doc = " If the pointer is NULL, the function does nothing."]
    #[doc = ""]
    #[doc = " @param ptr"]
    #[doc = "   The pointer to memory to be freed."]
    pub fn rte_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " If malloc debug is enabled, check a memory block for header"]
    #[doc = " and trailer markers to indicate that all is well with the block."]
    #[doc = " If size is non-null, also return the size of the block."]
    #[doc = ""]
    #[doc = " @param ptr"]
    #[doc = "   pointer to the start of a data block, must have been returned"]
    #[doc = "   by a previous call to rte_malloc(), rte_zmalloc(), rte_calloc()"]
    #[doc = "   or rte_realloc()"]
    #[doc = " @param size"]
    #[doc = "   if non-null, and memory block pointer is valid, returns the size"]
    #[doc = "   of the memory block"]
    #[doc = " @return"]
    #[doc = "   -1 on error, invalid pointer passed or header and trailer markers"]
    #[doc = "   are missing or corrupted"]
    #[doc = "   0 on success"]
    pub fn rte_malloc_validate(
        ptr: *const ::std::os::raw::c_void,
        size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get heap statistics for the specified heap."]
    #[doc = ""]
    #[doc = " @note This function is not thread-safe with respect to"]
    #[doc = "    ``rte_malloc_heap_create()``/``rte_malloc_heap_destroy()`` functions."]
    #[doc = ""]
    #[doc = " @param socket"]
    #[doc = "   An unsigned integer specifying the socket to get heap statistics for"]
    #[doc = " @param socket_stats"]
    #[doc = "   A structure which provides memory to store statistics"]
    #[doc = " @return"]
    #[doc = "   Null on error"]
    #[doc = "   Pointer to structure storing statistics on success"]
    pub fn rte_malloc_get_socket_stats(
        socket: ::std::os::raw::c_int,
        socket_stats: *mut rte_malloc_socket_stats,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add memory chunk to a heap with specified name."]
    #[doc = ""]
    #[doc = " @note Multiple memory chunks can be added to the same heap"]
    #[doc = ""]
    #[doc = " @note Before accessing this memory in other processes, it needs to be"]
    #[doc = "   attached in each of those processes by calling"]
    #[doc = "   ``rte_malloc_heap_memory_attach`` in each other process."]
    #[doc = ""]
    #[doc = " @note Memory must be previously allocated for DPDK to be able to use it as a"]
    #[doc = "   malloc heap. Failing to do so will result in undefined behavior, up to and"]
    #[doc = "   including segmentation faults."]
    #[doc = ""]
    #[doc = " @note Calling this function will erase any contents already present at the"]
    #[doc = "   supplied memory address."]
    #[doc = ""]
    #[doc = " @param heap_name"]
    #[doc = "   Name of the heap to add memory chunk to"]
    #[doc = " @param va_addr"]
    #[doc = "   Start of virtual area to add to the heap. Must be aligned by ``page_sz``."]
    #[doc = " @param len"]
    #[doc = "   Length of virtual area to add to the heap. Must be aligned by ``page_sz``."]
    #[doc = " @param iova_addrs"]
    #[doc = "   Array of page IOVA addresses corresponding to each page in this memory"]
    #[doc = "   area. Can be NULL, in which case page IOVA addresses will be set to"]
    #[doc = "   RTE_BAD_IOVA."]
    #[doc = " @param n_pages"]
    #[doc = "   Number of elements in the iova_addrs array. Ignored if  ``iova_addrs``"]
    #[doc = "   is NULL."]
    #[doc = " @param page_sz"]
    #[doc = "   Page size of the underlying memory"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - -1 in case of error, with rte_errno set to one of the following:"]
    #[doc = "     EINVAL - one of the parameters was invalid"]
    #[doc = "     EPERM  - attempted to add memory to a reserved heap"]
    #[doc = "     ENOSPC - no more space in internal config to store a new memory chunk"]
    pub fn rte_malloc_heap_memory_add(
        heap_name: *const ::std::os::raw::c_char,
        va_addr: *mut ::std::os::raw::c_void,
        len: size_t,
        iova_addrs: *mut rte_iova_t,
        n_pages: ::std::os::raw::c_uint,
        page_sz: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove memory chunk from heap with specified name."]
    #[doc = ""]
    #[doc = " @note Memory chunk being removed must be the same as one that was added;"]
    #[doc = "   partially removing memory chunks is not supported"]
    #[doc = ""]
    #[doc = " @note Memory area must not contain any allocated elements to allow its"]
    #[doc = "   removal from the heap"]
    #[doc = ""]
    #[doc = " @note All other processes must detach from the memory chunk prior to it being"]
    #[doc = "   removed from the heap."]
    #[doc = ""]
    #[doc = " @param heap_name"]
    #[doc = "   Name of the heap to remove memory from"]
    #[doc = " @param va_addr"]
    #[doc = "   Virtual address to remove from the heap"]
    #[doc = " @param len"]
    #[doc = "   Length of virtual area to remove from the heap"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - -1 in case of error, with rte_errno set to one of the following:"]
    #[doc = "     EINVAL - one of the parameters was invalid"]
    #[doc = "     EPERM  - attempted to remove memory from a reserved heap"]
    #[doc = "     ENOENT - heap or memory chunk was not found"]
    #[doc = "     EBUSY  - memory chunk still contains data"]
    pub fn rte_malloc_heap_memory_remove(
        heap_name: *const ::std::os::raw::c_char,
        va_addr: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attach to an already existing chunk of external memory in another process."]
    #[doc = ""]
    #[doc = " @note This function must be called before any attempt is made to use an"]
    #[doc = "   already existing external memory chunk. This function does *not* need to"]
    #[doc = "   be called if a call to ``rte_malloc_heap_memory_add`` was made in the"]
    #[doc = "   current process."]
    #[doc = ""]
    #[doc = " @param heap_name"]
    #[doc = "   Heap name to which this chunk of memory belongs"]
    #[doc = " @param va_addr"]
    #[doc = "   Start address of memory chunk to attach to"]
    #[doc = " @param len"]
    #[doc = "   Length of memory chunk to attach to"]
    #[doc = " @return"]
    #[doc = "   0 on successful attach"]
    #[doc = "   -1 on unsuccessful attach, with rte_errno set to indicate cause for error:"]
    #[doc = "     EINVAL - one of the parameters was invalid"]
    #[doc = "     EPERM  - attempted to attach memory to a reserved heap"]
    #[doc = "     ENOENT - heap or memory chunk was not found"]
    pub fn rte_malloc_heap_memory_attach(
        heap_name: *const ::std::os::raw::c_char,
        va_addr: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Detach from a chunk of external memory in secondary process."]
    #[doc = ""]
    #[doc = " @note This function must be called in before any attempt is made to remove"]
    #[doc = "   external memory from the heap in another process. This function does *not*"]
    #[doc = "   need to be called if a call to ``rte_malloc_heap_memory_remove`` will be"]
    #[doc = "   called in current process."]
    #[doc = ""]
    #[doc = " @param heap_name"]
    #[doc = "   Heap name to which this chunk of memory belongs"]
    #[doc = " @param va_addr"]
    #[doc = "   Start address of memory chunk to attach to"]
    #[doc = " @param len"]
    #[doc = "   Length of memory chunk to attach to"]
    #[doc = " @return"]
    #[doc = "   0 on successful detach"]
    #[doc = "   -1 on unsuccessful detach, with rte_errno set to indicate cause for error:"]
    #[doc = "     EINVAL - one of the parameters was invalid"]
    #[doc = "     EPERM  - attempted to detach memory from a reserved heap"]
    #[doc = "     ENOENT - heap or memory chunk was not found"]
    pub fn rte_malloc_heap_memory_detach(
        heap_name: *const ::std::os::raw::c_char,
        va_addr: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new empty malloc heap with a specified name."]
    #[doc = ""]
    #[doc = " @note Heaps created via this call will automatically get assigned a unique"]
    #[doc = "   socket ID, which can be found using ``rte_malloc_heap_get_socket()``"]
    #[doc = ""]
    #[doc = " @param heap_name"]
    #[doc = "   Name of the heap to create."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on successful creation"]
    #[doc = "   - -1 in case of error, with rte_errno set to one of the following:"]
    #[doc = "     EINVAL - ``heap_name`` was NULL, empty or too long"]
    #[doc = "     EEXIST - heap by name of ``heap_name`` already exists"]
    #[doc = "     ENOSPC - no more space in internal config to store a new heap"]
    pub fn rte_malloc_heap_create(
        heap_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroys a previously created malloc heap with specified name."]
    #[doc = ""]
    #[doc = " @note This function will return a failure result if not all memory allocated"]
    #[doc = "   from the heap has been freed back to the heap"]
    #[doc = ""]
    #[doc = " @note This function will return a failure result if not all memory segments"]
    #[doc = "   were removed from the heap prior to its destruction"]
    #[doc = ""]
    #[doc = " @param heap_name"]
    #[doc = "   Name of the heap to create."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - -1 in case of error, with rte_errno set to one of the following:"]
    #[doc = "     EINVAL - ``heap_name`` was NULL, empty or too long"]
    #[doc = "     ENOENT - heap by the name of ``heap_name`` was not found"]
    #[doc = "     EPERM  - attempting to destroy reserved heap"]
    #[doc = "     EBUSY  - heap still contains data"]
    pub fn rte_malloc_heap_destroy(
        heap_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find socket ID corresponding to a named heap."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Heap name to find socket ID for"]
    #[doc = " @return"]
    #[doc = "   Socket ID in case of success (a non-negative number)"]
    #[doc = "   -1 in case of error, with rte_errno set to one of the following:"]
    #[doc = "     EINVAL - ``name`` was NULL"]
    #[doc = "     ENOENT - heap identified by the name ``name`` was not found"]
    pub fn rte_malloc_heap_get_socket(name: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if a given socket ID refers to externally allocated memory."]
    #[doc = ""]
    #[doc = " @note Passing SOCKET_ID_ANY will return 0."]
    #[doc = ""]
    #[doc = " @param socket_id"]
    #[doc = "   Socket ID to check"]
    #[doc = " @return"]
    #[doc = "   1 if socket ID refers to externally allocated memory"]
    #[doc = "   0 if socket ID refers to internal DPDK memory"]
    #[doc = "   -1 if socket ID is invalid"]
    pub fn rte_malloc_heap_socket_is_external(
        socket_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump statistics."]
    #[doc = ""]
    #[doc = " Dump for the specified type to a file. If the type argument is"]
    #[doc = " NULL, all memory types will be dumped."]
    #[doc = ""]
    #[doc = " @note This function is not thread-safe with respect to"]
    #[doc = "    ``rte_malloc_heap_create()``/``rte_malloc_heap_destroy()`` functions."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    #[doc = " @param type"]
    #[doc = "   A string identifying the type of objects to dump, or NULL"]
    #[doc = "   to dump all objects."]
    pub fn rte_malloc_dump_stats(f: *mut FILE, type_: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Dump contents of all malloc heaps to a file."]
    #[doc = ""]
    #[doc = " @note This function is not thread-safe with respect to"]
    #[doc = "    ``rte_malloc_heap_create()``/``rte_malloc_heap_destroy()`` functions."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_malloc_dump_heaps(f: *mut FILE);
}
extern "C" {
    #[doc = " Set the maximum amount of allocated memory for this type."]
    #[doc = ""]
    #[doc = " This is not yet implemented"]
    #[doc = ""]
    #[doc = " @param type"]
    #[doc = "   A string identifying the type of allocated objects."]
    #[doc = " @param max"]
    #[doc = "   The maximum amount of allocated bytes for this type."]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - (-1): Error."]
    pub fn rte_malloc_set_limit(
        type_: *const ::std::os::raw::c_char,
        max: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the IO address of a virtual address obtained through"]
    #[doc = " rte_malloc"]
    #[doc = ""]
    #[doc = " @param addr"]
    #[doc = "   Address obtained from a previous rte_malloc call"]
    #[doc = " @return"]
    #[doc = "   RTE_BAD_IOVA on error"]
    #[doc = "   otherwise return an address suitable for IO"]
    pub fn rte_malloc_virt2iova(addr: *const ::std::os::raw::c_void) -> rte_iova_t;
}
extern "C" {
    #[doc = " Function which returns a printable string describing a particular"]
    #[doc = " error code. For non-RTE-specific error codes, this function returns"]
    #[doc = " the value from the libc strerror function."]
    #[doc = ""]
    #[doc = " @param errnum"]
    #[doc = "   The error number to be looked up - generally the value of rte_errno"]
    #[doc = " @return"]
    #[doc = "   A pointer to a thread-local string containing the text describing"]
    #[doc = "   the error."]
    pub fn rte_strerror(errnum: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
pub const RTE_MIN_ERRNO: _bindgen_ty_12 = _bindgen_ty_12::RTE_MIN_ERRNO;
pub const E_RTE_SECONDARY: _bindgen_ty_12 = _bindgen_ty_12::E_RTE_SECONDARY;
pub const E_RTE_NO_CONFIG: _bindgen_ty_12 = _bindgen_ty_12::E_RTE_NO_CONFIG;
pub const RTE_MAX_ERRNO: _bindgen_ty_12 = _bindgen_ty_12::RTE_MAX_ERRNO;
#[repr(u32)]
#[doc = " Error types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_12 {
    #[doc = "< Start numbering above std errno vals"]
    RTE_MIN_ERRNO = 1000,
    #[doc = "< Operation not allowed in secondary processes"]
    E_RTE_SECONDARY = 1001,
    #[doc = "< Missing rte_config"]
    E_RTE_NO_CONFIG = 1002,
    #[doc = "< Max RTE error number"]
    RTE_MAX_ERRNO = 1003,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_acl_field_types {
    pub u8_: u8,
    pub u16_: u16,
    pub u32_: u32,
    pub u64_: u64,
}
pub const RTE_ACL_FIELD_TYPE_MASK: _bindgen_ty_13 = _bindgen_ty_13::RTE_ACL_FIELD_TYPE_MASK;
pub const RTE_ACL_FIELD_TYPE_RANGE: _bindgen_ty_13 = _bindgen_ty_13::RTE_ACL_FIELD_TYPE_RANGE;
pub const RTE_ACL_FIELD_TYPE_BITMASK: _bindgen_ty_13 = _bindgen_ty_13::RTE_ACL_FIELD_TYPE_BITMASK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_13 {
    RTE_ACL_FIELD_TYPE_MASK = 0,
    RTE_ACL_FIELD_TYPE_RANGE = 1,
    RTE_ACL_FIELD_TYPE_BITMASK = 2,
}
#[doc = " ACL Field definition."]
#[doc = " Each field in the ACL rule has an associate definition."]
#[doc = " It defines the type of field, its size, its offset in the input buffer,"]
#[doc = " the field index, and the input index."]
#[doc = " For performance reasons, the inner loop of the search function is unrolled"]
#[doc = " to process four input bytes at a time. This requires the input to be grouped"]
#[doc = " into sets of 4 consecutive bytes. The loop processes the first input byte as"]
#[doc = " part of the setup and then subsequent bytes must be in groups of 4"]
#[doc = " consecutive bytes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_acl_field_def {
    #[doc = "< type - RTE_ACL_FIELD_TYPE_*."]
    pub type_: u8,
    #[doc = "< size of field 1,2,4, or 8."]
    pub size: u8,
    #[doc = "< index of field inside the rule."]
    pub field_index: u8,
    #[doc = "< 0-N input index."]
    pub input_index: u8,
    #[doc = "< offset to start of field."]
    pub offset: u32,
}
#[doc = " ACL build configuration."]
#[doc = " Defines the fields of an ACL trie and number of categories to build with."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_acl_config {
    #[doc = "< Number of categories to build with."]
    pub num_categories: u32,
    #[doc = "< Number of field definitions."]
    pub num_fields: u32,
    pub defs: [rte_acl_field_def; 64usize],
    pub max_size: size_t,
}
#[doc = " Defines the value of a field for a rule."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_acl_field {
    pub value: rte_acl_field_types,
    pub mask_range: rte_acl_field_types,
}
pub const RTE_ACL_TYPE_SHIFT: _bindgen_ty_14 = _bindgen_ty_14::RTE_ACL_TYPE_SHIFT;
pub const RTE_ACL_MAX_INDEX: _bindgen_ty_14 = _bindgen_ty_14::RTE_ACL_MAX_INDEX;
pub const RTE_ACL_MAX_PRIORITY: _bindgen_ty_14 = _bindgen_ty_14::RTE_ACL_MAX_INDEX;
pub const RTE_ACL_MIN_PRIORITY: _bindgen_ty_14 = _bindgen_ty_14::RTE_ACL_MIN_PRIORITY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_14 {
    RTE_ACL_TYPE_SHIFT = 29,
    RTE_ACL_MAX_INDEX = 536870911,
    RTE_ACL_MIN_PRIORITY = 1,
}
#[doc = " Miscellaneous data for ACL rule."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_acl_rule_data {
    #[doc = "< Mask of categories for that rule."]
    pub category_mask: u32,
    #[doc = "< Priority for that rule."]
    pub priority: i32,
    #[doc = "< Associated with the rule user data."]
    pub userdata: u32,
}
#[repr(C)]
pub struct rte_acl_rule {
    pub data: rte_acl_rule_data,
    pub field: __IncompleteArrayField<rte_acl_field>,
}
#[doc = " Parameters used when creating the ACL context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_acl_param {
    #[doc = "< Name of the ACL context."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Socket ID to allocate memory for."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< Size of each rule."]
    pub rule_size: u32,
    #[doc = "< Maximum number of rules."]
    pub max_rule_num: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_acl_ctx {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a new ACL context."]
    #[doc = ""]
    #[doc = " @param param"]
    #[doc = "   Parameters used to create and initialise the ACL context."]
    #[doc = " @return"]
    #[doc = "   Pointer to ACL context structure that is used in future ACL"]
    #[doc = "   operations, or NULL on error, with error code set in rte_errno."]
    #[doc = "   Possible rte_errno errors include:"]
    #[doc = "   - EINVAL - invalid parameter passed to function"]
    pub fn rte_acl_create(param: *const rte_acl_param) -> *mut rte_acl_ctx;
}
extern "C" {
    #[doc = " Find an existing ACL context object and return a pointer to it."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Name of the ACL context as passed to rte_acl_create()"]
    #[doc = " @return"]
    #[doc = "   Pointer to ACL context or NULL if object not found"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - ENOENT - value not available for return"]
    pub fn rte_acl_find_existing(name: *const ::std::os::raw::c_char) -> *mut rte_acl_ctx;
}
extern "C" {
    #[doc = " De-allocate all memory used by ACL context."]
    #[doc = ""]
    #[doc = " @param ctx"]
    #[doc = "   ACL context to free"]
    pub fn rte_acl_free(ctx: *mut rte_acl_ctx);
}
extern "C" {
    #[doc = " Add rules to an existing ACL context."]
    #[doc = " This function is not multi-thread safe."]
    #[doc = ""]
    #[doc = " @param ctx"]
    #[doc = "   ACL context to add patterns to."]
    #[doc = " @param rules"]
    #[doc = "   Array of rules to add to the ACL context."]
    #[doc = "   Note that all fields in rte_acl_rule structures are expected"]
    #[doc = "   to be in host byte order."]
    #[doc = "   Each rule expected to be in the same format and not exceed size"]
    #[doc = "   specified at ACL context creation time."]
    #[doc = " @param num"]
    #[doc = "   Number of elements in the input array of rules."]
    #[doc = " @return"]
    #[doc = "   - -ENOMEM if there is no space in the ACL context for these rules."]
    #[doc = "   - -EINVAL if the parameters are invalid."]
    #[doc = "   - Zero if operation completed successfully."]
    pub fn rte_acl_add_rules(
        ctx: *mut rte_acl_ctx,
        rules: *const rte_acl_rule,
        num: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete all rules from the ACL context."]
    #[doc = " This function is not multi-thread safe."]
    #[doc = " Note that internal run-time structures are not affected."]
    #[doc = ""]
    #[doc = " @param ctx"]
    #[doc = "   ACL context to delete rules from."]
    pub fn rte_acl_reset_rules(ctx: *mut rte_acl_ctx);
}
extern "C" {
    #[doc = " Analyze set of rules and build required internal run-time structures."]
    #[doc = " This function is not multi-thread safe."]
    #[doc = ""]
    #[doc = " @param ctx"]
    #[doc = "   ACL context to build."]
    #[doc = " @param cfg"]
    #[doc = "   Pointer to struct rte_acl_config - defines build parameters."]
    #[doc = " @return"]
    #[doc = "   - -ENOMEM if couldn't allocate enough memory."]
    #[doc = "   - -EINVAL if the parameters are invalid."]
    #[doc = "   - Negative error code if operation failed."]
    #[doc = "   - Zero if operation completed successfully."]
    pub fn rte_acl_build(
        ctx: *mut rte_acl_ctx,
        cfg: *const rte_acl_config,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete all rules from the ACL context and"]
    #[doc = " destroy all internal run-time structures."]
    #[doc = " This function is not multi-thread safe."]
    #[doc = ""]
    #[doc = " @param ctx"]
    #[doc = "   ACL context to reset."]
    pub fn rte_acl_reset(ctx: *mut rte_acl_ctx);
}
#[repr(u32)]
#[doc = "  Available implementations of ACL classify."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_acl_classify_alg {
    RTE_ACL_CLASSIFY_DEFAULT = 0,
    #[doc = "< generic implementation."]
    RTE_ACL_CLASSIFY_SCALAR = 1,
    #[doc = "< requires SSE4.1 support."]
    RTE_ACL_CLASSIFY_SSE = 2,
    #[doc = "< requires AVX2 support."]
    RTE_ACL_CLASSIFY_AVX2 = 3,
    #[doc = "< requires NEON support."]
    RTE_ACL_CLASSIFY_NEON = 4,
    #[doc = "< requires ALTIVEC support."]
    RTE_ACL_CLASSIFY_ALTIVEC = 5,
    #[doc = "< requires AVX512 support."]
    RTE_ACL_CLASSIFY_AVX512X16 = 6,
    #[doc = "< requires AVX512 support."]
    RTE_ACL_CLASSIFY_AVX512X32 = 7,
}
extern "C" {
    #[doc = " Perform search for a matching ACL rule for each input data buffer."]
    #[doc = " Each input data buffer can have up to *categories* matches."]
    #[doc = " That implies that results array should be big enough to hold"]
    #[doc = " (categories * num) elements."]
    #[doc = " Also categories parameter should be either one or multiple of"]
    #[doc = " RTE_ACL_RESULTS_MULTIPLIER and can't be bigger than RTE_ACL_MAX_CATEGORIES."]
    #[doc = " If more than one rule is applicable for given input buffer and"]
    #[doc = " given category, then rule with highest priority will be returned as a match."]
    #[doc = " Note, that it is a caller's responsibility to ensure that input parameters"]
    #[doc = " are valid and point to correct memory locations."]
    #[doc = ""]
    #[doc = " @param ctx"]
    #[doc = "   ACL context to search with."]
    #[doc = " @param data"]
    #[doc = "   Array of pointers to input data buffers to perform search."]
    #[doc = "   Note that all fields in input data buffers supposed to be in network"]
    #[doc = "   byte order (MSB)."]
    #[doc = " @param results"]
    #[doc = "   Array of search results, *categories* results per each input data buffer."]
    #[doc = " @param num"]
    #[doc = "   Number of elements in the input data buffers array."]
    #[doc = " @param categories"]
    #[doc = "   Number of maximum possible matches for each input buffer, one possible"]
    #[doc = "   match per category."]
    #[doc = " @return"]
    #[doc = "   zero on successful completion."]
    #[doc = "   -EINVAL for incorrect arguments."]
    pub fn rte_acl_classify(
        ctx: *const rte_acl_ctx,
        data: *mut *const u8,
        results: *mut u32,
        num: u32,
        categories: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Perform search using specified algorithm for a matching ACL rule for"]
    #[doc = " each input data buffer."]
    #[doc = " Each input data buffer can have up to *categories* matches."]
    #[doc = " That implies that results array should be big enough to hold"]
    #[doc = " (categories * num) elements."]
    #[doc = " Also categories parameter should be either one or multiple of"]
    #[doc = " RTE_ACL_RESULTS_MULTIPLIER and can't be bigger than RTE_ACL_MAX_CATEGORIES."]
    #[doc = " If more than one rule is applicable for given input buffer and"]
    #[doc = " given category, then rule with highest priority will be returned as a match."]
    #[doc = " Note, that it is a caller's responsibility to ensure that input parameters"]
    #[doc = " are valid and point to correct memory locations."]
    #[doc = ""]
    #[doc = " @param ctx"]
    #[doc = "   ACL context to search with."]
    #[doc = " @param data"]
    #[doc = "   Array of pointers to input data buffers to perform search."]
    #[doc = "   Note that all fields in input data buffers supposed to be in network"]
    #[doc = "   byte order (MSB)."]
    #[doc = " @param results"]
    #[doc = "   Array of search results, *categories* results per each input data buffer."]
    #[doc = " @param num"]
    #[doc = "   Number of elements in the input data buffers array."]
    #[doc = " @param categories"]
    #[doc = "   Number of maximum possible matches for each input buffer, one possible"]
    #[doc = "   match per category."]
    #[doc = " @param alg"]
    #[doc = "   Algorithm to be used for the search."]
    #[doc = "   It is the caller responsibility to ensure that the value refers to the"]
    #[doc = "   existing algorithm, and that it could be run on the given CPU."]
    #[doc = " @return"]
    #[doc = "   zero on successful completion."]
    #[doc = "   -EINVAL for incorrect arguments."]
    pub fn rte_acl_classify_alg(
        ctx: *const rte_acl_ctx,
        data: *mut *const u8,
        results: *mut u32,
        num: u32,
        categories: u32,
        alg: rte_acl_classify_alg,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_acl_set_ctx_classify(
        ctx: *mut rte_acl_ctx,
        alg: rte_acl_classify_alg,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump an ACL context structure to the console."]
    #[doc = ""]
    #[doc = " @param ctx"]
    #[doc = "   ACL context to dump."]
    pub fn rte_acl_dump(ctx: *const rte_acl_ctx);
}
extern "C" {
    #[doc = " Dump all ACL context structures to the console."]
    pub fn rte_acl_list_dump();
}
#[doc = " Signature of callback back function called when an alarm goes off."]
pub type rte_eal_alarm_callback =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Function to set a callback to be triggered when us microseconds"]
    #[doc = " have expired. Accuracy of timing to the microsecond is not guaranteed. The"]
    #[doc = " alarm function will not be called *before* the requested time, but may"]
    #[doc = " be called a short period of time afterwards."]
    #[doc = " The alarm handler will be called only once. There is no need to call"]
    #[doc = " \"rte_eal_alarm_cancel\" from within the callback function."]
    #[doc = ""]
    #[doc = " @param us"]
    #[doc = "   The time in microseconds before the callback is called"]
    #[doc = " @param cb"]
    #[doc = "   The function to be called when the alarm expires"]
    #[doc = " @param cb_arg"]
    #[doc = "   Pointer parameter to be passed to the callback function"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   On success, zero."]
    #[doc = "   On failure, a negative error number"]
    pub fn rte_eal_alarm_set(
        us: u64,
        cb: rte_eal_alarm_callback,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function to cancel an alarm callback which has been registered before. If"]
    #[doc = " used outside alarm callback it wait for all callbacks to finish execution."]
    #[doc = ""]
    #[doc = " @param cb_fn"]
    #[doc = "  alarm callback"]
    #[doc = " @param cb_arg"]
    #[doc = "  Pointer parameter to be passed to the callback function. To remove all"]
    #[doc = "  copies of a given callback function, irrespective of parameter, (void *)-1"]
    #[doc = "  can be used here."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - value greater than 0 and rte_errno not changed - returned value is"]
    #[doc = "      the number of canceled alarm callback functions"]
    #[doc = "    - value greater or equal 0 and rte_errno set to EINPROGRESS, at least one"]
    #[doc = "      alarm could not be canceled because cancellation was requested from alarm"]
    #[doc = "      callback context. Returned value is the number of successfully canceled"]
    #[doc = "      alarm callbacks"]
    #[doc = "    -  0 and rte_errno set to ENOENT - no alarm found"]
    #[doc = "    - -1 and rte_errno set to EINVAL - invalid parameter (NULL callback)"]
    pub fn rte_eal_alarm_cancel(
        cb_fn: rte_eal_alarm_callback,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find best rational approximation"]
    #[doc = ""]
    #[doc = " @param alpha"]
    #[doc = "   Rational number to approximate"]
    #[doc = " @param d"]
    #[doc = "   Precision for the rational approximation"]
    #[doc = " @param p"]
    #[doc = "   Pointer to pre-allocated space where the numerator of the rational"]
    #[doc = "   approximation will be stored when operation is successful"]
    #[doc = " @param q"]
    #[doc = "   Pointer to pre-allocated space where the denominator of the rational"]
    #[doc = "   approximation will be stored when operation is successful"]
    #[doc = " @return"]
    #[doc = "   0 upon success, error code otherwise"]
    pub fn rte_approx(alpha: f64, d: f64, p: *mut u32, q: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find best rational approximation (64 bit version)"]
    #[doc = ""]
    #[doc = " @param alpha"]
    #[doc = "   Rational number to approximate"]
    #[doc = " @param d"]
    #[doc = "   Precision for the rational approximation"]
    #[doc = " @param p"]
    #[doc = "   Pointer to pre-allocated space where the numerator of the rational"]
    #[doc = "   approximation will be stored when operation is successful"]
    #[doc = " @param q"]
    #[doc = "   Pointer to pre-allocated space where the denominator of the rational"]
    #[doc = "   approximation will be stored when operation is successful"]
    #[doc = " @return"]
    #[doc = "   0 upon success, error code otherwise"]
    pub fn rte_approx_64(alpha: f64, d: f64, p: *mut u64, q: *mut u64) -> ::std::os::raw::c_int;
}
#[doc = " A structure describing a memzone, which is a contiguous portion of"]
#[doc = " physical memory identified by a name."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memzone {
    #[doc = "< Name of the memory zone."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Start IO address."]
    pub iova: rte_iova_t,
    pub __bindgen_anon_1: rte_memzone__bindgen_ty_1,
    #[doc = "< Length of the memzone."]
    pub len: size_t,
    #[doc = "< The page size of underlying memory"]
    pub hugepage_sz: u64,
    #[doc = "< NUMA socket ID."]
    pub socket_id: i32,
    #[doc = "< Characteristics of this memzone."]
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memzone__bindgen_ty_1 {
    #[doc = "< Start virtual address."]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< Makes sure addr is always 64-bits"]
    pub addr_64: u64,
}
extern "C" {
    #[doc = " Reserve a portion of physical memory."]
    #[doc = ""]
    #[doc = " This function reserves some memory and returns a pointer to a"]
    #[doc = " correctly filled memzone descriptor. If the allocation cannot be"]
    #[doc = " done, return NULL."]
    #[doc = ""]
    #[doc = " @note Reserving memzones with len set to 0 will only attempt to allocate"]
    #[doc = "   memzones from memory that is already available. It will not trigger any"]
    #[doc = "   new allocations."]
    #[doc = ""]
    #[doc = " @note: When reserving memzones with len set to 0, it is preferable to also"]
    #[doc = "   set a valid socket_id. Setting socket_id to SOCKET_ID_ANY is supported, but"]
    #[doc = "   will likely not yield expected results. Specifically, the resulting memzone"]
    #[doc = "   may not necessarily be the biggest memzone available, but rather biggest"]
    #[doc = "   memzone available on socket id corresponding to an lcore from which"]
    #[doc = "   reservation was called."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the memzone. If it already exists, the function will"]
    #[doc = "   fail and return NULL."]
    #[doc = " @param len"]
    #[doc = "   The size of the memory to be reserved. If it"]
    #[doc = "   is 0, the biggest contiguous zone will be reserved."]
    #[doc = " @param socket_id"]
    #[doc = "   The socket identifier in the case of"]
    #[doc = "   NUMA. The value can be SOCKET_ID_ANY if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   The flags parameter is used to request memzones to be"]
    #[doc = "   taken from specifically sized hugepages."]
    #[doc = "   - RTE_MEMZONE_2MB - Reserved from 2MB pages"]
    #[doc = "   - RTE_MEMZONE_1GB - Reserved from 1GB pages"]
    #[doc = "   - RTE_MEMZONE_16MB - Reserved from 16MB pages"]
    #[doc = "   - RTE_MEMZONE_16GB - Reserved from 16GB pages"]
    #[doc = "   - RTE_MEMZONE_256KB - Reserved from 256KB pages"]
    #[doc = "   - RTE_MEMZONE_256MB - Reserved from 256MB pages"]
    #[doc = "   - RTE_MEMZONE_512MB - Reserved from 512MB pages"]
    #[doc = "   - RTE_MEMZONE_4GB - Reserved from 4GB pages"]
    #[doc = "   - RTE_MEMZONE_SIZE_HINT_ONLY - Allow alternative page size to be used if"]
    #[doc = "                                  the requested page size is unavailable."]
    #[doc = "                                  If this flag is not set, the function"]
    #[doc = "                                  will return error on an unavailable size"]
    #[doc = "                                  request."]
    #[doc = "   - RTE_MEMZONE_IOVA_CONTIG - Ensure reserved memzone is IOVA-contiguous."]
    #[doc = "                               This option should be used when allocating"]
    #[doc = "                               memory intended for hardware rings etc."]
    #[doc = " @return"]
    #[doc = "   A pointer to a correctly-filled read-only memzone descriptor, or NULL"]
    #[doc = "   on error."]
    #[doc = "   On error case, rte_errno will be set appropriately:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    #[doc = "    - EINVAL - invalid parameters"]
    pub fn rte_memzone_reserve(
        name: *const ::std::os::raw::c_char,
        len: size_t,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
extern "C" {
    #[doc = " Reserve a portion of physical memory with alignment on a specified"]
    #[doc = " boundary."]
    #[doc = ""]
    #[doc = " This function reserves some memory with alignment on a specified"]
    #[doc = " boundary, and returns a pointer to a correctly filled memzone"]
    #[doc = " descriptor. If the allocation cannot be done or if the alignment"]
    #[doc = " is not a power of 2, returns NULL."]
    #[doc = ""]
    #[doc = " @note Reserving memzones with len set to 0 will only attempt to allocate"]
    #[doc = "   memzones from memory that is already available. It will not trigger any"]
    #[doc = "   new allocations."]
    #[doc = ""]
    #[doc = " @note: When reserving memzones with len set to 0, it is preferable to also"]
    #[doc = "   set a valid socket_id. Setting socket_id to SOCKET_ID_ANY is supported, but"]
    #[doc = "   will likely not yield expected results. Specifically, the resulting memzone"]
    #[doc = "   may not necessarily be the biggest memzone available, but rather biggest"]
    #[doc = "   memzone available on socket id corresponding to an lcore from which"]
    #[doc = "   reservation was called."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the memzone. If it already exists, the function will"]
    #[doc = "   fail and return NULL."]
    #[doc = " @param len"]
    #[doc = "   The size of the memory to be reserved. If it"]
    #[doc = "   is 0, the biggest contiguous zone will be reserved."]
    #[doc = " @param socket_id"]
    #[doc = "   The socket identifier in the case of"]
    #[doc = "   NUMA. The value can be SOCKET_ID_ANY if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   The flags parameter is used to request memzones to be"]
    #[doc = "   taken from specifically sized hugepages."]
    #[doc = "   - RTE_MEMZONE_2MB - Reserved from 2MB pages"]
    #[doc = "   - RTE_MEMZONE_1GB - Reserved from 1GB pages"]
    #[doc = "   - RTE_MEMZONE_16MB - Reserved from 16MB pages"]
    #[doc = "   - RTE_MEMZONE_16GB - Reserved from 16GB pages"]
    #[doc = "   - RTE_MEMZONE_256KB - Reserved from 256KB pages"]
    #[doc = "   - RTE_MEMZONE_256MB - Reserved from 256MB pages"]
    #[doc = "   - RTE_MEMZONE_512MB - Reserved from 512MB pages"]
    #[doc = "   - RTE_MEMZONE_4GB - Reserved from 4GB pages"]
    #[doc = "   - RTE_MEMZONE_SIZE_HINT_ONLY - Allow alternative page size to be used if"]
    #[doc = "                                  the requested page size is unavailable."]
    #[doc = "                                  If this flag is not set, the function"]
    #[doc = "                                  will return error on an unavailable size"]
    #[doc = "                                  request."]
    #[doc = "   - RTE_MEMZONE_IOVA_CONTIG - Ensure reserved memzone is IOVA-contiguous."]
    #[doc = "                               This option should be used when allocating"]
    #[doc = "                               memory intended for hardware rings etc."]
    #[doc = " @param align"]
    #[doc = "   Alignment for resulting memzone. Must be a power of 2."]
    #[doc = " @return"]
    #[doc = "   A pointer to a correctly-filled read-only memzone descriptor, or NULL"]
    #[doc = "   on error."]
    #[doc = "   On error case, rte_errno will be set appropriately:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    #[doc = "    - EINVAL - invalid parameters"]
    pub fn rte_memzone_reserve_aligned(
        name: *const ::std::os::raw::c_char,
        len: size_t,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
extern "C" {
    #[doc = " Reserve a portion of physical memory with specified alignment and"]
    #[doc = " boundary."]
    #[doc = ""]
    #[doc = " This function reserves some memory with specified alignment and"]
    #[doc = " boundary, and returns a pointer to a correctly filled memzone"]
    #[doc = " descriptor. If the allocation cannot be done or if the alignment"]
    #[doc = " or boundary are not a power of 2, returns NULL."]
    #[doc = " Memory buffer is reserved in a way, that it wouldn't cross specified"]
    #[doc = " boundary. That implies that requested length should be less or equal"]
    #[doc = " then boundary."]
    #[doc = ""]
    #[doc = " @note Reserving memzones with len set to 0 will only attempt to allocate"]
    #[doc = "   memzones from memory that is already available. It will not trigger any"]
    #[doc = "   new allocations."]
    #[doc = ""]
    #[doc = " @note: When reserving memzones with len set to 0, it is preferable to also"]
    #[doc = "   set a valid socket_id. Setting socket_id to SOCKET_ID_ANY is supported, but"]
    #[doc = "   will likely not yield expected results. Specifically, the resulting memzone"]
    #[doc = "   may not necessarily be the biggest memzone available, but rather biggest"]
    #[doc = "   memzone available on socket id corresponding to an lcore from which"]
    #[doc = "   reservation was called."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the memzone. If it already exists, the function will"]
    #[doc = "   fail and return NULL."]
    #[doc = " @param len"]
    #[doc = "   The size of the memory to be reserved. If it"]
    #[doc = "   is 0, the biggest contiguous zone will be reserved."]
    #[doc = " @param socket_id"]
    #[doc = "   The socket identifier in the case of"]
    #[doc = "   NUMA. The value can be SOCKET_ID_ANY if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   The flags parameter is used to request memzones to be"]
    #[doc = "   taken from specifically sized hugepages."]
    #[doc = "   - RTE_MEMZONE_2MB - Reserved from 2MB pages"]
    #[doc = "   - RTE_MEMZONE_1GB - Reserved from 1GB pages"]
    #[doc = "   - RTE_MEMZONE_16MB - Reserved from 16MB pages"]
    #[doc = "   - RTE_MEMZONE_16GB - Reserved from 16GB pages"]
    #[doc = "   - RTE_MEMZONE_256KB - Reserved from 256KB pages"]
    #[doc = "   - RTE_MEMZONE_256MB - Reserved from 256MB pages"]
    #[doc = "   - RTE_MEMZONE_512MB - Reserved from 512MB pages"]
    #[doc = "   - RTE_MEMZONE_4GB - Reserved from 4GB pages"]
    #[doc = "   - RTE_MEMZONE_SIZE_HINT_ONLY - Allow alternative page size to be used if"]
    #[doc = "                                  the requested page size is unavailable."]
    #[doc = "                                  If this flag is not set, the function"]
    #[doc = "                                  will return error on an unavailable size"]
    #[doc = "                                  request."]
    #[doc = "   - RTE_MEMZONE_IOVA_CONTIG - Ensure reserved memzone is IOVA-contiguous."]
    #[doc = "                               This option should be used when allocating"]
    #[doc = "                               memory intended for hardware rings etc."]
    #[doc = " @param align"]
    #[doc = "   Alignment for resulting memzone. Must be a power of 2."]
    #[doc = " @param bound"]
    #[doc = "   Boundary for resulting memzone. Must be a power of 2 or zero."]
    #[doc = "   Zero value implies no boundary condition."]
    #[doc = " @return"]
    #[doc = "   A pointer to a correctly-filled read-only memzone descriptor, or NULL"]
    #[doc = "   on error."]
    #[doc = "   On error case, rte_errno will be set appropriately:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    #[doc = "    - EINVAL - invalid parameters"]
    pub fn rte_memzone_reserve_bounded(
        name: *const ::std::os::raw::c_char,
        len: size_t,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
        bound: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
extern "C" {
    #[doc = " Free a memzone."]
    #[doc = ""]
    #[doc = " @param mz"]
    #[doc = "   A pointer to the memzone"]
    #[doc = " @return"]
    #[doc = "  -EINVAL - invalid parameter."]
    #[doc = "  0 - success"]
    pub fn rte_memzone_free(mz: *const rte_memzone) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Lookup for a memzone."]
    #[doc = ""]
    #[doc = " Get a pointer to a descriptor of an already reserved memory"]
    #[doc = " zone identified by the name given as an argument."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the memzone."]
    #[doc = " @return"]
    #[doc = "   A pointer to a read-only memzone descriptor."]
    pub fn rte_memzone_lookup(name: *const ::std::os::raw::c_char) -> *const rte_memzone;
}
extern "C" {
    #[doc = " Dump all reserved memzones to a file."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_memzone_dump(f: *mut FILE);
}
extern "C" {
    #[doc = " Walk list of all memzones"]
    #[doc = ""]
    #[doc = " @param func"]
    #[doc = "   Iterator function"]
    #[doc = " @param arg"]
    #[doc = "   Argument passed to iterator"]
    pub fn rte_memzone_walk(
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const rte_memzone, arg: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
#[repr(u32)]
#[doc = " enqueue/dequeue behavior types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_ring_queue_behavior {
    #[doc = " Enq/Deq a fixed number of items from a ring"]
    RTE_RING_QUEUE_FIXED = 0,
    #[doc = " Enq/Deq as many items as possible from ring"]
    RTE_RING_QUEUE_VARIABLE = 1,
}
#[repr(u32)]
#[doc = " prod/cons sync types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_ring_sync_type {
    #[doc = "< multi-thread safe (default mode)"]
    RTE_RING_SYNC_MT = 0,
    #[doc = "< single thread only"]
    RTE_RING_SYNC_ST = 1,
    #[doc = "< multi-thread relaxed tail sync"]
    RTE_RING_SYNC_MT_RTS = 2,
    #[doc = "< multi-thread head/tail sync"]
    RTE_RING_SYNC_MT_HTS = 3,
}
#[doc = " structures to hold a pair of head/tail values and other metadata."]
#[doc = " Depending on sync_type format of that structure might be different,"]
#[doc = " but offset for *sync_type* and *tail* values should remain the same."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_headtail {
    #[doc = "< prod/consumer head."]
    pub head: u32,
    #[doc = "< prod/consumer tail."]
    pub tail: u32,
    pub __bindgen_anon_1: rte_ring_headtail__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_ring_headtail__bindgen_ty_1 {
    #[doc = " sync type of prod/cons"]
    pub sync_type: rte_ring_sync_type,
    #[doc = " deprecated -  True if single prod/cons"]
    pub single: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __rte_ring_rts_poscnt {
    #[doc = " raw 8B value to read/write *cnt* and *pos* as one atomic op"]
    pub raw: u64,
    pub val: __rte_ring_rts_poscnt__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __rte_ring_rts_poscnt__bindgen_ty_1 {
    #[doc = "< head/tail reference counter"]
    pub cnt: u32,
    #[doc = "< head/tail position"]
    pub pos: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_rts_headtail {
    pub tail: __rte_ring_rts_poscnt,
    #[doc = "< sync type of prod/cons"]
    pub sync_type: rte_ring_sync_type,
    #[doc = "< max allowed distance between head/tail"]
    pub htd_max: u32,
    pub head: __rte_ring_rts_poscnt,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __rte_ring_hts_pos {
    #[doc = " raw 8B value to read/write *head* and *tail* as one atomic op"]
    pub raw: u64,
    pub pos: __rte_ring_hts_pos__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __rte_ring_hts_pos__bindgen_ty_1 {
    #[doc = "< head position"]
    pub head: u32,
    #[doc = "< tail position"]
    pub tail: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_hts_headtail {
    pub ht: __rte_ring_hts_pos,
    #[doc = "< sync type of prod/cons"]
    pub sync_type: rte_ring_sync_type,
}
#[doc = " An RTE ring structure."]
#[doc = ""]
#[doc = " The producer and the consumer have a head and a tail index. The particularity"]
#[doc = " of these index is that they are not between 0 and size(ring). These indexes"]
#[doc = " are between 0 and 2^32, and we mask their value when we access the ring[]"]
#[doc = " field. Thanks to this assumption, we can do subtractions between 2 index"]
#[doc = " values in a modulo-32bit base: that's why the overflow of the indexes is not"]
#[doc = " a problem."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_ring {
    pub name: [::std::os::raw::c_char; 29usize],
    #[doc = "< Flags supplied at creation."]
    pub flags: ::std::os::raw::c_int,
    pub memzone: *const rte_memzone,
    #[doc = "< Size of ring."]
    pub size: u32,
    #[doc = "< Mask (size-1) of ring."]
    pub mask: u32,
    #[doc = "< Usable size of ring"]
    pub capacity: u32,
    pub __bindgen_padding_0: [u8; 4usize],
    #[doc = "< empty cache line"]
    pub pad0: ::std::os::raw::c_char,
    pub __bindgen_padding_1: [u64; 7usize],
    pub __bindgen_anon_1: rte_ring__bindgen_ty_1,
    #[doc = "< empty cache line"]
    pub pad1: ::std::os::raw::c_char,
    pub __bindgen_padding_2: [u64; 7usize],
    pub __bindgen_anon_2: rte_ring__bindgen_ty_2,
    #[doc = "< empty cache line"]
    pub pad2: ::std::os::raw::c_char,
}
#[doc = " Ring producer status."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub union rte_ring__bindgen_ty_1 {
    pub prod: rte_ring_headtail,
    pub hts_prod: rte_ring_hts_headtail,
    pub rts_prod: rte_ring_rts_headtail,
}
#[doc = " Ring consumer status."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub union rte_ring__bindgen_ty_2 {
    pub cons: rte_ring_headtail,
    pub hts_cons: rte_ring_hts_headtail,
    pub rts_cons: rte_ring_rts_headtail,
}
extern "C" {
    #[doc = " Calculate the memory size needed for a ring with given element size"]
    #[doc = ""]
    #[doc = " This function returns the number of bytes needed for a ring, given"]
    #[doc = " the number of elements in it and the size of the element. This value"]
    #[doc = " is the sum of the size of the structure rte_ring and the size of the"]
    #[doc = " memory needed for storing the elements. The value is aligned to a cache"]
    #[doc = " line size."]
    #[doc = ""]
    #[doc = " @param esize"]
    #[doc = "   The size of ring element, in bytes. It must be a multiple of 4."]
    #[doc = " @param count"]
    #[doc = "   The number of elements in the ring (must be a power of 2)."]
    #[doc = " @return"]
    #[doc = "   - The memory size needed for the ring on success."]
    #[doc = "   - -EINVAL - esize is not a multiple of 4 or count provided is not a"]
    #[doc = "\t\t power of 2."]
    pub fn rte_ring_get_memsize_elem(
        esize: ::std::os::raw::c_uint,
        count: ::std::os::raw::c_uint,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " Create a new ring named *name* that stores elements with given size."]
    #[doc = ""]
    #[doc = " This function uses ``memzone_reserve()`` to allocate memory. Then it"]
    #[doc = " calls rte_ring_init() to initialize an empty ring."]
    #[doc = ""]
    #[doc = " The new ring size is set to *count*, which must be a power of"]
    #[doc = " two. Water marking is disabled by default. The real usable ring size"]
    #[doc = " is *count-1* instead of *count* to differentiate a full ring from an"]
    #[doc = " empty ring."]
    #[doc = ""]
    #[doc = " The ring is added in RTE_TAILQ_RING list."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the ring."]
    #[doc = " @param esize"]
    #[doc = "   The size of ring element, in bytes. It must be a multiple of 4."]
    #[doc = " @param count"]
    #[doc = "   The number of elements in the ring (must be a power of 2)."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in case of"]
    #[doc = "   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   An OR of the following:"]
    #[doc = "   - One of mutually exclusive flags that define producer behavior:"]
    #[doc = "      - RING_F_SP_ENQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``"]
    #[doc = "        is \"single-producer\"."]
    #[doc = "      - RING_F_MP_RTS_ENQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``"]
    #[doc = "        is \"multi-producer RTS mode\"."]
    #[doc = "      - RING_F_MP_HTS_ENQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``"]
    #[doc = "        is \"multi-producer HTS mode\"."]
    #[doc = "     If none of these flags is set, then default \"multi-producer\""]
    #[doc = "     behavior is selected."]
    #[doc = "   - One of mutually exclusive flags that define consumer behavior:"]
    #[doc = "      - RING_F_SC_DEQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``"]
    #[doc = "        is \"single-consumer\". Otherwise, it is \"multi-consumers\"."]
    #[doc = "      - RING_F_MC_RTS_DEQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``"]
    #[doc = "        is \"multi-consumer RTS mode\"."]
    #[doc = "      - RING_F_MC_HTS_DEQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``"]
    #[doc = "        is \"multi-consumer HTS mode\"."]
    #[doc = "     If none of these flags is set, then default \"multi-consumer\""]
    #[doc = "     behavior is selected."]
    #[doc = " @return"]
    #[doc = "   On success, the pointer to the new allocated ring. NULL on error with"]
    #[doc = "    rte_errno set appropriately. Possible errno values include:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - EINVAL - esize is not a multiple of 4 or count provided is not a"]
    #[doc = "\t\t power of 2."]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_ring_create_elem(
        name: *const ::std::os::raw::c_char,
        esize: ::std::os::raw::c_uint,
        count: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_ring;
}
#[doc = " Ring zero-copy information structure."]
#[doc = ""]
#[doc = " This structure contains the pointers and length of the space"]
#[doc = " reserved on the ring storage."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_ring_zc_data {
    pub ptr1: *mut ::std::os::raw::c_void,
    pub ptr2: *mut ::std::os::raw::c_void,
    pub n1: ::std::os::raw::c_uint,
}
extern "C" {
    #[doc = " Calculate the memory size needed for a ring"]
    #[doc = ""]
    #[doc = " This function returns the number of bytes needed for a ring, given"]
    #[doc = " the number of elements in it. This value is the sum of the size of"]
    #[doc = " the structure rte_ring and the size of the memory needed by the"]
    #[doc = " objects pointers. The value is aligned to a cache line size."]
    #[doc = ""]
    #[doc = " @param count"]
    #[doc = "   The number of elements in the ring (must be a power of 2)."]
    #[doc = " @return"]
    #[doc = "   - The memory size needed for the ring on success."]
    #[doc = "   - -EINVAL if count is not a power of 2."]
    pub fn rte_ring_get_memsize(count: ::std::os::raw::c_uint) -> ssize_t;
}
extern "C" {
    #[doc = " Initialize a ring structure."]
    #[doc = ""]
    #[doc = " Initialize a ring structure in memory pointed by \"r\". The size of the"]
    #[doc = " memory area must be large enough to store the ring structure and the"]
    #[doc = " object table. It is advised to use rte_ring_get_memsize() to get the"]
    #[doc = " appropriate size."]
    #[doc = ""]
    #[doc = " The ring size is set to *count*, which must be a power of two. Water"]
    #[doc = " marking is disabled by default. The real usable ring size is"]
    #[doc = " *count-1* instead of *count* to differentiate a full ring from an"]
    #[doc = " empty ring."]
    #[doc = ""]
    #[doc = " The ring is not added in RTE_TAILQ_RING global list. Indeed, the"]
    #[doc = " memory given by the caller may not be shareable among dpdk"]
    #[doc = " processes."]
    #[doc = ""]
    #[doc = " @param r"]
    #[doc = "   The pointer to the ring structure followed by the objects table."]
    #[doc = " @param name"]
    #[doc = "   The name of the ring."]
    #[doc = " @param count"]
    #[doc = "   The number of elements in the ring (must be a power of 2,"]
    #[doc = "   unless RING_F_EXACT_SZ is set in flags)."]
    #[doc = " @param flags"]
    #[doc = "   An OR of the following:"]
    #[doc = "   - One of mutually exclusive flags that define producer behavior:"]
    #[doc = "      - RING_F_SP_ENQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``"]
    #[doc = "        is \"single-producer\"."]
    #[doc = "      - RING_F_MP_RTS_ENQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``"]
    #[doc = "        is \"multi-producer RTS mode\"."]
    #[doc = "      - RING_F_MP_HTS_ENQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``"]
    #[doc = "        is \"multi-producer HTS mode\"."]
    #[doc = "     If none of these flags is set, then default \"multi-producer\""]
    #[doc = "     behavior is selected."]
    #[doc = "   - One of mutually exclusive flags that define consumer behavior:"]
    #[doc = "      - RING_F_SC_DEQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``"]
    #[doc = "        is \"single-consumer\". Otherwise, it is \"multi-consumers\"."]
    #[doc = "      - RING_F_MC_RTS_DEQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``"]
    #[doc = "        is \"multi-consumer RTS mode\"."]
    #[doc = "      - RING_F_MC_HTS_DEQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``"]
    #[doc = "        is \"multi-consumer HTS mode\"."]
    #[doc = "     If none of these flags is set, then default \"multi-consumer\""]
    #[doc = "     behavior is selected."]
    #[doc = "   - RING_F_EXACT_SZ: If this flag is set, the ring will hold exactly the"]
    #[doc = "     requested number of entries, and the requested size will be rounded up"]
    #[doc = "     to the next power of two, but the usable space will be exactly that"]
    #[doc = "     requested. Worst case, if a power-of-2 size is requested, half the"]
    #[doc = "     ring space will be wasted."]
    #[doc = "     Without this flag set, the ring size requested must be a power of 2,"]
    #[doc = "     and the usable space will be that size - 1."]
    #[doc = " @return"]
    #[doc = "   0 on success, or a negative value on error."]
    pub fn rte_ring_init(
        r: *mut rte_ring,
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new ring named *name* in memory."]
    #[doc = ""]
    #[doc = " This function uses ``memzone_reserve()`` to allocate memory. Then it"]
    #[doc = " calls rte_ring_init() to initialize an empty ring."]
    #[doc = ""]
    #[doc = " The new ring size is set to *count*, which must be a power of"]
    #[doc = " two. Water marking is disabled by default. The real usable ring size"]
    #[doc = " is *count-1* instead of *count* to differentiate a full ring from an"]
    #[doc = " empty ring."]
    #[doc = ""]
    #[doc = " The ring is added in RTE_TAILQ_RING list."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the ring."]
    #[doc = " @param count"]
    #[doc = "   The size of the ring (must be a power of 2,"]
    #[doc = "   unless RING_F_EXACT_SZ is set in flags)."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in case of"]
    #[doc = "   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   An OR of the following:"]
    #[doc = "   - One of mutually exclusive flags that define producer behavior:"]
    #[doc = "      - RING_F_SP_ENQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``"]
    #[doc = "        is \"single-producer\"."]
    #[doc = "      - RING_F_MP_RTS_ENQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``"]
    #[doc = "        is \"multi-producer RTS mode\"."]
    #[doc = "      - RING_F_MP_HTS_ENQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``"]
    #[doc = "        is \"multi-producer HTS mode\"."]
    #[doc = "     If none of these flags is set, then default \"multi-producer\""]
    #[doc = "     behavior is selected."]
    #[doc = "   - One of mutually exclusive flags that define consumer behavior:"]
    #[doc = "      - RING_F_SC_DEQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``"]
    #[doc = "        is \"single-consumer\". Otherwise, it is \"multi-consumers\"."]
    #[doc = "      - RING_F_MC_RTS_DEQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``"]
    #[doc = "        is \"multi-consumer RTS mode\"."]
    #[doc = "      - RING_F_MC_HTS_DEQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``"]
    #[doc = "        is \"multi-consumer HTS mode\"."]
    #[doc = "     If none of these flags is set, then default \"multi-consumer\""]
    #[doc = "     behavior is selected."]
    #[doc = "   - RING_F_EXACT_SZ: If this flag is set, the ring will hold exactly the"]
    #[doc = "     requested number of entries, and the requested size will be rounded up"]
    #[doc = "     to the next power of two, but the usable space will be exactly that"]
    #[doc = "     requested. Worst case, if a power-of-2 size is requested, half the"]
    #[doc = "     ring space will be wasted."]
    #[doc = "     Without this flag set, the ring size requested must be a power of 2,"]
    #[doc = "     and the usable space will be that size - 1."]
    #[doc = " @return"]
    #[doc = "   On success, the pointer to the new allocated ring. NULL on error with"]
    #[doc = "    rte_errno set appropriately. Possible errno values include:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - EINVAL - count provided is not a power of 2"]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_ring_create(
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_ring;
}
extern "C" {
    #[doc = " De-allocate all memory used by the ring."]
    #[doc = ""]
    #[doc = " @param r"]
    #[doc = "   Ring to free."]
    #[doc = "   If NULL then, the function does nothing."]
    pub fn rte_ring_free(r: *mut rte_ring);
}
extern "C" {
    #[doc = " Dump the status of the ring to a file."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    #[doc = " @param r"]
    #[doc = "   A pointer to the ring structure."]
    pub fn rte_ring_dump(f: *mut FILE, r: *const rte_ring);
}
extern "C" {
    #[doc = " Flush a ring."]
    #[doc = ""]
    #[doc = " This function flush all the elements in a ring"]
    #[doc = ""]
    #[doc = " @warning"]
    #[doc = " Make sure the ring is not in use while calling this function."]
    #[doc = ""]
    #[doc = " @param r"]
    #[doc = "   A pointer to the ring structure."]
    pub fn rte_ring_reset(r: *mut rte_ring);
}
extern "C" {
    #[doc = " Dump the status of all rings on the console"]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_ring_list_dump(f: *mut FILE);
}
extern "C" {
    #[doc = " Search a ring from its name"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the ring."]
    #[doc = " @return"]
    #[doc = "   The pointer to the ring matching the name, or NULL if not found,"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - ENOENT - required entry not available to return."]
    pub fn rte_ring_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_ring;
}
extern "C" {
    pub static mut __rte_mempool_trace_ops_dequeue_bulk: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_ops_dequeue_contig_blocks: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_ops_enqueue_bulk: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_generic_put: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_put_bulk: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_generic_get: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_get_bulk: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_get_contig_blocks: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_default_cache: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_cache_flush: rte_trace_point_t;
}
#[doc = " A structure that stores a per-core object cache."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_cache {
    #[doc = "< Size of the cache"]
    pub size: u32,
    #[doc = "< Threshold before we flush excess elements"]
    pub flushthresh: u32,
    #[doc = "< Current cache count"]
    pub len: u32,
    #[doc = "< Cache objects"]
    pub objs: [*mut ::std::os::raw::c_void; 1536usize],
}
#[doc = " A structure that stores the size of mempool elements."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objsz {
    #[doc = "< Size of an element."]
    pub elt_size: u32,
    #[doc = "< Size of header (before elt)."]
    pub header_size: u32,
    #[doc = "< Size of trailer (after elt)."]
    pub trailer_size: u32,
    pub total_size: u32,
}
#[doc = " Mempool object header structure"]
#[doc = ""]
#[doc = " Each object stored in mempools are prefixed by this header structure,"]
#[doc = " it allows to retrieve the mempool pointer from the object and to"]
#[doc = " iterate on all objects attached to a mempool. When debug is enabled,"]
#[doc = " a cookie is also added in this structure preventing corruptions and"]
#[doc = " double-frees."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_objhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the object."]
    pub mp: *mut rte_mempool,
    #[doc = "< IO address of the object."]
    pub iova: rte_iova_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_objhdr,
}
#[doc = " A list of object headers type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objhdr_list {
    pub stqh_first: *mut rte_mempool_objhdr,
    pub stqh_last: *mut *mut rte_mempool_objhdr,
}
#[doc = " A list of memory where objects are stored"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_memhdr_list {
    pub stqh_first: *mut rte_mempool_memhdr,
    pub stqh_last: *mut *mut rte_mempool_memhdr,
}
#[doc = " Callback used to free a memory chunk"]
pub type rte_mempool_memchunk_free_cb_t = ::std::option::Option<
    unsafe extern "C" fn(memhdr: *mut rte_mempool_memhdr, opaque: *mut ::std::os::raw::c_void),
>;
#[doc = " Mempool objects memory header structure"]
#[doc = ""]
#[doc = " The memory chunks where objects are stored. Each chunk is virtually"]
#[doc = " and physically contiguous."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_memhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_memhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the chunk"]
    pub mp: *mut rte_mempool,
    #[doc = "< Virtual address of the chunk"]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< IO address of the chunk"]
    pub iova: rte_iova_t,
    #[doc = "< length of the chunk"]
    pub len: size_t,
    #[doc = "< Free callback"]
    pub free_cb: rte_mempool_memchunk_free_cb_t,
    #[doc = "< Argument passed to the free callback"]
    pub opaque: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_memhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_memhdr,
}
#[doc = " Additional information about the mempool"]
#[doc = ""]
#[doc = " The structure is cache-line aligned to avoid ABI breakages in"]
#[doc = " a number of cases when something small is added."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_info {
    #[doc = " Number of objects in the contiguous block"]
    pub contig_block_size: ::std::os::raw::c_uint,
}
#[doc = " The RTE mempool structure."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool {
    #[doc = "< Name of mempool."]
    pub name: [::std::os::raw::c_char; 26usize],
    pub __bindgen_anon_1: rte_mempool__bindgen_ty_1,
    #[doc = "< optional args for ops alloc."]
    pub pool_config: *mut ::std::os::raw::c_void,
    #[doc = "< Memzone where pool is alloc'd."]
    pub mz: *const rte_memzone,
    #[doc = "< Flags of the mempool."]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< Socket id passed at create."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< Max size of the mempool."]
    pub size: u32,
    pub cache_size: u32,
    #[doc = "< Size of an element."]
    pub elt_size: u32,
    #[doc = "< Size of header (before elt)."]
    pub header_size: u32,
    #[doc = "< Size of trailer (after elt)."]
    pub trailer_size: u32,
    #[doc = "< Size of private data."]
    pub private_data_size: ::std::os::raw::c_uint,
    #[doc = " Index into rte_mempool_ops_table array of mempool ops"]
    #[doc = " structs, which contain callback function pointers."]
    #[doc = " We're using an index here rather than pointers to the callbacks"]
    #[doc = " to facilitate any secondary processes that may want to use"]
    #[doc = " this mempool."]
    pub ops_index: i32,
    #[doc = "< Per-lcore local cache"]
    pub local_cache: *mut rte_mempool_cache,
    #[doc = "< Number of populated objects."]
    pub populated_size: u32,
    #[doc = "< List of objects in pool"]
    pub elt_list: rte_mempool_objhdr_list,
    #[doc = "< Number of memory chunks"]
    pub nb_mem_chunks: u32,
    #[doc = "< List of memory chunks"]
    pub mem_list: rte_mempool_memhdr_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool__bindgen_ty_1 {
    #[doc = "< Ring or pool to store objects."]
    pub pool_data: *mut ::std::os::raw::c_void,
    #[doc = "< External mempool identifier."]
    pub pool_id: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objtlr {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @internal Check and update cookies or panic."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @param obj_table_const"]
    #[doc = "   Pointer to a table of void * pointers (objects)."]
    #[doc = " @param n"]
    #[doc = "   Index of object in object table."]
    #[doc = " @param free"]
    #[doc = "   - 0: object is supposed to be allocated, mark it as free"]
    #[doc = "   - 1: object is supposed to be free, mark it as allocated"]
    #[doc = "   - 2: just check that cookie is valid (free or allocated)"]
    pub fn rte_mempool_check_cookies(
        mp: *const rte_mempool,
        obj_table_const: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
        free: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @internal Check contiguous object blocks and update cookies or panic."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @param first_obj_table_const"]
    #[doc = "   Pointer to a table of void * pointers (first object of the contiguous"]
    #[doc = "   object blocks)."]
    #[doc = " @param n"]
    #[doc = "   Number of contiguous object blocks."]
    #[doc = " @param free"]
    #[doc = "   - 0: object is supposed to be allocated, mark it as free"]
    #[doc = "   - 1: object is supposed to be free, mark it as allocated"]
    #[doc = "   - 2: just check that cookie is valid (free or allocated)"]
    pub fn rte_mempool_contig_blocks_check_cookies(
        mp: *const rte_mempool,
        first_obj_table_const: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
        free: ::std::os::raw::c_int,
    );
}
#[doc = " Prototype for implementation specific data provisioning function."]
#[doc = ""]
#[doc = " The function should provide the implementation specific memory for"]
#[doc = " use by the other mempool ops functions in a given mempool ops struct."]
#[doc = " E.g. the default ops provides an instance of the rte_ring for this purpose."]
#[doc = " it will most likely point to a different type of data structure, and"]
#[doc = " will be transparent to the application programmer."]
#[doc = " This function should set mp->pool_data."]
pub type rte_mempool_alloc_t =
    ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool) -> ::std::os::raw::c_int>;
#[doc = " Free the opaque private data pointed to by mp->pool_data pointer."]
pub type rte_mempool_free_t = ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool)>;
#[doc = " Enqueue an object into the external pool."]
pub type rte_mempool_enqueue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Dequeue an object from the external pool."]
pub type rte_mempool_dequeue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Dequeue a number of contiguous object blocks from the external pool."]
pub type rte_mempool_dequeue_contig_blocks_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        first_obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Return the number of available objects in the external pool."]
pub type rte_mempool_get_count =
    ::std::option::Option<unsafe extern "C" fn(mp: *const rte_mempool) -> ::std::os::raw::c_uint>;
#[doc = " Calculate memory size required to store given number of objects."]
#[doc = ""]
#[doc = " If mempool objects are not required to be IOVA-contiguous"]
#[doc = " (the flag RTE_MEMPOOL_F_NO_IOVA_CONTIG is set), min_chunk_size defines"]
#[doc = " virtually contiguous chunk size. Otherwise, if mempool objects must"]
#[doc = " be IOVA-contiguous (the flag RTE_MEMPOOL_F_NO_IOVA_CONTIG is clear),"]
#[doc = " min_chunk_size defines IOVA-contiguous chunk size."]
#[doc = ""]
#[doc = " @param[in] mp"]
#[doc = "   Pointer to the memory pool."]
#[doc = " @param[in] obj_num"]
#[doc = "   Number of objects."]
#[doc = " @param[in] pg_shift"]
#[doc = "   LOG2 of the physical pages size. If set to 0, ignore page boundaries."]
#[doc = " @param[out] min_chunk_size"]
#[doc = "   Location for minimum size of the memory chunk which may be used to"]
#[doc = "   store memory pool objects."]
#[doc = " @param[out] align"]
#[doc = "   Location for required memory chunk alignment."]
#[doc = " @return"]
#[doc = "   Required memory size."]
pub type rte_mempool_calc_mem_size_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut size_t,
        align: *mut size_t,
    ) -> ssize_t,
>;
extern "C" {
    #[doc = " @internal Helper to calculate memory size required to store given"]
    #[doc = " number of objects."]
    #[doc = ""]
    #[doc = " This function is internal to mempool library and mempool drivers."]
    #[doc = ""]
    #[doc = " If page boundaries may be ignored, it is just a product of total"]
    #[doc = " object size including header and trailer and number of objects."]
    #[doc = " Otherwise, it is a number of pages required to store given number of"]
    #[doc = " objects without crossing page boundary."]
    #[doc = ""]
    #[doc = " Note that if object size is bigger than page size, then it assumes"]
    #[doc = " that pages are grouped in subsets of physically continuous pages big"]
    #[doc = " enough to store at least one object."]
    #[doc = ""]
    #[doc = " Minimum size of memory chunk is the total element size."]
    #[doc = " Required memory chunk alignment is the cache line size."]
    #[doc = ""]
    #[doc = " @param[in] mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param[in] obj_num"]
    #[doc = "   Number of objects to be added in mempool."]
    #[doc = " @param[in] pg_shift"]
    #[doc = "   LOG2 of the physical pages size. If set to 0, ignore page boundaries."]
    #[doc = " @param[in] chunk_reserve"]
    #[doc = "   Amount of memory that must be reserved at the beginning of each page,"]
    #[doc = "   or at the beginning of the memory area if pg_shift is 0."]
    #[doc = " @param[out] min_chunk_size"]
    #[doc = "   Location for minimum size of the memory chunk which may be used to"]
    #[doc = "   store memory pool objects."]
    #[doc = " @param[out] align"]
    #[doc = "   Location for required memory chunk alignment."]
    #[doc = " @return"]
    #[doc = "   Required memory size."]
    pub fn rte_mempool_op_calc_mem_size_helper(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        chunk_reserve: size_t,
        min_chunk_size: *mut size_t,
        align: *mut size_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " Default way to calculate memory size required to store given number of"]
    #[doc = " objects."]
    #[doc = ""]
    #[doc = " Equivalent to rte_mempool_op_calc_mem_size_helper(mp, obj_num, pg_shift,"]
    #[doc = " 0, min_chunk_size, align)."]
    pub fn rte_mempool_op_calc_mem_size_default(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut size_t,
        align: *mut size_t,
    ) -> ssize_t;
}
#[doc = " Function to be called for each populated object."]
#[doc = ""]
#[doc = " @param[in] mp"]
#[doc = "   A pointer to the mempool structure."]
#[doc = " @param[in] opaque"]
#[doc = "   An opaque pointer passed to iterator."]
#[doc = " @param[in] vaddr"]
#[doc = "   Object virtual address."]
#[doc = " @param[in] iova"]
#[doc = "   Input/output virtual address of the object or RTE_BAD_IOVA."]
pub type rte_mempool_populate_obj_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
    ),
>;
#[doc = " Populate memory pool objects using provided memory chunk."]
#[doc = ""]
#[doc = " Populated objects should be enqueued to the pool, e.g. using"]
#[doc = " rte_mempool_ops_enqueue_bulk()."]
#[doc = ""]
#[doc = " If the given IO address is unknown (iova = RTE_BAD_IOVA),"]
#[doc = " the chunk doesn't need to be physically contiguous (only virtually),"]
#[doc = " and allocated objects may span two pages."]
#[doc = ""]
#[doc = " @param[in] mp"]
#[doc = "   A pointer to the mempool structure."]
#[doc = " @param[in] max_objs"]
#[doc = "   Maximum number of objects to be populated."]
#[doc = " @param[in] vaddr"]
#[doc = "   The virtual address of memory that should be used to store objects."]
#[doc = " @param[in] iova"]
#[doc = "   The IO address"]
#[doc = " @param[in] len"]
#[doc = "   The length of memory in bytes."]
#[doc = " @param[in] obj_cb"]
#[doc = "   Callback function to be executed for each populated object."]
#[doc = " @param[in] obj_cb_arg"]
#[doc = "   An opaque pointer passed to the callback function."]
#[doc = " @return"]
#[doc = "   The number of objects added on success."]
#[doc = "   On error, no objects are populated and a negative errno is returned."]
pub type rte_mempool_populate_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: size_t,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @internal Helper to populate memory pool object using provided memory"]
    #[doc = " chunk: just slice objects one by one, taking care of not"]
    #[doc = " crossing page boundaries."]
    #[doc = ""]
    #[doc = " If RTE_MEMPOOL_POPULATE_F_ALIGN_OBJ is set in flags, the addresses"]
    #[doc = " of object headers will be aligned on a multiple of total_elt_sz."]
    #[doc = " This feature is used by octeontx hardware."]
    #[doc = ""]
    #[doc = " This function is internal to mempool library and mempool drivers."]
    #[doc = ""]
    #[doc = " @param[in] mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param[in] flags"]
    #[doc = "   Logical OR of following flags:"]
    #[doc = "   - RTE_MEMPOOL_POPULATE_F_ALIGN_OBJ: align objects on addresses"]
    #[doc = "     multiple of total_elt_sz."]
    #[doc = " @param[in] max_objs"]
    #[doc = "   Maximum number of objects to be added in mempool."]
    #[doc = " @param[in] vaddr"]
    #[doc = "   The virtual address of memory that should be used to store objects."]
    #[doc = " @param[in] iova"]
    #[doc = "   The IO address corresponding to vaddr, or RTE_BAD_IOVA."]
    #[doc = " @param[in] len"]
    #[doc = "   The length of memory in bytes."]
    #[doc = " @param[in] obj_cb"]
    #[doc = "   Callback function to be executed for each populated object."]
    #[doc = " @param[in] obj_cb_arg"]
    #[doc = "   An opaque pointer passed to the callback function."]
    #[doc = " @return"]
    #[doc = "   The number of objects added in mempool."]
    pub fn rte_mempool_op_populate_helper(
        mp: *mut rte_mempool,
        flags: ::std::os::raw::c_uint,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: size_t,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Default way to populate memory pool object using provided memory chunk."]
    #[doc = ""]
    #[doc = " Equivalent to rte_mempool_op_populate_helper(mp, 0, max_objs, vaddr, iova,"]
    #[doc = " len, obj_cb, obj_cb_arg)."]
    pub fn rte_mempool_op_populate_default(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: size_t,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Get some additional information about a mempool."]
pub type rte_mempool_get_info_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *const rte_mempool,
        info: *mut rte_mempool_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Structure defining mempool operations structure"]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_ops {
    #[doc = "< Name of mempool ops struct."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Allocate private data."]
    pub alloc: rte_mempool_alloc_t,
    #[doc = "< Free the external pool."]
    pub free: rte_mempool_free_t,
    #[doc = "< Enqueue an object."]
    pub enqueue: rte_mempool_enqueue_t,
    #[doc = "< Dequeue an object."]
    pub dequeue: rte_mempool_dequeue_t,
    #[doc = "< Get qty of available objs."]
    pub get_count: rte_mempool_get_count,
    #[doc = " Optional callback to calculate memory size required to"]
    #[doc = " store specified number of objects."]
    pub calc_mem_size: rte_mempool_calc_mem_size_t,
    #[doc = " Optional callback to populate mempool objects using"]
    #[doc = " provided memory chunk."]
    pub populate: rte_mempool_populate_t,
    #[doc = " Get mempool info"]
    pub get_info: rte_mempool_get_info_t,
    #[doc = " Dequeue a number of contiguous object blocks."]
    pub dequeue_contig_blocks: rte_mempool_dequeue_contig_blocks_t,
}
#[doc = " Structure storing the table of registered ops structs, each of which contain"]
#[doc = " the function pointers for the mempool ops functions."]
#[doc = " Each process has its own storage for this ops struct array so that"]
#[doc = " the mempools can be shared across primary and secondary processes."]
#[doc = " The indices used to access the array are valid across processes, whereas"]
#[doc = " any function pointers stored directly in the mempool struct would not be."]
#[doc = " This results in us simply having \"ops_index\" in the mempool struct."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_ops_table {
    #[doc = "< Spinlock for add/delete."]
    pub sl: rte_spinlock_t,
    #[doc = "< Number of used ops structs in the table."]
    pub num_ops: u32,
    pub __bindgen_padding_0: [u64; 7usize],
    #[doc = " Storage for all possible ops structs."]
    pub ops: [rte_mempool_ops; 16usize],
}
extern "C" {
    #[doc = " Array of registered ops structs."]
    pub static mut rte_mempool_ops_table: rte_mempool_ops_table;
}
extern "C" {
    #[doc = " @internal Wrapper for mempool_ops alloc callback."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; successfully allocated mempool pool_data."]
    #[doc = "   - <0: Error; code of alloc function."]
    pub fn rte_mempool_ops_alloc(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal wrapper for mempool_ops get_count callback."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @return"]
    #[doc = "   The number of available objects in the external pool."]
    pub fn rte_mempool_ops_get_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @internal wrapper for mempool_ops calc_mem_size callback."]
    #[doc = " API to calculate size of memory required to store specified number of"]
    #[doc = " object."]
    #[doc = ""]
    #[doc = " @param[in] mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @param[in] obj_num"]
    #[doc = "   Number of objects."]
    #[doc = " @param[in] pg_shift"]
    #[doc = "   LOG2 of the physical pages size. If set to 0, ignore page boundaries."]
    #[doc = " @param[out] min_chunk_size"]
    #[doc = "   Location for minimum size of the memory chunk which may be used to"]
    #[doc = "   store memory pool objects."]
    #[doc = " @param[out] align"]
    #[doc = "   Location for required memory chunk alignment."]
    #[doc = " @return"]
    #[doc = "   Required memory size aligned at page boundary."]
    pub fn rte_mempool_ops_calc_mem_size(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut size_t,
        align: *mut size_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " @internal wrapper for mempool_ops populate callback."]
    #[doc = ""]
    #[doc = " Populate memory pool objects using provided memory chunk."]
    #[doc = ""]
    #[doc = " @param[in] mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param[in] max_objs"]
    #[doc = "   Maximum number of objects to be populated."]
    #[doc = " @param[in] vaddr"]
    #[doc = "   The virtual address of memory that should be used to store objects."]
    #[doc = " @param[in] iova"]
    #[doc = "   The IO address"]
    #[doc = " @param[in] len"]
    #[doc = "   The length of memory in bytes."]
    #[doc = " @param[in] obj_cb"]
    #[doc = "   Callback function to be executed for each populated object."]
    #[doc = " @param[in] obj_cb_arg"]
    #[doc = "   An opaque pointer passed to the callback function."]
    #[doc = " @return"]
    #[doc = "   The number of objects added on success."]
    #[doc = "   On error, no objects are populated and a negative errno is returned."]
    pub fn rte_mempool_ops_populate(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: size_t,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wrapper for mempool_ops get_info callback."]
    #[doc = ""]
    #[doc = " @param[in] mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @param[out] info"]
    #[doc = "   Pointer to the rte_mempool_info structure"]
    #[doc = " @return"]
    #[doc = "   - 0: Success; The mempool driver supports retrieving supplementary"]
    #[doc = "        mempool information"]
    #[doc = "   - -ENOTSUP - doesn't support get_info ops (valid case)."]
    pub fn rte_mempool_ops_get_info(
        mp: *const rte_mempool,
        info: *mut rte_mempool_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal wrapper for mempool_ops free callback."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    pub fn rte_mempool_ops_free(mp: *mut rte_mempool);
}
extern "C" {
    #[doc = " Set the ops of a mempool."]
    #[doc = ""]
    #[doc = " This can only be done on a mempool that is not populated, i.e. just after"]
    #[doc = " a call to rte_mempool_create_empty()."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @param name"]
    #[doc = "   Name of the ops structure to use for this mempool."]
    #[doc = " @param pool_config"]
    #[doc = "   Opaque data that can be passed by the application to the ops functions."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; the mempool is now using the requested ops functions."]
    #[doc = "   - -EINVAL - Invalid ops struct name provided."]
    #[doc = "   - -EEXIST - mempool already has an ops struct assigned."]
    pub fn rte_mempool_set_ops_byname(
        mp: *mut rte_mempool,
        name: *const ::std::os::raw::c_char,
        pool_config: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register mempool operations."]
    #[doc = ""]
    #[doc = " @param ops"]
    #[doc = "   Pointer to an ops structure to register."]
    #[doc = " @return"]
    #[doc = "   - >=0: Success; return the index of the ops struct in the table."]
    #[doc = "   - -EINVAL - some missing callbacks while registering ops struct."]
    #[doc = "   - -ENOSPC - the maximum number of ops structs has been reached."]
    pub fn rte_mempool_register_ops(ops: *const rte_mempool_ops) -> ::std::os::raw::c_int;
}
#[doc = " An object callback function for mempool."]
#[doc = ""]
#[doc = " Used by rte_mempool_create() and rte_mempool_obj_iter()."]
pub type rte_mempool_obj_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        obj: *mut ::std::os::raw::c_void,
        obj_idx: ::std::os::raw::c_uint,
    ),
>;
pub type rte_mempool_obj_ctor_t = rte_mempool_obj_cb_t;
#[doc = " A memory callback function for mempool."]
#[doc = ""]
#[doc = " Used by rte_mempool_mem_iter()."]
pub type rte_mempool_mem_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        memhdr: *mut rte_mempool_memhdr,
        mem_idx: ::std::os::raw::c_uint,
    ),
>;
#[doc = " A mempool constructor callback function."]
#[doc = ""]
#[doc = " Arguments are the mempool and the opaque pointer given by the user in"]
#[doc = " rte_mempool_create()."]
pub type rte_mempool_ctor_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut rte_mempool, arg2: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Create a new mempool named *name* in memory."]
    #[doc = ""]
    #[doc = " This function uses ``rte_memzone_reserve()`` to allocate memory. The"]
    #[doc = " pool contains n elements of elt_size. Its size is set to n."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the mempool."]
    #[doc = " @param n"]
    #[doc = "   The number of elements in the mempool. The optimum size (in terms of"]
    #[doc = "   memory usage) for a mempool is when n is a power of two minus one:"]
    #[doc = "   n = (2^q - 1)."]
    #[doc = " @param elt_size"]
    #[doc = "   The size of each element."]
    #[doc = " @param cache_size"]
    #[doc = "   If cache_size is non-zero, the rte_mempool library will try to"]
    #[doc = "   limit the accesses to the common lockless pool, by maintaining a"]
    #[doc = "   per-lcore object cache. This argument must be lower or equal to"]
    #[doc = "   RTE_MEMPOOL_CACHE_MAX_SIZE and n / 1.5. It is advised to choose"]
    #[doc = "   cache_size to have \"n modulo cache_size == 0\": if this is"]
    #[doc = "   not the case, some elements will always stay in the pool and will"]
    #[doc = "   never be used. The access to the per-lcore table is of course"]
    #[doc = "   faster than the multi-producer/consumer pool. The cache can be"]
    #[doc = "   disabled if the cache_size argument is set to 0; it can be useful to"]
    #[doc = "   avoid losing objects in cache."]
    #[doc = " @param private_data_size"]
    #[doc = "   The size of the private data appended after the mempool"]
    #[doc = "   structure. This is useful for storing some private data after the"]
    #[doc = "   mempool structure, as is done for rte_mbuf_pool for example."]
    #[doc = " @param mp_init"]
    #[doc = "   A function pointer that is called for initialization of the pool,"]
    #[doc = "   before object initialization. The user can initialize the private"]
    #[doc = "   data in this function if needed. This parameter can be NULL if"]
    #[doc = "   not needed."]
    #[doc = " @param mp_init_arg"]
    #[doc = "   An opaque pointer to data that can be used in the mempool"]
    #[doc = "   constructor function."]
    #[doc = " @param obj_init"]
    #[doc = "   A function pointer that is called for each object at"]
    #[doc = "   initialization of the pool. The user can set some meta data in"]
    #[doc = "   objects if needed. This parameter can be NULL if not needed."]
    #[doc = "   The obj_init() function takes the mempool pointer, the init_arg,"]
    #[doc = "   the object pointer and the object number as parameters."]
    #[doc = " @param obj_init_arg"]
    #[doc = "   An opaque pointer to data that can be used as an argument for"]
    #[doc = "   each call to the object constructor function."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in the case of"]
    #[doc = "   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   The *flags* arguments is an OR of following flags:"]
    #[doc = "   - RTE_MEMPOOL_F_NO_SPREAD: By default, objects addresses are spread"]
    #[doc = "     between channels in RAM: the pool allocator will add padding"]
    #[doc = "     between objects depending on the hardware configuration. See"]
    #[doc = "     Memory alignment constraints for details. If this flag is set,"]
    #[doc = "     the allocator will just align them to a cache line."]
    #[doc = "   - RTE_MEMPOOL_F_NO_CACHE_ALIGN: By default, the returned objects are"]
    #[doc = "     cache-aligned. This flag removes this constraint, and no"]
    #[doc = "     padding will be present between objects. This flag implies"]
    #[doc = "     RTE_MEMPOOL_F_NO_SPREAD."]
    #[doc = "   - RTE_MEMPOOL_F_SP_PUT: If this flag is set, the default behavior"]
    #[doc = "     when using rte_mempool_put() or rte_mempool_put_bulk() is"]
    #[doc = "     \"single-producer\". Otherwise, it is \"multi-producers\"."]
    #[doc = "   - RTE_MEMPOOL_F_SC_GET: If this flag is set, the default behavior"]
    #[doc = "     when using rte_mempool_get() or rte_mempool_get_bulk() is"]
    #[doc = "     \"single-consumer\". Otherwise, it is \"multi-consumers\"."]
    #[doc = "   - RTE_MEMPOOL_F_NO_IOVA_CONTIG: If set, allocated objects won't"]
    #[doc = "     necessarily be contiguous in IO memory."]
    #[doc = " @return"]
    #[doc = "   The pointer to the new allocated mempool, on success. NULL on error"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - EINVAL - cache size provided is too large or an unknown flag was passed"]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_mempool_create(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        elt_size: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        private_data_size: ::std::os::raw::c_uint,
        mp_init: rte_mempool_ctor_t,
        mp_init_arg: *mut ::std::os::raw::c_void,
        obj_init: rte_mempool_obj_cb_t,
        obj_init_arg: *mut ::std::os::raw::c_void,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Create an empty mempool"]
    #[doc = ""]
    #[doc = " The mempool is allocated and initialized, but it is not populated: no"]
    #[doc = " memory is allocated for the mempool elements. The user has to call"]
    #[doc = " rte_mempool_populate_*() to add memory chunks to the pool. Once"]
    #[doc = " populated, the user may also want to initialize each object with"]
    #[doc = " rte_mempool_obj_iter()."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the mempool."]
    #[doc = " @param n"]
    #[doc = "   The maximum number of elements that can be added in the mempool."]
    #[doc = "   The optimum size (in terms of memory usage) for a mempool is when n"]
    #[doc = "   is a power of two minus one: n = (2^q - 1)."]
    #[doc = " @param elt_size"]
    #[doc = "   The size of each element."]
    #[doc = " @param cache_size"]
    #[doc = "   Size of the cache. See rte_mempool_create() for details."]
    #[doc = " @param private_data_size"]
    #[doc = "   The size of the private data appended after the mempool"]
    #[doc = "   structure. This is useful for storing some private data after the"]
    #[doc = "   mempool structure, as is done for rte_mbuf_pool for example."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in the case of"]
    #[doc = "   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   Flags controlling the behavior of the mempool. See"]
    #[doc = "   rte_mempool_create() for details."]
    #[doc = " @return"]
    #[doc = "   The pointer to the new allocated mempool, on success. NULL on error"]
    #[doc = "   with rte_errno set appropriately. See rte_mempool_create() for details."]
    pub fn rte_mempool_create_empty(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        elt_size: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        private_data_size: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Free a mempool"]
    #[doc = ""]
    #[doc = " Unlink the mempool from global list, free the memory chunks, and all"]
    #[doc = " memory referenced by the mempool. The objects must not be used by"]
    #[doc = " other cores as they will be freed."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = "   If NULL then, the function does nothing."]
    pub fn rte_mempool_free(mp: *mut rte_mempool);
}
extern "C" {
    #[doc = " Add physically contiguous memory for objects in the pool at init"]
    #[doc = ""]
    #[doc = " Add a virtually and physically contiguous memory chunk in the pool"]
    #[doc = " where objects can be instantiated."]
    #[doc = ""]
    #[doc = " If the given IO address is unknown (iova = RTE_BAD_IOVA),"]
    #[doc = " the chunk doesn't need to be physically contiguous (only virtually),"]
    #[doc = " and allocated objects may span two pages."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param vaddr"]
    #[doc = "   The virtual address of memory that should be used to store objects."]
    #[doc = " @param iova"]
    #[doc = "   The IO address"]
    #[doc = " @param len"]
    #[doc = "   The length of memory in bytes."]
    #[doc = " @param free_cb"]
    #[doc = "   The callback used to free this chunk when destroying the mempool."]
    #[doc = " @param opaque"]
    #[doc = "   An opaque argument passed to free_cb."]
    #[doc = " @return"]
    #[doc = "   The number of objects added on success (strictly positive)."]
    #[doc = "   On error, the chunk is not added in the memory list of the"]
    #[doc = "   mempool the following code is returned:"]
    #[doc = "     (0): not enough room in chunk for one object."]
    #[doc = "     (-ENOSPC): mempool is already populated."]
    #[doc = "     (-ENOMEM): allocation failure."]
    pub fn rte_mempool_populate_iova(
        mp: *mut rte_mempool,
        vaddr: *mut ::std::os::raw::c_char,
        iova: rte_iova_t,
        len: size_t,
        free_cb: rte_mempool_memchunk_free_cb_t,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add virtually contiguous memory for objects in the pool at init"]
    #[doc = ""]
    #[doc = " Add a virtually contiguous memory chunk in the pool where objects can"]
    #[doc = " be instantiated."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param addr"]
    #[doc = "   The virtual address of memory that should be used to store objects."]
    #[doc = " @param len"]
    #[doc = "   The length of memory in bytes."]
    #[doc = " @param pg_sz"]
    #[doc = "   The size of memory pages in this virtual area."]
    #[doc = " @param free_cb"]
    #[doc = "   The callback used to free this chunk when destroying the mempool."]
    #[doc = " @param opaque"]
    #[doc = "   An opaque argument passed to free_cb."]
    #[doc = " @return"]
    #[doc = "   The number of objects added on success (strictly positive)."]
    #[doc = "   On error, the chunk is not added in the memory list of the"]
    #[doc = "   mempool the following code is returned:"]
    #[doc = "     (0): not enough room in chunk for one object."]
    #[doc = "     (-ENOSPC): mempool is already populated."]
    #[doc = "     (-ENOMEM): allocation failure."]
    pub fn rte_mempool_populate_virt(
        mp: *mut rte_mempool,
        addr: *mut ::std::os::raw::c_char,
        len: size_t,
        pg_sz: size_t,
        free_cb: rte_mempool_memchunk_free_cb_t,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add memory for objects in the pool at init"]
    #[doc = ""]
    #[doc = " This is the default function used by rte_mempool_create() to populate"]
    #[doc = " the mempool. It adds memory allocated using rte_memzone_reserve()."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @return"]
    #[doc = "   The number of objects added on success."]
    #[doc = "   On error, the chunk is not added in the memory list of the"]
    #[doc = "   mempool and a negative errno is returned."]
    pub fn rte_mempool_populate_default(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add memory from anonymous mapping for objects in the pool at init"]
    #[doc = ""]
    #[doc = " This function mmap an anonymous memory zone that is locked in"]
    #[doc = " memory to store the objects of the mempool."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @return"]
    #[doc = "   The number of objects added on success."]
    #[doc = "   On error, 0 is returned, rte_errno is set, and the chunk is not added in"]
    #[doc = "   the memory list of the mempool."]
    pub fn rte_mempool_populate_anon(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call a function for each mempool element"]
    #[doc = ""]
    #[doc = " Iterate across all objects attached to a rte_mempool and call the"]
    #[doc = " callback function on it."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to an initialized mempool."]
    #[doc = " @param obj_cb"]
    #[doc = "   A function pointer that is called for each object."]
    #[doc = " @param obj_cb_arg"]
    #[doc = "   An opaque pointer passed to the callback function."]
    #[doc = " @return"]
    #[doc = "   Number of objects iterated."]
    pub fn rte_mempool_obj_iter(
        mp: *mut rte_mempool,
        obj_cb: rte_mempool_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    #[doc = " Call a function for each mempool memory chunk"]
    #[doc = ""]
    #[doc = " Iterate across all memory chunks attached to a rte_mempool and call"]
    #[doc = " the callback function on it."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to an initialized mempool."]
    #[doc = " @param mem_cb"]
    #[doc = "   A function pointer that is called for each memory chunk."]
    #[doc = " @param mem_cb_arg"]
    #[doc = "   An opaque pointer passed to the callback function."]
    #[doc = " @return"]
    #[doc = "   Number of memory chunks iterated."]
    pub fn rte_mempool_mem_iter(
        mp: *mut rte_mempool,
        mem_cb: rte_mempool_mem_cb_t,
        mem_cb_arg: *mut ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    #[doc = " Dump the status of the mempool to a file."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    pub fn rte_mempool_dump(f: *mut FILE, mp: *mut rte_mempool);
}
extern "C" {
    #[doc = " Create a user-owned mempool cache."]
    #[doc = ""]
    #[doc = " This can be used by unregistered non-EAL threads to enable caching when they"]
    #[doc = " interact with a mempool."]
    #[doc = ""]
    #[doc = " @param size"]
    #[doc = "   The size of the mempool cache. See rte_mempool_create()'s cache_size"]
    #[doc = "   parameter description for more information. The same limits and"]
    #[doc = "   considerations apply here too."]
    #[doc = " @param socket_id"]
    #[doc = "   The socket identifier in the case of NUMA. The value can be"]
    #[doc = "   SOCKET_ID_ANY if there is no NUMA constraint for the reserved zone."]
    pub fn rte_mempool_cache_create(
        size: u32,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_mempool_cache;
}
extern "C" {
    #[doc = " Free a user-owned mempool cache."]
    #[doc = ""]
    #[doc = " @param cache"]
    #[doc = "   A pointer to the mempool cache."]
    pub fn rte_mempool_cache_free(cache: *mut rte_mempool_cache);
}
extern "C" {
    #[doc = " Return the number of entries in the mempool."]
    #[doc = ""]
    #[doc = " When cache is enabled, this function has to browse the length of"]
    #[doc = " all lcores, so it should not be used in a data path, but only for"]
    #[doc = " debug purposes. User-owned mempool caches are not accounted for."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @return"]
    #[doc = "   The number of entries in the mempool."]
    pub fn rte_mempool_avail_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the number of elements which have been allocated from the mempool"]
    #[doc = ""]
    #[doc = " When cache is enabled, this function has to browse the length of"]
    #[doc = " all lcores, so it should not be used in a data path, but only for"]
    #[doc = " debug purposes."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @return"]
    #[doc = "   The number of free entries in the mempool."]
    pub fn rte_mempool_in_use_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Check the consistency of mempool objects."]
    #[doc = ""]
    #[doc = " Verify the coherency of fields in the mempool structure. Also check"]
    #[doc = " that the cookies of mempool objects (even the ones that are not"]
    #[doc = " present in pool) have a correct value. If not, a panic will occur."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    pub fn rte_mempool_audit(mp: *mut rte_mempool);
}
extern "C" {
    #[doc = " Dump the status of all mempools on the console"]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_mempool_list_dump(f: *mut FILE);
}
extern "C" {
    #[doc = " Search a mempool from its name"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the mempool."]
    #[doc = " @return"]
    #[doc = "   The pointer to the mempool matching the name, or NULL if not found."]
    #[doc = "   NULL on error"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - ENOENT - required entry not available to return."]
    #[doc = ""]
    pub fn rte_mempool_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Get the header, trailer and total size of a mempool element."]
    #[doc = ""]
    #[doc = " Given a desired size of the mempool element and mempool flags,"]
    #[doc = " calculates header, trailer, body and total sizes of the mempool object."]
    #[doc = ""]
    #[doc = " @param elt_size"]
    #[doc = "   The size of each element, without header and trailer."]
    #[doc = " @param flags"]
    #[doc = "   The flags used for the mempool creation."]
    #[doc = "   Consult rte_mempool_create() for more information about possible values."]
    #[doc = "   The size of each element."]
    #[doc = " @param sz"]
    #[doc = "   The calculated detailed size the mempool object. May be NULL."]
    #[doc = " @return"]
    #[doc = "   Total size of the mempool object."]
    pub fn rte_mempool_calc_obj_size(elt_size: u32, flags: u32, sz: *mut rte_mempool_objsz) -> u32;
}
extern "C" {
    #[doc = " Walk list of all memory pools"]
    #[doc = ""]
    #[doc = " @param func"]
    #[doc = "   Iterator function"]
    #[doc = " @param arg"]
    #[doc = "   Argument passed to iterator"]
    pub fn rte_mempool_walk(
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut rte_mempool, arg: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @internal Get page size used for mempool object allocation."]
    #[doc = " This function is internal to mempool library and mempool drivers."]
    pub fn rte_mempool_get_page_size(
        mp: *mut rte_mempool,
        pg_sz: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " Mempool event type."]
#[doc = " @internal"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_mempool_event {
    #[doc = " Occurs after a mempool is fully populated."]
    RTE_MEMPOOL_EVENT_READY = 0,
    #[doc = " Occurs before the destruction of a mempool begins."]
    RTE_MEMPOOL_EVENT_DESTROY = 1,
}
#[doc = " @internal"]
#[doc = " Mempool event callback."]
#[doc = ""]
#[doc = " rte_mempool_event_callback_register() may be called from within the callback,"]
#[doc = " but the callbacks registered this way will not be invoked for the same event."]
#[doc = " rte_mempool_event_callback_unregister() may only be safely called"]
#[doc = " to remove the running callback."]
pub type rte_mempool_event_callback = ::std::option::Option<
    unsafe extern "C" fn(
        event: rte_mempool_event,
        mp: *mut rte_mempool,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @internal"]
    #[doc = " Register a callback function invoked on mempool life cycle event."]
    #[doc = " The function will be invoked in the process"]
    #[doc = " that performs an action which triggers the callback."]
    #[doc = ""]
    #[doc = " @param func"]
    #[doc = "   Callback function."]
    #[doc = " @param user_data"]
    #[doc = "   User data."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, negative on failure and rte_errno is set."]
    pub fn rte_mempool_event_callback_register(
        func: rte_mempool_event_callback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Unregister a callback added with rte_mempool_event_callback_register()."]
    #[doc = " @p func and @p user_data must exactly match registration parameters."]
    #[doc = ""]
    #[doc = " @param func"]
    #[doc = "   Callback function."]
    #[doc = " @param user_data"]
    #[doc = "   User data."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, negative on failure and rte_errno is set."]
    pub fn rte_mempool_event_callback_unregister(
        func: rte_mempool_event_callback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the name of the l2 packet type"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @return"]
    #[doc = "   A non-null string describing the packet type."]
    pub fn rte_get_ptype_l2_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the l3 packet type"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @return"]
    #[doc = "   A non-null string describing the packet type."]
    pub fn rte_get_ptype_l3_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the l4 packet type"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @return"]
    #[doc = "   A non-null string describing the packet type."]
    pub fn rte_get_ptype_l4_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the tunnel packet type"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @return"]
    #[doc = "   A non-null string describing the packet type."]
    pub fn rte_get_ptype_tunnel_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the inner_l2 packet type"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @return"]
    #[doc = "   A non-null string describing the packet type."]
    pub fn rte_get_ptype_inner_l2_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the inner_l3 packet type"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @return"]
    #[doc = "   A non-null string describing the packet type."]
    pub fn rte_get_ptype_inner_l3_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the inner_l4 packet type"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @return"]
    #[doc = "   A non-null string describing the packet type."]
    pub fn rte_get_ptype_inner_l4_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Write the packet type name into the buffer"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @param buf"]
    #[doc = "   The buffer where the string is written."]
    #[doc = " @param buflen"]
    #[doc = "   The length of the buffer."]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - (-1) if the buffer is too small"]
    pub fn rte_get_ptype_name(
        ptype: u32,
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf_sched {
    #[doc = "< Queue ID."]
    pub queue_id: u32,
    pub traffic_class: u8,
    pub color: u8,
    #[doc = "< Reserved."]
    pub reserved: u16,
}
pub const RTE_MBUF_L2_LEN_BITS: _bindgen_ty_15 = _bindgen_ty_15::RTE_MBUF_L2_LEN_BITS;
pub const RTE_MBUF_L3_LEN_BITS: _bindgen_ty_15 = _bindgen_ty_15::RTE_MBUF_L3_LEN_BITS;
pub const RTE_MBUF_L4_LEN_BITS: _bindgen_ty_15 = _bindgen_ty_15::RTE_MBUF_L4_LEN_BITS;
pub const RTE_MBUF_TSO_SEGSZ_BITS: _bindgen_ty_15 = _bindgen_ty_15::RTE_MBUF_TSO_SEGSZ_BITS;
pub const RTE_MBUF_OUTL3_LEN_BITS: _bindgen_ty_15 = _bindgen_ty_15::RTE_MBUF_L3_LEN_BITS;
pub const RTE_MBUF_OUTL2_LEN_BITS: _bindgen_ty_15 = _bindgen_ty_15::RTE_MBUF_L2_LEN_BITS;
pub const RTE_MBUF_TXOFLD_UNUSED_BITS: _bindgen_ty_15 = _bindgen_ty_15::RTE_MBUF_L4_LEN_BITS;
pub const RTE_MBUF_L2_LEN_OFS: _bindgen_ty_15 = _bindgen_ty_15::RTE_MBUF_L2_LEN_OFS;
pub const RTE_MBUF_L3_LEN_OFS: _bindgen_ty_15 = _bindgen_ty_15::RTE_MBUF_L2_LEN_BITS;
pub const RTE_MBUF_L4_LEN_OFS: _bindgen_ty_15 = _bindgen_ty_15::RTE_MBUF_TSO_SEGSZ_BITS;
pub const RTE_MBUF_TSO_SEGSZ_OFS: _bindgen_ty_15 = _bindgen_ty_15::RTE_MBUF_TSO_SEGSZ_OFS;
pub const RTE_MBUF_OUTL3_LEN_OFS: _bindgen_ty_15 = _bindgen_ty_15::RTE_MBUF_OUTL3_LEN_OFS;
pub const RTE_MBUF_OUTL2_LEN_OFS: _bindgen_ty_15 = _bindgen_ty_15::RTE_MBUF_OUTL2_LEN_OFS;
pub const RTE_MBUF_TXOFLD_UNUSED_OFS: _bindgen_ty_15 = _bindgen_ty_15::RTE_MBUF_TXOFLD_UNUSED_OFS;
#[repr(u32)]
#[doc = " enum for the tx_offload bit-fields lengths and offsets."]
#[doc = " defines the layout of rte_mbuf tx_offload field."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_15 {
    RTE_MBUF_L2_LEN_BITS = 7,
    RTE_MBUF_L3_LEN_BITS = 9,
    RTE_MBUF_L4_LEN_BITS = 8,
    RTE_MBUF_TSO_SEGSZ_BITS = 16,
    RTE_MBUF_L2_LEN_OFS = 0,
    RTE_MBUF_TSO_SEGSZ_OFS = 24,
    RTE_MBUF_OUTL3_LEN_OFS = 40,
    RTE_MBUF_OUTL2_LEN_OFS = 49,
    RTE_MBUF_TXOFLD_UNUSED_OFS = 56,
}
#[doc = " The generic rte_mbuf, containing a packet mbuf."]
#[repr(C)]
#[repr(align(64))]
pub struct rte_mbuf {
    pub cacheline0: RTE_MARKER,
    #[doc = "< Virtual address of segment buffer."]
    pub buf_addr: *mut ::std::os::raw::c_void,
    #[doc = " Physical address of segment buffer."]
    #[doc = " Force alignment to 8-bytes, so as to ensure we have the exact"]
    #[doc = " same mbuf cacheline0 layout for 32-bit and 64-bit. This makes"]
    #[doc = " working on vector drivers easier."]
    pub buf_iova: rte_iova_t,
    pub rearm_data: RTE_MARKER64,
    pub data_off: u16,
    #[doc = " Reference counter. Its size should at least equal to the size"]
    #[doc = " of port field (16 bits), to support zero-copy broadcast."]
    #[doc = " It should only be accessed using the following functions:"]
    #[doc = " rte_mbuf_refcnt_update(), rte_mbuf_refcnt_read(), and"]
    #[doc = " rte_mbuf_refcnt_set(). The functionality of these functions (atomic,"]
    #[doc = " or non-atomic) is controlled by the RTE_MBUF_REFCNT_ATOMIC flag."]
    pub refcnt: u16,
    #[doc = " Number of segments. Only valid for the first segment of an mbuf"]
    #[doc = " chain."]
    pub nb_segs: u16,
    #[doc = " Input port (16 bits to support more than 256 virtual ports)."]
    #[doc = " The event eth Tx adapter uses this field to specify the output port."]
    pub port: u16,
    #[doc = "< Offload features."]
    pub ol_flags: u64,
    pub rx_descriptor_fields1: RTE_MARKER,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1,
    #[doc = "< Total pkt len: sum of all segments."]
    pub pkt_len: u32,
    #[doc = "< Amount of data in segment buffer."]
    pub data_len: u16,
    #[doc = " VLAN TCI (CPU order), valid if RTE_MBUF_F_RX_VLAN is set."]
    pub vlan_tci: u16,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2,
    #[doc = " Outer VLAN TCI (CPU order), valid if RTE_MBUF_F_RX_QINQ is set."]
    pub vlan_tci_outer: u16,
    #[doc = "< Length of segment buffer."]
    pub buf_len: u16,
    #[doc = "< Pool from which mbuf was allocated."]
    pub pool: *mut rte_mempool,
    pub cacheline1: RTE_MARKER,
    #[doc = " Next segment of scattered packet. Must be NULL in the last segment or"]
    #[doc = " in case of non-segmented packet."]
    pub next: *mut rte_mbuf,
    pub __bindgen_anon_3: rte_mbuf__bindgen_ty_3,
    #[doc = " Shared data for external buffer attached to mbuf. See"]
    #[doc = " rte_pktmbuf_attach_extbuf()."]
    pub shinfo: *mut rte_mbuf_ext_shared_info,
    #[doc = " Size of the application private data. In case of an indirect"]
    #[doc = " mbuf, it stores the direct mbuf private data size."]
    pub priv_size: u16,
    #[doc = " Timesync flags for use with IEEE1588."]
    pub timesync: u16,
    #[doc = "< Reserved for dynamic fields."]
    pub dynfield1: [u32; 9usize],
}

unsafe impl Send for rte_mbuf {}

#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_1 {
    #[doc = "< L2/L3/L4 and tunnel information."]
    pub packet_type: u32,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub inner_esp_next_proto: u8,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn inner_l2_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_l3_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inner_l2_type: u8,
        inner_l3_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l2_type: u8 = unsafe { ::std::mem::transmute(inner_l2_type) };
            inner_l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let inner_l3_type: u8 = unsafe { ::std::mem::transmute(inner_l3_type) };
            inner_l3_type as u64
        });
        __bindgen_bitfield_unit
    }
}
impl rte_mbuf__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn l2_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn l3_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l4_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tun_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tun_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_type: u8,
        l3_type: u8,
        l4_type: u8,
        tun_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let l2_type: u8 = unsafe { ::std::mem::transmute(l2_type) };
            l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let l3_type: u8 = unsafe { ::std::mem::transmute(l3_type) };
            l3_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let l4_type: u8 = unsafe { ::std::mem::transmute(l4_type) };
            l4_type as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let tun_type: u8 = unsafe { ::std::mem::transmute(tun_type) };
            tun_type as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn inner_l4_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l4_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(inner_l4_type: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l4_type: u8 = unsafe { ::std::mem::transmute(inner_l4_type) };
            inner_l4_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2 {
    #[doc = "< hash information"]
    pub hash: rte_mbuf__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "< RSS hash result if RSS enabled"]
    pub rss: u32,
    #[doc = "< Filter identifier if FDIR enabled"]
    pub fdir: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub sched: rte_mbuf_sched,
    #[doc = "< Eventdev ethdev Tx adapter */"]
    pub txadapter: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    pub usr: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub hi: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1:
        rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub lo: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u16,
    pub id: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub reserved1: u32,
    pub reserved2: u16,
    pub txq: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_3 {
    #[doc = "< combined for easy fetch"]
    pub tx_offload: u64,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
}
impl rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_l4_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn tso_segsz(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_tso_segsz(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn outer_l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn outer_l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_len: u64,
        l3_len: u64,
        l4_len: u64,
        tso_segsz: u64,
        outer_l3_len: u64,
        outer_l2_len: u64,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let l2_len: u64 = unsafe { ::std::mem::transmute(l2_len) };
            l2_len as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let l3_len: u64 = unsafe { ::std::mem::transmute(l3_len) };
            l3_len as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let l4_len: u64 = unsafe { ::std::mem::transmute(l4_len) };
            l4_len as u64
        });
        __bindgen_bitfield_unit.set(24usize, 16u8, {
            let tso_segsz: u64 = unsafe { ::std::mem::transmute(tso_segsz) };
            tso_segsz as u64
        });
        __bindgen_bitfield_unit.set(40usize, 9u8, {
            let outer_l3_len: u64 = unsafe { ::std::mem::transmute(outer_l3_len) };
            outer_l3_len as u64
        });
        __bindgen_bitfield_unit.set(49usize, 7u8, {
            let outer_l2_len: u64 = unsafe { ::std::mem::transmute(outer_l2_len) };
            outer_l2_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Function typedef of callback to free externally attached buffer."]
pub type rte_mbuf_extbuf_free_callback_t = ::std::option::Option<
    unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, opaque: *mut ::std::os::raw::c_void),
>;
#[doc = " Shared data at the end of an external buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf_ext_shared_info {
    #[doc = "< Free callback function"]
    pub free_cb: rte_mbuf_extbuf_free_callback_t,
    #[doc = "< Free callback argument"]
    pub fcb_opaque: *mut ::std::os::raw::c_void,
    pub refcnt: u16,
}
extern "C" {
    #[doc = " Get the name of a RX offload flag"]
    #[doc = ""]
    #[doc = " @param mask"]
    #[doc = "   The mask describing the flag."]
    #[doc = " @return"]
    #[doc = "   The name of this flag, or NULL if it's not a valid RX flag."]
    pub fn rte_get_rx_ol_flag_name(mask: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Dump the list of RX offload flags in a buffer"]
    #[doc = ""]
    #[doc = " @param mask"]
    #[doc = "   The mask describing the RX flags."]
    #[doc = " @param buf"]
    #[doc = "   The output buffer."]
    #[doc = " @param buflen"]
    #[doc = "   The length of the buffer."]
    #[doc = " @return"]
    #[doc = "   0 on success, (-1) on error."]
    pub fn rte_get_rx_ol_flag_list(
        mask: u64,
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the name of a TX offload flag"]
    #[doc = ""]
    #[doc = " @param mask"]
    #[doc = "   The mask describing the flag. Usually only one bit must be set."]
    #[doc = "   Several bits can be given if they belong to the same mask."]
    #[doc = "   Ex: RTE_MBUF_F_TX_L4_MASK."]
    #[doc = " @return"]
    #[doc = "   The name of this flag, or NULL if it's not a valid TX flag."]
    pub fn rte_get_tx_ol_flag_name(mask: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Dump the list of TX offload flags in a buffer"]
    #[doc = ""]
    #[doc = " @param mask"]
    #[doc = "   The mask describing the TX flags."]
    #[doc = " @param buf"]
    #[doc = "   The output buffer."]
    #[doc = " @param buflen"]
    #[doc = "   The length of the buffer."]
    #[doc = " @return"]
    #[doc = "   0 on success, (-1) on error."]
    pub fn rte_get_tx_ol_flag_list(
        mask: u64,
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Private data in case of pktmbuf pool."]
#[doc = ""]
#[doc = " A structure that contains some pktmbuf_pool-specific data that are"]
#[doc = " appended after the mempool structure (in private data)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pktmbuf_pool_private {
    #[doc = "< Size of data space in each mbuf."]
    pub mbuf_data_room_size: u16,
    #[doc = "< Size of private area in each mbuf."]
    pub mbuf_priv_size: u16,
    #[doc = "< reserved for future use."]
    pub flags: u32,
}
extern "C" {
    #[doc = " Sanity checks on an mbuf."]
    #[doc = ""]
    #[doc = " Check the consistency of the given mbuf. The function will cause a"]
    #[doc = " panic if corruption is detected."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The mbuf to be checked."]
    #[doc = " @param is_header"]
    #[doc = "   True if the mbuf is a packet header, false if it is a sub-segment"]
    #[doc = "   of a packet (in this case, some fields like nb_segs are not checked)"]
    pub fn rte_mbuf_sanity_check(m: *const rte_mbuf, is_header: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Sanity checks on a mbuf."]
    #[doc = ""]
    #[doc = " Almost like rte_mbuf_sanity_check(), but this function gives the reason"]
    #[doc = " if corruption is detected rather than panic."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The mbuf to be checked."]
    #[doc = " @param is_header"]
    #[doc = "   True if the mbuf is a packet header, false if it is a sub-segment"]
    #[doc = "   of a packet (in this case, some fields like nb_segs are not checked)"]
    #[doc = " @param reason"]
    #[doc = "   A reference to a string pointer where to store the reason why a mbuf is"]
    #[doc = "   considered invalid."]
    #[doc = " @return"]
    #[doc = "   - 0 if no issue has been found, reason is left untouched."]
    #[doc = "   - -1 if a problem is detected, reason then points to a string describing"]
    #[doc = "     the reason why the mbuf is deemed invalid."]
    pub fn rte_mbuf_check(
        m: *const rte_mbuf,
        is_header: ::std::os::raw::c_int,
        reason: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The packet mbuf constructor."]
    #[doc = ""]
    #[doc = " This function initializes some fields in the mbuf structure that are"]
    #[doc = " not modified by the user once created (origin pool, buffer start"]
    #[doc = " address, and so on). This function is given as a callback function to"]
    #[doc = " rte_mempool_obj_iter() or rte_mempool_create() at pool creation time."]
    #[doc = ""]
    #[doc = " This function expects that the mempool private area was previously"]
    #[doc = " initialized with rte_pktmbuf_pool_init()."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   The mempool from which mbufs originate."]
    #[doc = " @param opaque_arg"]
    #[doc = "   A pointer that can be used by the user to retrieve useful information"]
    #[doc = "   for mbuf initialization. This pointer is the opaque argument passed to"]
    #[doc = "   rte_mempool_obj_iter() or rte_mempool_create()."]
    #[doc = " @param m"]
    #[doc = "   The mbuf to initialize."]
    #[doc = " @param i"]
    #[doc = "   The index of the mbuf in the pool table."]
    pub fn rte_pktmbuf_init(
        mp: *mut rte_mempool,
        opaque_arg: *mut ::std::os::raw::c_void,
        m: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " A packet mbuf pool constructor."]
    #[doc = ""]
    #[doc = " This function initializes the mempool private data in the case of a"]
    #[doc = " pktmbuf pool. This private data is needed by the driver. The"]
    #[doc = " function must be called on the mempool before it is used, or it"]
    #[doc = " can be given as a callback function to rte_mempool_create() at"]
    #[doc = " pool creation. It can be extended by the user, for example, to"]
    #[doc = " provide another packet size."]
    #[doc = ""]
    #[doc = " The mempool private area size must be at least equal to"]
    #[doc = " sizeof(struct rte_pktmbuf_pool_private)."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   The mempool from which mbufs originate."]
    #[doc = " @param opaque_arg"]
    #[doc = "   A pointer that can be used by the user to retrieve useful information"]
    #[doc = "   for mbuf initialization. This pointer is the opaque argument passed to"]
    #[doc = "   rte_mempool_create()."]
    pub fn rte_pktmbuf_pool_init(mp: *mut rte_mempool, opaque_arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Create a mbuf pool."]
    #[doc = ""]
    #[doc = " This function creates and initializes a packet mbuf pool. It is"]
    #[doc = " a wrapper to rte_mempool functions."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the mbuf pool."]
    #[doc = " @param n"]
    #[doc = "   The number of elements in the mbuf pool. The optimum size (in terms"]
    #[doc = "   of memory usage) for a mempool is when n is a power of two minus one:"]
    #[doc = "   n = (2^q - 1)."]
    #[doc = " @param cache_size"]
    #[doc = "   Size of the per-core object cache. See rte_mempool_create() for"]
    #[doc = "   details."]
    #[doc = " @param priv_size"]
    #[doc = "   Size of application private are between the rte_mbuf structure"]
    #[doc = "   and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN."]
    #[doc = " @param data_room_size"]
    #[doc = "   Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM."]
    #[doc = " @param socket_id"]
    #[doc = "   The socket identifier where the memory should be allocated. The"]
    #[doc = "   value can be *SOCKET_ID_ANY* if there is no NUMA constraint for the"]
    #[doc = "   reserved zone."]
    #[doc = " @return"]
    #[doc = "   The pointer to the new allocated mempool, on success. NULL on error"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - EINVAL - cache size provided is too large, or priv_size is not aligned."]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_pktmbuf_pool_create(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        priv_size: u16,
        data_room_size: u16,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Create a mbuf pool with a given mempool ops name"]
    #[doc = ""]
    #[doc = " This function creates and initializes a packet mbuf pool. It is"]
    #[doc = " a wrapper to rte_mempool functions."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the mbuf pool."]
    #[doc = " @param n"]
    #[doc = "   The number of elements in the mbuf pool. The optimum size (in terms"]
    #[doc = "   of memory usage) for a mempool is when n is a power of two minus one:"]
    #[doc = "   n = (2^q - 1)."]
    #[doc = " @param cache_size"]
    #[doc = "   Size of the per-core object cache. See rte_mempool_create() for"]
    #[doc = "   details."]
    #[doc = " @param priv_size"]
    #[doc = "   Size of application private are between the rte_mbuf structure"]
    #[doc = "   and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN."]
    #[doc = " @param data_room_size"]
    #[doc = "   Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM."]
    #[doc = " @param socket_id"]
    #[doc = "   The socket identifier where the memory should be allocated. The"]
    #[doc = "   value can be *SOCKET_ID_ANY* if there is no NUMA constraint for the"]
    #[doc = "   reserved zone."]
    #[doc = " @param ops_name"]
    #[doc = "   The mempool ops name to be used for this mempool instead of"]
    #[doc = "   default mempool. The value can be *NULL* to use default mempool."]
    #[doc = " @return"]
    #[doc = "   The pointer to the new allocated mempool, on success. NULL on error"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - EINVAL - cache size provided is too large, or priv_size is not aligned."]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_pktmbuf_pool_create_by_ops(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        priv_size: u16,
        data_room_size: u16,
        socket_id: ::std::os::raw::c_int,
        ops_name: *const ::std::os::raw::c_char,
    ) -> *mut rte_mempool;
}
#[doc = " A structure that describes the pinned external buffer segment."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pktmbuf_extmem {
    #[doc = "< The virtual address of data buffer."]
    pub buf_ptr: *mut ::std::os::raw::c_void,
    #[doc = "< The IO address of the data buffer."]
    pub buf_iova: rte_iova_t,
    #[doc = "< External buffer length in bytes."]
    pub buf_len: size_t,
    #[doc = "< mbuf element size in bytes."]
    pub elt_size: u16,
}
extern "C" {
    #[doc = " Create a mbuf pool with external pinned data buffers."]
    #[doc = ""]
    #[doc = " This function creates and initializes a packet mbuf pool that contains"]
    #[doc = " only mbufs with external buffer. It is a wrapper to rte_mempool functions."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the mbuf pool."]
    #[doc = " @param n"]
    #[doc = "   The number of elements in the mbuf pool. The optimum size (in terms"]
    #[doc = "   of memory usage) for a mempool is when n is a power of two minus one:"]
    #[doc = "   n = (2^q - 1)."]
    #[doc = " @param cache_size"]
    #[doc = "   Size of the per-core object cache. See rte_mempool_create() for"]
    #[doc = "   details."]
    #[doc = " @param priv_size"]
    #[doc = "   Size of application private are between the rte_mbuf structure"]
    #[doc = "   and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN."]
    #[doc = " @param data_room_size"]
    #[doc = "   Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM."]
    #[doc = " @param socket_id"]
    #[doc = "   The socket identifier where the memory should be allocated. The"]
    #[doc = "   value can be *SOCKET_ID_ANY* if there is no NUMA constraint for the"]
    #[doc = "   reserved zone."]
    #[doc = " @param ext_mem"]
    #[doc = "   Pointer to the array of structures describing the external memory"]
    #[doc = "   for data buffers. It is caller responsibility to register this memory"]
    #[doc = "   with rte_extmem_register() (if needed), map this memory to appropriate"]
    #[doc = "   physical device, etc."]
    #[doc = " @param ext_num"]
    #[doc = "   Number of elements in the ext_mem array."]
    #[doc = " @return"]
    #[doc = "   The pointer to the new allocated mempool, on success. NULL on error"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - EINVAL - cache size provided is too large, or priv_size is not aligned."]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_pktmbuf_pool_create_extbuf(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        priv_size: u16,
        data_room_size: u16,
        socket_id: ::std::os::raw::c_int,
        ext_mem: *const rte_pktmbuf_extmem,
        ext_num: ::std::os::raw::c_uint,
    ) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Free a bulk of packet mbufs back into their original mempools."]
    #[doc = ""]
    #[doc = " Free a bulk of mbufs, and all their segments in case of chained buffers."]
    #[doc = " Each segment is added back into its original mempool."]
    #[doc = ""]
    #[doc = "  @param mbufs"]
    #[doc = "    Array of pointers to packet mbufs."]
    #[doc = "    The array may contain NULL pointers."]
    #[doc = "  @param count"]
    #[doc = "    Array size."]
    pub fn rte_pktmbuf_free_bulk(mbufs: *mut *mut rte_mbuf, count: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Create a \"clone\" of the given packet mbuf."]
    #[doc = ""]
    #[doc = " Walks through all segments of the given packet mbuf, and for each of them:"]
    #[doc = "  - Creates a new packet mbuf from the given pool."]
    #[doc = "  - Attaches newly created mbuf to the segment."]
    #[doc = " Then updates pkt_len and nb_segs of the \"clone\" packet mbuf to match values"]
    #[doc = " from the original packet mbuf."]
    #[doc = ""]
    #[doc = " @param md"]
    #[doc = "   The packet mbuf to be cloned."]
    #[doc = " @param mp"]
    #[doc = "   The mempool from which the \"clone\" mbufs are allocated."]
    #[doc = " @return"]
    #[doc = "   - The pointer to the new \"clone\" mbuf on success."]
    #[doc = "   - NULL if allocation fails."]
    pub fn rte_pktmbuf_clone(md: *mut rte_mbuf, mp: *mut rte_mempool) -> *mut rte_mbuf;
}
extern "C" {
    #[doc = " Create a full copy of a given packet mbuf."]
    #[doc = ""]
    #[doc = " Copies all the data from a given packet mbuf to a newly allocated"]
    #[doc = " set of mbufs. The private data are is not copied."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf to be copied."]
    #[doc = " @param mp"]
    #[doc = "   The mempool from which the \"clone\" mbufs are allocated."]
    #[doc = " @param offset"]
    #[doc = "   The number of bytes to skip before copying."]
    #[doc = "   If the mbuf does not have that many bytes, it is an error"]
    #[doc = "   and NULL is returned."]
    #[doc = " @param length"]
    #[doc = "   The upper limit on bytes to copy.  Passing UINT32_MAX"]
    #[doc = "   means all data (after offset)."]
    #[doc = " @return"]
    #[doc = "   - The pointer to the new \"clone\" mbuf on success."]
    #[doc = "   - NULL if allocation fails."]
    pub fn rte_pktmbuf_copy(
        m: *const rte_mbuf,
        mp: *mut rte_mempool,
        offset: u32,
        length: u32,
    ) -> *mut rte_mbuf;
}
extern "C" {
    #[doc = " @internal used by rte_pktmbuf_read()."]
    pub fn __rte_pktmbuf_read(
        m: *const rte_mbuf,
        off: u32,
        len: u32,
        buf: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @internal used by rte_pktmbuf_linearize()."]
    pub fn __rte_pktmbuf_linearize(mbuf: *mut rte_mbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump an mbuf structure to a file."]
    #[doc = ""]
    #[doc = " Dump all fields for the given packet mbuf and all its associated"]
    #[doc = " segments (in the case of a chained buffer)."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf."]
    #[doc = " @param dump_len"]
    #[doc = "   If dump_len != 0, also dump the \"dump_len\" first data bytes of"]
    #[doc = "   the packet."]
    pub fn rte_pktmbuf_dump(f: *mut FILE, m: *const rte_mbuf, dump_len: ::std::os::raw::c_uint);
}
#[repr(u32)]
#[doc = " Flags for turbo decoder operation and capability structure"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_bbdev_op_td_flag_bitmasks {
    #[doc = " If sub block de-interleaving is to be performed."]
    RTE_BBDEV_TURBO_SUBBLOCK_DEINTERLEAVE = 1,
    #[doc = " To use CRC Type 24B (otherwise use CRC Type 24A)."]
    RTE_BBDEV_TURBO_CRC_TYPE_24B = 2,
    #[doc = " If turbo equalization is to be performed."]
    RTE_BBDEV_TURBO_EQUALIZER = 4,
    #[doc = " If set, saturate soft output to +/-127"]
    RTE_BBDEV_TURBO_SOFT_OUT_SATURATE = 8,
    #[doc = " Set to 1 to start iteration from even, else odd; one iteration ="]
    #[doc = " max_iteration + 0.5"]
    RTE_BBDEV_TURBO_HALF_ITERATION_EVEN = 16,
    #[doc = " If 0, TD stops after CRC matches; else if 1, runs to end of next"]
    #[doc = " odd iteration after CRC matches"]
    RTE_BBDEV_TURBO_CONTINUE_CRC_MATCH = 32,
    #[doc = " Set if soft output is required to be output"]
    RTE_BBDEV_TURBO_SOFT_OUTPUT = 64,
    #[doc = " Set to enable early termination mode"]
    RTE_BBDEV_TURBO_EARLY_TERMINATION = 128,
    #[doc = " Set if a device supports decoder dequeue interrupts"]
    RTE_BBDEV_TURBO_DEC_INTERRUPTS = 512,
    #[doc = " Set if positive LLR encoded input is supported. Positive LLR value"]
    #[doc = " represents the level of confidence for bit '1', and vice versa for"]
    #[doc = " bit '0'."]
    #[doc = " This is mutually exclusive with RTE_BBDEV_TURBO_NEG_LLR_1_BIT_IN"]
    #[doc = " when used to formalize the input data format."]
    RTE_BBDEV_TURBO_POS_LLR_1_BIT_IN = 1024,
    #[doc = " Set if negative LLR encoded input is supported. Negative LLR value"]
    #[doc = " represents the level of confidence for bit '1', and vice versa for"]
    #[doc = " bit '0'."]
    #[doc = " This is mutually exclusive with RTE_BBDEV_TURBO_POS_LLR_1_BIT_IN"]
    #[doc = " when used to formalize the input data format."]
    RTE_BBDEV_TURBO_NEG_LLR_1_BIT_IN = 2048,
    #[doc = " Set if positive LLR soft output is supported. Positive LLR value"]
    #[doc = " represents the level of confidence for bit '1', and vice versa for"]
    #[doc = " bit '0'."]
    #[doc = " This is mutually exclusive with"]
    #[doc = " RTE_BBDEV_TURBO_NEG_LLR_1_BIT_SOFT_OUT when used to formalize"]
    #[doc = " the input data format."]
    RTE_BBDEV_TURBO_POS_LLR_1_BIT_SOFT_OUT = 4096,
    #[doc = " Set if negative LLR soft output is supported. Negative LLR value"]
    #[doc = " represents the level of confidence for bit '1', and vice versa for"]
    #[doc = " bit '0'."]
    #[doc = " This is mutually exclusive with"]
    #[doc = " RTE_BBDEV_TURBO_POS_LLR_1_BIT_SOFT_OUT when used to formalize the"]
    #[doc = " input data format."]
    RTE_BBDEV_TURBO_NEG_LLR_1_BIT_SOFT_OUT = 8192,
    #[doc = " Set if driver supports flexible parallel MAP engine decoding. If"]
    #[doc = " not supported, num_maps (number of MAP engines) argument is unusable."]
    RTE_BBDEV_TURBO_MAP_DEC = 16384,
    #[doc = " Set if a device supports scatter-gather functionality"]
    RTE_BBDEV_TURBO_DEC_SCATTER_GATHER = 32768,
    #[doc = " Set to keep CRC24B bits appended while decoding. Only usable when"]
    #[doc = " decoding Transport Block mode."]
    RTE_BBDEV_TURBO_DEC_TB_CRC_24B_KEEP = 65536,
    #[doc = " Set to drop CRC24B bits not to be appended while decoding."]
    RTE_BBDEV_TURBO_DEC_CRC_24B_DROP = 131072,
}
#[repr(u32)]
#[doc = " Flags for turbo encoder operation and capability structure"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_bbdev_op_te_flag_bitmasks {
    #[doc = " Ignore rv_index and set K0 = 0"]
    RTE_BBDEV_TURBO_RV_INDEX_BYPASS = 1,
    #[doc = " If rate matching is to be performed"]
    RTE_BBDEV_TURBO_RATE_MATCH = 2,
    #[doc = " This bit must be set to enable CRC-24B generation"]
    RTE_BBDEV_TURBO_CRC_24B_ATTACH = 4,
    #[doc = " This bit must be set to enable CRC-24A generation"]
    RTE_BBDEV_TURBO_CRC_24A_ATTACH = 8,
    #[doc = " Set if a device supports encoder dequeue interrupts"]
    RTE_BBDEV_TURBO_ENC_INTERRUPTS = 16,
    #[doc = " Set if a device supports scatter-gather functionality"]
    RTE_BBDEV_TURBO_ENC_SCATTER_GATHER = 32,
}
#[repr(u32)]
#[doc = " Flags for LDPC decoder operation and capability structure"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_bbdev_op_ldpcdec_flag_bitmasks {
    #[doc = " Set for transport block CRC-24A checking"]
    RTE_BBDEV_LDPC_CRC_TYPE_24A_CHECK = 1,
    #[doc = " Set for code block CRC-24B checking"]
    RTE_BBDEV_LDPC_CRC_TYPE_24B_CHECK = 2,
    #[doc = " Set to drop the last CRC bits decoding output"]
    RTE_BBDEV_LDPC_CRC_TYPE_24B_DROP = 4,
    #[doc = " Set for transport block CRC-16 checking"]
    RTE_BBDEV_LDPC_CRC_TYPE_16_CHECK = 8,
    #[doc = " Set for bit-level de-interleaver bypass on Rx stream."]
    RTE_BBDEV_LDPC_DEINTERLEAVER_BYPASS = 16,
    #[doc = " Set for HARQ combined input stream enable."]
    RTE_BBDEV_LDPC_HQ_COMBINE_IN_ENABLE = 32,
    #[doc = " Set for HARQ combined output stream enable."]
    RTE_BBDEV_LDPC_HQ_COMBINE_OUT_ENABLE = 64,
    #[doc = " Set for LDPC decoder bypass."]
    #[doc = "  RTE_BBDEV_LDPC_HQ_COMBINE_OUT_ENABLE must be set."]
    RTE_BBDEV_LDPC_DECODE_BYPASS = 128,
    #[doc = " Set for soft-output stream enable"]
    RTE_BBDEV_LDPC_SOFT_OUT_ENABLE = 256,
    #[doc = " Set for Rate-Matching bypass on soft-out stream."]
    RTE_BBDEV_LDPC_SOFT_OUT_RM_BYPASS = 512,
    #[doc = " Set for bit-level de-interleaver bypass on soft-output stream."]
    RTE_BBDEV_LDPC_SOFT_OUT_DEINTERLEAVER_BYPASS = 1024,
    #[doc = " Set for iteration stopping on successful decode condition"]
    #[doc = "  i.e. a successful syndrome check."]
    RTE_BBDEV_LDPC_ITERATION_STOP_ENABLE = 2048,
    #[doc = " Set if a device supports decoder dequeue interrupts."]
    RTE_BBDEV_LDPC_DEC_INTERRUPTS = 4096,
    #[doc = " Set if a device supports scatter-gather functionality."]
    RTE_BBDEV_LDPC_DEC_SCATTER_GATHER = 8192,
    #[doc = " Set if a device supports input/output HARQ compression."]
    RTE_BBDEV_LDPC_HARQ_6BIT_COMPRESSION = 16384,
    #[doc = " Set if a device supports input LLR compression."]
    RTE_BBDEV_LDPC_LLR_COMPRESSION = 32768,
    #[doc = " Set if a device supports HARQ input from"]
    #[doc = "  device's internal memory."]
    RTE_BBDEV_LDPC_INTERNAL_HARQ_MEMORY_IN_ENABLE = 65536,
    #[doc = " Set if a device supports HARQ output to"]
    #[doc = "  device's internal memory."]
    RTE_BBDEV_LDPC_INTERNAL_HARQ_MEMORY_OUT_ENABLE = 131072,
    #[doc = " Set if a device supports loop-back access to"]
    #[doc = "  HARQ internal memory. Intended for troubleshooting."]
    RTE_BBDEV_LDPC_INTERNAL_HARQ_MEMORY_LOOPBACK = 262144,
    #[doc = " Set if a device includes LLR filler bits in the circular buffer"]
    #[doc = "  for HARQ memory. If not set, it is assumed the filler bits are not"]
    #[doc = "  in HARQ memory and handled directly by the LDPC decoder."]
    RTE_BBDEV_LDPC_INTERNAL_HARQ_MEMORY_FILLERS = 524288,
}
#[repr(u32)]
#[doc = " Flags for LDPC encoder operation and capability structure"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_bbdev_op_ldpcenc_flag_bitmasks {
    #[doc = " Set for bit-level interleaver bypass on output stream."]
    RTE_BBDEV_LDPC_INTERLEAVER_BYPASS = 1,
    #[doc = " If rate matching is to be performed"]
    RTE_BBDEV_LDPC_RATE_MATCH = 2,
    #[doc = " Set for transport block CRC-24A attach"]
    RTE_BBDEV_LDPC_CRC_24A_ATTACH = 4,
    #[doc = " Set for code block CRC-24B attach"]
    RTE_BBDEV_LDPC_CRC_24B_ATTACH = 8,
    #[doc = " Set for code block CRC-16 attach"]
    RTE_BBDEV_LDPC_CRC_16_ATTACH = 16,
    #[doc = " Set if a device supports encoder dequeue interrupts."]
    RTE_BBDEV_LDPC_ENC_INTERRUPTS = 32,
    #[doc = " Set if a device supports scatter-gather functionality."]
    RTE_BBDEV_LDPC_ENC_SCATTER_GATHER = 64,
    #[doc = " Set if a device supports concatenation of non byte aligned output"]
    RTE_BBDEV_LDPC_ENC_CONCATENATION = 128,
}
#[repr(u32)]
#[doc = " Flags for the Code Block/Transport block mode"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_bbdev_op_cb_mode {
    #[doc = " One operation is one or fraction of one transport block"]
    RTE_BBDEV_TRANSPORT_BLOCK = 0,
    #[doc = " One operation is one code block mode"]
    RTE_BBDEV_CODE_BLOCK = 1,
}
#[doc = " Data input and output buffer for BBDEV operations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_op_data {
    #[doc = " The mbuf data structure representing the data for BBDEV operation."]
    #[doc = ""]
    #[doc = " This mbuf pointer can point to one Code Block (CB) data buffer or"]
    #[doc = " multiple CBs contiguously located next to each other."]
    #[doc = " A Transport Block (TB) represents a whole piece of data that is"]
    #[doc = " divided into one or more CBs. Maximum number of CBs can be contained"]
    #[doc = " in one TB is defined by RTE_BBDEV_(TURBO/LDPC)_MAX_CODE_BLOCKS."]
    #[doc = ""]
    #[doc = " An mbuf data structure cannot represent more than one TB. The"]
    #[doc = " smallest piece of data that can be contained in one mbuf is one CB."]
    #[doc = " An mbuf can include one contiguous CB, subset of contiguous CBs that"]
    #[doc = " are belonging to one TB, or all contiguous CBs that are belonging to"]
    #[doc = " one TB."]
    #[doc = ""]
    #[doc = " If a BBDEV PMD supports the extended capability \"Scatter-Gather\","]
    #[doc = " then it is capable of collecting (gathering) non-contiguous"]
    #[doc = " (scattered) data from multiple locations in the memory."]
    #[doc = " This capability is reported by the capability flags:"]
    #[doc = " - RTE_BBDEV_(TURBO/LDPC)_ENC_SCATTER_GATHER and"]
    #[doc = " - RTE_BBDEV_(TURBO/LDPC)_DEC_SCATTER_GATHER."]
    #[doc = " Only if a BBDEV PMD supports this feature, chained mbuf data"]
    #[doc = " structures are accepted. A chained mbuf can represent one"]
    #[doc = " non-contiguous CB or multiple non-contiguous CBs."]
    #[doc = " If BBDEV PMD does not support this feature, it will assume inbound"]
    #[doc = " mbuf data contains one segment."]
    #[doc = ""]
    #[doc = " The output mbuf data though is always one segment, even if the input"]
    #[doc = " was a chained mbuf."]
    pub data: *mut rte_mbuf,
    #[doc = " The starting point of the BBDEV (encode/decode) operation,"]
    #[doc = " in bytes."]
    #[doc = ""]
    #[doc = " BBDEV starts to read data past this offset."]
    #[doc = " In case of chained mbuf, this offset applies only to the first mbuf"]
    #[doc = " segment."]
    pub offset: u32,
    #[doc = " The total data length to be processed in one operation, in bytes."]
    #[doc = ""]
    #[doc = " In case the mbuf data is representing one CB, this is the length of"]
    #[doc = " the CB undergoing the operation."]
    #[doc = " If it's for multiple CBs, this is the total length of those CBs"]
    #[doc = " undergoing the operation."]
    #[doc = " If it is for one TB, this is the total length of the TB under"]
    #[doc = " operation."]
    #[doc = ""]
    #[doc = " In case of chained mbuf, this data length includes the lengths of the"]
    #[doc = " \"scattered\" data segments undergoing the operation."]
    pub length: u32,
}
#[doc = " Turbo decode code block parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_op_dec_turbo_cb_params {
    #[doc = " The K size of the input CB, in bits [40:6144], as specified in"]
    #[doc = " 3GPP TS 36.212."]
    #[doc = " This size is inclusive of CRC bits, regardless whether it was"]
    #[doc = " pre-calculated by the application or not."]
    pub k: u16,
    #[doc = " The E length of the CB rate matched LLR output, in bytes, as in"]
    #[doc = " 3GPP TS 36.212."]
    pub e: u32,
}
#[doc = " LDPC decode code block parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_op_dec_ldpc_cb_params {
    #[doc = " Rate matching output sequence length in bits or LLRs."]
    #[doc = "  [3GPP TS38.212, section 5.4.2.1]"]
    pub e: u32,
}
#[doc = " Turbo decode transport block parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_op_dec_turbo_tb_params {
    #[doc = " The K- size of the input CB, in bits [40:6144], that is in the"]
    #[doc = " Turbo operation when r < C-, as in 3GPP TS 36.212."]
    pub k_neg: u16,
    #[doc = " The K+ size of the input CB, in bits [40:6144], that is in the"]
    #[doc = " Turbo operation when r >= C-, as in 3GPP TS 36.212."]
    pub k_pos: u16,
    #[doc = " The number of CBs that have K- size, [0:63]"]
    pub c_neg: u8,
    #[doc = " The total number of CBs in the TB,"]
    #[doc = " [1:RTE_BBDEV_TURBO_MAX_CODE_BLOCKS]"]
    pub c: u8,
    #[doc = " The number of CBs that uses Ea before switching to Eb, [0:63]"]
    pub cab: u8,
    #[doc = " The E size of the CB rate matched output to use in the Turbo"]
    #[doc = " operation when r < cab"]
    pub ea: u32,
    #[doc = " The E size of the CB rate matched output to use in the Turbo"]
    #[doc = " operation when r >= cab"]
    pub eb: u32,
    #[doc = " The index of the first CB in the inbound mbuf data, default is 0"]
    pub r: u8,
}
#[doc = " LDPC decode transport block parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_op_dec_ldpc_tb_params {
    #[doc = " Ea, length after rate matching in bits, r < cab."]
    #[doc = "  [3GPP TS38.212, section 5.4.2.1]"]
    pub ea: u32,
    #[doc = " Eb, length after rate matching in bits, r >= cab."]
    #[doc = "  [3GPP TS38.212, section 5.4.2.1]"]
    pub eb: u32,
    #[doc = " The total number of CBs in the TB or partial TB"]
    #[doc = " [1:RTE_BBDEV_LDPC_MAX_CODE_BLOCKS]"]
    pub c: u8,
    #[doc = " The index of the first CB in the inbound mbuf data, default is 0"]
    pub r: u8,
    #[doc = " The number of CBs that use Ea before switching to Eb, [0:63]"]
    pub cab: u8,
}
#[doc = " Operation structure for Turbo decode."]
#[doc = " An operation can be performed on one CB at a time \"CB-mode\"."]
#[doc = " An operation can be performed on one or multiple CBs that logically"]
#[doc = " belong to one TB \"TB-mode\"."]
#[doc = " The provided K size parameter of the CB is its size coming from the"]
#[doc = " decode operation."]
#[doc = " CRC24A/B check is requested by the application by setting the flag"]
#[doc = " RTE_BBDEV_TURBO_CRC_TYPE_24B for CRC24B check or CRC24A otherwise."]
#[doc = " In TB-mode, BBDEV concatenates the decoded CBs one next to the other with"]
#[doc = " relevant CRC24B in between."]
#[doc = ""]
#[doc = " The input encoded CB data is the Virtual Circular Buffer data stream, wk,"]
#[doc = " with the null padding included as described in 3GPP TS 36.212"]
#[doc = " section 5.1.4.1.2 and shown in 3GPP TS 36.212 section 5.1.4.1 Figure 5.1.4-1."]
#[doc = " The size of the virtual circular buffer is 3*Kpi, where Kpi is the 32 byte"]
#[doc = " aligned value of K, as specified in 3GPP TS 36.212 section 5.1.4.1.1."]
#[doc = ""]
#[doc = " Each byte in the input circular buffer is the LLR value of each bit of the"]
#[doc = " original CB."]
#[doc = ""]
#[doc = " Hard output is a mandatory capability that all BBDEV PMDs support. This is"]
#[doc = " the decoded CBs of K sizes (CRC24A/B is the last 24-bit in each decoded CB)."]
#[doc = " Soft output is an optional capability for BBDEV PMDs. If supported, an LLR"]
#[doc = " rate matched output is computed in the soft_output buffer structure."]
#[doc = ""]
#[doc = " The output mbuf data structure is expected to be allocated by the"]
#[doc = " application with enough room for the output data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_bbdev_op_turbo_dec {
    #[doc = " The Virtual Circular Buffer, wk, size 3*Kpi for each CB"]
    pub input: rte_bbdev_op_data,
    #[doc = " The hard decisions buffer for the decoded output,"]
    #[doc = " size K for each CB"]
    pub hard_output: rte_bbdev_op_data,
    #[doc = " The soft LLR output buffer - optional"]
    pub soft_output: rte_bbdev_op_data,
    #[doc = " Flags from rte_bbdev_op_td_flag_bitmasks"]
    pub op_flags: u32,
    #[doc = " Rv index for rate matching [0:3]"]
    pub rv_index: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " The maximum number of iterations that were performed in decoding"]
    #[doc = " all CBs in this decode operation - output"]
    pub iter_count: u8,
    #[doc = " 5 bit extrinsic scale (scale factor on extrinsic info)"]
    pub ext_scale: u8,
    #[doc = " Number of MAP engines to use in decode,"]
    #[doc = "  must be power of 2 (or 0 to auto-select)"]
    pub num_maps: u8,
    #[doc = " [0 - TB : 1 - CB]"]
    pub code_block_mode: u8,
    pub __bindgen_anon_1: rte_bbdev_op_turbo_dec__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_bbdev_op_turbo_dec__bindgen_ty_1 {
    #[doc = " Struct which stores Code Block specific parameters"]
    pub cb_params: rte_bbdev_op_dec_turbo_cb_params,
    #[doc = " Struct which stores Transport Block specific parameters"]
    pub tb_params: rte_bbdev_op_dec_turbo_tb_params,
}
impl rte_bbdev_op_turbo_dec {
    #[inline]
    pub fn iter_min(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_iter_min(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn iter_max(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_iter_max(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(iter_min: u8, iter_max: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let iter_min: u8 = unsafe { ::std::mem::transmute(iter_min) };
            iter_min as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let iter_max: u8 = unsafe { ::std::mem::transmute(iter_max) };
            iter_max as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Operation structure for LDPC decode."]
#[doc = ""]
#[doc = " An operation can be performed on one CB at a time \"CB-mode\"."]
#[doc = " An operation can also be performed on one or multiple CBs that logically"]
#[doc = " belong to a TB \"TB-mode\" (Currently not supported)."]
#[doc = ""]
#[doc = " The input encoded CB data is the Virtual Circular Buffer data stream."]
#[doc = ""]
#[doc = " Each byte in the input circular buffer is the LLR value of each bit of the"]
#[doc = " original CB."]
#[doc = ""]
#[doc = " Hard output is a mandatory capability that all BBDEV PMDs support. This is"]
#[doc = " the decoded CBs (CRC24A/B is the last 24-bit in each decoded CB)."]
#[doc = ""]
#[doc = " Soft output is an optional capability for BBDEV PMDs. If supported, an LLR"]
#[doc = " rate matched output is computed in the soft_output buffer structure."]
#[doc = " These are A Posteriori Probabilities (APP) LLR samples for coded bits."]
#[doc = ""]
#[doc = " HARQ combined output is an optional capability for BBDEV PMDs."]
#[doc = " If supported, a LLR output is streamed to the harq_combined_output"]
#[doc = " buffer."]
#[doc = ""]
#[doc = " HARQ combined input is an optional capability for BBDEV PMDs."]
#[doc = " If supported, a LLR input is streamed from the harq_combined_input"]
#[doc = " buffer."]
#[doc = ""]
#[doc = " The output mbuf data structure is expected to be allocated by the"]
#[doc = " application with enough room for the output data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_bbdev_op_ldpc_dec {
    #[doc = " The Virtual Circular Buffer for this code block, one LLR"]
    #[doc = " per bit of the original CB."]
    pub input: rte_bbdev_op_data,
    #[doc = " The hard decisions buffer for the decoded output,"]
    #[doc = " size K for each CB"]
    pub hard_output: rte_bbdev_op_data,
    #[doc = " The soft LLR output LLR stream buffer - optional"]
    pub soft_output: rte_bbdev_op_data,
    #[doc = " The HARQ combined LLR stream input buffer - optional"]
    pub harq_combined_input: rte_bbdev_op_data,
    #[doc = " The HARQ combined LLR stream output buffer - optional"]
    pub harq_combined_output: rte_bbdev_op_data,
    #[doc = " Flags from rte_bbdev_op_ldpcdec_flag_bitmasks"]
    pub op_flags: u32,
    #[doc = " Rate matching redundancy version"]
    #[doc = "  [3GPP TS38.212, section 5.4.2.1]"]
    pub rv_index: u8,
    #[doc = " The maximum number of iterations to perform in decoding CB in"]
    #[doc = "  this operation - input"]
    pub iter_max: u8,
    #[doc = " The number of iterations that were performed in decoding"]
    #[doc = " CB in this decode operation - output"]
    pub iter_count: u8,
    #[doc = " 1: LDPC Base graph 1, 2: LDPC Base graph 2."]
    #[doc = " [3GPP TS38.212, section 5.2.2]"]
    pub basegraph: u8,
    #[doc = " Zc, LDPC lifting size."]
    #[doc = "  [3GPP TS38.212, section 5.2.2]"]
    pub z_c: u16,
    #[doc = " Ncb, length of the circular buffer in bits."]
    #[doc = "  [3GPP TS38.212, section 5.4.2.1]"]
    pub n_cb: u16,
    #[doc = " Qm, modulation order {1,2,4,6,8}."]
    #[doc = "  [3GPP TS38.212, section 5.4.2.2]"]
    pub q_m: u8,
    #[doc = " Number of Filler bits, n_filler = K  K"]
    #[doc = "  [3GPP TS38.212 section 5.2.2]"]
    pub n_filler: u16,
    #[doc = " [0 - TB : 1 - CB]"]
    pub code_block_mode: u8,
    pub __bindgen_anon_1: rte_bbdev_op_ldpc_dec__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_bbdev_op_ldpc_dec__bindgen_ty_1 {
    #[doc = " Struct which stores Code Block specific parameters"]
    pub cb_params: rte_bbdev_op_dec_ldpc_cb_params,
    #[doc = " Struct which stores Transport Block specific parameters"]
    pub tb_params: rte_bbdev_op_dec_ldpc_tb_params,
}
#[doc = " Turbo encode code block parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_op_enc_turbo_cb_params {
    #[doc = " The K size of the input CB, in bits [40:6144], as specified in"]
    #[doc = " 3GPP TS 36.212."]
    #[doc = " This size is inclusive of CRC24A, regardless whether it was"]
    #[doc = " pre-calculated by the application or not."]
    pub k: u16,
    #[doc = " The E length of the CB rate matched output, in bits, as in"]
    #[doc = " 3GPP TS 36.212."]
    pub e: u32,
    #[doc = " The Ncb soft buffer size of the CB rate matched output [K:3*Kpi],"]
    #[doc = " in bits, as specified in 3GPP TS 36.212."]
    pub ncb: u16,
}
#[doc = " Turbo encode transport block parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_op_enc_turbo_tb_params {
    #[doc = " The K- size of the input CB, in bits [40:6144], that is in the"]
    #[doc = " Turbo operation when r < C-, as in 3GPP TS 36.212."]
    #[doc = " This size is inclusive of CRC24B, regardless whether it was"]
    #[doc = " pre-calculated and appended by the application or not."]
    pub k_neg: u16,
    #[doc = " The K+ size of the input CB, in bits [40:6144], that is in the"]
    #[doc = " Turbo operation when r >= C-, as in 3GPP TS 36.212."]
    #[doc = " This size is inclusive of CRC24B, regardless whether it was"]
    #[doc = " pre-calculated and appended by the application or not."]
    pub k_pos: u16,
    #[doc = " The number of CBs that have K- size, [0:63]"]
    pub c_neg: u8,
    #[doc = " The total number of CBs in the TB,"]
    #[doc = " [1:RTE_BBDEV_TURBO_MAX_CODE_BLOCKS]"]
    pub c: u8,
    #[doc = " The number of CBs that uses Ea before switching to Eb, [0:63]"]
    pub cab: u8,
    #[doc = " The E size of the CB rate matched output to use in the Turbo"]
    #[doc = " operation when r < cab"]
    pub ea: u32,
    #[doc = " The E size of the CB rate matched output to use in the Turbo"]
    #[doc = " operation when r >= cab"]
    pub eb: u32,
    #[doc = " The Ncb soft buffer size for the rate matched CB that is used in"]
    #[doc = " the Turbo operation when r < C-, [K:3*Kpi]"]
    pub ncb_neg: u16,
    #[doc = " The Ncb soft buffer size for the rate matched CB that is used in"]
    #[doc = " the Turbo operation when r >= C-, [K:3*Kpi]"]
    pub ncb_pos: u16,
    #[doc = " The index of the first CB in the inbound mbuf data, default is 0"]
    pub r: u8,
}
#[doc = " LDPC encode code block parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_op_enc_ldpc_cb_params {
    #[doc = " E, length after rate matching in bits."]
    #[doc = "  [3GPP TS38.212, section 5.4.2.1]"]
    pub e: u32,
}
#[doc = " LDPC encode transport block parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_op_enc_ldpc_tb_params {
    #[doc = " Ea, length after rate matching in bits, r < cab."]
    #[doc = "  [3GPP TS38.212, section 5.4.2.1]"]
    pub ea: u32,
    #[doc = " Eb, length after rate matching in bits, r >= cab."]
    #[doc = "  [3GPP TS38.212, section 5.4.2.1]"]
    pub eb: u32,
    #[doc = " The total number of CBs in the TB or partial TB"]
    #[doc = " [1:RTE_BBDEV_LDPC_MAX_CODE_BLOCKS]"]
    pub c: u8,
    #[doc = " The index of the first CB in the inbound mbuf data, default is 0"]
    pub r: u8,
    #[doc = " The number of CBs that use Ea before switching to Eb, [0:63]"]
    pub cab: u8,
}
#[doc = " Operation structure for Turbo encode."]
#[doc = " An operation can be performed on one CB at a time \"CB-mode\"."]
#[doc = " An operation can pbe erformd on one or multiple CBs that logically"]
#[doc = " belong to one TB \"TB-mode\"."]
#[doc = ""]
#[doc = " In CB-mode, CRC24A/B is an optional operation. K size parameter is not"]
#[doc = " affected by CRC24A/B inclusion, this only affects the inbound mbuf data"]
#[doc = " length. Not all BBDEV PMDs are capable of CRC24A/B calculation. Flags"]
#[doc = " RTE_BBDEV_TURBO_CRC_24A_ATTACH and RTE_BBDEV_TURBO_CRC_24B_ATTACH informs"]
#[doc = " the application with relevant capability. These flags can be set in the"]
#[doc = " op_flags parameter to indicate BBDEV to calculate and append CRC24A to CB"]
#[doc = " before going forward with Turbo encoding."]
#[doc = ""]
#[doc = " In TB-mode, CRC24A is assumed to be pre-calculated and appended to the"]
#[doc = " inbound TB mbuf data buffer."]
#[doc = ""]
#[doc = " The output mbuf data structure is expected to be allocated by the"]
#[doc = " application with enough room for the output data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_bbdev_op_turbo_enc {
    #[doc = " The input CB or TB data"]
    pub input: rte_bbdev_op_data,
    #[doc = " The rate matched CB or TB output buffer"]
    pub output: rte_bbdev_op_data,
    #[doc = " Flags from rte_bbdev_op_te_flag_bitmasks"]
    pub op_flags: u32,
    #[doc = " Rv index for rate matching [0:3]"]
    pub rv_index: u8,
    #[doc = " [0 - TB : 1 - CB]"]
    pub code_block_mode: u8,
    pub __bindgen_anon_1: rte_bbdev_op_turbo_enc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_bbdev_op_turbo_enc__bindgen_ty_1 {
    #[doc = " Struct which stores Code Block specific parameters"]
    pub cb_params: rte_bbdev_op_enc_turbo_cb_params,
    #[doc = " Struct which stores Transport Block specific parameters"]
    pub tb_params: rte_bbdev_op_enc_turbo_tb_params,
}
#[doc = " Operation structure for LDPC encode."]
#[doc = " An operation can be performed on one CB at a time \"CB-mode\"."]
#[doc = " An operation can be performed on one or multiple CBs that logically"]
#[doc = " belong to a TB \"TB-mode\"."]
#[doc = ""]
#[doc = " The input data is the CB or TB input to the decoder."]
#[doc = ""]
#[doc = " The output data is the ratematched CB or TB data, or the output after"]
#[doc = " bit-selection if RTE_BBDEV_LDPC_INTERLEAVER_BYPASS is set."]
#[doc = ""]
#[doc = " The output mbuf data structure is expected to be allocated by the"]
#[doc = " application with enough room for the output data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_bbdev_op_ldpc_enc {
    #[doc = " The input TB or CB data"]
    pub input: rte_bbdev_op_data,
    #[doc = " The rate matched TB or CB output buffer"]
    pub output: rte_bbdev_op_data,
    #[doc = " Flags from rte_bbdev_op_ldpcenc_flag_bitmasks"]
    pub op_flags: u32,
    #[doc = " Rate matching redundancy version"]
    pub rv_index: u8,
    #[doc = " 1: LDPC Base graph 1, 2: LDPC Base graph 2."]
    #[doc = "  [3GPP TS38.212, section 5.2.2]"]
    pub basegraph: u8,
    #[doc = " Zc, LDPC lifting size."]
    #[doc = "  [3GPP TS38.212, section 5.2.2]"]
    pub z_c: u16,
    #[doc = " Ncb, length of the circular buffer in bits."]
    #[doc = "  [3GPP TS38.212, section 5.4.2.1]"]
    pub n_cb: u16,
    #[doc = " Qm, modulation order {2,4,6,8,10}."]
    #[doc = "  [3GPP TS38.212, section 5.4.2.2]"]
    pub q_m: u8,
    #[doc = " Number of Filler bits, n_filler = K  K"]
    #[doc = "  [3GPP TS38.212 section 5.2.2]"]
    pub n_filler: u16,
    #[doc = " [0 - TB : 1 - CB]"]
    pub code_block_mode: u8,
    pub __bindgen_anon_1: rte_bbdev_op_ldpc_enc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_bbdev_op_ldpc_enc__bindgen_ty_1 {
    #[doc = " Struct which stores Code Block specific parameters"]
    pub cb_params: rte_bbdev_op_enc_ldpc_cb_params,
    #[doc = " Struct which stores Transport Block specific parameters"]
    pub tb_params: rte_bbdev_op_enc_ldpc_tb_params,
}
#[doc = " List of the capabilities for the Turbo Decoder"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_op_cap_turbo_dec {
    #[doc = " Flags from rte_bbdev_op_td_flag_bitmasks"]
    pub capability_flags: u32,
    #[doc = " Maximal LLR absolute value. Acceptable LLR values lie in range"]
    #[doc = " [-max_llr_modulus, max_llr_modulus]."]
    pub max_llr_modulus: i8,
    #[doc = "< Num input code block buffers"]
    pub num_buffers_src: u8,
    #[doc = " Num hard output code block buffers"]
    pub num_buffers_hard_out: u8,
    #[doc = " Num soft output code block buffers if supported by the driver"]
    pub num_buffers_soft_out: u8,
}
#[doc = " List of the capabilities for the Turbo Encoder"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_op_cap_turbo_enc {
    #[doc = " Flags from rte_bbdev_op_te_flag_bitmasks"]
    pub capability_flags: u32,
    #[doc = " Num input code block buffers"]
    pub num_buffers_src: u8,
    #[doc = " Num output code block buffers"]
    pub num_buffers_dst: u8,
}
#[doc = " List of the capabilities for the LDPC Decoder"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_op_cap_ldpc_dec {
    #[doc = " Flags from rte_bbdev_op_ldpcdec_flag_bitmasks"]
    pub capability_flags: u32,
    #[doc = " LLR size in bits. LLR is a twos complement number."]
    pub llr_size: i8,
    #[doc = " LLR numbers of decimals bit for arithmetic representation"]
    pub llr_decimals: i8,
    #[doc = " Num input code block buffers"]
    pub num_buffers_src: u16,
    #[doc = " Num hard output code block buffers"]
    pub num_buffers_hard_out: u16,
    #[doc = " Num soft output code block buffers if supported by the driver"]
    pub num_buffers_soft_out: u16,
}
#[doc = " List of the capabilities for the LDPC Encoder"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_op_cap_ldpc_enc {
    #[doc = " Flags from rte_bbdev_op_ldpcenc_flag_bitmasks"]
    pub capability_flags: u32,
    #[doc = " Num input code block buffers"]
    pub num_buffers_src: u16,
    #[doc = " Num output code block buffers"]
    pub num_buffers_dst: u16,
}
#[repr(u32)]
#[doc = " Different operation types supported by the device"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_bbdev_op_type {
    #[doc = "< Dummy operation that does nothing"]
    RTE_BBDEV_OP_NONE = 0,
    #[doc = "< Turbo decode"]
    RTE_BBDEV_OP_TURBO_DEC = 1,
    #[doc = "< Turbo encode"]
    RTE_BBDEV_OP_TURBO_ENC = 2,
    #[doc = "< LDPC decode"]
    RTE_BBDEV_OP_LDPC_DEC = 3,
    #[doc = "< LDPC encode"]
    RTE_BBDEV_OP_LDPC_ENC = 4,
    #[doc = "< Count of different op types"]
    RTE_BBDEV_OP_TYPE_COUNT = 5,
}
pub const RTE_BBDEV_DRV_ERROR: _bindgen_ty_16 = _bindgen_ty_16::RTE_BBDEV_DRV_ERROR;
pub const RTE_BBDEV_DATA_ERROR: _bindgen_ty_16 = _bindgen_ty_16::RTE_BBDEV_DATA_ERROR;
pub const RTE_BBDEV_CRC_ERROR: _bindgen_ty_16 = _bindgen_ty_16::RTE_BBDEV_CRC_ERROR;
pub const RTE_BBDEV_SYNDROME_ERROR: _bindgen_ty_16 = _bindgen_ty_16::RTE_BBDEV_SYNDROME_ERROR;
#[repr(u32)]
#[doc = " Bit indexes of possible errors reported through status field"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_16 {
    RTE_BBDEV_DRV_ERROR = 0,
    RTE_BBDEV_DATA_ERROR = 1,
    RTE_BBDEV_CRC_ERROR = 2,
    RTE_BBDEV_SYNDROME_ERROR = 3,
}
#[doc = " Structure specifying a single encode operation"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_bbdev_enc_op {
    #[doc = " Status of operation that was performed"]
    pub status: ::std::os::raw::c_int,
    #[doc = " Mempool which op instance is in"]
    pub mempool: *mut rte_mempool,
    #[doc = " Opaque pointer for user data"]
    pub opaque_data: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: rte_bbdev_enc_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_bbdev_enc_op__bindgen_ty_1 {
    #[doc = " Contains turbo decoder specific parameters"]
    pub turbo_enc: rte_bbdev_op_turbo_enc,
    #[doc = " Contains LDPC decoder specific parameters"]
    pub ldpc_enc: rte_bbdev_op_ldpc_enc,
}
#[doc = " Structure specifying a single decode operation"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_bbdev_dec_op {
    #[doc = " Status of operation that was performed"]
    pub status: ::std::os::raw::c_int,
    #[doc = " Mempool which op instance is in"]
    pub mempool: *mut rte_mempool,
    #[doc = " Opaque pointer for user data"]
    pub opaque_data: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: rte_bbdev_dec_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_bbdev_dec_op__bindgen_ty_1 {
    #[doc = " Contains turbo decoder specific parameters"]
    pub turbo_dec: rte_bbdev_op_turbo_dec,
    #[doc = " Contains LDPC decoder specific parameters"]
    pub ldpc_dec: rte_bbdev_op_ldpc_dec,
}
#[doc = " Operation capabilities supported by a device"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_bbdev_op_cap {
    #[doc = "< Type of operation"]
    pub type_: rte_bbdev_op_type,
    #[doc = "< Operation-type specific capabilities"]
    pub cap: rte_bbdev_op_cap__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_bbdev_op_cap__bindgen_ty_1 {
    pub turbo_dec: rte_bbdev_op_cap_turbo_dec,
    pub turbo_enc: rte_bbdev_op_cap_turbo_enc,
    pub ldpc_dec: rte_bbdev_op_cap_ldpc_dec,
    pub ldpc_enc: rte_bbdev_op_cap_ldpc_enc,
}
#[doc = " @internal Private data structure stored with operation pool."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_op_pool_private {
    #[doc = "< Type of operations in a pool"]
    pub type_: rte_bbdev_op_type,
}
extern "C" {
    #[doc = " Converts queue operation type from enum to string"]
    #[doc = ""]
    #[doc = " @param op_type"]
    #[doc = "   Operation type as enum"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "   Operation type as string or NULL if op_type is invalid"]
    #[doc = ""]
    pub fn rte_bbdev_op_type_str(op_type: rte_bbdev_op_type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Creates a bbdev operation mempool"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Pool name."]
    #[doc = " @param type"]
    #[doc = "   Operation type, use RTE_BBDEV_OP_NONE for a pool which supports all"]
    #[doc = "   operation types."]
    #[doc = " @param num_elements"]
    #[doc = "   Number of elements in the pool."]
    #[doc = " @param cache_size"]
    #[doc = "   Number of elements to cache on an lcore, see rte_mempool_create() for"]
    #[doc = "   further details about cache size."]
    #[doc = " @param socket_id"]
    #[doc = "   Socket to allocate memory on."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - Pointer to a mempool on success,"]
    #[doc = "   - NULL pointer on failure."]
    pub fn rte_bbdev_op_pool_create(
        name: *const ::std::os::raw::c_char,
        type_: rte_bbdev_op_type,
        num_elements: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_mempool;
}
#[repr(u32)]
#[doc = " Flags indicate current state of BBDEV device"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_bbdev_state {
    RTE_BBDEV_UNUSED = 0,
    RTE_BBDEV_INITIALIZED = 1,
}
extern "C" {
    #[doc = " Get the total number of devices that have been successfully initialised."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The total number of usable devices."]
    pub fn rte_bbdev_count() -> u16;
}
extern "C" {
    #[doc = " Check if a device is valid."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   true if device ID is valid and device is attached, false otherwise."]
    pub fn rte_bbdev_is_valid(dev_id: u16) -> bool;
}
extern "C" {
    #[doc = " Get the next enabled device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The current device"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - The next device, or"]
    #[doc = "   - RTE_BBDEV_MAX_DEVS if none found"]
    pub fn rte_bbdev_find_next(dev_id: u16) -> u16;
}
extern "C" {
    #[doc = " Setup up device queues."]
    #[doc = " This function must be called on a device before setting up the queues and"]
    #[doc = " starting the device. It can also be called when a device is in the stopped"]
    #[doc = " state. If any device queues have been configured their configuration will be"]
    #[doc = " cleared by a call to this function."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param num_queues"]
    #[doc = "   Number of queues to configure on device."]
    #[doc = " @param socket_id"]
    #[doc = "   ID of a socket which will be used to allocate memory."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - -ENODEV if dev_id is invalid or the device is corrupted"]
    #[doc = "   - -EINVAL if num_queues is invalid, 0 or greater than maximum"]
    #[doc = "   - -EBUSY if the identified device has already started"]
    #[doc = "   - -ENOMEM if unable to allocate memory"]
    pub fn rte_bbdev_setup_queues(
        dev_id: u16,
        num_queues: u16,
        socket_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable interrupts."]
    #[doc = " This function may be called before starting the device to enable the"]
    #[doc = " interrupts if they are available."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - -ENODEV if dev_id is invalid or the device is corrupted"]
    #[doc = "   - -EBUSY if the identified device has already started"]
    #[doc = "   - -ENOTSUP if the interrupts are not supported by the device"]
    pub fn rte_bbdev_intr_enable(dev_id: u16) -> ::std::os::raw::c_int;
}
#[doc = " Device queue configuration structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_queue_conf {
    #[doc = "< NUMA socket used for memory allocation"]
    pub socket: ::std::os::raw::c_int,
    #[doc = "< Size of queue"]
    pub queue_size: u32,
    #[doc = "< Queue priority"]
    pub priority: u8,
    #[doc = "< Do not start queue when device is started."]
    pub deferred_start: bool,
    #[doc = "< Operation type"]
    pub op_type: rte_bbdev_op_type,
}
extern "C" {
    #[doc = " Configure a queue on a device."]
    #[doc = " This function can be called after device configuration, and before starting."]
    #[doc = " It can also be called when the device or the queue is in the stopped state."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the queue."]
    #[doc = " @param conf"]
    #[doc = "   The queue configuration. If NULL, a default configuration will be used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - EINVAL if the identified queue size or priority are invalid"]
    #[doc = "   - EBUSY if the identified queue or its device have already started"]
    pub fn rte_bbdev_queue_configure(
        dev_id: u16,
        queue_id: u16,
        conf: *const rte_bbdev_queue_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start a device."]
    #[doc = " This is the last step needed before enqueueing operations is possible."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - negative value on failure - as returned from PMD"]
    pub fn rte_bbdev_start(dev_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop a device."]
    #[doc = " The device can be reconfigured, and restarted after being stopped."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    pub fn rte_bbdev_stop(dev_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close a device."]
    #[doc = " The device cannot be restarted without reconfiguration!"]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    pub fn rte_bbdev_close(dev_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start a specified queue on a device."]
    #[doc = " This is only needed if the queue has been stopped, or if the deferred_start"]
    #[doc = " flag has been set when configuring the queue."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the queue."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - negative value on failure - as returned from PMD"]
    pub fn rte_bbdev_queue_start(dev_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop a specified queue on a device, to allow re configuration."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the queue."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - negative value on failure - as returned from PMD"]
    pub fn rte_bbdev_queue_stop(dev_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
#[doc = " Device statistics."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_stats {
    #[doc = "< Count of all operations enqueued"]
    pub enqueued_count: u64,
    #[doc = "< Count of all operations dequeued"]
    pub dequeued_count: u64,
    #[doc = " Total error count on operations enqueued"]
    pub enqueue_err_count: u64,
    #[doc = " Total error count on operations dequeued"]
    pub dequeue_err_count: u64,
    #[doc = " CPU cycles consumed by the (HW/SW) accelerator device to offload"]
    #[doc = "  the enqueue request to its internal queues."]
    #[doc = "  - For a HW device this is the cycles consumed in MMIO write"]
    #[doc = "  - For a SW (vdev) device, this is the processing time of the"]
    #[doc = "     bbdev operation"]
    pub acc_offload_cycles: u64,
}
extern "C" {
    #[doc = " Retrieve the general I/O statistics of a device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param stats"]
    #[doc = "   Pointer to structure to where statistics will be copied. On error, this"]
    #[doc = "   location may or may not have been modified."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - EINVAL if invalid parameter pointer is provided"]
    pub fn rte_bbdev_stats_get(dev_id: u16, stats: *mut rte_bbdev_stats) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset the statistics of a device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    pub fn rte_bbdev_stats_reset(dev_id: u16) -> ::std::os::raw::c_int;
}
#[doc = " Device information supplied by the device's driver"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_driver_info {
    #[doc = " Driver name"]
    pub driver_name: *const ::std::os::raw::c_char,
    #[doc = " Maximum number of queues supported by the device"]
    pub max_num_queues: ::std::os::raw::c_uint,
    #[doc = " Queue size limit (queue size must also be power of 2)"]
    pub queue_size_lim: u32,
    #[doc = " Set if device off-loads operation to hardware"]
    pub hardware_accelerated: bool,
    #[doc = " Max value supported by queue priority for DL"]
    pub max_dl_queue_priority: u8,
    #[doc = " Max value supported by queue priority for UL"]
    pub max_ul_queue_priority: u8,
    #[doc = " Set if device supports per-queue interrupts"]
    pub queue_intr_supported: bool,
    #[doc = " Minimum alignment of buffers, in bytes"]
    pub min_alignment: u16,
    #[doc = " HARQ memory available in kB"]
    pub harq_buffer_size: u32,
    #[doc = " Byte endianness (RTE_BIG_ENDIAN/RTE_LITTLE_ENDIAN) supported"]
    #[doc = "  for input/output data"]
    pub data_endianness: u8,
    #[doc = " Default queue configuration used if none is supplied"]
    pub default_queue_conf: rte_bbdev_queue_conf,
    #[doc = " Device operation capabilities"]
    pub capabilities: *const rte_bbdev_op_cap,
    #[doc = " Device cpu_flag requirements"]
    pub cpu_flag_reqs: *const rte_cpu_flag_t,
}
#[doc = " Device information structure used by an application to discover a devices"]
#[doc = " capabilities and current configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_info {
    #[doc = "< NUMA socket that device is on"]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< Unique device name"]
    pub dev_name: *const ::std::os::raw::c_char,
    #[doc = "< Device Information"]
    pub device: *const rte_device,
    #[doc = "< Number of queues currently configured"]
    pub num_queues: u16,
    #[doc = "< Set if device is currently started"]
    pub started: bool,
    #[doc = "< Info from device driver"]
    pub drv: rte_bbdev_driver_info,
}
extern "C" {
    #[doc = " Retrieve information about a device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param dev_info"]
    #[doc = "   Pointer to structure to where information will be copied. On error, this"]
    #[doc = "   location may or may not have been modified."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - EINVAL if invalid parameter pointer is provided"]
    pub fn rte_bbdev_info_get(dev_id: u16, dev_info: *mut rte_bbdev_info) -> ::std::os::raw::c_int;
}
#[doc = " Queue information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_queue_info {
    #[doc = " Current device configuration"]
    pub conf: rte_bbdev_queue_conf,
    #[doc = " Set if queue is currently started"]
    pub started: bool,
}
extern "C" {
    #[doc = " Retrieve information about a specific queue on a device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the queue."]
    #[doc = " @param queue_info"]
    #[doc = "   Pointer to structure to where information will be copied. On error, this"]
    #[doc = "   location may or may not have been modified."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - EINVAL if invalid parameter pointer is provided"]
    pub fn rte_bbdev_queue_info_get(
        dev_id: u16,
        queue_id: u16,
        queue_info: *mut rte_bbdev_queue_info,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @internal The data structure associated with each queue of a device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_queue_data {
    #[doc = "< Driver-specific per-queue data"]
    pub queue_private: *mut ::std::os::raw::c_void,
    #[doc = "< Current configuration"]
    pub conf: rte_bbdev_queue_conf,
    #[doc = "< Queue statistics"]
    pub queue_stats: rte_bbdev_stats,
    #[doc = "< Queue state"]
    pub started: bool,
}
#[doc = " @internal Enqueue encode operations for processing on queue of a device."]
pub type rte_bbdev_enqueue_enc_ops_t = ::std::option::Option<
    unsafe extern "C" fn(
        q_data: *mut rte_bbdev_queue_data,
        ops: *mut *mut rte_bbdev_enc_op,
        num: u16,
    ) -> u16,
>;
#[doc = " @internal Enqueue decode operations for processing on queue of a device."]
pub type rte_bbdev_enqueue_dec_ops_t = ::std::option::Option<
    unsafe extern "C" fn(
        q_data: *mut rte_bbdev_queue_data,
        ops: *mut *mut rte_bbdev_dec_op,
        num: u16,
    ) -> u16,
>;
#[doc = " @internal Dequeue encode operations from a queue of a device."]
pub type rte_bbdev_dequeue_enc_ops_t = ::std::option::Option<
    unsafe extern "C" fn(
        q_data: *mut rte_bbdev_queue_data,
        ops: *mut *mut rte_bbdev_enc_op,
        num: u16,
    ) -> u16,
>;
#[doc = " @internal Dequeue decode operations from a queue of a device."]
pub type rte_bbdev_dequeue_dec_ops_t = ::std::option::Option<
    unsafe extern "C" fn(
        q_data: *mut rte_bbdev_queue_data,
        ops: *mut *mut rte_bbdev_dec_op,
        num: u16,
    ) -> u16,
>;
#[doc = " @internal The data associated with a device, with no function pointers."]
#[doc = " This structure is safe to place in shared memory to be common among"]
#[doc = " different processes in a multi-process configuration. Drivers can access"]
#[doc = " these fields, but should never write to them!"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_data {
    #[doc = "< Unique identifier name"]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< Driver-specific private data"]
    pub dev_private: *mut ::std::os::raw::c_void,
    #[doc = "< Number of currently configured queues"]
    pub num_queues: u16,
    #[doc = "< Queue structures"]
    pub queues: *mut rte_bbdev_queue_data,
    #[doc = "< Device ID"]
    pub dev_id: u16,
    #[doc = "< NUMA socket that device is on"]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< Device run-time state"]
    pub started: bool,
    pub process_cnt: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_callback {
    _unused: [u8; 0],
}
#[doc = " Structure to keep track of registered callbacks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_cb_list {
    pub tqh_first: *mut rte_bbdev_callback,
    pub tqh_last: *mut *mut rte_bbdev_callback,
}
#[doc = " @internal The data structure associated with a device. Drivers can access"]
#[doc = " these fields, but should only write to the *_ops fields."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev {
    #[doc = " Enqueue encode function"]
    pub enqueue_enc_ops: rte_bbdev_enqueue_enc_ops_t,
    #[doc = " Enqueue decode function"]
    pub enqueue_dec_ops: rte_bbdev_enqueue_dec_ops_t,
    #[doc = " Dequeue encode function"]
    pub dequeue_enc_ops: rte_bbdev_dequeue_enc_ops_t,
    #[doc = " Dequeue decode function"]
    pub dequeue_dec_ops: rte_bbdev_dequeue_dec_ops_t,
    #[doc = " Enqueue encode function"]
    pub enqueue_ldpc_enc_ops: rte_bbdev_enqueue_enc_ops_t,
    #[doc = " Enqueue decode function"]
    pub enqueue_ldpc_dec_ops: rte_bbdev_enqueue_dec_ops_t,
    #[doc = " Dequeue encode function"]
    pub dequeue_ldpc_enc_ops: rte_bbdev_dequeue_enc_ops_t,
    #[doc = " Dequeue decode function"]
    pub dequeue_ldpc_dec_ops: rte_bbdev_dequeue_dec_ops_t,
    #[doc = "< Functions exported by PMD"]
    pub dev_ops: *const rte_bbdev_ops,
    #[doc = "< Pointer to device data"]
    pub data: *mut rte_bbdev_data,
    #[doc = "< If device is currently used or not"]
    pub state: rte_bbdev_state,
    #[doc = "< Backing device"]
    pub device: *mut rte_device,
    #[doc = " User application callback for interrupts if present"]
    pub list_cbs: rte_bbdev_cb_list,
    #[doc = "< Device interrupt handle"]
    pub intr_handle: *mut rte_intr_handle,
}
extern "C" {
    #[doc = " @internal array of all devices"]
    pub static mut rte_bbdev_devices: [rte_bbdev; 0usize];
}
#[repr(u32)]
#[doc = " Definitions of device event types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_bbdev_event_type {
    #[doc = "< unknown event type"]
    RTE_BBDEV_EVENT_UNKNOWN = 0,
    #[doc = "< error interrupt event"]
    RTE_BBDEV_EVENT_ERROR = 1,
    #[doc = "< dequeue event"]
    RTE_BBDEV_EVENT_DEQUEUE = 2,
    #[doc = "< max value of this enum"]
    RTE_BBDEV_EVENT_MAX = 3,
}
#[doc = " Typedef for application callback function registered by application"]
#[doc = " software for notification of device events"]
#[doc = ""]
#[doc = " @param dev_id"]
#[doc = "   Device identifier"]
#[doc = " @param event"]
#[doc = "   Device event to register for notification of."]
#[doc = " @param cb_arg"]
#[doc = "   User specified parameter to be passed to user's callback function."]
#[doc = " @param ret_param"]
#[doc = "   To pass data back to user application."]
pub type rte_bbdev_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        dev_id: u16,
        event: rte_bbdev_event_type,
        cb_arg: *mut ::std::os::raw::c_void,
        ret_param: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Register a callback function for specific device id. Multiple callbacks can"]
    #[doc = " be added and will be called in the order they are added when an event is"]
    #[doc = " triggered. Callbacks are called in a separate thread created by the DPDK EAL."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Device id."]
    #[doc = " @param event"]
    #[doc = "   The event that the callback will be registered for."]
    #[doc = " @param cb_fn"]
    #[doc = "   User supplied callback function to be called."]
    #[doc = " @param cb_arg"]
    #[doc = "   Pointer to parameter that will be passed to the callback."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Zero on success, negative value on failure."]
    pub fn rte_bbdev_callback_register(
        dev_id: u16,
        event: rte_bbdev_event_type,
        cb_fn: rte_bbdev_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unregister a callback function for specific device id."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The device identifier."]
    #[doc = " @param event"]
    #[doc = "   The event that the callback will be unregistered for."]
    #[doc = " @param cb_fn"]
    #[doc = "   User supplied callback function to be unregistered."]
    #[doc = " @param cb_arg"]
    #[doc = "   Pointer to the parameter supplied when registering the callback."]
    #[doc = "   (void *)-1 means to remove all registered callbacks with the specified"]
    #[doc = "   function address."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - EINVAL if invalid parameter pointer is provided"]
    #[doc = "   - EAGAIN if the provided callback pointer does not exist"]
    pub fn rte_bbdev_callback_unregister(
        dev_id: u16,
        event: rte_bbdev_event_type,
        cb_fn: rte_bbdev_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable a one-shot interrupt on the next operation enqueued to a particular"]
    #[doc = " queue. The interrupt will be triggered when the operation is ready to be"]
    #[doc = " dequeued. To handle the interrupt, an epoll file descriptor must be"]
    #[doc = " registered using rte_bbdev_queue_intr_ctl(), and then an application"]
    #[doc = " thread/lcore can wait for the interrupt using rte_epoll_wait()."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The device identifier."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the queue."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - negative value on failure - as returned from PMD"]
    pub fn rte_bbdev_queue_intr_enable(dev_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disable a one-shot interrupt on the next operation enqueued to a particular"]
    #[doc = " queue (if it has been enabled)."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The device identifier."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the queue."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - negative value on failure - as returned from PMD"]
    pub fn rte_bbdev_queue_intr_disable(dev_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Control interface for per-queue interrupts."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The device identifier."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the queue."]
    #[doc = " @param epfd"]
    #[doc = "   Epoll file descriptor that will be associated with the interrupt source."]
    #[doc = "   If the special value RTE_EPOLL_PER_THREAD is provided, a per thread epoll"]
    #[doc = "   file descriptor created by the EAL is used (RTE_EPOLL_PER_THREAD can also"]
    #[doc = "   be used when calling rte_epoll_wait())."]
    #[doc = " @param op"]
    #[doc = "   The operation be performed for the vector.RTE_INTR_EVENT_ADD or"]
    #[doc = "   RTE_INTR_EVENT_DEL."]
    #[doc = " @param data"]
    #[doc = "   User context, that will be returned in the epdata.data field of the"]
    #[doc = "   rte_epoll_event structure filled in by rte_epoll_wait()."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - ENOTSUP if interrupts are not supported by the identified device"]
    #[doc = "   - negative value on failure - as returned from PMD"]
    pub fn rte_bbdev_queue_intr_ctl(
        dev_id: u16,
        queue_id: u16,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Allocates a new slot for a bbdev and returns the pointer to that slot"]
    #[doc = " for the driver to use."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Unique identifier name for each bbdev device"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - Slot in the rte_bbdev array for a new device;"]
    pub fn rte_bbdev_allocate(name: *const ::std::os::raw::c_char) -> *mut rte_bbdev;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Release the specified bbdev."]
    #[doc = ""]
    #[doc = " @param bbdev"]
    #[doc = "   The *bbdev* pointer is the address of the *rte_bbdev* structure."]
    #[doc = " @return"]
    #[doc = "   - 0 on success, negative on error"]
    pub fn rte_bbdev_release(bbdev: *mut rte_bbdev) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the device structure for a named device."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Name of the device"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - The device structure pointer, or"]
    #[doc = "   - NULL otherwise"]
    #[doc = ""]
    pub fn rte_bbdev_get_named_dev(name: *const ::std::os::raw::c_char) -> *mut rte_bbdev;
}
#[doc = " @internal Function used to configure device memory."]
pub type rte_bbdev_setup_queues_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_bbdev,
        num_queues: u16,
        socket_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function used to configure interrupts for a device."]
pub type rte_bbdev_intr_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_bbdev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function to allocate and configure a device queue."]
pub type rte_bbdev_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_bbdev,
        queue_id: u16,
        conf: *const rte_bbdev_queue_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_bbdev_queue_release_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_bbdev, queue_id: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function to start a configured device."]
pub type rte_bbdev_start_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_bbdev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function to stop a device."]
pub type rte_bbdev_stop_t = ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_bbdev)>;
#[doc = " @internal Function to close a device."]
pub type rte_bbdev_close_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_bbdev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function to start a device queue."]
pub type rte_bbdev_queue_start_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_bbdev, queue_id: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function to stop a device queue."]
pub type rte_bbdev_queue_stop_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_bbdev, queue_id: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function to read stats from a device."]
pub type rte_bbdev_stats_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_bbdev, stats: *mut rte_bbdev_stats)>;
#[doc = " @internal Function to reset stats on a device."]
pub type rte_bbdev_stats_reset_t = ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_bbdev)>;
#[doc = " @internal Function to retrieve specific information of a device."]
pub type rte_bbdev_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_bbdev, dev_info: *mut rte_bbdev_driver_info),
>;
pub type rte_bbdev_queue_intr_enable_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_bbdev, queue_id: u16) -> ::std::os::raw::c_int,
>;
pub type rte_bbdev_queue_intr_disable_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_bbdev, queue_id: u16) -> ::std::os::raw::c_int,
>;
#[doc = " Operations implemented by drivers. Fields marked as \"Required\" must be"]
#[doc = " provided by a driver for a device to have basic functionality. \"Optional\""]
#[doc = " fields are for non-vital operations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bbdev_ops {
    #[doc = " Allocate and configure device memory. Optional."]
    pub setup_queues: rte_bbdev_setup_queues_t,
    #[doc = " Configure interrupts. Optional."]
    pub intr_enable: rte_bbdev_intr_enable_t,
    #[doc = " Start device. Optional."]
    pub start: rte_bbdev_start_t,
    #[doc = " Stop device. Optional."]
    pub stop: rte_bbdev_stop_t,
    #[doc = " Close device. Optional."]
    pub close: rte_bbdev_close_t,
    #[doc = " Get device info. Required."]
    pub info_get: rte_bbdev_info_get_t,
    #[doc = " Get device statistics. Optional."]
    pub stats_get: rte_bbdev_stats_get_t,
    #[doc = " Reset device statistics. Optional."]
    pub stats_reset: rte_bbdev_stats_reset_t,
    #[doc = " Set up a device queue. Required."]
    pub queue_setup: rte_bbdev_queue_setup_t,
    #[doc = " Release a queue. Required."]
    pub queue_release: rte_bbdev_queue_release_t,
    #[doc = " Start a queue. Optional."]
    pub queue_start: rte_bbdev_queue_start_t,
    #[doc = " Stop a queue pair. Optional."]
    pub queue_stop: rte_bbdev_queue_stop_t,
    #[doc = " Enable queue interrupt. Optional"]
    pub queue_intr_enable: rte_bbdev_queue_intr_enable_t,
    #[doc = " Disable queue interrupt. Optional"]
    pub queue_intr_disable: rte_bbdev_queue_intr_disable_t,
}
extern "C" {
    #[doc = " Executes all the user application registered callbacks for the specific"]
    #[doc = " device and event type."]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "   Pointer to the device structure."]
    #[doc = " @param event"]
    #[doc = "   Event type."]
    #[doc = " @param ret_param"]
    #[doc = "   To pass data back to user application."]
    pub fn rte_bbdev_pmd_callback_process(
        dev: *mut rte_bbdev,
        event: rte_bbdev_event_type,
        ret_param: *mut ::std::os::raw::c_void,
    );
}
#[doc = " Bitmap data structure"]
#[repr(C)]
#[derive(Debug)]
pub struct rte_bitmap {
    #[doc = "< Bitmap array1"]
    pub array1: *mut u64,
    #[doc = "< Bitmap array2"]
    pub array2: *mut u64,
    #[doc = "< Number of 64-bit slabs in array1 that are actually used"]
    pub array1_size: u32,
    #[doc = "< Number of 64-bit slabs in array2"]
    pub array2_size: u32,
    #[doc = "< Bitmap scan: Index of current array1 slab"]
    pub index1: u32,
    #[doc = "< Bitmap scan: Offset of current bit within current array1 slab"]
    pub offset1: u32,
    #[doc = "< Bitmap scan: Index of current array2 slab"]
    pub index2: u32,
    #[doc = "< Bitmap scan: Go/stop condition for current array2 cache line"]
    pub go2: u32,
    pub memory: __IncompleteArrayField<u8>,
}
#[doc = "  Bitrate statistics data structure."]
#[doc = "  This data structure is intentionally opaque."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_stats_bitrates {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate a bitrate statistics structure"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - Pointer to structure on success"]
    #[doc = "   - NULL on error (zmalloc failure)"]
    pub fn rte_stats_bitrate_create() -> *mut rte_stats_bitrates;
}
extern "C" {
    #[doc = " Free bitrate statistics structure"]
    #[doc = ""]
    #[doc = " @param bitrate_data"]
    #[doc = "   Pointer allocated by rte_stats_bitrate_create()"]
    pub fn rte_stats_bitrate_free(bitrate_data: *mut rte_stats_bitrates);
}
extern "C" {
    #[doc = " Register bitrate statistics with the metric library."]
    #[doc = ""]
    #[doc = " @param bitrate_data"]
    #[doc = "   Pointer allocated by rte_stats_bitrate_create()"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Zero on success"]
    #[doc = "   Negative on error"]
    pub fn rte_stats_bitrate_reg(bitrate_data: *mut rte_stats_bitrates) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calculate statistics for current time window. The period with which"]
    #[doc = " this function is called should be the intended sampling window width."]
    #[doc = ""]
    #[doc = " @param bitrate_data"]
    #[doc = "   Bitrate statistics data pointer"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port id to calculate statistics for"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - Zero on success"]
    #[doc = "  - Negative value on error"]
    pub fn rte_stats_bitrate_calc(
        bitrate_data: *mut rte_stats_bitrates,
        port_id: u16,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Configuration file"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_cfgfile {
    _unused: [u8; 0],
}
#[doc = " Configuration file entry"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_cfgfile_entry {
    #[doc = "< Name"]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< Value"]
    pub value: [::std::os::raw::c_char; 256usize],
}
#[doc = " Configuration file operation optional arguments"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_cfgfile_parameters {
    #[doc = " Config file comment character; one of '!', '#', '%', ';', '@'"]
    pub comment_character: ::std::os::raw::c_char,
}
pub const CFG_FLAG_GLOBAL_SECTION: _bindgen_ty_17 = _bindgen_ty_17::CFG_FLAG_GLOBAL_SECTION;
pub const CFG_FLAG_EMPTY_VALUES: _bindgen_ty_17 = _bindgen_ty_17::CFG_FLAG_EMPTY_VALUES;
#[repr(u32)]
#[doc = "@{ cfgfile load operation flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_17 {
    #[doc = " Indicates that the file supports key value entries before the first"]
    #[doc = " defined section.  These entries can be accessed in the \"GLOBAL\""]
    #[doc = " section."]
    CFG_FLAG_GLOBAL_SECTION = 1,
    #[doc = " Indicates that file supports key value entries where the value can"]
    #[doc = " be zero length (e.g., \"key=\")."]
    CFG_FLAG_EMPTY_VALUES = 2,
}
extern "C" {
    #[doc = " Open config file"]
    #[doc = ""]
    #[doc = " @param filename"]
    #[doc = "   Config file name"]
    #[doc = " @param flags"]
    #[doc = "   Config file flags"]
    #[doc = " @return"]
    #[doc = "   Handle to configuration file on success, NULL otherwise"]
    pub fn rte_cfgfile_load(
        filename: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> *mut rte_cfgfile;
}
extern "C" {
    #[doc = " Open config file with specified optional parameters."]
    #[doc = ""]
    #[doc = " @param filename"]
    #[doc = "   Config file name"]
    #[doc = " @param flags"]
    #[doc = "   Config file flags"]
    #[doc = " @param params"]
    #[doc = "   Additional configuration attributes.  Must be configured with desired"]
    #[doc = "   values prior to invoking this API."]
    #[doc = " @return"]
    #[doc = "   Handle to configuration file on success, NULL otherwise"]
    pub fn rte_cfgfile_load_with_params(
        filename: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        params: *const rte_cfgfile_parameters,
    ) -> *mut rte_cfgfile;
}
extern "C" {
    #[doc = " Create new cfgfile instance with empty sections and entries"]
    #[doc = ""]
    #[doc = " @param flags"]
    #[doc = "   - CFG_FLAG_GLOBAL_SECTION"]
    #[doc = "     Indicates that the file supports key value entries before the first"]
    #[doc = "     defined section.  These entries can be accessed in the \"GLOBAL\""]
    #[doc = "     section."]
    #[doc = "   - CFG_FLAG_EMPTY_VALUES"]
    #[doc = "     Indicates that file supports key value entries where the value can"]
    #[doc = "     be zero length (e.g., \"key=\")."]
    #[doc = " @return"]
    #[doc = "   Handle to cfgfile instance on success, NULL otherwise"]
    pub fn rte_cfgfile_create(flags: ::std::os::raw::c_int) -> *mut rte_cfgfile;
}
extern "C" {
    #[doc = " Add section in cfgfile instance."]
    #[doc = ""]
    #[doc = " @param cfg"]
    #[doc = "   Pointer to the cfgfile structure."]
    #[doc = " @param sectionname"]
    #[doc = "   Section name which will be add to cfgfile."]
    #[doc = " @return"]
    #[doc = "   0 on success, -ENOMEM if can't add section"]
    pub fn rte_cfgfile_add_section(
        cfg: *mut rte_cfgfile,
        sectionname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add entry to specified section in cfgfile instance."]
    #[doc = ""]
    #[doc = " @param cfg"]
    #[doc = "   Pointer to the cfgfile structure."]
    #[doc = " @param sectionname"]
    #[doc = "   Given section name to add an entry."]
    #[doc = " @param entryname"]
    #[doc = "   Entry name to add."]
    #[doc = " @param entryvalue"]
    #[doc = "   Entry value to add."]
    #[doc = " @return"]
    #[doc = "   0 on success, -EEXIST if entry already exist, -EINVAL if bad argument"]
    pub fn rte_cfgfile_add_entry(
        cfg: *mut rte_cfgfile,
        sectionname: *const ::std::os::raw::c_char,
        entryname: *const ::std::os::raw::c_char,
        entryvalue: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Update value of specified entry name in given section in config file"]
    #[doc = ""]
    #[doc = " @param cfg"]
    #[doc = "   Config file"]
    #[doc = " @param sectionname"]
    #[doc = "   Section name"]
    #[doc = " @param entryname"]
    #[doc = "   Entry name to look for the value change"]
    #[doc = " @param entryvalue"]
    #[doc = "   New entry value. Can be also an empty string if CFG_FLAG_EMPTY_VALUES = 1"]
    #[doc = " @return"]
    #[doc = "   0 on success, -EINVAL if bad argument"]
    pub fn rte_cfgfile_set_entry(
        cfg: *mut rte_cfgfile,
        sectionname: *const ::std::os::raw::c_char,
        entryname: *const ::std::os::raw::c_char,
        entryvalue: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Save object cfgfile to file on disc"]
    #[doc = ""]
    #[doc = " @param cfg"]
    #[doc = "   Config file structure"]
    #[doc = " @param filename"]
    #[doc = "   File name to save data"]
    #[doc = " @return"]
    #[doc = "   0 on success, errno otherwise"]
    pub fn rte_cfgfile_save(
        cfg: *mut rte_cfgfile,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get number of sections in config file"]
    #[doc = ""]
    #[doc = " @param cfg"]
    #[doc = "   Config file"]
    #[doc = " @param sec_name"]
    #[doc = "   Section name"]
    #[doc = " @param length"]
    #[doc = "   Maximum section name length"]
    #[doc = " @return"]
    #[doc = "   Number of sections"]
    pub fn rte_cfgfile_num_sections(
        cfg: *mut rte_cfgfile,
        sec_name: *const ::std::os::raw::c_char,
        length: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get name of all config file sections."]
    #[doc = ""]
    #[doc = " Fills in the array sections with the name of all the sections in the file"]
    #[doc = " (up to the number of max_sections sections)."]
    #[doc = ""]
    #[doc = " @param cfg"]
    #[doc = "   Config file"]
    #[doc = " @param sections"]
    #[doc = "   Array containing section names after successful invocation. Each element"]
    #[doc = "   of this array should be preallocated by the user with at least"]
    #[doc = "   CFG_NAME_LEN characters."]
    #[doc = " @param max_sections"]
    #[doc = "   Maximum number of section names to be stored in sections array"]
    #[doc = " @return"]
    #[doc = "   Number of populated sections names"]
    pub fn rte_cfgfile_sections(
        cfg: *mut rte_cfgfile,
        sections: *mut *mut ::std::os::raw::c_char,
        max_sections: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if given section exists in config file"]
    #[doc = ""]
    #[doc = " @param cfg"]
    #[doc = "   Config file"]
    #[doc = " @param sectionname"]
    #[doc = "   Section name"]
    #[doc = " @return"]
    #[doc = "   TRUE (value different than 0) if section exists, FALSE (value 0) otherwise"]
    pub fn rte_cfgfile_has_section(
        cfg: *mut rte_cfgfile,
        sectionname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get number of entries in given config file section"]
    #[doc = ""]
    #[doc = " If multiple sections have the given name this function operates on the"]
    #[doc = " first one."]
    #[doc = ""]
    #[doc = " @param cfg"]
    #[doc = "   Config file"]
    #[doc = " @param sectionname"]
    #[doc = "   Section name"]
    #[doc = " @return"]
    #[doc = "   Number of entries in section on success, -1 otherwise"]
    pub fn rte_cfgfile_section_num_entries(
        cfg: *mut rte_cfgfile,
        sectionname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get number of entries in given config file section"]
    #[doc = ""]
    #[doc = " The index of a section is the same as the index of its name in the"]
    #[doc = " result of rte_cfgfile_sections. This API can be used when there are"]
    #[doc = " multiple sections with the same name."]
    #[doc = ""]
    #[doc = " @param cfg"]
    #[doc = "   Config file"]
    #[doc = " @param sectionname"]
    #[doc = "   Section name"]
    #[doc = " @param index"]
    #[doc = "   Section index"]
    #[doc = " @return"]
    #[doc = "   Number of entries in section on success, -1 otherwise"]
    pub fn rte_cfgfile_section_num_entries_by_index(
        cfg: *mut rte_cfgfile,
        sectionname: *mut ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get section entries as key-value pairs"]
    #[doc = ""]
    #[doc = " If multiple sections have the given name this function operates on the"]
    #[doc = " first one."]
    #[doc = ""]
    #[doc = " @param cfg"]
    #[doc = "   Config file"]
    #[doc = " @param sectionname"]
    #[doc = "   Section name"]
    #[doc = " @param entries"]
    #[doc = "   Pre-allocated array of at least max_entries entries where the section"]
    #[doc = "   entries are stored as key-value pair after successful invocation"]
    #[doc = " @param max_entries"]
    #[doc = "   Maximum number of section entries to be stored in entries array"]
    #[doc = " @return"]
    #[doc = "   Number of entries populated on success, -1 otherwise"]
    pub fn rte_cfgfile_section_entries(
        cfg: *mut rte_cfgfile,
        sectionname: *const ::std::os::raw::c_char,
        entries: *mut rte_cfgfile_entry,
        max_entries: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get section entries as key-value pairs"]
    #[doc = ""]
    #[doc = " The index of a section is the same as the index of its name in the"]
    #[doc = " result of rte_cfgfile_sections. This API can be used when there are"]
    #[doc = " multiple sections with the same name."]
    #[doc = ""]
    #[doc = " @param cfg"]
    #[doc = "   Config file"]
    #[doc = " @param index"]
    #[doc = "   Section index"]
    #[doc = " @param sectionname"]
    #[doc = "   Pre-allocated string of at least CFG_NAME_LEN characters where the"]
    #[doc = "   section name is stored after successful invocation."]
    #[doc = " @param entries"]
    #[doc = "   Pre-allocated array of at least max_entries entries where the section"]
    #[doc = "   entries are stored as key-value pair after successful invocation"]
    #[doc = " @param max_entries"]
    #[doc = "   Maximum number of section entries to be stored in entries array"]
    #[doc = " @return"]
    #[doc = "   Number of entries populated on success, -1 otherwise"]
    pub fn rte_cfgfile_section_entries_by_index(
        cfg: *mut rte_cfgfile,
        index: ::std::os::raw::c_int,
        sectionname: *mut ::std::os::raw::c_char,
        entries: *mut rte_cfgfile_entry,
        max_entries: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get value of the named entry in named config file section"]
    #[doc = ""]
    #[doc = " If multiple sections have the given name this function operates on the"]
    #[doc = " first one."]
    #[doc = ""]
    #[doc = " @param cfg"]
    #[doc = "   Config file"]
    #[doc = " @param sectionname"]
    #[doc = "   Section name"]
    #[doc = " @param entryname"]
    #[doc = "   Entry name"]
    #[doc = " @return"]
    #[doc = "   Entry value on success, NULL otherwise"]
    pub fn rte_cfgfile_get_entry(
        cfg: *mut rte_cfgfile,
        sectionname: *const ::std::os::raw::c_char,
        entryname: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Check if given entry exists in named config file section"]
    #[doc = ""]
    #[doc = " If multiple sections have the given name this function operates on the"]
    #[doc = " first one."]
    #[doc = ""]
    #[doc = " @param cfg"]
    #[doc = "   Config file"]
    #[doc = " @param sectionname"]
    #[doc = "   Section name"]
    #[doc = " @param entryname"]
    #[doc = "   Entry name"]
    #[doc = " @return"]
    #[doc = "   TRUE (value different than 0) if entry exists, FALSE (value 0) otherwise"]
    pub fn rte_cfgfile_has_entry(
        cfg: *mut rte_cfgfile,
        sectionname: *const ::std::os::raw::c_char,
        entryname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close config file"]
    #[doc = ""]
    #[doc = " @param cfg"]
    #[doc = "   Config file"]
    #[doc = " @return"]
    #[doc = "   0 on success, -1 otherwise"]
    pub fn rte_cfgfile_close(cfg: *mut rte_cfgfile) -> ::std::os::raw::c_int;
}
#[doc = " Double linked list of classes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_class_list {
    pub tqh_first: *mut rte_class,
    pub tqh_last: *mut *mut rte_class,
}
#[doc = " A structure describing a generic device class."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_class {
    #[doc = "< Next device class in linked list"]
    pub next: rte_class__bindgen_ty_1,
    #[doc = "< Name of the class"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Device iterator."]
    pub dev_iterate: rte_dev_iterate_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_class__bindgen_ty_1 {
    pub tqe_next: *mut rte_class,
    pub tqe_prev: *mut *mut rte_class,
}
#[doc = " Class comparison function."]
#[doc = ""]
#[doc = " @param cls"]
#[doc = "\tClass under test."]
#[doc = ""]
#[doc = " @param data"]
#[doc = "\tData to compare against."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 if the class matches the data."]
#[doc = "\t!0 if the class does not match."]
#[doc = "\t<0 if ordering is possible and the class is lower than the data."]
#[doc = "\t>0 if ordering is possible and the class is greater than the data."]
pub type rte_class_cmp_t = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *const rte_class,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Class iterator to find a particular class."]
    #[doc = ""]
    #[doc = " This function compares each registered class to find one that matches"]
    #[doc = " the data passed as parameter."]
    #[doc = ""]
    #[doc = " If the comparison function returns zero this function will stop iterating"]
    #[doc = " over any more classes. To continue a search the class of a previous search"]
    #[doc = " can be passed via the start parameter."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "\tStarting point for the iteration."]
    #[doc = ""]
    #[doc = " @param cmp"]
    #[doc = "\tComparison function."]
    #[doc = ""]
    #[doc = " @param data"]
    #[doc = "\t Data to pass to comparison function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\t A pointer to a rte_class structure or NULL in case no class matches"]
    pub fn rte_class_find(
        start: *const rte_class,
        cmp: rte_class_cmp_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut rte_class;
}
extern "C" {
    #[doc = " Find the registered class for a given name."]
    pub fn rte_class_find_by_name(name: *const ::std::os::raw::c_char) -> *mut rte_class;
}
extern "C" {
    #[doc = " Register a Class handle."]
    #[doc = ""]
    #[doc = " @param cls"]
    #[doc = "   A pointer to a rte_class structure describing the class"]
    #[doc = "   to be registered."]
    pub fn rte_class_register(cls: *mut rte_class);
}
extern "C" {
    #[doc = " Unregister a Class handle."]
    #[doc = ""]
    #[doc = " @param cls"]
    #[doc = "   A pointer to a rte_class structure describing the class"]
    #[doc = "   to be unregistered."]
    pub fn rte_class_unregister(cls: *mut rte_class);
}
#[repr(u32)]
#[doc = " Status of comp operation"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_comp_op_status {
    RTE_COMP_OP_STATUS_SUCCESS = 0,
    RTE_COMP_OP_STATUS_NOT_PROCESSED = 1,
    RTE_COMP_OP_STATUS_INVALID_ARGS = 2,
    RTE_COMP_OP_STATUS_ERROR = 3,
    RTE_COMP_OP_STATUS_INVALID_STATE = 4,
    RTE_COMP_OP_STATUS_OUT_OF_SPACE_TERMINATED = 5,
    RTE_COMP_OP_STATUS_OUT_OF_SPACE_RECOVERABLE = 6,
}
#[repr(u32)]
#[doc = " Compression Algorithms"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_comp_algorithm {
    RTE_COMP_ALGO_UNSPECIFIED = 0,
    #[doc = " No Compression algorithm"]
    RTE_COMP_ALGO_NULL = 1,
    RTE_COMP_ALGO_DEFLATE = 2,
    RTE_COMP_ALGO_LZS = 3,
    RTE_COMP_ALGO_LIST_END = 4,
}
#[repr(u32)]
#[doc = " Compression Hash Algorithms"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_comp_hash_algorithm {
    RTE_COMP_HASH_ALGO_NONE = 0,
    RTE_COMP_HASH_ALGO_SHA1 = 1,
    RTE_COMP_HASH_ALGO_SHA2_256 = 2,
    RTE_COMP_HASH_ALGO_LIST_END = 3,
}
#[repr(u32)]
#[doc = " Compression checksum types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_comp_checksum_type {
    RTE_COMP_CHECKSUM_NONE = 0,
    RTE_COMP_CHECKSUM_CRC32 = 1,
    RTE_COMP_CHECKSUM_ADLER32 = 2,
    RTE_COMP_CHECKSUM_CRC32_ADLER32 = 3,
}
#[repr(u32)]
#[doc = " Compression Huffman Type - used by DEFLATE algorithm"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_comp_huffman {
    RTE_COMP_HUFFMAN_DEFAULT = 0,
    RTE_COMP_HUFFMAN_FIXED = 1,
    RTE_COMP_HUFFMAN_DYNAMIC = 2,
}
#[repr(u32)]
#[doc = " Compression flush flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_comp_flush_flag {
    RTE_COMP_FLUSH_NONE = 0,
    RTE_COMP_FLUSH_SYNC = 1,
    RTE_COMP_FLUSH_FULL = 2,
    RTE_COMP_FLUSH_FINAL = 3,
}
#[repr(u32)]
#[doc = " Compression transform types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_comp_xform_type {
    RTE_COMP_COMPRESS = 0,
    RTE_COMP_DECOMPRESS = 1,
}
#[repr(u32)]
#[doc = " Compression operation type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_comp_op_type {
    RTE_COMP_OP_STATELESS = 0,
    RTE_COMP_OP_STATEFUL = 1,
}
#[doc = " Parameters specific to the deflate algorithm"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_comp_deflate_params {
    pub huffman: rte_comp_huffman,
}
#[doc = " Setup Data for compression"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_comp_compress_xform {
    pub algo: rte_comp_algorithm,
    pub __bindgen_anon_1: rte_comp_compress_xform__bindgen_ty_1,
    pub level: ::std::os::raw::c_int,
    pub window_size: u8,
    pub chksum: rte_comp_checksum_type,
    pub hash_algo: rte_comp_hash_algorithm,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_comp_compress_xform__bindgen_ty_1 {
    pub deflate: rte_comp_deflate_params,
}
#[doc = " Setup Data for decompression."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_comp_decompress_xform {
    pub algo: rte_comp_algorithm,
    pub chksum: rte_comp_checksum_type,
    pub window_size: u8,
    pub hash_algo: rte_comp_hash_algorithm,
}
#[doc = " Compression transform structure."]
#[doc = ""]
#[doc = " This is used to specify the compression transforms required."]
#[doc = " Each transform structure can hold a single transform, the type field is"]
#[doc = " used to specify which transform is contained within the union."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_comp_xform {
    pub type_: rte_comp_xform_type,
    pub __bindgen_anon_1: rte_comp_xform__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_comp_xform__bindgen_ty_1 {
    pub compress: rte_comp_compress_xform,
    pub decompress: rte_comp_decompress_xform,
}
#[doc = " Compression Operation."]
#[doc = ""]
#[doc = " This structure contains data relating to performing a compression"]
#[doc = " operation on the referenced mbuf data buffers."]
#[doc = ""]
#[doc = " Comp operations are enqueued and dequeued in comp PMDs using the"]
#[doc = " rte_compressdev_enqueue_burst() / rte_compressdev_dequeue_burst() APIs"]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_comp_op {
    pub op_type: rte_comp_op_type,
    pub __bindgen_anon_1: rte_comp_op__bindgen_ty_1,
    pub mempool: *mut rte_mempool,
    pub iova_addr: rte_iova_t,
    pub m_src: *mut rte_mbuf,
    pub m_dst: *mut rte_mbuf,
    pub src: rte_comp_op__bindgen_ty_2,
    pub dst: rte_comp_op__bindgen_ty_3,
    pub hash: rte_comp_op__bindgen_ty_4,
    pub flush_flag: rte_comp_flush_flag,
    pub input_chksum: u64,
    pub output_chksum: u64,
    pub consumed: u32,
    pub produced: u32,
    pub debug_status: u64,
    pub status: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_comp_op__bindgen_ty_1 {
    pub private_xform: *mut ::std::os::raw::c_void,
    pub stream: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_comp_op__bindgen_ty_2 {
    pub offset: u32,
    pub length: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_comp_op__bindgen_ty_3 {
    pub offset: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_comp_op__bindgen_ty_4 {
    pub digest: *mut u8,
    pub iova_addr: rte_iova_t,
}
extern "C" {
    #[doc = " Creates an operation pool"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Compress pool name"]
    #[doc = " @param nb_elts"]
    #[doc = "   Number of elements in pool"]
    #[doc = " @param cache_size"]
    #[doc = "   Number of elements to cache on lcore, see"]
    #[doc = "   *rte_mempool_create* for further details about cache size"]
    #[doc = " @param user_size"]
    #[doc = "   Size of private data to allocate for user with each operation"]
    #[doc = " @param socket_id"]
    #[doc = "   Socket to identifier allocate memory on"]
    #[doc = " @return"]
    #[doc = "  - On success pointer to mempool"]
    #[doc = "  - On failure NULL"]
    pub fn rte_comp_op_pool_create(
        name: *const ::std::os::raw::c_char,
        nb_elts: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        user_size: u16,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Allocate an operation from a mempool with default parameters set"]
    #[doc = ""]
    #[doc = " @param mempool"]
    #[doc = "   Compress operation mempool"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " - On success returns a valid rte_comp_op structure"]
    #[doc = " - On failure returns NULL"]
    pub fn rte_comp_op_alloc(mempool: *mut rte_mempool) -> *mut rte_comp_op;
}
extern "C" {
    #[doc = " Bulk allocate operations from a mempool with default parameters set"]
    #[doc = ""]
    #[doc = " @param mempool"]
    #[doc = "   Compress operation mempool"]
    #[doc = " @param ops"]
    #[doc = "   Array to place allocated operations"]
    #[doc = " @param nb_ops"]
    #[doc = "   Number of operations to allocate"]
    #[doc = " @return"]
    #[doc = "   - nb_ops: Success, the nb_ops requested was allocated"]
    #[doc = "   - 0: Not enough entries in the mempool; no ops are retrieved."]
    pub fn rte_comp_op_bulk_alloc(
        mempool: *mut rte_mempool,
        ops: *mut *mut rte_comp_op,
        nb_ops: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free operation structure"]
    #[doc = " If operation has been allocate from a rte_mempool, then the operation will"]
    #[doc = " be returned to the mempool."]
    #[doc = ""]
    #[doc = " @param op"]
    #[doc = "   Compress operation"]
    pub fn rte_comp_op_free(op: *mut rte_comp_op);
}
extern "C" {
    #[doc = " Bulk free operation structures"]
    #[doc = " If operations have been allocated from an rte_mempool, then the operations"]
    #[doc = " will be returned to the mempool."]
    #[doc = " The array entry will be cleared."]
    #[doc = ""]
    #[doc = " @param ops"]
    #[doc = "   Array of Compress operations"]
    #[doc = " @param nb_ops"]
    #[doc = "   Number of operations to free"]
    pub fn rte_comp_op_bulk_free(ops: *mut *mut rte_comp_op, nb_ops: u16);
}
extern "C" {
    #[doc = " Get the name of a compress service feature flag"]
    #[doc = ""]
    #[doc = " @param flag"]
    #[doc = "   The mask describing the flag"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The name of this flag, or NULL if it's not a valid feature flag."]
    pub fn rte_comp_get_feature_name(flag: u64) -> *const ::std::os::raw::c_char;
}
#[doc = " Parameter log base 2 range description."]
#[doc = " Final value will be 2^value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_param_log2_range {
    #[doc = "< Minimum log2 value"]
    pub min: u8,
    #[doc = "< Maximum log2 value"]
    pub max: u8,
    pub increment: u8,
}
#[doc = " Structure used to capture a capability of a comp device"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_compressdev_capabilities {
    pub algo: rte_comp_algorithm,
    pub comp_feature_flags: u64,
    pub window_size: rte_param_log2_range,
}
extern "C" {
    pub fn rte_compressdev_capability_get(
        dev_id: u8,
        algo: rte_comp_algorithm,
    ) -> *const rte_compressdev_capabilities;
}
extern "C" {
    #[doc = " Get the name of a compress device feature flag."]
    #[doc = ""]
    #[doc = " @param flag"]
    #[doc = "   The mask describing the flag"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The name of this flag, or NULL if it's not a valid feature flag."]
    pub fn rte_compressdev_get_feature_name(flag: u64) -> *const ::std::os::raw::c_char;
}
#[doc = "  comp device information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_compressdev_info {
    #[doc = "< Driver name."]
    pub driver_name: *const ::std::os::raw::c_char,
    #[doc = "< Feature flags"]
    pub feature_flags: u64,
    pub capabilities: *const rte_compressdev_capabilities,
    pub max_nb_queue_pairs: u16,
}
#[doc = " comp device statistics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_compressdev_stats {
    pub enqueued_count: u64,
    pub dequeued_count: u64,
    pub enqueue_err_count: u64,
    pub dequeue_err_count: u64,
}
extern "C" {
    #[doc = " Get the device identifier for the named compress device."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Device name to select the device structure"]
    #[doc = " @return"]
    #[doc = "   - Returns compress device identifier on success."]
    #[doc = "   - Return -1 on failure to find named compress device."]
    pub fn rte_compressdev_get_dev_id(name: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the compress device name given a device identifier."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Compress device identifier"]
    #[doc = " @return"]
    #[doc = "   - Returns compress device name."]
    #[doc = "   - Returns NULL if compress device is not present."]
    pub fn rte_compressdev_name_get(dev_id: u8) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the total number of compress devices that have been successfully"]
    #[doc = " initialised."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - The total number of usable compress devices."]
    pub fn rte_compressdev_count() -> u8;
}
extern "C" {
    #[doc = " Get number and identifiers of attached comp devices that"]
    #[doc = " use the same compress driver."]
    #[doc = ""]
    #[doc = " @param driver_name"]
    #[doc = "   Driver name"]
    #[doc = " @param devices"]
    #[doc = "   Output devices identifiers"]
    #[doc = " @param nb_devices"]
    #[doc = "   Maximal number of devices"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Returns number of attached compress devices."]
    pub fn rte_compressdev_devices_get(
        driver_name: *const ::std::os::raw::c_char,
        devices: *mut u8,
        nb_devices: u8,
    ) -> u8;
}
extern "C" {
    pub fn rte_compressdev_socket_id(dev_id: u8) -> ::std::os::raw::c_int;
}
#[doc = " Compress device configuration structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_compressdev_config {
    pub socket_id: ::std::os::raw::c_int,
    pub nb_queue_pairs: u16,
    pub max_nb_priv_xforms: u16,
    pub max_nb_streams: u16,
}
extern "C" {
    #[doc = " Configure a device."]
    #[doc = ""]
    #[doc = " This function must be invoked first before any other function in the"]
    #[doc = " API. This function can also be re-invoked when a device is in the"]
    #[doc = " stopped state."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Compress device identifier"]
    #[doc = " @param config"]
    #[doc = "   The compress device configuration"]
    #[doc = " @return"]
    #[doc = "   - 0: Success, device configured."]
    #[doc = "   - <0: Error code returned by the driver configuration function."]
    pub fn rte_compressdev_configure(
        dev_id: u8,
        config: *mut rte_compressdev_config,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start a device."]
    #[doc = ""]
    #[doc = " The device start step is called after configuring the device and setting up"]
    #[doc = " its queue pairs."]
    #[doc = " On success, data-path functions exported by the API (enqueue/dequeue, etc)"]
    #[doc = " can be invoked."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Compress device identifier"]
    #[doc = " @return"]
    #[doc = "   - 0: Success, device started."]
    #[doc = "   - <0: Error code of the driver device start function."]
    pub fn rte_compressdev_start(dev_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop a device. The device can be restarted with a call to"]
    #[doc = " rte_compressdev_start()"]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Compress device identifier"]
    pub fn rte_compressdev_stop(dev_id: u8);
}
extern "C" {
    #[doc = " Close an device."]
    #[doc = " The memory allocated in the device gets freed."]
    #[doc = " After calling this function, in order to use"]
    #[doc = " the device again, it is required to"]
    #[doc = " configure the device again."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Compress device identifier"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 on successfully closing device"]
    #[doc = "  - <0 on failure to close device"]
    pub fn rte_compressdev_close(dev_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate and set up a receive queue pair for a device."]
    #[doc = " This should only be called when the device is stopped."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Compress device identifier"]
    #[doc = " @param queue_pair_id"]
    #[doc = "   The index of the queue pairs to set up. The"]
    #[doc = "   value must be in the range [0, nb_queue_pair - 1]"]
    #[doc = "   previously supplied to rte_compressdev_configure()"]
    #[doc = " @param max_inflight_ops"]
    #[doc = "   Max number of ops which the qp will have to"]
    #[doc = "   accommodate simultaneously"]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier"]
    #[doc = "   in case of NUMA. The value can be *SOCKET_ID_ANY*"]
    #[doc = "   if there is no NUMA constraint for the DMA memory"]
    #[doc = "   allocated for the receive queue pair"]
    #[doc = " @return"]
    #[doc = "   - 0: Success, queue pair correctly set up."]
    #[doc = "   - <0: Queue pair configuration failed"]
    pub fn rte_compressdev_queue_pair_setup(
        dev_id: u8,
        queue_pair_id: u16,
        max_inflight_ops: u32,
        socket_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the number of queue pairs on a specific comp device"]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Compress device identifier"]
    #[doc = " @return"]
    #[doc = "   - The number of configured queue pairs."]
    pub fn rte_compressdev_queue_pair_count(dev_id: u8) -> u16;
}
extern "C" {
    #[doc = " Retrieve the general I/O statistics of a device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device"]
    #[doc = " @param stats"]
    #[doc = "   A pointer to a structure of type"]
    #[doc = "   *rte_compressdev_stats* to be filled with the"]
    #[doc = "   values of device counters"]
    #[doc = " @return"]
    #[doc = "   - Zero if successful."]
    #[doc = "   - Non-zero otherwise."]
    pub fn rte_compressdev_stats_get(
        dev_id: u8,
        stats: *mut rte_compressdev_stats,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset the general I/O statistics of a device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    pub fn rte_compressdev_stats_reset(dev_id: u8);
}
extern "C" {
    #[doc = " Retrieve the contextual information of a device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Compress device identifier"]
    #[doc = " @param dev_info"]
    #[doc = "   A pointer to a structure of type *rte_compressdev_info*"]
    #[doc = "   to be filled with the contextual information of the device"]
    #[doc = ""]
    #[doc = " @note The capabilities field of dev_info is set to point to the first"]
    #[doc = " element of an array of struct rte_compressdev_capabilities."]
    #[doc = " The element after the last valid element has it's op field set to"]
    #[doc = " RTE_COMP_ALGO_LIST_END."]
    pub fn rte_compressdev_info_get(dev_id: u8, dev_info: *mut rte_compressdev_info);
}
extern "C" {
    #[doc = " Dequeue a burst of processed compression operations from a queue on the comp"]
    #[doc = " device. The dequeued operation are stored in *rte_comp_op* structures"]
    #[doc = " whose pointers are supplied in the *ops* array."]
    #[doc = ""]
    #[doc = " The rte_compressdev_dequeue_burst() function returns the number of ops"]
    #[doc = " actually dequeued, which is the number of *rte_comp_op* data structures"]
    #[doc = " effectively supplied into the *ops* array."]
    #[doc = ""]
    #[doc = " A return value equal to *nb_ops* indicates that the queue contained"]
    #[doc = " at least *nb_ops* operations, and this is likely to signify that other"]
    #[doc = " processed operations remain in the devices output queue. Applications"]
    #[doc = " implementing a \"retrieve as many processed operations as possible\" policy"]
    #[doc = " can check this specific case and keep invoking the"]
    #[doc = " rte_compressdev_dequeue_burst() function until a value less than"]
    #[doc = " *nb_ops* is returned."]
    #[doc = ""]
    #[doc = " The rte_compressdev_dequeue_burst() function does not provide any error"]
    #[doc = " notification to avoid the corresponding overhead."]
    #[doc = ""]
    #[doc = " @note: operation ordering is not maintained within the queue pair."]
    #[doc = ""]
    #[doc = " @note: In case op status = OUT_OF_SPACE_TERMINATED, op.consumed=0 and the"]
    #[doc = " op must be resubmitted with the same input data and a larger output buffer."]
    #[doc = " op.produced is usually 0, but in decompression cases a PMD may return > 0"]
    #[doc = " and the application may find it useful to inspect that data."]
    #[doc = " This status is only returned on STATELESS ops."]
    #[doc = ""]
    #[doc = " @note: In case op status = OUT_OF_SPACE_RECOVERABLE, op.produced can be used"]
    #[doc = " and next op in stream should continue on from op.consumed+1 with a fresh"]
    #[doc = " output buffer."]
    #[doc = " Consumed=0, produced=0 is an unusual but allowed case. There may be useful"]
    #[doc = " state/history stored in the PMD, even though no output was produced yet."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Compress device identifier"]
    #[doc = " @param qp_id"]
    #[doc = "   The index of the queue pair from which to retrieve"]
    #[doc = "   processed operations. The value must be in the range"]
    #[doc = "   [0, nb_queue_pair - 1] previously supplied to"]
    #[doc = "   rte_compressdev_configure()"]
    #[doc = " @param ops"]
    #[doc = "   The address of an array of pointers to"]
    #[doc = "   *rte_comp_op* structures that must be"]
    #[doc = "   large enough to store *nb_ops* pointers in it"]
    #[doc = " @param nb_ops"]
    #[doc = "   The maximum number of operations to dequeue"]
    #[doc = " @return"]
    #[doc = "   - The number of operations actually dequeued, which is the number"]
    #[doc = "   of pointers to *rte_comp_op* structures effectively supplied to the"]
    #[doc = "   *ops* array."]
    pub fn rte_compressdev_dequeue_burst(
        dev_id: u8,
        qp_id: u16,
        ops: *mut *mut rte_comp_op,
        nb_ops: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " Enqueue a burst of operations for processing on a compression device."]
    #[doc = ""]
    #[doc = " The rte_compressdev_enqueue_burst() function is invoked to place"]
    #[doc = " comp operations on the queue *qp_id* of the device designated by"]
    #[doc = " its *dev_id*."]
    #[doc = ""]
    #[doc = " The *nb_ops* parameter is the number of operations to process which are"]
    #[doc = " supplied in the *ops* array of *rte_comp_op* structures."]
    #[doc = ""]
    #[doc = " The rte_compressdev_enqueue_burst() function returns the number of"]
    #[doc = " operations it actually enqueued for processing. A return value equal to"]
    #[doc = " *nb_ops* means that all packets have been enqueued."]
    #[doc = ""]
    #[doc = " @note All compression operations are Out-of-place (OOP) operations,"]
    #[doc = " as the size of the output data is different to the size of the input data."]
    #[doc = ""]
    #[doc = " @note The rte_comp_op contains both input and output parameters and is the"]
    #[doc = " vehicle for the application to pass data into and out of the PMD. While an"]
    #[doc = " op is inflight, i.e. once it has been enqueued, the private_xform or stream"]
    #[doc = " attached to it and any mbufs or memory referenced by it should not be altered"]
    #[doc = " or freed by the application. The PMD may use or change some of this data at"]
    #[doc = " any time until it has been returned in a dequeue operation."]
    #[doc = ""]
    #[doc = " @note The flush flag only applies to operations which return SUCCESS."]
    #[doc = " In OUT_OF_SPACE cases whether STATEFUL or STATELESS, data in dest buffer"]
    #[doc = " is as if flush flag was FLUSH_NONE."]
    #[doc = " @note flush flag only applies in compression direction. It has no meaning"]
    #[doc = " for decompression."]
    #[doc = " @note: operation ordering is not maintained within the queue pair."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Compress device identifier"]
    #[doc = " @param qp_id"]
    #[doc = "   The index of the queue pair on which operations"]
    #[doc = "   are to be enqueued for processing. The value"]
    #[doc = "   must be in the range [0, nb_queue_pairs - 1]"]
    #[doc = "   previously supplied to *rte_compressdev_configure*"]
    #[doc = " @param ops"]
    #[doc = "   The address of an array of *nb_ops* pointers"]
    #[doc = "   to *rte_comp_op* structures which contain"]
    #[doc = "   the operations to be processed"]
    #[doc = " @param nb_ops"]
    #[doc = "   The number of operations to process"]
    #[doc = " @return"]
    #[doc = "   The number of operations actually enqueued on the device. The return"]
    #[doc = "   value can be less than the value of the *nb_ops* parameter when the"]
    #[doc = "   comp devices queue is full or if invalid parameters are specified in"]
    #[doc = "   a *rte_comp_op*."]
    pub fn rte_compressdev_enqueue_burst(
        dev_id: u8,
        qp_id: u16,
        ops: *mut *mut rte_comp_op,
        nb_ops: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " This should alloc a stream from the device's mempool and initialise it."]
    #[doc = " The application should call this API when setting up for the stateful"]
    #[doc = " processing of a set of data on a device. The API can be called multiple"]
    #[doc = " times to set up a stream for each data set. The handle returned is only for"]
    #[doc = " use with ops of op_type STATEFUL and must be passed to the PMD"]
    #[doc = " with every op in the data stream"]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Compress device identifier"]
    #[doc = " @param xform"]
    #[doc = "   xform data"]
    #[doc = " @param stream"]
    #[doc = "   Pointer to where PMD's private stream handle should be stored"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 if successful and valid stream handle"]
    #[doc = "  - <0 in error cases"]
    #[doc = "  - Returns -EINVAL if input parameters are invalid."]
    #[doc = "  - Returns -ENOTSUP if comp device does not support STATEFUL operations."]
    #[doc = "  - Returns -ENOTSUP if comp device does not support the comp transform."]
    #[doc = "  - Returns -ENOMEM if the private stream could not be allocated."]
    #[doc = ""]
    pub fn rte_compressdev_stream_create(
        dev_id: u8,
        xform: *const rte_comp_xform,
        stream: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This should clear the stream and return it to the device's mempool."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Compress device identifier"]
    #[doc = ""]
    #[doc = " @param stream"]
    #[doc = "   PMD's private stream data"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 if successful"]
    #[doc = "  - <0 in error cases"]
    #[doc = "  - Returns -EINVAL if input parameters are invalid."]
    #[doc = "  - Returns -ENOTSUP if comp device does not support STATEFUL operations."]
    #[doc = "  - Returns -EBUSY if can't free stream as there are inflight operations"]
    pub fn rte_compressdev_stream_free(
        dev_id: u8,
        stream: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This should alloc a private_xform from the device's mempool and initialise"]
    #[doc = " it. The application should call this API when setting up for stateless"]
    #[doc = " processing on a device. If it returns non-shareable, then the appl cannot"]
    #[doc = " share this handle with multiple in-flight ops and should call this API again"]
    #[doc = " to get a separate handle for every in-flight op."]
    #[doc = " The handle returned is only valid for use with ops of op_type STATELESS."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Compress device identifier"]
    #[doc = " @param xform"]
    #[doc = "   xform data"]
    #[doc = " @param private_xform"]
    #[doc = "   Pointer to where PMD's private_xform handle should be stored"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - if successful returns 0"]
    #[doc = "    and valid private_xform handle"]
    #[doc = "  - <0 in error cases"]
    #[doc = "  - Returns -EINVAL if input parameters are invalid."]
    #[doc = "  - Returns -ENOTSUP if comp device does not support the comp transform."]
    #[doc = "  - Returns -ENOMEM if the private_xform could not be allocated."]
    pub fn rte_compressdev_private_xform_create(
        dev_id: u8,
        xform: *const rte_comp_xform,
        private_xform: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This should clear the private_xform and return it to the device's mempool."]
    #[doc = " It is the application's responsibility to ensure that private_xform data"]
    #[doc = " is not cleared while there are still in-flight operations using it."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Compress device identifier"]
    #[doc = ""]
    #[doc = " @param private_xform"]
    #[doc = "   PMD's private_xform data"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 if successful"]
    #[doc = "  - <0 in error cases"]
    #[doc = "  - Returns -EINVAL if input parameters are invalid."]
    pub fn rte_compressdev_private_xform_free(
        dev_id: u8,
        private_xform: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " Type of generic device"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_devtype {
    RTE_DEVTYPE_ALLOWED = 0,
    RTE_DEVTYPE_BLOCKED = 1,
    RTE_DEVTYPE_VIRTUAL = 2,
}
#[doc = " Structure that stores a device given by the user with its arguments"]
#[doc = ""]
#[doc = " A user device is a physical or a virtual device given by the user to"]
#[doc = " the DPDK application at startup through command line arguments."]
#[doc = ""]
#[doc = " The structure stores the configuration of the device, its PCI"]
#[doc = " identifier if it's a PCI device or the driver name if it's a virtual"]
#[doc = " device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_devargs {
    #[doc = " Next in list."]
    pub next: rte_devargs__bindgen_ty_1,
    #[doc = " Type of device."]
    pub type_: rte_devtype,
    #[doc = " Device policy."]
    pub policy: rte_dev_policy,
    #[doc = " Name of the device."]
    pub name: [::std::os::raw::c_char; 64usize],
    pub __bindgen_anon_1: rte_devargs__bindgen_ty_2,
    #[doc = "< bus handle."]
    pub bus: *mut rte_bus,
    #[doc = "< class handle."]
    pub cls: *mut rte_class,
    #[doc = "< bus-related part of device string."]
    pub bus_str: *const ::std::os::raw::c_char,
    #[doc = "< class-related part of device string."]
    pub cls_str: *const ::std::os::raw::c_char,
    #[doc = "< raw string including bus, class and driver parts."]
    pub data: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_devargs__bindgen_ty_1 {
    pub tqe_next: *mut rte_devargs,
    pub tqe_prev: *mut *mut rte_devargs,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_devargs__bindgen_ty_2 {
    #[doc = "< legacy name."]
    pub args: *const ::std::os::raw::c_char,
    #[doc = "< driver-related part of device string."]
    pub drv_str: *const ::std::os::raw::c_char,
}
extern "C" {
    #[doc = " Parse a device string."]
    #[doc = ""]
    #[doc = " Verify that a bus is capable of handling the device passed"]
    #[doc = " in argument. Store which bus will handle the device, its name"]
    #[doc = " and the eventual device parameters."]
    #[doc = ""]
    #[doc = " The syntax is:"]
    #[doc = ""]
    #[doc = "     bus:device_identifier,arg1=val1,arg2=val2"]
    #[doc = ""]
    #[doc = " where \"bus:\" is the bus name followed by any character separator."]
    #[doc = " The bus name is optional. If no bus name is specified, each bus"]
    #[doc = " will attempt to recognize the device identifier. The first one"]
    #[doc = " to succeed will be used."]
    #[doc = ""]
    #[doc = " Examples:"]
    #[doc = ""]
    #[doc = "     pci:0000:05.00.0,arg=val"]
    #[doc = "     05.00.0,arg=val"]
    #[doc = "     vdev:net_ring0"]
    #[doc = ""]
    #[doc = " @param da"]
    #[doc = "   The devargs structure holding the device information."]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "   String describing a device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success."]
    #[doc = "   - Negative errno on error."]
    pub fn rte_devargs_parse(
        da: *mut rte_devargs,
        dev: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse a device string."]
    #[doc = ""]
    #[doc = " Verify that a bus is capable of handling the device passed"]
    #[doc = " in argument. Store which bus will handle the device, its name"]
    #[doc = " and the eventual device parameters."]
    #[doc = ""]
    #[doc = " The device string is built with a printf-like syntax."]
    #[doc = ""]
    #[doc = " The syntax is:"]
    #[doc = ""]
    #[doc = "     bus:device_identifier,arg1=val1,arg2=val2"]
    #[doc = ""]
    #[doc = " where \"bus:\" is the bus name followed by any character separator."]
    #[doc = " The bus name is optional. If no bus name is specified, each bus"]
    #[doc = " will attempt to recognize the device identifier. The first one"]
    #[doc = " to succeed will be used."]
    #[doc = ""]
    #[doc = " Examples:"]
    #[doc = ""]
    #[doc = "     pci:0000:05.00.0,arg=val"]
    #[doc = "     05.00.0,arg=val"]
    #[doc = "     vdev:net_ring0"]
    #[doc = ""]
    #[doc = " @param da"]
    #[doc = "   The devargs structure holding the device information."]
    #[doc = " @param format"]
    #[doc = "   Format string describing a device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success."]
    #[doc = "   - Negative errno on error."]
    pub fn rte_devargs_parsef(
        da: *mut rte_devargs,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free resources in devargs."]
    #[doc = ""]
    #[doc = " @param da"]
    #[doc = "   The devargs structure holding the device information."]
    pub fn rte_devargs_reset(da: *mut rte_devargs);
}
extern "C" {
    #[doc = " Insert an rte_devargs in the global list."]
    #[doc = ""]
    #[doc = " @param da"]
    #[doc = "  The devargs structure to insert."]
    #[doc = "  If a devargs for the same device is already inserted,"]
    #[doc = "  it will be updated and returned. It means *da pointer can change."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - Negative on error."]
    pub fn rte_devargs_insert(da: *mut *mut rte_devargs) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a device to the user device list"]
    #[doc = " See rte_devargs_parse() for details."]
    #[doc = ""]
    #[doc = " @param devtype"]
    #[doc = "   The type of the device."]
    #[doc = " @param devargs_str"]
    #[doc = "   The arguments as given by the user."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - A negative value on error"]
    pub fn rte_devargs_add(
        devtype: rte_devtype,
        devargs_str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a device from the user device list."]
    #[doc = " Its resources are freed."]
    #[doc = " If the devargs cannot be found, nothing happens."]
    #[doc = ""]
    #[doc = " @param devargs"]
    #[doc = "   The instance or a copy of devargs to remove."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success."]
    #[doc = "   <0 on error."]
    #[doc = "   >0 if the devargs was not within the user device list."]
    pub fn rte_devargs_remove(devargs: *mut rte_devargs) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Count the number of user devices of a specified type"]
    #[doc = ""]
    #[doc = " @param devtype"]
    #[doc = "   The type of the devices to counted."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The number of devices."]
    pub fn rte_devargs_type_count(devtype: rte_devtype) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " This function dumps the list of user device and their arguments."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_devargs_dump(f: *mut FILE);
}
extern "C" {
    #[doc = " Find next rte_devargs matching the provided bus name."]
    #[doc = ""]
    #[doc = " @param busname"]
    #[doc = "   Limit the iteration to devargs related to buses"]
    #[doc = "   matching this name."]
    #[doc = "   Will return any next rte_devargs if NULL."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Starting iteration point. The iteration will start at"]
    #[doc = "   the first rte_devargs if NULL."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Next rte_devargs entry matching the requested bus,"]
    #[doc = "   NULL if there is none."]
    pub fn rte_devargs_next(
        busname: *const ::std::os::raw::c_char,
        start: *const rte_devargs,
    ) -> *mut rte_devargs;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_dev_reg_info {
    #[doc = "< Buffer for return registers"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< Start register table location for access"]
    pub offset: u32,
    #[doc = "< Number of registers to fetch"]
    pub length: u32,
    #[doc = "< Size of device register"]
    pub width: u32,
    #[doc = "< Device version"]
    pub version: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_dev_eeprom_info {
    #[doc = "< Buffer for return EEPROM"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< Start EEPROM address for access"]
    pub offset: u32,
    #[doc = "< Length of EEPROM region to access"]
    pub length: u32,
    #[doc = "< Device-specific key, such as device-id"]
    pub magic: u32,
}
#[doc = " Placeholder for accessing plugin module EEPROM"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_module_info {
    #[doc = "< Type of plugin module EEPROM"]
    pub type_: u32,
    #[doc = "< Length of plugin module EEPROM"]
    pub eeprom_len: u32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_distributor_alg_type {
    RTE_DIST_ALG_BURST = 0,
    RTE_DIST_ALG_SINGLE = 1,
    RTE_DIST_NUM_ALG_TYPES = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_distributor {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Function to create a new distributor instance"]
    #[doc = ""]
    #[doc = " Reserves the memory needed for the distributor operation and"]
    #[doc = " initializes the distributor to work with the configured number of workers."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name to be given to the distributor instance."]
    #[doc = " @param socket_id"]
    #[doc = "   The NUMA node on which the memory is to be allocated"]
    #[doc = " @param num_workers"]
    #[doc = "   The maximum number of workers that will request packets from this"]
    #[doc = "   distributor"]
    #[doc = " @param alg_type"]
    #[doc = "   Call the legacy API, or use the new burst API. legacy uses 32-bit"]
    #[doc = "   flow ID, and works on a single packet at a time. Latest uses 15-"]
    #[doc = "   bit flow ID and works on up to 8 packets at a time to workers."]
    #[doc = " @return"]
    #[doc = "   The newly created distributor instance"]
    pub fn rte_distributor_create(
        name: *const ::std::os::raw::c_char,
        socket_id: ::std::os::raw::c_uint,
        num_workers: ::std::os::raw::c_uint,
        alg_type: ::std::os::raw::c_uint,
    ) -> *mut rte_distributor;
}
extern "C" {
    #[doc = " Process a set of packets by distributing them among workers that request"]
    #[doc = " packets. The distributor will ensure that no two packets that have the"]
    #[doc = " same flow id, or tag, in the mbuf will be processed on different cores at"]
    #[doc = " the same time."]
    #[doc = ""]
    #[doc = " The user is advocated to set tag for each mbuf before calling this function."]
    #[doc = " If user doesn't set the tag, the tag value can be various values depending on"]
    #[doc = " driver implementation and configuration."]
    #[doc = ""]
    #[doc = " This is not multi-thread safe and should only be called on a single lcore."]
    #[doc = ""]
    #[doc = " @param d"]
    #[doc = "   The distributor instance to be used"]
    #[doc = " @param mbufs"]
    #[doc = "   The mbufs to be distributed"]
    #[doc = " @param num_mbufs"]
    #[doc = "   The number of mbufs in the mbufs array"]
    #[doc = " @return"]
    #[doc = "   The number of mbufs processed."]
    pub fn rte_distributor_process(
        d: *mut rte_distributor,
        mbufs: *mut *mut rte_mbuf,
        num_mbufs: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a set of mbufs that have been returned to the distributor by workers"]
    #[doc = ""]
    #[doc = " This should only be called on the same lcore as rte_distributor_process()"]
    #[doc = ""]
    #[doc = " @param d"]
    #[doc = "   The distributor instance to be used"]
    #[doc = " @param mbufs"]
    #[doc = "   The mbufs pointer array to be filled in"]
    #[doc = " @param max_mbufs"]
    #[doc = "   The size of the mbufs array"]
    #[doc = " @return"]
    #[doc = "   The number of mbufs returned in the mbufs array."]
    pub fn rte_distributor_returned_pkts(
        d: *mut rte_distributor,
        mbufs: *mut *mut rte_mbuf,
        max_mbufs: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Flush the distributor component, so that there are no in-flight or"]
    #[doc = " backlogged packets awaiting processing"]
    #[doc = ""]
    #[doc = " This should only be called on the same lcore as rte_distributor_process()"]
    #[doc = ""]
    #[doc = " @param d"]
    #[doc = "   The distributor instance to be used"]
    #[doc = " @return"]
    #[doc = "   The number of queued/in-flight packets that were completed by this call."]
    pub fn rte_distributor_flush(d: *mut rte_distributor) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clears the array of returned packets used as the source for the"]
    #[doc = " rte_distributor_returned_pkts() API call."]
    #[doc = ""]
    #[doc = " This should only be called on the same lcore as rte_distributor_process()"]
    #[doc = ""]
    #[doc = " @param d"]
    #[doc = "   The distributor instance to be used"]
    pub fn rte_distributor_clear_returns(d: *mut rte_distributor);
}
extern "C" {
    #[doc = " API called by a worker to get new packets to process. Any previous packets"]
    #[doc = " given to the worker is assumed to have completed processing, and may be"]
    #[doc = " optionally returned to the distributor via the oldpkt parameter."]
    #[doc = ""]
    #[doc = " @param d"]
    #[doc = "   The distributor instance to be used"]
    #[doc = " @param worker_id"]
    #[doc = "   The worker instance number to use - must be less that num_workers passed"]
    #[doc = "   at distributor creation time."]
    #[doc = " @param pkts"]
    #[doc = "   The mbufs pointer array to be filled in (up to 8 packets)"]
    #[doc = " @param oldpkt"]
    #[doc = "   The previous packets, if any, being processed by the worker"]
    #[doc = " @param retcount"]
    #[doc = "   The number of packets being returned"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The number of packets in the pkts array"]
    pub fn rte_distributor_get_pkt(
        d: *mut rte_distributor,
        worker_id: ::std::os::raw::c_uint,
        pkts: *mut *mut rte_mbuf,
        oldpkt: *mut *mut rte_mbuf,
        retcount: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " API called by a worker to return a completed packet without requesting a"]
    #[doc = " new packet, for example, because a worker thread is shutting down"]
    #[doc = ""]
    #[doc = " @param d"]
    #[doc = "   The distributor instance to be used"]
    #[doc = " @param worker_id"]
    #[doc = "   The worker instance number to use - must be less that num_workers passed"]
    #[doc = "   at distributor creation time."]
    #[doc = " @param oldpkt"]
    #[doc = "   The previous packets being processed by the worker"]
    #[doc = " @param num"]
    #[doc = "   The number of packets in the oldpkt array"]
    pub fn rte_distributor_return_pkt(
        d: *mut rte_distributor,
        worker_id: ::std::os::raw::c_uint,
        oldpkt: *mut *mut rte_mbuf,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " API called by a worker to request a new packet to process."]
    #[doc = " Any previous packets given to the worker are assumed to have completed"]
    #[doc = " processing, and may be optionally returned to the distributor via"]
    #[doc = " the oldpkt parameter."]
    #[doc = " Unlike rte_distributor_get_pkt(), this function does not wait for"]
    #[doc = " new packets to be provided by the distributor."]
    #[doc = ""]
    #[doc = " NOTE: after calling this function, rte_distributor_poll_pkt() should"]
    #[doc = " be used to poll for the packets requested. The rte_distributor_get_pkt()"]
    #[doc = " API should *not* be used to try and retrieve the new packets."]
    #[doc = ""]
    #[doc = " @param d"]
    #[doc = "   The distributor instance to be used"]
    #[doc = " @param worker_id"]
    #[doc = "   The worker instance number to use - must be less that num_workers passed"]
    #[doc = "   at distributor creation time."]
    #[doc = " @param oldpkt"]
    #[doc = "   The returning packets, if any, processed by the worker"]
    #[doc = " @param count"]
    #[doc = "   The number of returning packets"]
    pub fn rte_distributor_request_pkt(
        d: *mut rte_distributor,
        worker_id: ::std::os::raw::c_uint,
        oldpkt: *mut *mut rte_mbuf,
        count: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " API called by a worker to check for new packets that were previously"]
    #[doc = " requested by a call to rte_distributor_request_pkt(). It does not wait"]
    #[doc = " for the new packets to be available, but returns if the request has"]
    #[doc = " not yet been fulfilled by the distributor."]
    #[doc = ""]
    #[doc = " @param d"]
    #[doc = "   The distributor instance to be used"]
    #[doc = " @param worker_id"]
    #[doc = "   The worker instance number to use - must be less that num_workers passed"]
    #[doc = "   at distributor creation time."]
    #[doc = " @param mbufs"]
    #[doc = "   The array of mbufs being given to the worker"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The number of packets being given to the worker thread,"]
    #[doc = "   -1 if no packets are yet available (burst API - RTE_DIST_ALG_BURST)"]
    #[doc = "   0 if no packets are yet available (legacy single API - RTE_DIST_ALG_SINGLE)"]
    pub fn rte_distributor_poll_pkt(
        d: *mut rte_distributor,
        worker_id: ::std::os::raw::c_uint,
        mbufs: *mut *mut rte_mbuf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Configure the maximum number of dmadevs."]
    #[doc = " @note This function can be invoked before the primary process rte_eal_init()"]
    #[doc = " to change the maximum number of dmadevs. If not invoked, the maximum number"]
    #[doc = " of dmadevs is @see RTE_DMADEV_DEFAULT_MAX"]
    #[doc = ""]
    #[doc = " @param dev_max"]
    #[doc = "   maximum number of dmadevs."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success. Otherwise negative value is returned."]
    pub fn rte_dma_dev_max(dev_max: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Get the device identifier for the named DMA device."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   DMA device name."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Returns DMA device identifier on success."]
    #[doc = "   - <0: Failure to find named DMA device."]
    pub fn rte_dma_get_dev_id_by_name(name: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Check whether the dev_id is valid."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   DMA device index."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - If the device index is valid (true) or not (false)."]
    pub fn rte_dma_is_valid(dev_id: i16) -> bool;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Get the total number of DMA devices that have been successfully"]
    #[doc = " initialised."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The total number of usable DMA devices."]
    pub fn rte_dma_count_avail() -> u16;
}
extern "C" {
    #[doc = " Iterates over valid dmadev instances."]
    #[doc = ""]
    #[doc = " @param start_dev_id"]
    #[doc = "   The id of the next possible dmadev."]
    #[doc = " @return"]
    #[doc = "   Next valid dmadev, UINT16_MAX if there is none."]
    pub fn rte_dma_next_dev(start_dev_id: i16) -> i16;
}
#[doc = " A structure used to retrieve the information of a DMA device."]
#[doc = ""]
#[doc = " @see rte_dma_info_get"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_dma_info {
    #[doc = "< Unique device name."]
    pub dev_name: *const ::std::os::raw::c_char,
    #[doc = " Device capabilities (RTE_DMA_CAPA_*)."]
    pub dev_capa: u64,
    #[doc = " Maximum number of virtual DMA channels supported."]
    pub max_vchans: u16,
    #[doc = " Maximum allowed number of virtual DMA channel descriptors."]
    pub max_desc: u16,
    #[doc = " Minimum allowed number of virtual DMA channel descriptors."]
    pub min_desc: u16,
    #[doc = " Maximum number of source or destination scatter-gather entry"]
    #[doc = " supported."]
    #[doc = " If the device does not support COPY_SG capability, this value can be"]
    #[doc = " zero."]
    #[doc = " If the device supports COPY_SG capability, then rte_dma_copy_sg()"]
    #[doc = " parameter nb_src/nb_dst should not exceed this value."]
    pub max_sges: u16,
    #[doc = " NUMA node connection, -1 if unknown."]
    pub numa_node: i16,
    #[doc = " Number of virtual DMA channel configured."]
    pub nb_vchans: u16,
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Retrieve information of a DMA device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param[out] dev_info"]
    #[doc = "   A pointer to a structure of type *rte_dma_info* to be filled with the"]
    #[doc = "   information of the device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success. Otherwise negative value is returned."]
    pub fn rte_dma_info_get(dev_id: i16, dev_info: *mut rte_dma_info) -> ::std::os::raw::c_int;
}
#[doc = " A structure used to configure a DMA device."]
#[doc = ""]
#[doc = " @see rte_dma_configure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_dma_conf {
    #[doc = " The number of virtual DMA channels to set up for the DMA device."]
    #[doc = " This value cannot be greater than the field 'max_vchans' of struct"]
    #[doc = " rte_dma_info which get from rte_dma_info_get()."]
    pub nb_vchans: u16,
    #[doc = " Indicates whether to enable silent mode."]
    #[doc = " false-default mode, true-silent mode."]
    #[doc = " This value can be set to true only when the SILENT capability is"]
    #[doc = " supported."]
    #[doc = ""]
    #[doc = " @see RTE_DMA_CAPA_SILENT"]
    pub enable_silent: bool,
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Configure a DMA device."]
    #[doc = ""]
    #[doc = " This function must be invoked first before any other function in the"]
    #[doc = " API. This function can also be re-invoked when a device is in the"]
    #[doc = " stopped state."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device to configure."]
    #[doc = " @param dev_conf"]
    #[doc = "   The DMA device configuration structure encapsulated into rte_dma_conf"]
    #[doc = "   object."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success. Otherwise negative value is returned."]
    pub fn rte_dma_configure(dev_id: i16, dev_conf: *const rte_dma_conf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Start a DMA device."]
    #[doc = ""]
    #[doc = " The device start step is the last one and consists of setting the DMA"]
    #[doc = " to start accepting jobs."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success. Otherwise negative value is returned."]
    pub fn rte_dma_start(dev_id: i16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Stop a DMA device."]
    #[doc = ""]
    #[doc = " The device can be restarted with a call to rte_dma_start()."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success. Otherwise negative value is returned."]
    pub fn rte_dma_stop(dev_id: i16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Close a DMA device."]
    #[doc = ""]
    #[doc = " The device cannot be restarted after this call."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success. Otherwise negative value is returned."]
    pub fn rte_dma_close(dev_id: i16) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " DMA transfer direction defines."]
#[doc = ""]
#[doc = " @see struct rte_dma_vchan_conf::direction"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_dma_direction {
    #[doc = " DMA transfer direction - from memory to memory."]
    #[doc = ""]
    #[doc = " @see struct rte_dma_vchan_conf::direction"]
    RTE_DMA_DIR_MEM_TO_MEM = 0,
    #[doc = " DMA transfer direction - from memory to device."]
    #[doc = " In a typical scenario, the SoCs are installed on host servers as"]
    #[doc = " iNICs through the PCIe interface. In this case, the SoCs works in"]
    #[doc = " EP(endpoint) mode, it could initiate a DMA move request from memory"]
    #[doc = " (which is SoCs memory) to device (which is host memory)."]
    #[doc = ""]
    #[doc = " @see struct rte_dma_vchan_conf::direction"]
    RTE_DMA_DIR_MEM_TO_DEV = 1,
    #[doc = " DMA transfer direction - from device to memory."]
    #[doc = " In a typical scenario, the SoCs are installed on host servers as"]
    #[doc = " iNICs through the PCIe interface. In this case, the SoCs works in"]
    #[doc = " EP(endpoint) mode, it could initiate a DMA move request from device"]
    #[doc = " (which is host memory) to memory (which is SoCs memory)."]
    #[doc = ""]
    #[doc = " @see struct rte_dma_vchan_conf::direction"]
    RTE_DMA_DIR_DEV_TO_MEM = 2,
    #[doc = " DMA transfer direction - from device to device."]
    #[doc = " In a typical scenario, the SoCs are installed on host servers as"]
    #[doc = " iNICs through the PCIe interface. In this case, the SoCs works in"]
    #[doc = " EP(endpoint) mode, it could initiate a DMA move request from device"]
    #[doc = " (which is host memory) to the device (which is another host memory)."]
    #[doc = ""]
    #[doc = " @see struct rte_dma_vchan_conf::direction"]
    RTE_DMA_DIR_DEV_TO_DEV = 3,
}
#[repr(u32)]
#[doc = " DMA access port type defines."]
#[doc = ""]
#[doc = " @see struct rte_dma_port_param::port_type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_dma_port_type {
    RTE_DMA_PORT_NONE = 0,
    #[doc = "< The DMA access port is PCIe."]
    RTE_DMA_PORT_PCIE = 1,
}
#[doc = " A structure used to descript DMA access port parameters."]
#[doc = ""]
#[doc = " @see struct rte_dma_vchan_conf::src_port"]
#[doc = " @see struct rte_dma_vchan_conf::dst_port"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_dma_port_param {
    #[doc = " The device access port type."]
    #[doc = ""]
    #[doc = " @see enum rte_dma_port_type"]
    pub port_type: rte_dma_port_type,
    pub __bindgen_anon_1: rte_dma_port_param__bindgen_ty_1,
    #[doc = "< Reserved for future fields."]
    pub reserved: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_dma_port_param__bindgen_ty_1 {
    pub pcie: rte_dma_port_param__bindgen_ty_1__bindgen_ty_1,
}
#[doc = " PCIe access port parameters."]
#[doc = ""]
#[doc = " The following model shows SoC's PCIe module connects to"]
#[doc = " multiple PCIe hosts and multiple endpoints. The PCIe module"]
#[doc = " has an integrated DMA controller."]
#[doc = ""]
#[doc = " If the DMA wants to access the memory of host A, it can be"]
#[doc = " initiated by PF1 in core0, or by VF0 of PF0 in core0."]
#[doc = ""]
#[doc = " \\code{.unparsed}"]
#[doc = " System Bus"]
#[doc = "    |     ----------PCIe module----------"]
#[doc = "    |     Bus"]
#[doc = "    |     Interface"]
#[doc = "    |     -----        ------------------"]
#[doc = "    |     |   |        | PCIe Core0     |"]
#[doc = "    |     |   |        |                |        -----------"]
#[doc = "    |     |   |        |   PF-0 -- VF-0 |        | Host A  |"]
#[doc = "    |     |   |--------|        |- VF-1 |--------| Root    |"]
#[doc = "    |     |   |        |   PF-1         |        | Complex |"]
#[doc = "    |     |   |        |   PF-2         |        -----------"]
#[doc = "    |     |   |        ------------------"]
#[doc = "    |     |   |"]
#[doc = "    |     |   |        ------------------"]
#[doc = "    |     |   |        | PCIe Core1     |"]
#[doc = "    |     |   |        |                |        -----------"]
#[doc = "    |     |   |        |   PF-0 -- VF-0 |        | Host B  |"]
#[doc = "    |-----|   |--------|   PF-1 -- VF-0 |--------| Root    |"]
#[doc = "    |     |   |        |        |- VF-1 |        | Complex |"]
#[doc = "    |     |   |        |   PF-2         |        -----------"]
#[doc = "    |     |   |        ------------------"]
#[doc = "    |     |   |"]
#[doc = "    |     |   |        ------------------"]
#[doc = "    |     |DMA|        |                |        ------"]
#[doc = "    |     |   |        |                |--------| EP |"]
#[doc = "    |     |   |--------| PCIe Core2     |        ------"]
#[doc = "    |     |   |        |                |        ------"]
#[doc = "    |     |   |        |                |--------| EP |"]
#[doc = "    |     |   |        |                |        ------"]
#[doc = "    |     -----        ------------------"]
#[doc = ""]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " @note If some fields can not be supported by the"]
#[doc = " hardware/driver, then the driver ignores those fields."]
#[doc = " Please check driver-specific documentation for limitations"]
#[doc = " and capabilities."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct rte_dma_port_param__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 10usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl rte_dma_port_param__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn coreid(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_coreid(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn pfid(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_pfid(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn vfen(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_vfen(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vfid(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_vfid(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn pasid(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 20u8) as u64) }
    }
    #[inline]
    pub fn set_pasid(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn attr(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_attr(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ph(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_ph(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn st(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_st(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        coreid: u64,
        pfid: u64,
        vfen: u64,
        vfid: u64,
        pasid: u64,
        attr: u64,
        ph: u64,
        st: u64,
    ) -> __BindgenBitfieldUnit<[u8; 10usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 10usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let coreid: u64 = unsafe { ::std::mem::transmute(coreid) };
            coreid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 8u8, {
            let pfid: u64 = unsafe { ::std::mem::transmute(pfid) };
            pfid as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let vfen: u64 = unsafe { ::std::mem::transmute(vfen) };
            vfen as u64
        });
        __bindgen_bitfield_unit.set(13usize, 16u8, {
            let vfid: u64 = unsafe { ::std::mem::transmute(vfid) };
            vfid as u64
        });
        __bindgen_bitfield_unit.set(29usize, 20u8, {
            let pasid: u64 = unsafe { ::std::mem::transmute(pasid) };
            pasid as u64
        });
        __bindgen_bitfield_unit.set(49usize, 3u8, {
            let attr: u64 = unsafe { ::std::mem::transmute(attr) };
            attr as u64
        });
        __bindgen_bitfield_unit.set(52usize, 2u8, {
            let ph: u64 = unsafe { ::std::mem::transmute(ph) };
            ph as u64
        });
        __bindgen_bitfield_unit.set(64usize, 16u8, {
            let st: u64 = unsafe { ::std::mem::transmute(st) };
            st as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to configure a virtual DMA channel."]
#[doc = ""]
#[doc = " @see rte_dma_vchan_setup"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_dma_vchan_conf {
    #[doc = " Transfer direction"]
    #[doc = ""]
    #[doc = " @see enum rte_dma_direction"]
    pub direction: rte_dma_direction,
    #[doc = " Number of descriptor for the virtual DMA channel"]
    pub nb_desc: u16,
    #[doc = " 1) Used to describes the device access port parameter in the"]
    #[doc = " device-to-memory transfer scenario."]
    #[doc = " 2) Used to describes the source device access port parameter in the"]
    #[doc = " device-to-device transfer scenario."]
    #[doc = ""]
    #[doc = " @see struct rte_dma_port_param"]
    pub src_port: rte_dma_port_param,
    #[doc = " 1) Used to describes the device access port parameter in the"]
    #[doc = " memory-to-device transfer scenario."]
    #[doc = " 2) Used to describes the destination device access port parameter in"]
    #[doc = " the device-to-device transfer scenario."]
    #[doc = ""]
    #[doc = " @see struct rte_dma_port_param"]
    pub dst_port: rte_dma_port_param,
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Allocate and set up a virtual DMA channel."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param vchan"]
    #[doc = "   The identifier of virtual DMA channel. The value must be in the range"]
    #[doc = "   [0, nb_vchans - 1] previously supplied to rte_dma_configure()."]
    #[doc = " @param conf"]
    #[doc = "   The virtual DMA channel configuration structure encapsulated into"]
    #[doc = "   rte_dma_vchan_conf object."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success. Otherwise negative value is returned."]
    pub fn rte_dma_vchan_setup(
        dev_id: i16,
        vchan: u16,
        conf: *const rte_dma_vchan_conf,
    ) -> ::std::os::raw::c_int;
}
#[doc = " A structure used to retrieve statistics."]
#[doc = ""]
#[doc = " @see rte_dma_stats_get"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_dma_stats {
    #[doc = " Count of operations which were submitted to hardware."]
    pub submitted: u64,
    #[doc = " Count of operations which were completed, including successful and"]
    #[doc = " failed completions."]
    pub completed: u64,
    #[doc = " Count of operations which failed to complete."]
    pub errors: u64,
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Retrieve basic statistics of a or all virtual DMA channel(s)."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param vchan"]
    #[doc = "   The identifier of virtual DMA channel."]
    #[doc = "   If equal RTE_DMA_ALL_VCHAN means all channels."]
    #[doc = " @param[out] stats"]
    #[doc = "   The basic statistics structure encapsulated into rte_dma_stats"]
    #[doc = "   object."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success. Otherwise negative value is returned."]
    pub fn rte_dma_stats_get(
        dev_id: i16,
        vchan: u16,
        stats: *mut rte_dma_stats,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Reset basic statistics of a or all virtual DMA channel(s)."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param vchan"]
    #[doc = "   The identifier of virtual DMA channel."]
    #[doc = "   If equal RTE_DMA_ALL_VCHAN means all channels."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success. Otherwise negative value is returned."]
    pub fn rte_dma_stats_reset(dev_id: i16, vchan: u16) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " device vchannel status"]
#[doc = ""]
#[doc = " Enum with the options for the channel status, either idle, active or halted due to error"]
#[doc = " @see rte_dma_vchan_status"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_dma_vchan_status {
    #[doc = "< not processing, awaiting ops"]
    RTE_DMA_VCHAN_IDLE = 0,
    #[doc = "< currently processing jobs"]
    RTE_DMA_VCHAN_ACTIVE = 1,
    #[doc = "< not processing due to error, cannot accept new ops"]
    RTE_DMA_VCHAN_HALTED_ERROR = 2,
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Determine if all jobs have completed on a device channel."]
    #[doc = " This function is primarily designed for testing use, as it allows a process to check if"]
    #[doc = " all jobs are completed, without actually gathering completions from those jobs."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param vchan"]
    #[doc = "   The identifier of virtual DMA channel."]
    #[doc = " @param[out] status"]
    #[doc = "   The vchan status"]
    #[doc = " @return"]
    #[doc = "   0 - call completed successfully"]
    #[doc = "   < 0 - error code indicating there was a problem calling the API"]
    pub fn rte_dma_vchan_status(
        dev_id: i16,
        vchan: u16,
        status: *mut rte_dma_vchan_status,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Dump DMA device info."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param f"]
    #[doc = "   The file to write the output to."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success. Otherwise negative value is returned."]
    pub fn rte_dma_dump(dev_id: i16, f: *mut FILE) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " DMA transfer result status code defines."]
#[doc = ""]
#[doc = " @see rte_dma_completed_status"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_dma_status_code {
    #[doc = " The operation completed successfully."]
    RTE_DMA_STATUS_SUCCESSFUL = 0,
    #[doc = " The operation failed to complete due abort by user."]
    #[doc = " This is mainly used when processing dev_stop, user could modify the"]
    #[doc = " descriptors (e.g. change one bit to tell hardware abort this job),"]
    #[doc = " it allows outstanding requests to be complete as much as possible,"]
    #[doc = " so reduce the time to stop the device."]
    RTE_DMA_STATUS_USER_ABORT = 1,
    #[doc = " The operation failed to complete due to following scenarios:"]
    #[doc = " The jobs in a particular batch are not attempted because they"]
    #[doc = " appeared after a fence where a previous job failed. In some HW"]
    #[doc = " implementation it's possible for jobs from later batches would be"]
    #[doc = " completed, though, so report the status from the not attempted jobs"]
    #[doc = " before reporting those newer completed jobs."]
    RTE_DMA_STATUS_NOT_ATTEMPTED = 2,
    #[doc = " The operation failed to complete due invalid source address."]
    RTE_DMA_STATUS_INVALID_SRC_ADDR = 3,
    #[doc = " The operation failed to complete due invalid destination address."]
    RTE_DMA_STATUS_INVALID_DST_ADDR = 4,
    #[doc = " The operation failed to complete due invalid source or destination"]
    #[doc = " address, cover the case that only knows the address error, but not"]
    #[doc = " sure which address error."]
    RTE_DMA_STATUS_INVALID_ADDR = 5,
    #[doc = " The operation failed to complete due invalid length."]
    RTE_DMA_STATUS_INVALID_LENGTH = 6,
    #[doc = " The operation failed to complete due invalid opcode."]
    #[doc = " The DMA descriptor could have multiple format, which are"]
    #[doc = " distinguished by the opcode field."]
    RTE_DMA_STATUS_INVALID_OPCODE = 7,
    #[doc = " The operation failed to complete due bus read error."]
    RTE_DMA_STATUS_BUS_READ_ERROR = 8,
    #[doc = " The operation failed to complete due bus write error."]
    RTE_DMA_STATUS_BUS_WRITE_ERROR = 9,
    #[doc = " The operation failed to complete due bus error, cover the case that"]
    #[doc = " only knows the bus error, but not sure which direction error."]
    RTE_DMA_STATUS_BUS_ERROR = 10,
    #[doc = " The operation failed to complete due data poison."]
    RTE_DMA_STATUS_DATA_POISION = 11,
    #[doc = " The operation failed to complete due descriptor read error."]
    RTE_DMA_STATUS_DESCRIPTOR_READ_ERROR = 12,
    #[doc = " The operation failed to complete due device link error."]
    #[doc = " Used to indicates that the link error in the memory-to-device/"]
    #[doc = " device-to-memory/device-to-device transfer scenario."]
    RTE_DMA_STATUS_DEV_LINK_ERROR = 13,
    #[doc = " The operation failed to complete due lookup page fault."]
    RTE_DMA_STATUS_PAGE_FAULT = 14,
    #[doc = " The operation failed to complete due unknown reason."]
    #[doc = " The initial value is 256, which reserves space for future errors."]
    RTE_DMA_STATUS_ERROR_UNKNOWN = 256,
}
#[doc = " A structure used to hold scatter-gather DMA operation request entry."]
#[doc = ""]
#[doc = " @see rte_dma_copy_sg"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_dma_sge {
    #[doc = "< The DMA operation address."]
    pub addr: rte_iova_t,
    #[doc = "< The DMA operation length."]
    pub length: u32,
}
#[doc = " @internal Used to enqueue a copy operation."]
pub type rte_dma_copy_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev_private: *mut ::std::os::raw::c_void,
        vchan: u16,
        src: rte_iova_t,
        dst: rte_iova_t,
        length: u32,
        flags: u64,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Used to enqueue a scatter-gather list copy operation."]
pub type rte_dma_copy_sg_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev_private: *mut ::std::os::raw::c_void,
        vchan: u16,
        src: *const rte_dma_sge,
        dst: *const rte_dma_sge,
        nb_src: u16,
        nb_dst: u16,
        flags: u64,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Used to enqueue a fill operation."]
pub type rte_dma_fill_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev_private: *mut ::std::os::raw::c_void,
        vchan: u16,
        pattern: u64,
        dst: rte_iova_t,
        length: u32,
        flags: u64,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Used to trigger hardware to begin working."]
pub type rte_dma_submit_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev_private: *mut ::std::os::raw::c_void,
        vchan: u16,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Used to return number of successful completed operations."]
pub type rte_dma_completed_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev_private: *mut ::std::os::raw::c_void,
        vchan: u16,
        nb_cpls: u16,
        last_idx: *mut u16,
        has_error: *mut bool,
    ) -> u16,
>;
#[doc = " @internal Used to return number of completed operations."]
pub type rte_dma_completed_status_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev_private: *mut ::std::os::raw::c_void,
        vchan: u16,
        nb_cpls: u16,
        last_idx: *mut u16,
        status: *mut rte_dma_status_code,
    ) -> u16,
>;
#[doc = " @internal Used to check the remaining space in descriptor ring."]
pub type rte_dma_burst_capacity_t = ::std::option::Option<
    unsafe extern "C" fn(dev_private: *const ::std::os::raw::c_void, vchan: u16) -> u16,
>;
#[doc = " @internal"]
#[doc = " Fast-path dmadev functions and related data are hold in a flat array."]
#[doc = " One entry per dmadev."]
#[doc = ""]
#[doc = " This structure occupy exactly 128B which reserve space for future IO"]
#[doc = " functions."]
#[doc = ""]
#[doc = " The 'dev_private' field was placed in the first cache line to optimize"]
#[doc = " performance because the PMD mainly depends on this field."]
#[repr(C)]
#[repr(align(128))]
#[derive(Debug, Copy, Clone)]
pub struct rte_dma_fp_object {
    #[doc = " PMD-specific private data. The driver should copy"]
    #[doc = " rte_dma_dev.data->dev_private to this field during initialization."]
    pub dev_private: *mut ::std::os::raw::c_void,
    pub copy: rte_dma_copy_t,
    pub copy_sg: rte_dma_copy_sg_t,
    pub fill: rte_dma_fill_t,
    pub submit: rte_dma_submit_t,
    pub completed: rte_dma_completed_t,
    pub completed_status: rte_dma_completed_status_t,
    pub burst_capacity: rte_dma_burst_capacity_t,
}
extern "C" {
    pub static mut rte_dma_fp_objs: *mut rte_dma_fp_object;
}
extern "C" {
    #[doc = " Lock the internal EAL shared memory configuration for shared access."]
    pub fn rte_mcfg_mem_read_lock();
}
extern "C" {
    #[doc = " Unlock the internal EAL shared memory configuration for shared access."]
    pub fn rte_mcfg_mem_read_unlock();
}
extern "C" {
    #[doc = " Lock the internal EAL shared memory configuration for exclusive access."]
    pub fn rte_mcfg_mem_write_lock();
}
extern "C" {
    #[doc = " Unlock the internal EAL shared memory configuration for exclusive access."]
    pub fn rte_mcfg_mem_write_unlock();
}
extern "C" {
    #[doc = " Lock the internal EAL TAILQ list for shared access."]
    pub fn rte_mcfg_tailq_read_lock();
}
extern "C" {
    #[doc = " Unlock the internal EAL TAILQ list for shared access."]
    pub fn rte_mcfg_tailq_read_unlock();
}
extern "C" {
    #[doc = " Lock the internal EAL TAILQ list for exclusive access."]
    pub fn rte_mcfg_tailq_write_lock();
}
extern "C" {
    #[doc = " Unlock the internal EAL TAILQ list for exclusive access."]
    pub fn rte_mcfg_tailq_write_unlock();
}
extern "C" {
    #[doc = " Lock the internal EAL Mempool list for shared access."]
    pub fn rte_mcfg_mempool_read_lock();
}
extern "C" {
    #[doc = " Unlock the internal EAL Mempool list for shared access."]
    pub fn rte_mcfg_mempool_read_unlock();
}
extern "C" {
    #[doc = " Lock the internal EAL Mempool list for exclusive access."]
    pub fn rte_mcfg_mempool_write_lock();
}
extern "C" {
    #[doc = " Unlock the internal EAL Mempool list for exclusive access."]
    pub fn rte_mcfg_mempool_write_unlock();
}
extern "C" {
    #[doc = " Lock the internal EAL Timer Library lock for exclusive access."]
    pub fn rte_mcfg_timer_lock();
}
extern "C" {
    #[doc = " Unlock the internal EAL Timer Library lock for exclusive access."]
    pub fn rte_mcfg_timer_unlock();
}
extern "C" {
    #[doc = " If true, pages are put in single files (per memseg list),"]
    #[doc = " as opposed to creating a file per page."]
    pub fn rte_mcfg_get_single_file_segments() -> bool;
}
pub type rte_intr_event_cb_t = ::std::option::Option<
    unsafe extern "C" fn(fd: ::std::os::raw::c_int, arg: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_epoll_data {
    #[doc = "< event type"]
    pub event: u32,
    #[doc = "< User data"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< IN: callback fun"]
    pub cb_fun: rte_intr_event_cb_t,
    #[doc = "< IN: callback arg"]
    pub cb_arg: *mut ::std::os::raw::c_void,
}
pub const RTE_EPOLL_INVALID: _bindgen_ty_18 = _bindgen_ty_18::RTE_EPOLL_INVALID;
pub const RTE_EPOLL_VALID: _bindgen_ty_18 = _bindgen_ty_18::RTE_EPOLL_VALID;
pub const RTE_EPOLL_EXEC: _bindgen_ty_18 = _bindgen_ty_18::RTE_EPOLL_EXEC;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_18 {
    RTE_EPOLL_INVALID = 0,
    RTE_EPOLL_VALID = 1,
    RTE_EPOLL_EXEC = 2,
}
#[doc = " interrupt epoll event obj, taken by epoll_event.ptr"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_epoll_event {
    #[doc = "< OUT: event status"]
    pub status: u32,
    #[doc = "< OUT: event fd"]
    pub fd: ::std::os::raw::c_int,
    #[doc = "< OUT: epoll instance the ev associated with"]
    pub epfd: ::std::os::raw::c_int,
    pub epdata: rte_epoll_data,
}
extern "C" {
    #[doc = " It waits for events on the epoll instance."]
    #[doc = " Retries if signal received."]
    #[doc = ""]
    #[doc = " @param epfd"]
    #[doc = "   Epoll instance fd on which the caller wait for events."]
    #[doc = " @param events"]
    #[doc = "   Memory area contains the events that will be available for the caller."]
    #[doc = " @param maxevents"]
    #[doc = "   Up to maxevents are returned, must greater than zero."]
    #[doc = " @param timeout"]
    #[doc = "   Specifying a timeout of -1 causes a block indefinitely."]
    #[doc = "   Specifying a timeout equal to zero cause to return immediately."]
    #[doc = " @return"]
    #[doc = "   - On success, returns the number of available event."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_epoll_wait(
        epfd: ::std::os::raw::c_int,
        events: *mut rte_epoll_event,
        maxevents: ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It waits for events on the epoll instance."]
    #[doc = " Does not retry if signal received."]
    #[doc = ""]
    #[doc = " @param epfd"]
    #[doc = "   Epoll instance fd on which the caller wait for events."]
    #[doc = " @param events"]
    #[doc = "   Memory area contains the events that will be available for the caller."]
    #[doc = " @param maxevents"]
    #[doc = "   Up to maxevents are returned, must greater than zero."]
    #[doc = " @param timeout"]
    #[doc = "   Specifying a timeout of -1 causes a block indefinitely."]
    #[doc = "   Specifying a timeout equal to zero cause to return immediately."]
    #[doc = " @return"]
    #[doc = "   - On success, returns the number of available event."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_epoll_wait_interruptible(
        epfd: ::std::os::raw::c_int,
        events: *mut rte_epoll_event,
        maxevents: ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It performs control operations on epoll instance referred by the epfd."]
    #[doc = " It requests that the operation op be performed for the target fd."]
    #[doc = ""]
    #[doc = " @param epfd"]
    #[doc = "   Epoll instance fd on which the caller perform control operations."]
    #[doc = " @param op"]
    #[doc = "   The operation be performed for the target fd."]
    #[doc = " @param fd"]
    #[doc = "   The target fd on which the control ops perform."]
    #[doc = " @param event"]
    #[doc = "   Describes the object linked to the fd."]
    #[doc = "   Note: The caller must take care the object deletion after CTL_DEL."]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_epoll_ctl(
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        fd: ::std::os::raw::c_int,
        event: *mut rte_epoll_event,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " The interrupt source type, e.g. UIO, VFIO, ALARM etc."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_intr_handle_type {
    #[doc = "< generic unknown handle"]
    RTE_INTR_HANDLE_UNKNOWN = 0,
    #[doc = "< uio device handle"]
    RTE_INTR_HANDLE_UIO = 1,
    #[doc = "< uio generic handle"]
    RTE_INTR_HANDLE_UIO_INTX = 2,
    #[doc = "< vfio device handle (legacy)"]
    RTE_INTR_HANDLE_VFIO_LEGACY = 3,
    #[doc = "< vfio device handle (MSI)"]
    RTE_INTR_HANDLE_VFIO_MSI = 4,
    #[doc = "< vfio device handle (MSIX)"]
    RTE_INTR_HANDLE_VFIO_MSIX = 5,
    #[doc = "< alarm handle"]
    RTE_INTR_HANDLE_ALARM = 6,
    #[doc = "< external handler"]
    RTE_INTR_HANDLE_EXT = 7,
    #[doc = "< virtual device"]
    RTE_INTR_HANDLE_VDEV = 8,
    #[doc = "< device event handle"]
    RTE_INTR_HANDLE_DEV_EVENT = 9,
    #[doc = "< VFIO request handle"]
    RTE_INTR_HANDLE_VFIO_REQ = 10,
    #[doc = "< count of elements"]
    RTE_INTR_HANDLE_MAX = 11,
}
#[doc = " Function to be registered for the specific interrupt"]
pub type rte_intr_callback_fn =
    ::std::option::Option<unsafe extern "C" fn(cb_arg: *mut ::std::os::raw::c_void)>;
#[doc = " Function to call after a callback is unregistered."]
#[doc = " Can be used to close fd and free cb_arg."]
pub type rte_intr_unregister_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(intr_handle: *mut rte_intr_handle, cb_arg: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " It registers the callback for the specific interrupt. Multiple"]
    #[doc = " callbacks can be registered at the same time."]
    #[doc = " @param intr_handle"]
    #[doc = "  Pointer to the interrupt handle."]
    #[doc = " @param cb"]
    #[doc = "  callback address."]
    #[doc = " @param cb_arg"]
    #[doc = "  address of parameter for callback."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_intr_callback_register(
        intr_handle: *const rte_intr_handle,
        cb: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It unregisters the callback according to the specified interrupt handle."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = " @param cb"]
    #[doc = "  callback address."]
    #[doc = " @param cb_arg"]
    #[doc = "  address of parameter for callback, (void *)-1 means to remove all"]
    #[doc = "  registered which has the same callback address."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, return the number of callback entities removed."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_intr_callback_unregister(
        intr_handle: *const rte_intr_handle,
        cb: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unregister the callback according to the specified interrupt handle,"]
    #[doc = " after it's no longer active. Fail if source is not active."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = " @param cb_fn"]
    #[doc = "  callback address."]
    #[doc = " @param cb_arg"]
    #[doc = "  address of parameter for callback, (void *)-1 means to remove all"]
    #[doc = "  registered which has the same callback address."]
    #[doc = " @param ucb_fn"]
    #[doc = "  callback to call before cb is unregistered (optional)."]
    #[doc = "  can be used to close fd and free cb_arg."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, return the number of callback entities marked for remove."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_intr_callback_unregister_pending(
        intr_handle: *const rte_intr_handle,
        cb_fn: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
        ucb_fn: rte_intr_unregister_callback_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Loop until rte_intr_callback_unregister() succeeds."]
    #[doc = " After a call to this function,"]
    #[doc = " the callback provided by the specified interrupt handle is unregistered."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = " @param cb"]
    #[doc = "  callback address."]
    #[doc = " @param cb_arg"]
    #[doc = "  address of parameter for callback, (void *)-1 means to remove all"]
    #[doc = "  registered which has the same callback address."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, return the number of callback entities removed."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_intr_callback_unregister_sync(
        intr_handle: *const rte_intr_handle,
        cb: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It enables the interrupt for the specified handle."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_intr_enable(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It disables the interrupt for the specified handle."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_intr_disable(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " It acknowledges an interrupt raised for the specified handle."]
    #[doc = ""]
    #[doc = " This function should be called at the end of each interrupt handler either"]
    #[doc = " from application or driver, so that currently raised interrupt is acked and"]
    #[doc = " further new interrupts are raised."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_intr_ack(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Check if currently executing in interrupt context"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non zero in case of interrupt context"]
    #[doc = "  - zero in case of process context"]
    pub fn rte_thread_is_intr() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " It allocates memory for interrupt instance. API takes flag as an argument"]
    #[doc = " which define from where memory should be allocated i.e. using DPDK memory"]
    #[doc = " management library APIs or normal heap allocation."]
    #[doc = " Default memory allocation for event fds and event list array is done which"]
    #[doc = " can be realloced later based on size of MSIX interrupts supported by a PCI"]
    #[doc = " device."]
    #[doc = ""]
    #[doc = " This function should be called from application or driver, before calling"]
    #[doc = " any of the interrupt APIs."]
    #[doc = ""]
    #[doc = " @param flags"]
    #[doc = "  See RTE_INTR_INSTANCE_F_* flags definitions."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, address of interrupt handle."]
    #[doc = "  - On failure, NULL."]
    pub fn rte_intr_instance_alloc(flags: u32) -> *mut rte_intr_handle;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " This API is used to free the memory allocated for interrupt handle"]
    #[doc = " resources."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  Interrupt handle address."]
    #[doc = ""]
    pub fn rte_intr_instance_free(intr_handle: *mut rte_intr_handle);
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " This API is used to set the fd field of interrupt handle with user provided"]
    #[doc = " file descriptor."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = " @param fd"]
    #[doc = "  file descriptor value provided by user."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_fd_set(
        intr_handle: *mut rte_intr_handle,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Returns the fd field of the given interrupt handle instance."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, fd field."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_intr_fd_get(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " This API is used to set the type field of interrupt handle with user provided"]
    #[doc = " interrupt type."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = " @param type"]
    #[doc = "  interrupt type"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_type_set(
        intr_handle: *mut rte_intr_handle,
        type_: rte_intr_handle_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Returns the type field of the given interrupt handle instance."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, interrupt type"]
    #[doc = "  - On failure, RTE_INTR_HANDLE_UNKNOWN."]
    pub fn rte_intr_type_get(intr_handle: *const rte_intr_handle) -> rte_intr_handle_type;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " The function returns the per thread epoll instance."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   epfd the epoll instance referred to."]
    pub fn rte_intr_tls_epfd() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " @param intr_handle"]
    #[doc = "   Pointer to the interrupt handle."]
    #[doc = " @param epfd"]
    #[doc = "   Epoll instance fd which the intr vector associated to."]
    #[doc = " @param op"]
    #[doc = "   The operation be performed for the vector."]
    #[doc = "   Operation type of {ADD, DEL}."]
    #[doc = " @param vec"]
    #[doc = "   RX intr vector number added to the epoll instance wait list."]
    #[doc = " @param data"]
    #[doc = "   User raw data."]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_intr_rx_ctl(
        intr_handle: *mut rte_intr_handle,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        vec: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " It deletes registered eventfds."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "   Pointer to the interrupt handle."]
    pub fn rte_intr_free_epoll_fd(intr_handle: *mut rte_intr_handle);
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " It enables the packet I/O interrupt event if it's necessary."]
    #[doc = " It creates event fd for each interrupt vector when MSIX is used,"]
    #[doc = " otherwise it multiplexes a single event fd."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "   Pointer to the interrupt handle."]
    #[doc = " @param nb_efd"]
    #[doc = "   Number of interrupt vector trying to enable."]
    #[doc = "   The value 0 is not allowed."]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_intr_efd_enable(
        intr_handle: *mut rte_intr_handle,
        nb_efd: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " It disables the packet I/O interrupt event."]
    #[doc = " It deletes registered eventfds and closes the open fds."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "   Pointer to the interrupt handle."]
    pub fn rte_intr_efd_disable(intr_handle: *mut rte_intr_handle);
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " The packet I/O interrupt on datapath is enabled or not."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "   Pointer to the interrupt handle."]
    pub fn rte_intr_dp_is_en(intr_handle: *mut rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " The interrupt handle instance allows other causes or not."]
    #[doc = " Other causes stand for any none packet I/O interrupts."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "   Pointer to the interrupt handle."]
    pub fn rte_intr_allow_others(intr_handle: *mut rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " The multiple interrupt vector capability of interrupt handle instance."]
    #[doc = " It returns zero if no multiple interrupt vector support."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "   Pointer to the interrupt handle."]
    pub fn rte_intr_cap_multiple(intr_handle: *mut rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Creates a clone of src by allocating a new handle and copying src content."]
    #[doc = ""]
    #[doc = " @param src"]
    #[doc = "  Source interrupt handle to be cloned."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, address of interrupt handle."]
    #[doc = "  - On failure, NULL."]
    pub fn rte_intr_instance_dup(src: *const rte_intr_handle) -> *mut rte_intr_handle;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " This API is used to set the device fd field of interrupt handle with user"]
    #[doc = " provided dev fd. Device fd corresponds to VFIO device fd or UIO config fd."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = " @param fd"]
    #[doc = "  interrupt type"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_dev_fd_set(
        intr_handle: *mut rte_intr_handle,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Returns the device fd field of the given interrupt handle instance."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, dev fd."]
    #[doc = "  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_dev_fd_get(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " This API is used to set the max intr field of interrupt handle with user"]
    #[doc = " provided max intr value."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = " @param max_intr"]
    #[doc = "  interrupt type"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_max_intr_set(
        intr_handle: *mut rte_intr_handle,
        max_intr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Returns the max intr field of the given interrupt handle instance."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, max intr."]
    #[doc = "  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_max_intr_get(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " This API is used to set the number of event fd field of interrupt handle"]
    #[doc = " with user provided available event file descriptor value."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = " @param nb_efd"]
    #[doc = "  Available event fd"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_nb_efd_set(
        intr_handle: *mut rte_intr_handle,
        nb_efd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Returns the number of available event fd field of the given interrupt handle"]
    #[doc = " instance."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, nb_efd"]
    #[doc = "  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_nb_efd_get(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Returns the number of interrupt vector field of the given interrupt handle"]
    #[doc = " instance. This field is to configured on device probe time, and based on"]
    #[doc = " this value efds and elist arrays are dynamically allocated. By default"]
    #[doc = " this value is set to RTE_MAX_RXTX_INTR_VEC_ID."]
    #[doc = " For eg. in case of PCI device, its msix size is queried and efds/elist"]
    #[doc = " arrays are allocated accordingly."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, nb_intr"]
    #[doc = "  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_nb_intr_get(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " This API is used to set the event fd counter size field of interrupt handle"]
    #[doc = " with user provided efd counter size."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = " @param efd_counter_size"]
    #[doc = "  size of efd counter."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_efd_counter_size_set(
        intr_handle: *mut rte_intr_handle,
        efd_counter_size: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Returns the event fd counter size field of the given interrupt handle"]
    #[doc = " instance."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, efd_counter_size"]
    #[doc = "  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_efd_counter_size_get(
        intr_handle: *const rte_intr_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " This API is used to set the event fd array index with the given fd."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = " @param index"]
    #[doc = "  efds array index to be set"]
    #[doc = " @param fd"]
    #[doc = "  event fd"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_efds_index_set(
        intr_handle: *mut rte_intr_handle,
        index: ::std::os::raw::c_int,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Returns the fd value of event fds array at a given index."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = " @param index"]
    #[doc = "  efds array index to be returned"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, fd"]
    #[doc = "  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_efds_index_get(
        intr_handle: *const rte_intr_handle,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " This API is used to set the epoll event object array index with the given"]
    #[doc = " elist instance."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = " @param index"]
    #[doc = "  elist array index to be set"]
    #[doc = " @param elist"]
    #[doc = "  epoll event instance of struct rte_epoll_event"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_elist_index_set(
        intr_handle: *mut rte_intr_handle,
        index: ::std::os::raw::c_int,
        elist: rte_epoll_event,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Returns the address of epoll event instance from elist array at a given"]
    #[doc = " index."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = " @param index"]
    #[doc = "  elist array index to be returned"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, elist"]
    #[doc = "  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_elist_index_get(
        intr_handle: *mut rte_intr_handle,
        index: ::std::os::raw::c_int,
    ) -> *mut rte_epoll_event;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Allocates the memory of interrupt vector list array, with size defining the"]
    #[doc = " number of elements required in the array."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = " @param name"]
    #[doc = "  Name assigned to the allocation, or NULL."]
    #[doc = " @param size"]
    #[doc = "  Number of element required in the array."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero"]
    #[doc = "  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_vec_list_alloc(
        intr_handle: *mut rte_intr_handle,
        name: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Sets the vector value at given index of interrupt vector list field of given"]
    #[doc = " interrupt handle."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = " @param index"]
    #[doc = "  intr_vec array index to be set"]
    #[doc = " @param vec"]
    #[doc = "  Interrupt vector value."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero"]
    #[doc = "  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_vec_list_index_set(
        intr_handle: *mut rte_intr_handle,
        index: ::std::os::raw::c_int,
        vec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Returns the vector value at the given index of interrupt vector list array."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = " @param index"]
    #[doc = "  intr_vec array index to be returned"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, interrupt vector"]
    #[doc = "  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_vec_list_index_get(
        intr_handle: *const rte_intr_handle,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Frees the memory allocated for interrupt vector list array."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero"]
    #[doc = "  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_vec_list_free(intr_handle: *mut rte_intr_handle);
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Reallocates the size efds and elist array based on size provided by user."]
    #[doc = " By default efds and elist array are allocated with default size"]
    #[doc = " RTE_MAX_RXTX_INTR_VEC_ID on interrupt handle array creation. Later on device"]
    #[doc = " probe, device may have capability of more interrupts than"]
    #[doc = " RTE_MAX_RXTX_INTR_VEC_ID. Using this API, PMDs can reallocate the arrays as"]
    #[doc = " per the max interrupts capability of device."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = " @param size"]
    #[doc = "  efds and elist array size."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero"]
    #[doc = "  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_event_list_update(
        intr_handle: *mut rte_intr_handle,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " This API returns the Windows handle of the given interrupt instance."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, Windows handle."]
    #[doc = "  - On failure, NULL."]
    pub fn rte_intr_instance_windows_handle_get(
        intr_handle: *mut rte_intr_handle,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " This API set the Windows handle for the given interrupt instance."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = " @param windows_handle"]
    #[doc = "  Windows handle to be set."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero"]
    #[doc = "  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_instance_windows_handle_set(
        intr_handle: *mut rte_intr_handle,
        windows_handle: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Interrupt handle"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_intr_handle {
    pub __bindgen_anon_1: rte_intr_handle__bindgen_ty_1,
    #[doc = "< flags passed at allocation"]
    pub alloc_flags: u32,
    #[doc = "< handle type"]
    pub type_: rte_intr_handle_type,
    #[doc = "< max interrupt requested"]
    pub max_intr: u32,
    #[doc = "< number of available efd(event fd)"]
    pub nb_efd: u32,
    #[doc = "< size of efd counter, used for vdev"]
    pub efd_counter_size: u8,
    pub nb_intr: u16,
    #[doc = "< intr vectors/efds mapping"]
    pub efds: *mut ::std::os::raw::c_int,
    #[doc = "< intr vector epoll event"]
    pub elist: *mut rte_epoll_event,
    pub vec_list_size: u16,
    #[doc = "< intr vector number array"]
    pub intr_vec: *mut ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_intr_handle__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_intr_handle__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< device driver handle"]
    pub windows_handle: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_intr_handle__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< VFIO/UIO cfg device file descriptor"]
    pub dev_fd: ::std::os::raw::c_int,
    #[doc = "< interrupt event file descriptor"]
    pub fd: ::std::os::raw::c_int,
}
extern "C" {
    pub static mut __rte_eal_trace_alarm_set: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_alarm_cancel: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_generic_void: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_generic_u64: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_generic_u32: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_generic_u16: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_generic_u8: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_generic_i64: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_generic_i32: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_generic_i16: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_generic_i8: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_generic_int: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_generic_long: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_generic_float: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_generic_double: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_generic_ptr: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_generic_str: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_generic_size_t: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_generic_func: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_intr_callback_register: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_intr_callback_unregister: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_intr_enable: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_intr_disable: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_mem_zmalloc: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_mem_malloc: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_mem_realloc: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_mem_free: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_memzone_reserve: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_memzone_lookup: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_memzone_free: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_thread_remote_launch: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eal_trace_thread_lcore_ready: rte_trace_point_t;
}
#[doc = " eCPRI Common Header"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ecpri_common_hdr {
    pub __bindgen_anon_1: rte_ecpri_common_hdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_ecpri_common_hdr__bindgen_ty_1 {
    #[doc = "< 4B common header in BE"]
    pub u32_: rte_be32_t,
    pub __bindgen_anon_1: rte_ecpri_common_hdr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_ecpri_common_hdr__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rte_ecpri_common_hdr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn c(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_res(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn revision(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_revision(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        size: u32,
        type_: u32,
        c: u32,
        res: u32,
        revision: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let size: u32 = unsafe { ::std::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let c: u32 = unsafe { ::std::mem::transmute(c) };
            c as u64
        });
        __bindgen_bitfield_unit.set(25usize, 3u8, {
            let res: u32 = unsafe { ::std::mem::transmute(res) };
            res as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let revision: u32 = unsafe { ::std::mem::transmute(revision) };
            revision as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " eCPRI Message Header of Type #0: IQ Data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ecpri_msg_iq_data {
    #[doc = "< Physical channel ID"]
    pub pc_id: rte_be16_t,
    #[doc = "< Sequence ID"]
    pub seq_id: rte_be16_t,
}
#[doc = " eCPRI Message Header of Type #1: Bit Sequence"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ecpri_msg_bit_seq {
    #[doc = "< Physical channel ID"]
    pub pc_id: rte_be16_t,
    #[doc = "< Sequence ID"]
    pub seq_id: rte_be16_t,
}
#[doc = " eCPRI Message Header of Type #2: Real-Time Control Data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ecpri_msg_rtc_ctrl {
    #[doc = "< Real-Time Control Data ID"]
    pub rtc_id: rte_be16_t,
    #[doc = "< Sequence ID"]
    pub seq_id: rte_be16_t,
}
#[doc = " eCPRI Message Header of Type #3: Generic Data Transfer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ecpri_msg_gen_data {
    #[doc = "< Physical channel ID"]
    pub pc_id: rte_be32_t,
    #[doc = "< Sequence ID"]
    pub seq_id: rte_be32_t,
}
#[doc = " eCPRI Message Header of Type #4: Remote Memory Access"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_ecpri_msg_rm_access {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< 48-bits address"]
    pub addr: [u8; 6usize],
    #[doc = "< number of bytes"]
    pub length: rte_be16_t,
}
impl rte_ecpri_msg_rm_access {
    #[inline]
    pub fn ele_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_ele_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn rr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rw(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rma_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rma_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ele_id: u32,
        rr: u32,
        rw: u32,
        rma_id: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let ele_id: u32 = unsafe { ::std::mem::transmute(ele_id) };
            ele_id as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let rr: u32 = unsafe { ::std::mem::transmute(rr) };
            rr as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let rw: u32 = unsafe { ::std::mem::transmute(rw) };
            rw as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let rma_id: u32 = unsafe { ::std::mem::transmute(rma_id) };
            rma_id as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " eCPRI Message Header of Type #5: One-Way Delay Measurement"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ecpri_msg_delay_measure {
    #[doc = "< Measurement ID"]
    pub msr_id: u8,
    #[doc = "< Action Type"]
    pub act_type: u8,
}
#[doc = " eCPRI Message Header of Type #6: Remote Reset"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ecpri_msg_remote_reset {
    #[doc = "< Reset ID"]
    pub rst_id: rte_be16_t,
    #[doc = "< Reset Code Op"]
    pub rst_op: u8,
}
#[doc = " eCPRI Message Header of Type #7: Event Indication"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ecpri_msg_event_ind {
    #[doc = "< Event ID"]
    pub evt_id: u8,
    #[doc = "< Event Type"]
    pub evt_type: u8,
    #[doc = "< Sequence Number"]
    pub seq: u8,
    #[doc = "< Number of Faults/Notif"]
    pub number: u8,
}
#[doc = " eCPRI Combined Message Header Format: Common Header + Message Types"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ecpri_combined_msg_hdr {
    pub common: rte_ecpri_common_hdr,
    pub __bindgen_anon_1: rte_ecpri_combined_msg_hdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_ecpri_combined_msg_hdr__bindgen_ty_1 {
    pub type0: rte_ecpri_msg_iq_data,
    pub type1: rte_ecpri_msg_bit_seq,
    pub type2: rte_ecpri_msg_rtc_ctrl,
    pub type3: rte_ecpri_msg_gen_data,
    pub type4: rte_ecpri_msg_rm_access,
    pub type5: rte_ecpri_msg_delay_measure,
    pub type6: rte_ecpri_msg_remote_reset,
    pub type7: rte_ecpri_msg_event_ind,
    pub dummy: [rte_be32_t; 3usize],
}
pub type efd_value_t = u8;
pub type efd_lookuptbl_t = u16;
pub type efd_hashfunc_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_efd_table {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Creates an EFD table with a single offline region and multiple per-socket"]
    #[doc = " internally-managed copies of the online table used for lookups"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   EFD table name"]
    #[doc = " @param max_num_rules"]
    #[doc = "   Minimum number of rules the table should be sized to hold."]
    #[doc = "   Will be rounded up to the next smallest valid table size"]
    #[doc = " @param key_len"]
    #[doc = "   Length of the key"]
    #[doc = " @param online_cpu_socket_bitmask"]
    #[doc = "   Bitmask specifying which sockets should get a copy of the online table."]
    #[doc = "   LSB = socket 0, etc."]
    #[doc = " @param offline_cpu_socket"]
    #[doc = "   Identifies the socket where the offline table will be allocated"]
    #[doc = "   (and most efficiently accessed in the case of updates/insertions)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   EFD table, or NULL if table allocation failed or the bitmask is invalid"]
    pub fn rte_efd_create(
        name: *const ::std::os::raw::c_char,
        max_num_rules: u32,
        key_len: u32,
        online_cpu_socket_bitmask: u64,
        offline_cpu_socket: u8,
    ) -> *mut rte_efd_table;
}
extern "C" {
    #[doc = " Releases the resources from an EFD table"]
    #[doc = ""]
    #[doc = " @param table"]
    #[doc = "   Table to free"]
    pub fn rte_efd_free(table: *mut rte_efd_table);
}
extern "C" {
    #[doc = " Find an existing EFD table object and return a pointer to it."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Name of the EFD table as passed to rte_efd_create()"]
    #[doc = " @return"]
    #[doc = "   Pointer to EFD table or NULL if object not found"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - ENOENT - value not available for return"]
    pub fn rte_efd_find_existing(name: *const ::std::os::raw::c_char) -> *mut rte_efd_table;
}
extern "C" {
    #[doc = " Computes an updated table entry for the supplied key/value pair."]
    #[doc = " The update is then immediately applied to the provided table and"]
    #[doc = " all socket-local copies of the chunks are updated."]
    #[doc = " This operation is not multi-thread safe"]
    #[doc = " and should only be called one from thread."]
    #[doc = ""]
    #[doc = " @param table"]
    #[doc = "   EFD table to reference"]
    #[doc = " @param socket_id"]
    #[doc = "   Socket ID to use to lookup existing value (ideally caller's socket id)"]
    #[doc = " @param key"]
    #[doc = "   EFD table key to modify"]
    #[doc = " @param value"]
    #[doc = "   Value to associate with the key"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  RTE_EFD_UPDATE_WARN_GROUP_FULL"]
    #[doc = "     Operation is insert, and the last available space in the"]
    #[doc = "     key's group was just used"]
    #[doc = "     Future inserts may fail as groups fill up"]
    #[doc = "     This operation was still successful, and entry contains a valid update"]
    #[doc = "  RTE_EFD_UPDATE_FAILED"]
    #[doc = "     Either the EFD failed to find a suitable perfect hash or the group was full"]
    #[doc = "     This is a fatal error, and the table is now in an indeterminate state"]
    #[doc = "  RTE_EFD_UPDATE_NO_CHANGE"]
    #[doc = "     Operation resulted in no change to the table (same value already exists)"]
    #[doc = "  0 - success"]
    pub fn rte_efd_update(
        table: *mut rte_efd_table,
        socket_id: ::std::os::raw::c_uint,
        key: *const ::std::os::raw::c_void,
        value: efd_value_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Removes any value currently associated with the specified key from the table"]
    #[doc = " This operation is not multi-thread safe"]
    #[doc = " and should only be called from one thread."]
    #[doc = ""]
    #[doc = " @param table"]
    #[doc = "   EFD table to reference"]
    #[doc = " @param socket_id"]
    #[doc = "   Socket ID to use to lookup existing value (ideally caller's socket id)"]
    #[doc = " @param key"]
    #[doc = "   EFD table key to delete"]
    #[doc = " @param prev_value"]
    #[doc = "   If not NULL, will store the previous value here before deleting it"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 - successfully found and deleted the key"]
    #[doc = "   nonzero otherwise"]
    pub fn rte_efd_delete(
        table: *mut rte_efd_table,
        socket_id: ::std::os::raw::c_uint,
        key: *const ::std::os::raw::c_void,
        prev_value: *mut efd_value_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Looks up the value associated with a key"]
    #[doc = " This operation is multi-thread safe."]
    #[doc = ""]
    #[doc = " NOTE: Lookups will *always* succeed - this is a property of"]
    #[doc = " using a perfect hash table."]
    #[doc = " If the specified key was never inserted, a pseudorandom answer will be returned."]
    #[doc = " There is no way to know based on the lookup if the key was ever inserted"]
    #[doc = " originally, so this must be tracked elsewhere."]
    #[doc = ""]
    #[doc = " @param table"]
    #[doc = "   EFD table to reference"]
    #[doc = " @param socket_id"]
    #[doc = "   Socket ID to use to lookup existing value (ideally caller's socket id)"]
    #[doc = " @param key"]
    #[doc = "   EFD table key to look up"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Value associated with the key, or random junk if they key was never inserted"]
    pub fn rte_efd_lookup(
        table: *const rte_efd_table,
        socket_id: ::std::os::raw::c_uint,
        key: *const ::std::os::raw::c_void,
    ) -> efd_value_t;
}
extern "C" {
    #[doc = " Looks up the value associated with several keys."]
    #[doc = " This operation is multi-thread safe."]
    #[doc = ""]
    #[doc = " NOTE: Lookups will *always* succeed - this is a property of"]
    #[doc = " using a perfect hash table."]
    #[doc = " If the specified key was never inserted, a pseudorandom answer will be returned."]
    #[doc = " There is no way to know based on the lookup if the key was ever inserted"]
    #[doc = " originally, so this must be tracked elsewhere."]
    #[doc = ""]
    #[doc = " @param table"]
    #[doc = "   EFD table to reference"]
    #[doc = " @param socket_id"]
    #[doc = "   Socket ID to use to lookup existing value (ideally caller's socket id)"]
    #[doc = " @param num_keys"]
    #[doc = "   Number of keys in the key_list array, must be less than RTE_EFD_BURST_MAX"]
    #[doc = " @param key_list"]
    #[doc = "   Array of num_keys pointers which point to keys to look up"]
    #[doc = " @param value_list"]
    #[doc = "   Array of size num_keys where lookup values will be stored"]
    pub fn rte_efd_lookup_bulk(
        table: *const rte_efd_table,
        socket_id: ::std::os::raw::c_uint,
        num_keys: ::std::os::raw::c_int,
        key_list: *mut *const ::std::os::raw::c_void,
        value_list: *mut efd_value_t,
    );
}
extern "C" {
    #[doc = " Seed the pseudo-random generator."]
    #[doc = ""]
    #[doc = " The generator is automatically seeded by the EAL init with a timer"]
    #[doc = " value. It may need to be re-seeded by the user with a real random"]
    #[doc = " value."]
    #[doc = ""]
    #[doc = " This function is not multi-thread safe in regards to other"]
    #[doc = " rte_srand() calls, nor is it in relation to concurrent rte_rand()"]
    #[doc = " calls."]
    #[doc = ""]
    #[doc = " @param seedval"]
    #[doc = "   The value of the seed."]
    pub fn rte_srand(seedval: u64);
}
extern "C" {
    #[doc = " Get a pseudo-random value."]
    #[doc = ""]
    #[doc = " The generator is not cryptographically secure."]
    #[doc = ""]
    #[doc = " If called from lcore threads, this function is thread-safe."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   A pseudo-random value between 0 and (1<<64)-1."]
    pub fn rte_rand() -> u64;
}
extern "C" {
    #[doc = " Generates a pseudo-random number with an upper bound."]
    #[doc = ""]
    #[doc = " This function returns an uniformly distributed (unbiased) random"]
    #[doc = " number less than a user-specified maximum value."]
    #[doc = ""]
    #[doc = " If called from lcore threads, this function is thread-safe."]
    #[doc = ""]
    #[doc = " @param upper_bound"]
    #[doc = "   The upper bound of the generated number."]
    #[doc = " @return"]
    #[doc = "   A pseudo-random value between 0 and (upper_bound-1)."]
    pub fn rte_rand_max(upper_bound: u64) -> u64;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_l2tpv2_common_hdr__bindgen_ty_1 {
    #[doc = " header flags and protocol version"]
    pub flags_version: rte_be16_t,
    pub __bindgen_anon_1: rte_l2tpv2_common_hdr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct rte_l2tpv2_common_hdr__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl rte_l2tpv2_common_hdr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ver(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_ver(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn res3(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_res3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn o(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_o(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res2(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn s(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_s(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn l(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_l(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn t(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_t(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ver: u16,
        res3: u16,
        p: u16,
        o: u16,
        res2: u16,
        s: u16,
        res1: u16,
        l: u16,
        t: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ver: u16 = unsafe { ::std::mem::transmute(ver) };
            ver as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let res3: u16 = unsafe { ::std::mem::transmute(res3) };
            res3 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let p: u16 = unsafe { ::std::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let o: u16 = unsafe { ::std::mem::transmute(o) };
            o as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let res2: u16 = unsafe { ::std::mem::transmute(res2) };
            res2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let s: u16 = unsafe { ::std::mem::transmute(s) };
            s as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let res1: u16 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let l: u16 = unsafe { ::std::mem::transmute(l) };
            l as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let t: u16 = unsafe { ::std::mem::transmute(t) };
            t as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " L2TPv2 message Header contains all options(length, ns, nr,"]
#[doc = " offset size, offset padding)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_l2tpv2_msg_with_all_options {
    #[doc = "< length(16)"]
    pub length: rte_be16_t,
    #[doc = "< tunnel ID(16)"]
    pub tunnel_id: rte_be16_t,
    #[doc = "< session ID(16)"]
    pub session_id: rte_be16_t,
    #[doc = "< Ns(16)"]
    pub ns: rte_be16_t,
    #[doc = "< Nr(16)"]
    pub nr: rte_be16_t,
    #[doc = "< offset size(16)"]
    pub offset_size: rte_be16_t,
    #[doc = "< offset padding(variable length)"]
    pub offset_padding: *mut u8,
}
#[doc = " L2TPv2 message Header contains all options except length(ns, nr,"]
#[doc = " offset size, offset padding)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_l2tpv2_msg_without_length {
    #[doc = "< tunnel ID(16)"]
    pub tunnel_id: rte_be16_t,
    #[doc = "< session ID(16)"]
    pub session_id: rte_be16_t,
    #[doc = "< Ns(16)"]
    pub ns: rte_be16_t,
    #[doc = "< Nr(16)"]
    pub nr: rte_be16_t,
    #[doc = "< offset size(16)"]
    pub offset_size: rte_be16_t,
    #[doc = "< offset padding(variable length)"]
    pub offset_padding: *mut u8,
}
#[doc = " L2TPv2 message Header contains all options except ns_nr(length,"]
#[doc = " offset size, offset padding)."]
#[doc = " Ns and Nr MUST be together."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_l2tpv2_msg_without_ns_nr {
    #[doc = "< length(16)"]
    pub length: rte_be16_t,
    #[doc = "< tunnel ID(16)"]
    pub tunnel_id: rte_be16_t,
    #[doc = "< session ID(16)"]
    pub session_id: rte_be16_t,
    #[doc = "< offset size(16)"]
    pub offset_size: rte_be16_t,
    #[doc = "< offset padding(variable length)"]
    pub offset_padding: *mut u8,
}
#[doc = " L2TPv2 message Header contains all options except ns_nr(length, ns, nr)."]
#[doc = " offset size and offset padding MUST be together."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_l2tpv2_msg_without_offset {
    #[doc = "< length(16)"]
    pub length: rte_be16_t,
    #[doc = "< tunnel ID(16)"]
    pub tunnel_id: rte_be16_t,
    #[doc = "< session ID(16)"]
    pub session_id: rte_be16_t,
    #[doc = "< Ns(16)"]
    pub ns: rte_be16_t,
    #[doc = "< Nr(16)"]
    pub nr: rte_be16_t,
}
#[doc = " L2TPv2 message Header contains options offset size and offset padding."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_l2tpv2_msg_with_offset {
    #[doc = "< tunnel ID(16)"]
    pub tunnel_id: rte_be16_t,
    #[doc = "< session ID(16)"]
    pub session_id: rte_be16_t,
    #[doc = "< offset size(16)"]
    pub offset_size: rte_be16_t,
    #[doc = "< offset padding(variable length)"]
    pub offset_padding: *mut u8,
}
#[doc = " L2TPv2 message Header contains options ns and nr."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_l2tpv2_msg_with_ns_nr {
    #[doc = "< tunnel ID(16)"]
    pub tunnel_id: rte_be16_t,
    #[doc = "< session ID(16)"]
    pub session_id: rte_be16_t,
    #[doc = "< Ns(16)"]
    pub ns: rte_be16_t,
    #[doc = "< Nr(16)"]
    pub nr: rte_be16_t,
}
#[doc = " L2TPv2 message Header contains option length."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_l2tpv2_msg_with_length {
    #[doc = "< length(16)"]
    pub length: rte_be16_t,
    #[doc = "< tunnel ID(16)"]
    pub tunnel_id: rte_be16_t,
    #[doc = "< session ID(16)"]
    pub session_id: rte_be16_t,
}
#[doc = " L2TPv2 message Header without all options."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_l2tpv2_msg_without_all_options {
    #[doc = "< tunnel ID(16)"]
    pub tunnel_id: rte_be16_t,
    #[doc = "< session ID(16)"]
    pub session_id: rte_be16_t,
}
#[doc = " L2TPv2 Combined Message Header Format: Common Header + Options"]
#[repr(C, packed)]
pub struct rte_l2tpv2_combined_msg_hdr {
    #[doc = "< common header"]
    pub common: rte_l2tpv2_common_hdr,
    pub __bindgen_anon_1: rte_l2tpv2_combined_msg_hdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_l2tpv2_combined_msg_hdr__bindgen_ty_1 {
    #[doc = " header with all options"]
    pub type0: rte_l2tpv2_msg_with_all_options,
    #[doc = " header with all options except length"]
    pub type1: rte_l2tpv2_msg_without_length,
    #[doc = " header with all options except ns/nr"]
    pub type2: rte_l2tpv2_msg_without_ns_nr,
    #[doc = " header with all options except offset"]
    pub type3: rte_l2tpv2_msg_without_offset,
    #[doc = " header with offset options"]
    pub type4: rte_l2tpv2_msg_with_offset,
    #[doc = " header with ns/nr options"]
    pub type5: rte_l2tpv2_msg_with_ns_nr,
    #[doc = " header with length option"]
    pub type6: rte_l2tpv2_msg_with_length,
    #[doc = " header without all options"]
    pub type7: rte_l2tpv2_msg_without_all_options,
}
extern "C" {
    #[doc = " Generate a random Ethernet address that is locally administered"]
    #[doc = " and not multicast."]
    #[doc = " @param addr"]
    #[doc = "   A pointer to Ethernet address."]
    pub fn rte_eth_random_addr(addr: *mut u8);
}
extern "C" {
    #[doc = " Format 48bits Ethernet address in pattern xx:xx:xx:xx:xx:xx."]
    #[doc = ""]
    #[doc = " @param buf"]
    #[doc = "   A pointer to buffer contains the formatted MAC address."]
    #[doc = " @param size"]
    #[doc = "   The format buffer size."]
    #[doc = " @param eth_addr"]
    #[doc = "   A pointer to a ether_addr structure."]
    pub fn rte_ether_format_addr(
        buf: *mut ::std::os::raw::c_char,
        size: u16,
        eth_addr: *const rte_ether_addr,
    );
}
extern "C" {
    #[doc = " Convert string with Ethernet address to an ether_addr."]
    #[doc = ""]
    #[doc = " @param str"]
    #[doc = "   A pointer to buffer contains the formatted MAC address."]
    #[doc = "   The supported formats are:"]
    #[doc = "     XX:XX:XX:XX:XX:XX or XXXX:XXXX:XXXX"]
    #[doc = "   where XX is a hex digit: 0-9, a-f, or A-F."]
    #[doc = " @param eth_addr"]
    #[doc = "   A pointer to a ether_addr structure."]
    #[doc = " @return"]
    #[doc = "   0 if successful"]
    #[doc = "   -1 and sets rte_errno if invalid string"]
    pub fn rte_ether_unformat_addr(
        str_: *const ::std::os::raw::c_char,
        eth_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Ethernet VLAN Header."]
#[doc = " Contains the 16-bit VLAN Tag Control Identifier and the Ethernet type"]
#[doc = " of the encapsulated frame."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_vlan_hdr {
    #[doc = "< Priority (3) + CFI (1) + Identifier Code (12)"]
    pub vlan_tci: rte_be16_t,
    #[doc = "< Ethernet type of encapsulated frame."]
    pub eth_proto: rte_be16_t,
}
#[doc = " Callback definition for monitoring conditions. Callbacks with this signature"]
#[doc = " will be used by `rte_power_monitor()` to check if the entering of power"]
#[doc = " optimized state should be aborted."]
#[doc = ""]
#[doc = " @param val"]
#[doc = "   The value read from memory."]
#[doc = " @param opaque"]
#[doc = "   Callback-specific data."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   0 if entering of power optimized state should proceed"]
#[doc = "   -1 if entering of power optimized state should be aborted"]
pub type rte_power_monitor_clb_t = ::std::option::Option<
    unsafe extern "C" fn(val: u64, opaque: *const u64) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_power_monitor_cond {
    #[doc = "< Address to monitor for changes"]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< Data size (in bytes) that will be read from the"]
    #[doc = "   monitored memory location (`addr`). Can be 1, 2,"]
    #[doc = "   4, or 8. Supplying any other value will result in"]
    #[doc = "   an error."]
    pub size: u8,
    #[doc = "< Callback to be used to check if"]
    #[doc = "   entering power optimized state should"]
    #[doc = "   be aborted."]
    pub fn_: rte_power_monitor_clb_t,
    pub opaque: [u64; 4usize],
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Monitor specific address for changes. This will cause the CPU to enter an"]
    #[doc = " architecture-defined optimized power state until either the specified"]
    #[doc = " memory address is written to, a certain TSC timestamp is reached, or other"]
    #[doc = " reasons cause the CPU to wake up."]
    #[doc = ""]
    #[doc = " Additionally, an expected value (`pmc->val`), mask (`pmc->mask`), and data"]
    #[doc = " size (`pmc->size`) are provided in the `pmc` power monitoring condition. If"]
    #[doc = " the mask is non-zero, the current value pointed to by the `pmc->addr` pointer"]
    #[doc = " will be read and compared against the expected value, and if they match, the"]
    #[doc = " entering of optimized power state will be aborted. This is intended to"]
    #[doc = " prevent the CPU from entering optimized power state and waiting on a write"]
    #[doc = " that has already happened by the time this API is called."]
    #[doc = ""]
    #[doc = " @warning It is responsibility of the user to check if this function is"]
    #[doc = "   supported at runtime using `rte_cpu_get_intrinsics_support()` API call."]
    #[doc = ""]
    #[doc = " @param pmc"]
    #[doc = "   The monitoring condition structure."]
    #[doc = " @param tsc_timestamp"]
    #[doc = "   Maximum TSC timestamp to wait for. Note that the wait behavior is"]
    #[doc = "   architecture-dependent."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success"]
    #[doc = "   -EINVAL on invalid parameters"]
    #[doc = "   -ENOTSUP if unsupported"]
    pub fn rte_power_monitor(
        pmc: *const rte_power_monitor_cond,
        tsc_timestamp: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Wake up a specific lcore that is in a power optimized state and is monitoring"]
    #[doc = " an address."]
    #[doc = ""]
    #[doc = " @note It is safe to call this function if the lcore in question is not"]
    #[doc = "   sleeping. The function will have no effect."]
    #[doc = ""]
    #[doc = " @note This function will *not* wake up a core that is in a power optimized"]
    #[doc = "   state due to calling `rte_power_pause`."]
    #[doc = ""]
    #[doc = " @param lcore_id"]
    #[doc = "   Lcore ID of a sleeping thread."]
    pub fn rte_power_monitor_wakeup(lcore_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Enter an architecture-defined optimized power state until a certain TSC"]
    #[doc = " timestamp is reached."]
    #[doc = ""]
    #[doc = " @warning It is responsibility of the user to check if this function is"]
    #[doc = "   supported at runtime using `rte_cpu_get_intrinsics_support()` API call."]
    #[doc = ""]
    #[doc = " @param tsc_timestamp"]
    #[doc = "   Maximum TSC timestamp to wait for. Note that the wait behavior is"]
    #[doc = "   architecture-dependent."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success"]
    #[doc = "   -EINVAL on invalid parameters"]
    #[doc = "   -ENOTSUP if unsupported"]
    pub fn rte_power_pause(tsc_timestamp: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Monitor a set of addresses for changes. This will cause the CPU to enter an"]
    #[doc = " architecture-defined optimized power state until either one of the specified"]
    #[doc = " memory addresses is written to, a certain TSC timestamp is reached, or other"]
    #[doc = " reasons cause the CPU to wake up."]
    #[doc = ""]
    #[doc = " Additionally, `expected` 64-bit values and 64-bit masks are provided. If"]
    #[doc = " mask is non-zero, the current value pointed to by the `p` pointer will be"]
    #[doc = " checked against the expected value, and if they do not match, the entering of"]
    #[doc = " optimized power state may be aborted."]
    #[doc = ""]
    #[doc = " @warning It is responsibility of the user to check if this function is"]
    #[doc = "   supported at runtime using `rte_cpu_get_intrinsics_support()` API call."]
    #[doc = "   Failing to do so may result in an illegal CPU instruction error."]
    #[doc = ""]
    #[doc = " @param pmc"]
    #[doc = "   An array of monitoring condition structures."]
    #[doc = " @param num"]
    #[doc = "   Length of the `pmc` array."]
    #[doc = " @param tsc_timestamp"]
    #[doc = "   Maximum TSC timestamp to wait for. Note that the wait behavior is"]
    #[doc = "   architecture-dependent."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success"]
    #[doc = "   -EINVAL on invalid parameters"]
    #[doc = "   -ENOTSUP if unsupported"]
    pub fn rte_power_monitor_multi(
        pmc: *const rte_power_monitor_cond,
        num: u32,
        tsc_timestamp: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __rte_ethdev_trace_rx_burst: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_ethdev_trace_tx_burst: rte_trace_point_t;
}
extern "C" {
    pub static mut rte_eth_dev_logtype: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes a device iterator."]
    #[doc = ""]
    #[doc = " This iterator allows accessing a list of devices matching some devargs."]
    #[doc = ""]
    #[doc = " @param iter"]
    #[doc = "   Device iterator handle initialized by the function."]
    #[doc = "   The fields bus_str and cls_str might be dynamically allocated,"]
    #[doc = "   and could be freed by calling rte_eth_iterator_cleanup()."]
    #[doc = ""]
    #[doc = " @param devargs"]
    #[doc = "   Device description string."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on successful initialization, negative otherwise."]
    pub fn rte_eth_iterator_init(
        iter: *mut rte_dev_iterator,
        devargs: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iterates on devices with devargs filter."]
    #[doc = " The ownership is not checked."]
    #[doc = ""]
    #[doc = " The next port ID is returned, and the iterator is updated."]
    #[doc = ""]
    #[doc = " @param iter"]
    #[doc = "   Device iterator handle initialized by rte_eth_iterator_init()."]
    #[doc = "   Some fields bus_str and cls_str might be freed when no more port is found,"]
    #[doc = "   by calling rte_eth_iterator_cleanup()."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   A port ID if found, RTE_MAX_ETHPORTS otherwise."]
    pub fn rte_eth_iterator_next(iter: *mut rte_dev_iterator) -> u16;
}
extern "C" {
    #[doc = " Free some allocated fields of the iterator."]
    #[doc = ""]
    #[doc = " This function is automatically called by rte_eth_iterator_next()"]
    #[doc = " on the last iteration (i.e. when no more matching port is found)."]
    #[doc = ""]
    #[doc = " It is safe to call this function twice; it will do nothing more."]
    #[doc = ""]
    #[doc = " @param iter"]
    #[doc = "   Device iterator handle initialized by rte_eth_iterator_init()."]
    #[doc = "   The fields bus_str and cls_str are freed if needed."]
    pub fn rte_eth_iterator_cleanup(iter: *mut rte_dev_iterator);
}
#[doc = " A structure used to retrieve statistics for an Ethernet port."]
#[doc = " Not all statistics fields in struct rte_eth_stats are supported"]
#[doc = " by any type of network interface card (NIC). If any statistics"]
#[doc = " field is not supported, its value is 0."]
#[doc = " All byte-related statistics do not include Ethernet FCS regardless"]
#[doc = " of whether these bytes have been delivered to the application"]
#[doc = " (see RTE_ETH_RX_OFFLOAD_KEEP_CRC)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_stats {
    #[doc = "< Total number of successfully received packets."]
    pub ipackets: u64,
    #[doc = "< Total number of successfully transmitted packets."]
    pub opackets: u64,
    #[doc = "< Total number of successfully received bytes."]
    pub ibytes: u64,
    #[doc = "< Total number of successfully transmitted bytes."]
    pub obytes: u64,
    #[doc = " Total of Rx packets dropped by the HW,"]
    #[doc = " because there are no available buffer (i.e. Rx queues are full)."]
    pub imissed: u64,
    #[doc = "< Total number of erroneous received packets."]
    pub ierrors: u64,
    #[doc = "< Total number of failed transmitted packets."]
    pub oerrors: u64,
    #[doc = "< Total number of Rx mbuf allocation failures."]
    pub rx_nombuf: u64,
    #[doc = " Total number of queue Rx packets."]
    pub q_ipackets: [u64; 16usize],
    #[doc = " Total number of queue Tx packets."]
    pub q_opackets: [u64; 16usize],
    #[doc = " Total number of successfully received queue bytes."]
    pub q_ibytes: [u64; 16usize],
    #[doc = " Total number of successfully transmitted queue bytes."]
    pub q_obytes: [u64; 16usize],
    #[doc = " Total number of queue packets received that are dropped."]
    pub q_errors: [u64; 16usize],
}
#[doc = " A structure used to retrieve link-level information of an Ethernet port."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_link {
    #[doc = "< RTE_ETH_SPEED_NUM_"]
    pub link_speed: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl rte_eth_link {
    #[inline]
    pub fn link_duplex(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_duplex(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn link_autoneg(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_autoneg(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn link_status(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_status(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        link_duplex: u16,
        link_autoneg: u16,
        link_status: u16,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let link_duplex: u16 = unsafe { ::std::mem::transmute(link_duplex) };
            link_duplex as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let link_autoneg: u16 = unsafe { ::std::mem::transmute(link_autoneg) };
            link_autoneg as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let link_status: u16 = unsafe { ::std::mem::transmute(link_status) };
            link_status as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to configure the ring threshold registers of an Rx/Tx"]
#[doc = " queue for an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_thresh {
    #[doc = "< Ring prefetch threshold."]
    pub pthresh: u8,
    #[doc = "< Ring host threshold."]
    pub hthresh: u8,
    #[doc = "< Ring writeback threshold."]
    pub wthresh: u8,
}
#[repr(u32)]
#[doc = "  A set of values to identify what method is to be used to route"]
#[doc = "  packets to multiple queues."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_eth_rx_mq_mode {
    #[doc = " None of DCB, RSS or VMDq mode"]
    RTE_ETH_MQ_RX_NONE = 0,
    #[doc = " For Rx side, only RSS is on"]
    RTE_ETH_MQ_RX_RSS = 1,
    #[doc = " For Rx side,only DCB is on."]
    RTE_ETH_MQ_RX_DCB = 2,
    #[doc = " Both DCB and RSS enable"]
    RTE_ETH_MQ_RX_DCB_RSS = 3,
    #[doc = " Only VMDq, no RSS nor DCB"]
    RTE_ETH_MQ_RX_VMDQ_ONLY = 4,
    #[doc = " RSS mode with VMDq"]
    RTE_ETH_MQ_RX_VMDQ_RSS = 5,
    #[doc = " Use VMDq+DCB to route traffic to queues"]
    RTE_ETH_MQ_RX_VMDQ_DCB = 6,
    #[doc = " Enable both VMDq and DCB in VMDq"]
    RTE_ETH_MQ_RX_VMDQ_DCB_RSS = 7,
}
#[repr(u32)]
#[doc = " A set of values to identify what method is to be used to transmit"]
#[doc = " packets using multi-TCs."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_eth_tx_mq_mode {
    #[doc = "< It is in neither DCB nor VT mode."]
    RTE_ETH_MQ_TX_NONE = 0,
    #[doc = "< For Tx side,only DCB is on."]
    RTE_ETH_MQ_TX_DCB = 1,
    #[doc = "< For Tx side,both DCB and VT is on."]
    RTE_ETH_MQ_TX_VMDQ_DCB = 2,
    #[doc = "< Only VT on, no DCB"]
    RTE_ETH_MQ_TX_VMDQ_ONLY = 3,
}
#[doc = " A structure used to configure the Rx features of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rxmode {
    #[doc = " The multi-queue packet distribution mode to be used, e.g. RSS."]
    pub mq_mode: rte_eth_rx_mq_mode,
    #[doc = "< Requested MTU."]
    pub mtu: u32,
    #[doc = " Maximum allowed size of LRO aggregated packet."]
    pub max_lro_pkt_size: u32,
    #[doc = "< hdr buf size (header_split enabled)."]
    pub split_hdr_size: u16,
    #[doc = " Per-port Rx offloads to be set using RTE_ETH_RX_OFFLOAD_* flags."]
    #[doc = " Only offloads set on rx_offload_capa field on rte_eth_dev_info"]
    #[doc = " structure are allowed to be set."]
    pub offloads: u64,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[repr(u32)]
#[doc = " VLAN types to indicate if it is for single VLAN, inner VLAN or outer VLAN."]
#[doc = " Note that single VLAN is treated the same as inner VLAN."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_vlan_type {
    RTE_ETH_VLAN_TYPE_UNKNOWN = 0,
    #[doc = "< Inner VLAN."]
    RTE_ETH_VLAN_TYPE_INNER = 1,
    #[doc = "< Single VLAN, or outer VLAN."]
    RTE_ETH_VLAN_TYPE_OUTER = 2,
    RTE_ETH_VLAN_TYPE_MAX = 3,
}
#[doc = " A structure used to describe a VLAN filter."]
#[doc = " If the bit corresponding to a VID is set, such VID is on."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_vlan_filter_conf {
    pub ids: [u64; 64usize],
}
#[doc = " A structure used to configure the Receive Side Scaling (RSS) feature"]
#[doc = " of an Ethernet port."]
#[doc = " If not NULL, the *rss_key* pointer of the *rss_conf* structure points"]
#[doc = " to an array holding the RSS key to use for hashing specific header"]
#[doc = " fields of received packets. The length of this array should be indicated"]
#[doc = " by *rss_key_len* below. Otherwise, a default random hash key is used by"]
#[doc = " the device driver."]
#[doc = ""]
#[doc = " The *rss_key_len* field of the *rss_conf* structure indicates the length"]
#[doc = " in bytes of the array pointed by *rss_key*. To be compatible, this length"]
#[doc = " will be checked in i40e only. Others assume 40 bytes to be used as before."]
#[doc = ""]
#[doc = " The *rss_hf* field of the *rss_conf* structure indicates the different"]
#[doc = " types of IPv4/IPv6 packets to which the RSS hashing must be applied."]
#[doc = " Supplying an *rss_hf* equal to zero disables the RSS feature."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rss_conf {
    #[doc = "< If not NULL, 40-byte hash key."]
    pub rss_key: *mut u8,
    #[doc = "< hash key length in bytes."]
    pub rss_key_len: u8,
    #[doc = "< Hash functions to apply - see below."]
    pub rss_hf: u64,
}
#[doc = " A structure used to configure 64 entries of Redirection Table of the"]
#[doc = " Receive Side Scaling (RSS) feature of an Ethernet port. To configure"]
#[doc = " more than 64 entries supported by hardware, an array of this structure"]
#[doc = " is needed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rss_reta_entry64 {
    #[doc = " Mask bits indicate which entries need to be updated/queried."]
    pub mask: u64,
    #[doc = " Group of 64 redirection table entries."]
    pub reta: [u16; 64usize],
}
#[repr(u32)]
#[doc = " This enum indicates the possible number of traffic classes"]
#[doc = " in DCB configurations"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_eth_nb_tcs {
    #[doc = "< 4 TCs with DCB."]
    RTE_ETH_4_TCS = 4,
    #[doc = "< 8 TCs with DCB."]
    RTE_ETH_8_TCS = 8,
}
#[repr(u32)]
#[doc = " This enum indicates the possible number of queue pools"]
#[doc = " in VMDq configurations."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_eth_nb_pools {
    #[doc = "< 8 VMDq pools."]
    RTE_ETH_8_POOLS = 8,
    #[doc = "< 16 VMDq pools."]
    RTE_ETH_16_POOLS = 16,
    #[doc = "< 32 VMDq pools."]
    RTE_ETH_32_POOLS = 32,
    #[doc = "< 64 VMDq pools."]
    RTE_ETH_64_POOLS = 64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_rx_conf {
    #[doc = "< Possible DCB TCs, 4 or 8 TCs"]
    pub nb_tcs: rte_eth_nb_tcs,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_dcb_tx_conf {
    #[doc = "< With DCB, 16 or 32 pools."]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_tx_conf {
    #[doc = "< Possible DCB TCs, 4 or 8 TCs."]
    pub nb_tcs: rte_eth_nb_tcs,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_tx_conf {
    #[doc = "< VMDq mode, 64 pools."]
    pub nb_queue_pools: rte_eth_nb_pools,
}
#[doc = " A structure used to configure the VMDq+DCB feature"]
#[doc = " of an Ethernet port."]
#[doc = ""]
#[doc = " Using this feature, packets are routed to a pool of queues, based"]
#[doc = " on the VLAN ID in the VLAN tag, and then to a specific queue within"]
#[doc = " that pool, using the user priority VLAN tag field."]
#[doc = ""]
#[doc = " A default pool may be used, if desired, to route all traffic which"]
#[doc = " does not match the VLAN filter rules."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_dcb_conf {
    #[doc = "< With DCB, 16 or 32 pools"]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = "< If non-zero, use a default pool"]
    pub enable_default_pool: u8,
    #[doc = "< The default pool, if applicable"]
    pub default_pool: u8,
    #[doc = "< We can have up to 64 filters/mappings"]
    pub nb_pool_maps: u8,
    #[doc = "< VMDq VLAN pool maps."]
    pub pool_map: [rte_eth_vmdq_dcb_conf__bindgen_ty_1; 64usize],
    #[doc = " Selects a queue in a pool"]
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_dcb_conf__bindgen_ty_1 {
    #[doc = "< The VLAN ID of the received frame"]
    pub vlan_id: u16,
    #[doc = "< Bitmask of pools for packet Rx"]
    pub pools: u64,
}
#[doc = " A structure used to configure the VMDq feature of an Ethernet port when"]
#[doc = " not combined with the DCB feature."]
#[doc = ""]
#[doc = " Using this feature, packets are routed to a pool of queues. By default,"]
#[doc = " the pool selection is based on the MAC address, the VLAN ID in the"]
#[doc = " VLAN tag as specified in the pool_map array."]
#[doc = " Passing the RTE_ETH_VMDQ_ACCEPT_UNTAG in the rx_mode field allows pool"]
#[doc = " selection using only the MAC address. MAC address to pool mapping is done"]
#[doc = " using the rte_eth_dev_mac_addr_add function, with the pool parameter"]
#[doc = " corresponding to the pool ID."]
#[doc = ""]
#[doc = " Queue selection within the selected pool will be done using RSS when"]
#[doc = " it is enabled or revert to the first queue of the pool if not."]
#[doc = ""]
#[doc = " A default pool may be used, if desired, to route all traffic which"]
#[doc = " does not match the VLAN filter rules or any pool MAC address."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_rx_conf {
    #[doc = "< VMDq only mode, 8 or 64 pools"]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = "< If non-zero, use a default pool"]
    pub enable_default_pool: u8,
    #[doc = "< The default pool, if applicable"]
    pub default_pool: u8,
    #[doc = "< Enable VT loop back"]
    pub enable_loop_back: u8,
    #[doc = "< We can have up to 64 filters/mappings"]
    pub nb_pool_maps: u8,
    #[doc = "< Flags from ETH_VMDQ_ACCEPT_*"]
    pub rx_mode: u32,
    #[doc = "< VMDq VLAN pool maps."]
    pub pool_map: [rte_eth_vmdq_rx_conf__bindgen_ty_1; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_rx_conf__bindgen_ty_1 {
    #[doc = "< The VLAN ID of the received frame"]
    pub vlan_id: u16,
    #[doc = "< Bitmask of pools for packet Rx"]
    pub pools: u64,
}
#[doc = " A structure used to configure the Tx features of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_txmode {
    #[doc = "< Tx multi-queues mode."]
    pub mq_mode: rte_eth_tx_mq_mode,
    #[doc = " Per-port Tx offloads to be set using RTE_ETH_TX_OFFLOAD_* flags."]
    #[doc = " Only offloads set on tx_offload_capa field on rte_eth_dev_info"]
    #[doc = " structure are allowed to be set."]
    pub offloads: u64,
    pub pvid: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
impl rte_eth_txmode {
    #[inline]
    pub fn hw_vlan_reject_tagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_tagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hw_vlan_reject_untagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_untagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hw_vlan_insert_pvid(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_insert_pvid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hw_vlan_reject_tagged: u8,
        hw_vlan_reject_untagged: u8,
        hw_vlan_insert_pvid: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hw_vlan_reject_tagged: u8 = unsafe { ::std::mem::transmute(hw_vlan_reject_tagged) };
            hw_vlan_reject_tagged as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hw_vlan_reject_untagged: u8 =
                unsafe { ::std::mem::transmute(hw_vlan_reject_untagged) };
            hw_vlan_reject_untagged as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hw_vlan_insert_pvid: u8 = unsafe { ::std::mem::transmute(hw_vlan_insert_pvid) };
            hw_vlan_insert_pvid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice."]
#[doc = ""]
#[doc = " A structure used to configure an Rx packet segment to split."]
#[doc = ""]
#[doc = " If RTE_ETH_RX_OFFLOAD_BUFFER_SPLIT flag is set in offloads field,"]
#[doc = " the PMD will split the received packets into multiple segments"]
#[doc = " according to the specification in the description array:"]
#[doc = ""]
#[doc = " - The first network buffer will be allocated from the memory pool,"]
#[doc = "   specified in the first array element, the second buffer, from the"]
#[doc = "   pool in the second element, and so on."]
#[doc = ""]
#[doc = " - The offsets from the segment description elements specify"]
#[doc = "   the data offset from the buffer beginning except the first mbuf."]
#[doc = "   The first segment offset is added with RTE_PKTMBUF_HEADROOM."]
#[doc = ""]
#[doc = " - The lengths in the elements define the maximal data amount"]
#[doc = "   being received to each segment. The receiving starts with filling"]
#[doc = "   up the first mbuf data buffer up to specified length. If the"]
#[doc = "   there are data remaining (packet is longer than buffer in the first"]
#[doc = "   mbuf) the following data will be pushed to the next segment"]
#[doc = "   up to its own length, and so on."]
#[doc = ""]
#[doc = " - If the length in the segment description element is zero"]
#[doc = "   the actual buffer size will be deduced from the appropriate"]
#[doc = "   memory pool properties."]
#[doc = ""]
#[doc = " - If there is not enough elements to describe the buffer for entire"]
#[doc = "   packet of maximal length the following parameters will be used"]
#[doc = "   for the all remaining segments:"]
#[doc = "     - pool from the last valid element"]
#[doc = "     - the buffer size from this pool"]
#[doc = "     - zero offset"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rxseg_split {
    #[doc = "< Memory pool to allocate segment from."]
    pub mp: *mut rte_mempool,
    #[doc = "< Segment data length, configures split point."]
    pub length: u16,
    #[doc = "< Data offset from beginning of mbuf data buffer."]
    pub offset: u16,
    #[doc = "< Reserved field."]
    pub reserved: u32,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice."]
#[doc = ""]
#[doc = " A common structure used to describe Rx packet segment properties."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_rxseg {
    pub split: rte_eth_rxseg_split,
}
#[doc = " A structure used to configure an Rx ring of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rxconf {
    #[doc = "< Rx ring threshold registers."]
    pub rx_thresh: rte_eth_thresh,
    #[doc = "< Drives the freeing of Rx descriptors."]
    pub rx_free_thresh: u16,
    #[doc = "< Drop packets if no descriptors are available."]
    pub rx_drop_en: u8,
    #[doc = "< Do not start queue with rte_eth_dev_start()."]
    pub rx_deferred_start: u8,
    #[doc = "< Number of descriptions in rx_seg array."]
    pub rx_nseg: u16,
    #[doc = " Share group index in Rx domain and switch domain."]
    #[doc = " Non-zero value to enable Rx queue share, zero value disable share."]
    #[doc = " PMD is responsible for Rx queue consistency checks to avoid member"]
    #[doc = " port's configuration contradict to each other."]
    pub share_group: u16,
    #[doc = "< Shared Rx queue ID in group"]
    pub share_qid: u16,
    #[doc = " Per-queue Rx offloads to be set using RTE_ETH_RX_OFFLOAD_* flags."]
    #[doc = " Only offloads set on rx_queue_offload_capa or rx_offload_capa"]
    #[doc = " fields on rte_eth_dev_info structure are allowed to be set."]
    pub offloads: u64,
    #[doc = " Points to the array of segment descriptions for an entire packet."]
    #[doc = " Array elements are properties for consecutive Rx segments."]
    #[doc = ""]
    #[doc = " The supported capabilities of receiving segmentation is reported"]
    #[doc = " in rte_eth_dev_info.rx_seg_capa field."]
    pub rx_seg: *mut rte_eth_rxseg,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[doc = " A structure used to configure a Tx ring of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_txconf {
    #[doc = "< Tx ring threshold registers."]
    pub tx_thresh: rte_eth_thresh,
    #[doc = "< Drives the setting of RS bit on TXDs."]
    pub tx_rs_thresh: u16,
    #[doc = "< Start freeing Tx buffers if there are"]
    #[doc = "less free descriptors than this value."]
    pub tx_free_thresh: u16,
    #[doc = "< Do not start queue with rte_eth_dev_start()."]
    pub tx_deferred_start: u8,
    #[doc = " Per-queue Tx offloads to be set  using RTE_ETH_TX_OFFLOAD_* flags."]
    #[doc = " Only offloads set on tx_queue_offload_capa or tx_offload_capa"]
    #[doc = " fields on rte_eth_dev_info structure are allowed to be set."]
    pub offloads: u64,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
#[doc = ""]
#[doc = " A structure used to return the hairpin capabilities that are supported."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_hairpin_cap {
    #[doc = " The max number of hairpin queues (different bindings)."]
    pub max_nb_queues: u16,
    #[doc = " Max number of Rx queues to be connected to one Tx queue."]
    pub max_rx_2_tx: u16,
    #[doc = " Max number of Tx queues to be connected to one Rx queue."]
    pub max_tx_2_rx: u16,
    #[doc = "< The max num of descriptors."]
    pub max_nb_desc: u16,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
#[doc = ""]
#[doc = " A structure used to hold hairpin peer data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_hairpin_peer {
    #[doc = "< Peer port."]
    pub port: u16,
    #[doc = "< Peer queue."]
    pub queue: u16,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
#[doc = ""]
#[doc = " A structure used to configure hairpin binding."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_hairpin_conf {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub peers: [rte_eth_hairpin_peer; 32usize],
}
impl rte_eth_hairpin_conf {
    #[inline]
    pub fn peer_count(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_peer_count(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_explicit(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_explicit(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn manual_bind(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_manual_bind(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        peer_count: u32,
        tx_explicit: u32,
        manual_bind: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let peer_count: u32 = unsafe { ::std::mem::transmute(peer_count) };
            peer_count as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let tx_explicit: u32 = unsafe { ::std::mem::transmute(tx_explicit) };
            tx_explicit as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let manual_bind: u32 = unsafe { ::std::mem::transmute(manual_bind) };
            manual_bind as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure contains information about HW descriptor ring limitations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_desc_lim {
    #[doc = "< Max allowed number of descriptors."]
    pub nb_max: u16,
    #[doc = "< Min allowed number of descriptors."]
    pub nb_min: u16,
    #[doc = "< Number of descriptors should be aligned to."]
    pub nb_align: u16,
    #[doc = " Max allowed number of segments per whole packet."]
    #[doc = ""]
    #[doc = " - For TSO packet this is the total number of data descriptors allowed"]
    #[doc = "   by device."]
    #[doc = ""]
    #[doc = " @see nb_mtu_seg_max"]
    pub nb_seg_max: u16,
    #[doc = " Max number of segments per one MTU."]
    #[doc = ""]
    #[doc = " - For non-TSO packet, this is the maximum allowed number of segments"]
    #[doc = "   in a single transmit packet."]
    #[doc = ""]
    #[doc = " - For TSO packet each segment within the TSO may span up to this"]
    #[doc = "   value."]
    #[doc = ""]
    #[doc = " @see nb_seg_max"]
    pub nb_mtu_seg_max: u16,
}
#[repr(u32)]
#[doc = " This enum indicates the flow control mode"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_eth_fc_mode {
    #[doc = "< Disable flow control."]
    RTE_ETH_FC_NONE = 0,
    #[doc = "< Rx pause frame, enable flowctrl on Tx side."]
    RTE_ETH_FC_RX_PAUSE = 1,
    #[doc = "< Tx pause frame, enable flowctrl on Rx side."]
    RTE_ETH_FC_TX_PAUSE = 2,
    #[doc = "< Enable flow control on both side."]
    RTE_ETH_FC_FULL = 3,
}
#[doc = " A structure used to configure Ethernet flow control parameter."]
#[doc = " These parameters will be configured into the register of the NIC."]
#[doc = " Please refer to the corresponding data sheet for proper value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fc_conf {
    #[doc = "< High threshold value to trigger XOFF"]
    pub high_water: u32,
    #[doc = "< Low threshold value to trigger XON"]
    pub low_water: u32,
    #[doc = "< Pause quota in the Pause frame"]
    pub pause_time: u16,
    #[doc = "< Is XON frame need be sent"]
    pub send_xon: u16,
    #[doc = "< Link flow control mode"]
    pub mode: rte_eth_fc_mode,
    #[doc = "< Forward MAC control frames"]
    pub mac_ctrl_frame_fwd: u8,
    #[doc = "< Use Pause autoneg"]
    pub autoneg: u8,
}
#[doc = " A structure used to configure Ethernet priority flow control parameter."]
#[doc = " These parameters will be configured into the register of the NIC."]
#[doc = " Please refer to the corresponding data sheet for proper value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_pfc_conf {
    #[doc = "< General flow control parameter."]
    pub fc: rte_eth_fc_conf,
    #[doc = "< VLAN User Priority."]
    pub priority: u8,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
#[doc = ""]
#[doc = " A structure used to retrieve information of queue based PFC."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_pfc_queue_info {
    #[doc = " Maximum supported traffic class as per PFC (802.1Qbb) specification."]
    pub tc_max: u8,
    #[doc = " PFC queue mode capabilities."]
    pub mode_capa: rte_eth_fc_mode,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
#[doc = ""]
#[doc = " A structure used to configure Ethernet priority flow control parameters for"]
#[doc = " ethdev queues."]
#[doc = ""]
#[doc = " rte_eth_pfc_queue_conf::rx_pause structure shall be used to configure given"]
#[doc = " tx_qid with corresponding tc. When ethdev device receives PFC frame with"]
#[doc = " rte_eth_pfc_queue_conf::rx_pause::tc, traffic will be paused on"]
#[doc = " rte_eth_pfc_queue_conf::rx_pause::tx_qid for that tc."]
#[doc = ""]
#[doc = " rte_eth_pfc_queue_conf::tx_pause structure shall be used to configure given"]
#[doc = " rx_qid. When rx_qid is congested, PFC frames are generated with"]
#[doc = " rte_eth_pfc_queue_conf::rx_pause::tc and"]
#[doc = " rte_eth_pfc_queue_conf::rx_pause::pause_time to the peer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_pfc_queue_conf {
    #[doc = "< Link flow control mode"]
    pub mode: rte_eth_fc_mode,
    pub rx_pause: rte_eth_pfc_queue_conf__bindgen_ty_1,
    pub tx_pause: rte_eth_pfc_queue_conf__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_pfc_queue_conf__bindgen_ty_1 {
    #[doc = "< Tx queue ID"]
    pub tx_qid: u16,
    #[doc = " Traffic class as per PFC (802.1Qbb) spec. The value must be"]
    #[doc = " in the range [0, rte_eth_pfc_queue_info::tx_max - 1]"]
    pub tc: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_pfc_queue_conf__bindgen_ty_2 {
    #[doc = "< Pause quota in the Pause frame"]
    pub pause_time: u16,
    #[doc = "< Rx queue ID"]
    pub rx_qid: u16,
    #[doc = " Traffic class as per PFC (802.1Qbb) spec. The value must be"]
    #[doc = " in the range [0, rte_eth_pfc_queue_info::tx_max - 1]"]
    pub tc: u8,
}
#[repr(u32)]
#[doc = " Tunnel type for device-specific classifier configuration."]
#[doc = " @see rte_eth_udp_tunnel"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_eth_tunnel_type {
    RTE_ETH_TUNNEL_TYPE_NONE = 0,
    RTE_ETH_TUNNEL_TYPE_VXLAN = 1,
    RTE_ETH_TUNNEL_TYPE_GENEVE = 2,
    RTE_ETH_TUNNEL_TYPE_TEREDO = 3,
    RTE_ETH_TUNNEL_TYPE_NVGRE = 4,
    RTE_ETH_TUNNEL_TYPE_IP_IN_GRE = 5,
    RTE_ETH_L2_TUNNEL_TYPE_E_TAG = 6,
    RTE_ETH_TUNNEL_TYPE_VXLAN_GPE = 7,
    RTE_ETH_TUNNEL_TYPE_ECPRI = 8,
    RTE_ETH_TUNNEL_TYPE_MAX = 9,
}
#[doc = " ARP header IPv4 payload."]
#[repr(C, packed(2))]
pub struct rte_arp_ipv4 {
    #[doc = "< sender hardware address"]
    pub arp_sha: rte_ether_addr,
    #[doc = "< sender IP address"]
    pub arp_sip: u32,
    #[doc = "< target hardware address"]
    pub arp_tha: rte_ether_addr,
    #[doc = "< target IP address"]
    pub arp_tip: u32,
}
#[doc = " ARP header."]
#[repr(C, packed(2))]
pub struct rte_arp_hdr {
    pub arp_hardware: u16,
    pub arp_protocol: u16,
    pub arp_hlen: u8,
    pub arp_plen: u8,
    pub arp_opcode: u16,
    pub arp_data: rte_arp_ipv4,
}
extern "C" {
    #[doc = " Make a RARP packet based on MAC addr."]
    #[doc = ""]
    #[doc = " @param mpool"]
    #[doc = "   Pointer to the rte_mempool"]
    #[doc = " @param mac"]
    #[doc = "   Pointer to the MAC addr"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - RARP packet pointer on success, or NULL on error"]
    pub fn rte_net_make_rarp_packet(
        mpool: *mut rte_mempool,
        mac: *const rte_ether_addr,
    ) -> *mut rte_mbuf;
}
#[doc = " ICMP Header"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_icmp_hdr {
    pub icmp_type: u8,
    pub icmp_code: u8,
    pub icmp_cksum: rte_be16_t,
    pub icmp_ident: rte_be16_t,
    pub icmp_seq_nb: rte_be16_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: size_t,
}
pub type socklen_t = __socklen_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __socket_type {
    SOCK_STREAM = 1,
    SOCK_DGRAM = 2,
    SOCK_RAW = 3,
    SOCK_RDM = 4,
    SOCK_SEQPACKET = 5,
    SOCK_DCCP = 6,
    SOCK_PACKET = 10,
    SOCK_CLOEXEC = 524288,
    SOCK_NONBLOCK = 2048,
}
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
pub const MSG_OOB: _bindgen_ty_19 = _bindgen_ty_19::MSG_OOB;
pub const MSG_PEEK: _bindgen_ty_19 = _bindgen_ty_19::MSG_PEEK;
pub const MSG_DONTROUTE: _bindgen_ty_19 = _bindgen_ty_19::MSG_DONTROUTE;
pub const MSG_CTRUNC: _bindgen_ty_19 = _bindgen_ty_19::MSG_CTRUNC;
pub const MSG_PROXY: _bindgen_ty_19 = _bindgen_ty_19::MSG_PROXY;
pub const MSG_TRUNC: _bindgen_ty_19 = _bindgen_ty_19::MSG_TRUNC;
pub const MSG_DONTWAIT: _bindgen_ty_19 = _bindgen_ty_19::MSG_DONTWAIT;
pub const MSG_EOR: _bindgen_ty_19 = _bindgen_ty_19::MSG_EOR;
pub const MSG_WAITALL: _bindgen_ty_19 = _bindgen_ty_19::MSG_WAITALL;
pub const MSG_FIN: _bindgen_ty_19 = _bindgen_ty_19::MSG_FIN;
pub const MSG_SYN: _bindgen_ty_19 = _bindgen_ty_19::MSG_SYN;
pub const MSG_CONFIRM: _bindgen_ty_19 = _bindgen_ty_19::MSG_CONFIRM;
pub const MSG_RST: _bindgen_ty_19 = _bindgen_ty_19::MSG_RST;
pub const MSG_ERRQUEUE: _bindgen_ty_19 = _bindgen_ty_19::MSG_ERRQUEUE;
pub const MSG_NOSIGNAL: _bindgen_ty_19 = _bindgen_ty_19::MSG_NOSIGNAL;
pub const MSG_MORE: _bindgen_ty_19 = _bindgen_ty_19::MSG_MORE;
pub const MSG_WAITFORONE: _bindgen_ty_19 = _bindgen_ty_19::MSG_WAITFORONE;
pub const MSG_BATCH: _bindgen_ty_19 = _bindgen_ty_19::MSG_BATCH;
pub const MSG_ZEROCOPY: _bindgen_ty_19 = _bindgen_ty_19::MSG_ZEROCOPY;
pub const MSG_FASTOPEN: _bindgen_ty_19 = _bindgen_ty_19::MSG_FASTOPEN;
pub const MSG_CMSG_CLOEXEC: _bindgen_ty_19 = _bindgen_ty_19::MSG_CMSG_CLOEXEC;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_19 {
    MSG_OOB = 1,
    MSG_PEEK = 2,
    MSG_DONTROUTE = 4,
    MSG_CTRUNC = 8,
    MSG_PROXY = 16,
    MSG_TRUNC = 32,
    MSG_DONTWAIT = 64,
    MSG_EOR = 128,
    MSG_WAITALL = 256,
    MSG_FIN = 512,
    MSG_SYN = 1024,
    MSG_CONFIRM = 2048,
    MSG_RST = 4096,
    MSG_ERRQUEUE = 8192,
    MSG_NOSIGNAL = 16384,
    MSG_MORE = 32768,
    MSG_WAITFORONE = 65536,
    MSG_BATCH = 262144,
    MSG_ZEROCOPY = 67108864,
    MSG_FASTOPEN = 536870912,
    MSG_CMSG_CLOEXEC = 1073741824,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: size_t,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: size_t,
    pub msg_flags: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct cmsghdr {
    pub cmsg_len: size_t,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr) -> *mut cmsghdr;
}
pub const SCM_RIGHTS: _bindgen_ty_20 = _bindgen_ty_20::SCM_RIGHTS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_20 {
    SCM_RIGHTS = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
pub const SHUT_RD: _bindgen_ty_21 = _bindgen_ty_21::SHUT_RD;
pub const SHUT_WR: _bindgen_ty_21 = _bindgen_ty_21::SHUT_WR;
pub const SHUT_RDWR: _bindgen_ty_21 = _bindgen_ty_21::SHUT_RDWR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_21 {
    SHUT_RD = 0,
    SHUT_WR = 1,
    SHUT_RDWR = 2,
}
extern "C" {
    pub fn socket(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
        __fds: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: size_t,
        __flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn recv(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: size_t,
        __flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn sendto(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: size_t,
        __flags: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __addr_len: socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn recvfrom(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: size_t,
        __flags: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn sendmsg(
        __fd: ::std::os::raw::c_int,
        __message: *const msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn recvmsg(
        __fd: ::std::os::raw::c_int,
        __message: *mut msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn getsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *mut ::std::os::raw::c_void,
        __optlen: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *const ::std::os::raw::c_void,
        __optlen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        __fd: ::std::os::raw::c_int,
        __how: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isfdtype(
        __fd: ::std::os::raw::c_int,
        __fdtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
pub const IPPROTO_IP: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_IP;
pub const IPPROTO_ICMP: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_ICMP;
pub const IPPROTO_IGMP: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_IGMP;
pub const IPPROTO_IPIP: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_IPIP;
pub const IPPROTO_TCP: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_TCP;
pub const IPPROTO_EGP: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_EGP;
pub const IPPROTO_PUP: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_PUP;
pub const IPPROTO_UDP: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_UDP;
pub const IPPROTO_IDP: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_IDP;
pub const IPPROTO_TP: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_TP;
pub const IPPROTO_DCCP: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_DCCP;
pub const IPPROTO_IPV6: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_IPV6;
pub const IPPROTO_RSVP: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_RSVP;
pub const IPPROTO_GRE: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_GRE;
pub const IPPROTO_ESP: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_ESP;
pub const IPPROTO_AH: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_AH;
pub const IPPROTO_MTP: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_MTP;
pub const IPPROTO_BEETPH: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_BEETPH;
pub const IPPROTO_ENCAP: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_ENCAP;
pub const IPPROTO_PIM: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_PIM;
pub const IPPROTO_COMP: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_COMP;
pub const IPPROTO_SCTP: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_SCTP;
pub const IPPROTO_UDPLITE: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_UDPLITE;
pub const IPPROTO_MPLS: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_MPLS;
pub const IPPROTO_RAW: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_RAW;
pub const IPPROTO_MAX: _bindgen_ty_22 = _bindgen_ty_22::IPPROTO_MAX;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_22 {
    IPPROTO_IP = 0,
    IPPROTO_ICMP = 1,
    IPPROTO_IGMP = 2,
    IPPROTO_IPIP = 4,
    IPPROTO_TCP = 6,
    IPPROTO_EGP = 8,
    IPPROTO_PUP = 12,
    IPPROTO_UDP = 17,
    IPPROTO_IDP = 22,
    IPPROTO_TP = 29,
    IPPROTO_DCCP = 33,
    IPPROTO_IPV6 = 41,
    IPPROTO_RSVP = 46,
    IPPROTO_GRE = 47,
    IPPROTO_ESP = 50,
    IPPROTO_AH = 51,
    IPPROTO_MTP = 92,
    IPPROTO_BEETPH = 94,
    IPPROTO_ENCAP = 98,
    IPPROTO_PIM = 103,
    IPPROTO_COMP = 108,
    IPPROTO_SCTP = 132,
    IPPROTO_UDPLITE = 136,
    IPPROTO_MPLS = 137,
    IPPROTO_RAW = 255,
    IPPROTO_MAX = 256,
}
pub const IPPROTO_HOPOPTS: _bindgen_ty_23 = _bindgen_ty_23::IPPROTO_HOPOPTS;
pub const IPPROTO_ROUTING: _bindgen_ty_23 = _bindgen_ty_23::IPPROTO_ROUTING;
pub const IPPROTO_FRAGMENT: _bindgen_ty_23 = _bindgen_ty_23::IPPROTO_FRAGMENT;
pub const IPPROTO_ICMPV6: _bindgen_ty_23 = _bindgen_ty_23::IPPROTO_ICMPV6;
pub const IPPROTO_NONE: _bindgen_ty_23 = _bindgen_ty_23::IPPROTO_NONE;
pub const IPPROTO_DSTOPTS: _bindgen_ty_23 = _bindgen_ty_23::IPPROTO_DSTOPTS;
pub const IPPROTO_MH: _bindgen_ty_23 = _bindgen_ty_23::IPPROTO_MH;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_23 {
    IPPROTO_HOPOPTS = 0,
    IPPROTO_ROUTING = 43,
    IPPROTO_FRAGMENT = 44,
    IPPROTO_ICMPV6 = 58,
    IPPROTO_NONE = 59,
    IPPROTO_DSTOPTS = 60,
    IPPROTO_MH = 135,
}
pub type in_port_t = u16;
pub const IPPORT_ECHO: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_ECHO;
pub const IPPORT_DISCARD: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_DISCARD;
pub const IPPORT_SYSTAT: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_SYSTAT;
pub const IPPORT_DAYTIME: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_DAYTIME;
pub const IPPORT_NETSTAT: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_NETSTAT;
pub const IPPORT_FTP: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_FTP;
pub const IPPORT_TELNET: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_TELNET;
pub const IPPORT_SMTP: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_SMTP;
pub const IPPORT_TIMESERVER: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_TIMESERVER;
pub const IPPORT_NAMESERVER: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_NAMESERVER;
pub const IPPORT_WHOIS: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_WHOIS;
pub const IPPORT_MTP: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_MTP;
pub const IPPORT_TFTP: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_TFTP;
pub const IPPORT_RJE: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_RJE;
pub const IPPORT_FINGER: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_FINGER;
pub const IPPORT_TTYLINK: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_TTYLINK;
pub const IPPORT_SUPDUP: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_SUPDUP;
pub const IPPORT_EXECSERVER: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_EXECSERVER;
pub const IPPORT_LOGINSERVER: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_LOGINSERVER;
pub const IPPORT_CMDSERVER: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_CMDSERVER;
pub const IPPORT_EFSSERVER: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_EFSSERVER;
pub const IPPORT_BIFFUDP: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_EXECSERVER;
pub const IPPORT_WHOSERVER: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_LOGINSERVER;
pub const IPPORT_ROUTESERVER: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_EFSSERVER;
pub const IPPORT_RESERVED: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_RESERVED;
pub const IPPORT_USERRESERVED: _bindgen_ty_24 = _bindgen_ty_24::IPPORT_USERRESERVED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_24 {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,
    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,
    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,
    IPPORT_RESERVED = 1024,
    IPPORT_USERRESERVED = 5000,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
extern "C" {
    pub fn ntohl(__netlong: u32) -> u32;
}
extern "C" {
    pub fn ntohs(__netshort: u16) -> u16;
}
extern "C" {
    pub fn htonl(__hostlong: u32) -> u32;
}
extern "C" {
    pub fn htons(__hostshort: u16) -> u16;
}
extern "C" {
    pub fn bindresvport(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bindresvport6(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in6,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_addr(__cp: *const ::std::os::raw::c_char) -> in_addr_t;
}
extern "C" {
    pub fn inet_lnaof(__in: in_addr) -> in_addr_t;
}
extern "C" {
    pub fn inet_makeaddr(__net: in_addr_t, __host: in_addr_t) -> in_addr;
}
extern "C" {
    pub fn inet_netof(__in: in_addr) -> in_addr_t;
}
extern "C" {
    pub fn inet_network(__cp: *const ::std::os::raw::c_char) -> in_addr_t;
}
extern "C" {
    pub fn inet_ntoa(__in: in_addr) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_pton(
        __af: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_ntop(
        __af: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __len: socklen_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_aton(
        __cp: *const ::std::os::raw::c_char,
        __inp: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_neta(
        __net: in_addr_t,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_net_ntop(
        __af: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_void,
        __bits: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_net_pton(
        __af: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_void,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_nsap_addr(
        __cp: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_uchar,
        __len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn inet_nsap_ntoa(
        __len: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_uchar,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timestamp {
    pub len: u8,
    pub ptr: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub data: [u32; 9usize],
}
impl timestamp {
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn overflow(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_overflow(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: ::std::os::raw::c_uint,
        overflow: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let overflow: u32 = unsafe { ::std::mem::transmute(overflow) };
            overflow as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iphdr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub tos: u8,
    pub tot_len: u16,
    pub id: u16,
    pub frag_off: u16,
    pub ttl: u8,
    pub protocol: u8,
    pub check: u16,
    pub saddr: u32,
    pub daddr: u32,
}
impl iphdr {
    #[inline]
    pub fn ihl(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ihl(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ihl: ::std::os::raw::c_uint,
        version: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ihl: u32 = unsafe { ::std::mem::transmute(ihl) };
            ihl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ip_tos: u8,
    pub ip_len: ::std::os::raw::c_ushort,
    pub ip_id: ::std::os::raw::c_ushort,
    pub ip_off: ::std::os::raw::c_ushort,
    pub ip_ttl: u8,
    pub ip_p: u8,
    pub ip_sum: ::std::os::raw::c_ushort,
    pub ip_src: in_addr,
    pub ip_dst: in_addr,
}
impl ip {
    #[inline]
    pub fn ip_hl(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ip_hl(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ip_v(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ip_v(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ip_hl: ::std::os::raw::c_uint,
        ip_v: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ip_hl: u32 = unsafe { ::std::mem::transmute(ip_hl) };
            ip_hl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ip_v: u32 = unsafe { ::std::mem::transmute(ip_v) };
            ip_v as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_timestamp {
    pub ipt_code: u8,
    pub ipt_len: u8,
    pub ipt_ptr: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub data: [u32; 9usize],
}
impl ip_timestamp {
    #[inline]
    pub fn ipt_flg(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ipt_flg(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ipt_oflw(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ipt_oflw(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ipt_flg: ::std::os::raw::c_uint,
        ipt_oflw: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ipt_flg: u32 = unsafe { ::std::mem::transmute(ipt_flg) };
            ipt_flg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ipt_oflw: u32 = unsafe { ::std::mem::transmute(ipt_oflw) };
            ipt_oflw as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_hdr {
    pub ip6_ctlun: ip6_hdr__bindgen_ty_1,
    pub ip6_src: in6_addr,
    pub ip6_dst: in6_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip6_hdr__bindgen_ty_1 {
    pub ip6_un1: ip6_hdr__bindgen_ty_1_ip6_hdrctl,
    pub ip6_un2_vfc: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_hdr__bindgen_ty_1_ip6_hdrctl {
    pub ip6_un1_flow: u32,
    pub ip6_un1_plen: u16,
    pub ip6_un1_nxt: u8,
    pub ip6_un1_hlim: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_ext {
    pub ip6e_nxt: u8,
    pub ip6e_len: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_hbh {
    pub ip6h_nxt: u8,
    pub ip6h_len: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_dest {
    pub ip6d_nxt: u8,
    pub ip6d_len: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_rthdr {
    pub ip6r_nxt: u8,
    pub ip6r_len: u8,
    pub ip6r_type: u8,
    pub ip6r_segleft: u8,
}
#[repr(C)]
pub struct ip6_rthdr0 {
    pub ip6r0_nxt: u8,
    pub ip6r0_len: u8,
    pub ip6r0_type: u8,
    pub ip6r0_segleft: u8,
    pub ip6r0_reserved: u8,
    pub ip6r0_slmap: [u8; 3usize],
    pub ip6r0_addr: __IncompleteArrayField<in6_addr>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_frag {
    pub ip6f_nxt: u8,
    pub ip6f_reserved: u8,
    pub ip6f_offlg: u16,
    pub ip6f_ident: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_opt {
    pub ip6o_type: u8,
    pub ip6o_len: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_opt_jumbo {
    pub ip6oj_type: u8,
    pub ip6oj_len: u8,
    pub ip6oj_jumbo_len: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_opt_nsap {
    pub ip6on_type: u8,
    pub ip6on_len: u8,
    pub ip6on_src_nsap_len: u8,
    pub ip6on_dst_nsap_len: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_opt_tunnel {
    pub ip6ot_type: u8,
    pub ip6ot_len: u8,
    pub ip6ot_encap_limit: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_opt_router {
    pub ip6or_type: u8,
    pub ip6or_len: u8,
    pub ip6or_value: [u8; 2usize],
}
#[doc = " IPv4 Header"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_ipv4_hdr {
    pub __bindgen_anon_1: rte_ipv4_hdr__bindgen_ty_1,
    #[doc = "< type of service"]
    pub type_of_service: u8,
    #[doc = "< length of packet"]
    pub total_length: rte_be16_t,
    #[doc = "< packet ID"]
    pub packet_id: rte_be16_t,
    #[doc = "< fragmentation offset"]
    pub fragment_offset: rte_be16_t,
    #[doc = "< time to live"]
    pub time_to_live: u8,
    #[doc = "< protocol ID"]
    pub next_proto_id: u8,
    #[doc = "< header checksum"]
    pub hdr_checksum: rte_be16_t,
    #[doc = "< source address"]
    pub src_addr: rte_be32_t,
    #[doc = "< destination address"]
    pub dst_addr: rte_be32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_ipv4_hdr__bindgen_ty_1 {
    #[doc = "< version and header length"]
    pub version_ihl: u8,
    pub __bindgen_anon_1: rte_ipv4_hdr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ipv4_hdr__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl rte_ipv4_hdr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ihl(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ihl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_version(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ihl: u8, version: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ihl: u8 = unsafe { ::std::mem::transmute(ihl) };
            ihl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let version: u8 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " IPv6 Header"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ipv6_hdr {
    #[doc = "< IP version, traffic class & flow label."]
    pub vtc_flow: rte_be32_t,
    #[doc = "< IP payload size, including ext. headers"]
    pub payload_len: rte_be16_t,
    #[doc = "< Protocol, next header."]
    pub proto: u8,
    #[doc = "< Hop limits."]
    pub hop_limits: u8,
    #[doc = "< IP address of source host."]
    pub src_addr: [u8; 16usize],
    #[doc = "< IP address of destination host(s)."]
    pub dst_addr: [u8; 16usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ipv6_fragment_ext {
    #[doc = "< Next header type"]
    pub next_header: u8,
    #[doc = "< Reserved"]
    pub reserved: u8,
    #[doc = "< All fragmentation data"]
    pub frag_data: rte_be16_t,
    #[doc = "< Packet ID"]
    pub id: rte_be32_t,
}
#[doc = " SCTP Header"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_sctp_hdr {
    #[doc = "< Source port."]
    pub src_port: rte_be16_t,
    #[doc = "< Destin port."]
    pub dst_port: rte_be16_t,
    #[doc = "< Validation tag."]
    pub tag: rte_be32_t,
    #[doc = "< Checksum."]
    pub cksum: rte_be32_t,
}
#[doc = " TCP Header"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tcp_hdr {
    #[doc = "< TCP source port."]
    pub src_port: rte_be16_t,
    #[doc = "< TCP destination port."]
    pub dst_port: rte_be16_t,
    #[doc = "< TX data sequence number."]
    pub sent_seq: rte_be32_t,
    #[doc = "< RX data acknowledgment sequence number."]
    pub recv_ack: rte_be32_t,
    #[doc = "< Data offset."]
    pub data_off: u8,
    #[doc = "< TCP flags"]
    pub tcp_flags: u8,
    #[doc = "< RX flow control window."]
    pub rx_win: rte_be16_t,
    #[doc = "< TCP checksum."]
    pub cksum: rte_be16_t,
    #[doc = "< TCP urgent pointer, if any."]
    pub tcp_urp: rte_be16_t,
}
#[doc = " UDP Header"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_udp_hdr {
    #[doc = "< UDP source port."]
    pub src_port: rte_be16_t,
    #[doc = "< UDP destination port."]
    pub dst_port: rte_be16_t,
    #[doc = "< UDP datagram length"]
    pub dgram_len: rte_be16_t,
    #[doc = "< UDP datagram checksum"]
    pub dgram_cksum: rte_be16_t,
}
#[doc = " VXLAN protocol header."]
#[doc = " Contains the 8-bit flag, 24-bit VXLAN Network Identifier and"]
#[doc = " Reserved fields (24 bits and 8 bits)"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_vxlan_hdr {
    #[doc = "< flag (8) + Reserved (24)."]
    pub vx_flags: rte_be32_t,
    #[doc = "< VNI (24) + Reserved (8)."]
    pub vx_vni: rte_be32_t,
}
#[doc = " VXLAN-GPE protocol header (draft-ietf-nvo3-vxlan-gpe-05)."]
#[doc = " Contains the 8-bit flag, 8-bit next-protocol, 24-bit VXLAN Network"]
#[doc = " Identifier and Reserved fields (16 bits and 8 bits)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_vxlan_gpe_hdr {
    #[doc = "< flag (8)."]
    pub vx_flags: u8,
    #[doc = "< Reserved (16)."]
    pub reserved: [u8; 2usize],
    #[doc = "< next-protocol (8)."]
    pub proto: u8,
    #[doc = "< VNI (24) + Reserved (8)."]
    pub vx_vni: rte_be32_t,
}
#[doc = " ESP Header"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_esp_hdr {
    #[doc = "< Security Parameters Index"]
    pub spi: rte_be32_t,
    #[doc = "< packet sequence number"]
    pub seq: rte_be32_t,
}
#[doc = " ESP Trailer"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_esp_tail {
    #[doc = "< number of pad bytes (0-255)"]
    pub pad_len: u8,
    #[doc = "< IPv4 or IPv6 or next layer header"]
    pub next_proto: u8,
}
#[doc = " higig2 frc header."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_higig2_frc {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl rte_higig2_frc {
    #[inline]
    pub fn ksop(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ksop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn tc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mcst(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mcst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn resv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_resv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_modid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dst_modid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_pid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dst_pid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn src_modid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_src_modid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn src_pid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_src_pid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn lbid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lbid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ppd_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ppd_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn resv1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(59usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_resv1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(59usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(62usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(62usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ksop: u32,
        tc: u32,
        mcst: u32,
        resv: u32,
        dst_modid: u32,
        dst_pid: u32,
        src_modid: u32,
        src_pid: u32,
        lbid: u32,
        ppd_type: u32,
        resv1: u32,
        dp: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let ksop: u32 = unsafe { ::std::mem::transmute(ksop) };
            ksop as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let tc: u32 = unsafe { ::std::mem::transmute(tc) };
            tc as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let mcst: u32 = unsafe { ::std::mem::transmute(mcst) };
            mcst as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let resv: u32 = unsafe { ::std::mem::transmute(resv) };
            resv as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let dst_modid: u32 = unsafe { ::std::mem::transmute(dst_modid) };
            dst_modid as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let dst_pid: u32 = unsafe { ::std::mem::transmute(dst_pid) };
            dst_pid as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let src_modid: u32 = unsafe { ::std::mem::transmute(src_modid) };
            src_modid as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let src_pid: u32 = unsafe { ::std::mem::transmute(src_pid) };
            src_pid as u64
        });
        __bindgen_bitfield_unit.set(48usize, 8u8, {
            let lbid: u32 = unsafe { ::std::mem::transmute(lbid) };
            lbid as u64
        });
        __bindgen_bitfield_unit.set(56usize, 3u8, {
            let ppd_type: u32 = unsafe { ::std::mem::transmute(ppd_type) };
            ppd_type as u64
        });
        __bindgen_bitfield_unit.set(59usize, 3u8, {
            let resv1: u32 = unsafe { ::std::mem::transmute(resv1) };
            resv1 as u64
        });
        __bindgen_bitfield_unit.set(62usize, 2u8, {
            let dp: u32 = unsafe { ::std::mem::transmute(dp) };
            dp as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " higig2 ppt type0 header"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_higig2_ppt_type0 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl rte_higig2_ppt_type0 {
    #[inline]
    pub fn mirror(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mirror(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mirror_done(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mirror_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mirror_only(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mirror_only(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ingress_tagged(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress_tagged(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_tgid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_dst_tgid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_t(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dst_t(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vc_label2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_vc_label2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn label_present(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_label_present(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_l3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_res(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn vc_label1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vc_label1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn vc_label0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vc_label0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn vid_high(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vid_high(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn vid_low(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vid_low(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn opc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_opc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn res1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn srce_t(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_srce_t(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_pf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn res2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn hdr_ext_length(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(61usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_hdr_ext_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(61usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mirror: u32,
        mirror_done: u32,
        mirror_only: u32,
        ingress_tagged: u32,
        dst_tgid: u32,
        dst_t: u32,
        vc_label2: u32,
        label_present: u32,
        l3: u32,
        res: u32,
        vc_label1: u32,
        vc_label0: u32,
        vid_high: u32,
        vid_low: u32,
        opc: u32,
        res1: u32,
        srce_t: u32,
        pf: u32,
        res2: u32,
        hdr_ext_length: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mirror: u32 = unsafe { ::std::mem::transmute(mirror) };
            mirror as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mirror_done: u32 = unsafe { ::std::mem::transmute(mirror_done) };
            mirror_done as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mirror_only: u32 = unsafe { ::std::mem::transmute(mirror_only) };
            mirror_only as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ingress_tagged: u32 = unsafe { ::std::mem::transmute(ingress_tagged) };
            ingress_tagged as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let dst_tgid: u32 = unsafe { ::std::mem::transmute(dst_tgid) };
            dst_tgid as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let dst_t: u32 = unsafe { ::std::mem::transmute(dst_t) };
            dst_t as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let vc_label2: u32 = unsafe { ::std::mem::transmute(vc_label2) };
            vc_label2 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let label_present: u32 = unsafe { ::std::mem::transmute(label_present) };
            label_present as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let l3: u32 = unsafe { ::std::mem::transmute(l3) };
            l3 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let res: u32 = unsafe { ::std::mem::transmute(res) };
            res as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let vc_label1: u32 = unsafe { ::std::mem::transmute(vc_label1) };
            vc_label1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let vc_label0: u32 = unsafe { ::std::mem::transmute(vc_label0) };
            vc_label0 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let vid_high: u32 = unsafe { ::std::mem::transmute(vid_high) };
            vid_high as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let vid_low: u32 = unsafe { ::std::mem::transmute(vid_low) };
            vid_low as u64
        });
        __bindgen_bitfield_unit.set(48usize, 3u8, {
            let opc: u32 = unsafe { ::std::mem::transmute(opc) };
            opc as u64
        });
        __bindgen_bitfield_unit.set(51usize, 2u8, {
            let res1: u32 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let srce_t: u32 = unsafe { ::std::mem::transmute(srce_t) };
            srce_t as u64
        });
        __bindgen_bitfield_unit.set(54usize, 2u8, {
            let pf: u32 = unsafe { ::std::mem::transmute(pf) };
            pf as u64
        });
        __bindgen_bitfield_unit.set(56usize, 5u8, {
            let res2: u32 = unsafe { ::std::mem::transmute(res2) };
            res2 as u64
        });
        __bindgen_bitfield_unit.set(61usize, 3u8, {
            let hdr_ext_length: u32 = unsafe { ::std::mem::transmute(hdr_ext_length) };
            hdr_ext_length as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " higig2 ppt type1 header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_higig2_ppt_type1 {
    pub classification: u16,
    pub resv: u16,
    pub vid: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl rte_higig2_ppt_type1 {
    #[inline]
    pub fn opcode(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_opcode(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn resv1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_resv1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn src_t(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_src_t(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pfm(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_pfm(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn resv2(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_resv2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn hdr_ext_len(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_hdr_ext_len(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        opcode: u16,
        resv1: u16,
        src_t: u16,
        pfm: u16,
        resv2: u16,
        hdr_ext_len: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let opcode: u16 = unsafe { ::std::mem::transmute(opcode) };
            opcode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let resv1: u16 = unsafe { ::std::mem::transmute(resv1) };
            resv1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let src_t: u16 = unsafe { ::std::mem::transmute(src_t) };
            src_t as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let pfm: u16 = unsafe { ::std::mem::transmute(pfm) };
            pfm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let resv2: u16 = unsafe { ::std::mem::transmute(resv2) };
            resv2 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let hdr_ext_len: u16 = unsafe { ::std::mem::transmute(hdr_ext_len) };
            hdr_ext_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " higig2 header"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_higig2_hdr {
    pub fcr: rte_higig2_frc,
    pub __bindgen_anon_1: rte_higig2_hdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_higig2_hdr__bindgen_ty_1 {
    pub ppt0: rte_higig2_ppt_type0,
    pub ppt1: rte_higig2_ppt_type1,
}
#[doc = " Structure describing the parameters of a mbuf dynamic field."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf_dynfield {
    #[doc = "< Name of the field."]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< The number of bytes to reserve."]
    pub size: size_t,
    #[doc = "< The alignment constraint (power of 2)."]
    pub align: size_t,
    #[doc = "< Reserved for future use, must be 0."]
    pub flags: ::std::os::raw::c_uint,
}
#[doc = " Structure describing the parameters of a mbuf dynamic flag."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf_dynflag {
    #[doc = "< Name of the dynamic flag."]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< Reserved for future use, must be 0."]
    pub flags: ::std::os::raw::c_uint,
}
extern "C" {
    #[doc = " Register space for a dynamic field in the mbuf structure."]
    #[doc = ""]
    #[doc = " If the field is already registered (same name and parameters), its"]
    #[doc = " offset is returned."]
    #[doc = ""]
    #[doc = " @param params"]
    #[doc = "   A structure containing the requested parameters (name, size,"]
    #[doc = "   alignment constraint and flags)."]
    #[doc = " @return"]
    #[doc = "   The offset in the mbuf structure, or -1 on error."]
    #[doc = "   Possible values for rte_errno:"]
    #[doc = "   - EINVAL: invalid parameters (size, align, or flags)."]
    #[doc = "   - EEXIST: this name is already register with different parameters."]
    #[doc = "   - EPERM: called from a secondary process."]
    #[doc = "   - ENOENT: not enough room in mbuf."]
    #[doc = "   - ENOMEM: allocation failure."]
    #[doc = "   - ENAMETOOLONG: name does not ends with \\0."]
    pub fn rte_mbuf_dynfield_register(params: *const rte_mbuf_dynfield) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register space for a dynamic field in the mbuf structure at offset."]
    #[doc = ""]
    #[doc = " If the field is already registered (same name, parameters and offset),"]
    #[doc = " the offset is returned."]
    #[doc = ""]
    #[doc = " @param params"]
    #[doc = "   A structure containing the requested parameters (name, size,"]
    #[doc = "   alignment constraint and flags)."]
    #[doc = " @param offset"]
    #[doc = "   The requested offset. Ignored if SIZE_MAX is passed."]
    #[doc = " @return"]
    #[doc = "   The offset in the mbuf structure, or -1 on error."]
    #[doc = "   Possible values for rte_errno:"]
    #[doc = "   - EINVAL: invalid parameters (size, align, flags, or offset)."]
    #[doc = "   - EEXIST: this name is already register with different parameters."]
    #[doc = "   - EBUSY: the requested offset cannot be used."]
    #[doc = "   - EPERM: called from a secondary process."]
    #[doc = "   - ENOENT: not enough room in mbuf."]
    #[doc = "   - ENOMEM: allocation failure."]
    #[doc = "   - ENAMETOOLONG: name does not ends with \\0."]
    pub fn rte_mbuf_dynfield_register_offset(
        params: *const rte_mbuf_dynfield,
        offset: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Lookup for a registered dynamic mbuf field."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   A string identifying the dynamic field."]
    #[doc = " @param params"]
    #[doc = "   If not NULL, and if the lookup is successful, the structure is"]
    #[doc = "   filled with the parameters of the dynamic field."]
    #[doc = " @return"]
    #[doc = "   The offset of this field in the mbuf structure, or -1 on error."]
    #[doc = "   Possible values for rte_errno:"]
    #[doc = "   - ENOENT: no dynamic field matches this name."]
    pub fn rte_mbuf_dynfield_lookup(
        name: *const ::std::os::raw::c_char,
        params: *mut rte_mbuf_dynfield,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a dynamic flag in the mbuf structure."]
    #[doc = ""]
    #[doc = " If the flag is already registered (same name and parameters), its"]
    #[doc = " bitnum is returned."]
    #[doc = ""]
    #[doc = " @param params"]
    #[doc = "   A structure containing the requested parameters of the dynamic"]
    #[doc = "   flag (name and options)."]
    #[doc = " @return"]
    #[doc = "   The number of the reserved bit, or -1 on error."]
    #[doc = "   Possible values for rte_errno:"]
    #[doc = "   - EINVAL: invalid parameters (size, align, or flags)."]
    #[doc = "   - EEXIST: this name is already register with different parameters."]
    #[doc = "   - EPERM: called from a secondary process."]
    #[doc = "   - ENOENT: no more flag available."]
    #[doc = "   - ENOMEM: allocation failure."]
    #[doc = "   - ENAMETOOLONG: name is longer than RTE_MBUF_DYN_NAMESIZE - 1."]
    pub fn rte_mbuf_dynflag_register(params: *const rte_mbuf_dynflag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a dynamic flag in the mbuf structure specifying bitnum."]
    #[doc = ""]
    #[doc = " If the flag is already registered (same name, parameters and bitnum),"]
    #[doc = " the bitnum is returned."]
    #[doc = ""]
    #[doc = " @param params"]
    #[doc = "   A structure containing the requested parameters of the dynamic"]
    #[doc = "   flag (name and options)."]
    #[doc = " @param bitnum"]
    #[doc = "   The requested bitnum. Ignored if UINT_MAX is passed."]
    #[doc = " @return"]
    #[doc = "   The number of the reserved bit, or -1 on error."]
    #[doc = "   Possible values for rte_errno:"]
    #[doc = "   - EINVAL: invalid parameters (size, align, or flags)."]
    #[doc = "   - EEXIST: this name is already register with different parameters."]
    #[doc = "   - EBUSY: the requested bitnum cannot be used."]
    #[doc = "   - EPERM: called from a secondary process."]
    #[doc = "   - ENOENT: no more flag available."]
    #[doc = "   - ENOMEM: allocation failure."]
    #[doc = "   - ENAMETOOLONG: name is longer than RTE_MBUF_DYN_NAMESIZE - 1."]
    pub fn rte_mbuf_dynflag_register_bitnum(
        params: *const rte_mbuf_dynflag,
        bitnum: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Lookup for a registered dynamic mbuf flag."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   A string identifying the dynamic flag."]
    #[doc = " @param params"]
    #[doc = "   If not NULL, and if the lookup is successful, the structure is"]
    #[doc = "   filled with the parameters of the dynamic flag."]
    #[doc = " @return"]
    #[doc = "   The offset of this flag in the mbuf structure, or -1 on error."]
    #[doc = "   Possible values for rte_errno:"]
    #[doc = "   - ENOENT: no dynamic flag matches this name."]
    pub fn rte_mbuf_dynflag_lookup(
        name: *const ::std::os::raw::c_char,
        params: *mut rte_mbuf_dynflag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump the status of dynamic fields and flags."]
    #[doc = ""]
    #[doc = " @param out"]
    #[doc = "   The stream where the status is displayed."]
    pub fn rte_mbuf_dyn_dump(out: *mut FILE);
}
pub type rte_mbuf_timestamp_t = u64;
extern "C" {
    #[doc = " Register dynamic mbuf field and flag for Rx timestamp."]
    #[doc = ""]
    #[doc = " @param field_offset"]
    #[doc = "   Pointer to the offset of the registered mbuf field, can be NULL."]
    #[doc = "   The same field is shared for Rx and Tx timestamp."]
    #[doc = " @param rx_flag"]
    #[doc = "   Pointer to the mask of the registered offload flag, can be NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, -1 otherwise."]
    #[doc = "   Possible values for rte_errno:"]
    #[doc = "   - EEXIST: already registered with different parameters."]
    #[doc = "   - EPERM: called from a secondary process."]
    #[doc = "   - ENOENT: no more field or flag available."]
    #[doc = "   - ENOMEM: allocation failure."]
    pub fn rte_mbuf_dyn_rx_timestamp_register(
        field_offset: *mut ::std::os::raw::c_int,
        rx_flag: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register dynamic mbuf field and flag for Tx timestamp."]
    #[doc = ""]
    #[doc = " @param field_offset"]
    #[doc = "   Pointer to the offset of the registered mbuf field, can be NULL."]
    #[doc = "   The same field is shared for Rx and Tx timestamp."]
    #[doc = " @param tx_flag"]
    #[doc = "   Pointer to the mask of the registered offload flag, can be NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, -1 otherwise."]
    #[doc = "   Possible values for rte_errno:"]
    #[doc = "   - EEXIST: already registered with different parameters."]
    #[doc = "   - EPERM: called from a secondary process."]
    #[doc = "   - ENOENT: no more field or flag available."]
    #[doc = "   - ENOMEM: allocation failure."]
    pub fn rte_mbuf_dyn_tx_timestamp_register(
        field_offset: *mut ::std::os::raw::c_int,
        tx_flag: *mut u64,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " Color"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_color {
    #[doc = "< Green"]
    RTE_COLOR_GREEN = 0,
    #[doc = "< Yellow"]
    RTE_COLOR_YELLOW = 1,
    #[doc = "< Red"]
    RTE_COLOR_RED = 2,
    #[doc = "< Number of colors"]
    RTE_COLORS = 3,
}
#[doc = " srTCM parameters per metered traffic flow. The CIR, CBS and EBS parameters only"]
#[doc = "count bytes of IP packets and do not include link specific headers. At least one of"]
#[doc = "the CBS or EBS parameters has to be greater than zero."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_meter_srtcm_params {
    #[doc = "< Committed Information Rate (CIR). Measured in bytes per second."]
    pub cir: u64,
    #[doc = "< Committed Burst Size (CBS).  Measured in bytes."]
    pub cbs: u64,
    #[doc = "< Excess Burst Size (EBS).  Measured in bytes."]
    pub ebs: u64,
}
#[doc = " trTCM parameters per metered traffic flow. The CIR, PIR, CBS and PBS parameters"]
#[doc = "only count bytes of IP packets and do not include link specific headers. PIR has to"]
#[doc = "be greater than or equal to CIR. Both CBS or EBS have to be greater than zero."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_meter_trtcm_params {
    #[doc = "< Committed Information Rate (CIR). Measured in bytes per second."]
    pub cir: u64,
    #[doc = "< Peak Information Rate (PIR). Measured in bytes per second."]
    pub pir: u64,
    #[doc = "< Committed Burst Size (CBS). Measured in bytes."]
    pub cbs: u64,
    #[doc = "< Peak Burst Size (PBS). Measured in bytes."]
    pub pbs: u64,
}
#[doc = " trTCM parameters per metered traffic flow. The CIR, EIR, CBS and EBS"]
#[doc = "parameters only count bytes of IP packets and do not include link specific"]
#[doc = "headers. The CBS and EBS need to be greater than zero if CIR and EIR are"]
#[doc = "none-zero respectively."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_meter_trtcm_rfc4115_params {
    #[doc = "< Committed Information Rate (CIR). Measured in bytes per second."]
    pub cir: u64,
    #[doc = "< Excess Information Rate (EIR). Measured in bytes per second."]
    pub eir: u64,
    #[doc = "< Committed Burst Size (CBS). Measured in bytes."]
    pub cbs: u64,
    #[doc = "< Excess Burst Size (EBS). Measured in bytes."]
    pub ebs: u64,
}
extern "C" {
    #[doc = " srTCM profile configuration"]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "    Pointer to pre-allocated srTCM profile data structure"]
    #[doc = " @param params"]
    #[doc = "    srTCM profile parameters"]
    #[doc = " @return"]
    #[doc = "    0 upon success, error code otherwise"]
    pub fn rte_meter_srtcm_profile_config(
        p: *mut rte_meter_srtcm_profile,
        params: *mut rte_meter_srtcm_params,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " trTCM profile configuration"]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "    Pointer to pre-allocated trTCM profile data structure"]
    #[doc = " @param params"]
    #[doc = "    trTCM profile parameters"]
    #[doc = " @return"]
    #[doc = "    0 upon success, error code otherwise"]
    pub fn rte_meter_trtcm_profile_config(
        p: *mut rte_meter_trtcm_profile,
        params: *mut rte_meter_trtcm_params,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " trTCM RFC 4115 profile configuration"]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "    Pointer to pre-allocated trTCM profile data structure"]
    #[doc = " @param params"]
    #[doc = "    trTCM profile parameters"]
    #[doc = " @return"]
    #[doc = "    0 upon success, error code otherwise"]
    pub fn rte_meter_trtcm_rfc4115_profile_config(
        p: *mut rte_meter_trtcm_rfc4115_profile,
        params: *mut rte_meter_trtcm_rfc4115_params,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " srTCM configuration per metered traffic flow"]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "    Pointer to pre-allocated srTCM data structure"]
    #[doc = " @param p"]
    #[doc = "    srTCM profile. Needs to be valid."]
    #[doc = " @return"]
    #[doc = "    0 upon success, error code otherwise"]
    pub fn rte_meter_srtcm_config(
        m: *mut rte_meter_srtcm,
        p: *mut rte_meter_srtcm_profile,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " trTCM configuration per metered traffic flow"]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "    Pointer to pre-allocated trTCM data structure"]
    #[doc = " @param p"]
    #[doc = "    trTCM profile. Needs to be valid."]
    #[doc = " @return"]
    #[doc = "    0 upon success, error code otherwise"]
    pub fn rte_meter_trtcm_config(
        m: *mut rte_meter_trtcm,
        p: *mut rte_meter_trtcm_profile,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " trTCM RFC 4115 configuration per metered traffic flow"]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "    Pointer to pre-allocated trTCM data structure"]
    #[doc = " @param p"]
    #[doc = "    trTCM profile. Needs to be valid."]
    #[doc = " @return"]
    #[doc = "    0 upon success, error code otherwise"]
    pub fn rte_meter_trtcm_rfc4115_config(
        m: *mut rte_meter_trtcm_rfc4115,
        p: *mut rte_meter_trtcm_rfc4115_profile,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Internal data structure storing the srTCM configuration profile. Typically"]
#[doc = " shared by multiple srTCM objects."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_meter_srtcm_profile {
    pub cbs: u64,
    pub ebs: u64,
    pub cir_period: u64,
    pub cir_bytes_per_period: u64,
}
#[doc = " Internal data structure storing the srTCM run-time context per metered traffic flow."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_meter_srtcm {
    pub time: u64,
    pub tc: u64,
    pub te: u64,
}
#[doc = " Internal data structure storing the trTCM configuration profile. Typically"]
#[doc = " shared by multiple trTCM objects."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_meter_trtcm_profile {
    pub cbs: u64,
    pub pbs: u64,
    pub cir_period: u64,
    pub cir_bytes_per_period: u64,
    pub pir_period: u64,
    pub pir_bytes_per_period: u64,
}
#[doc = " Internal data structure storing the trTCM run-time context per metered traffic flow."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_meter_trtcm {
    pub time_tc: u64,
    pub time_tp: u64,
    pub tc: u64,
    pub tp: u64,
}
#[doc = " Internal data structure storing the trTCM RFC4115 configuration profile."]
#[doc = " Typically shared by multiple trTCM objects."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_meter_trtcm_rfc4115_profile {
    pub cbs: u64,
    pub ebs: u64,
    pub cir_period: u64,
    pub cir_bytes_per_period: u64,
    pub eir_period: u64,
    pub eir_bytes_per_period: u64,
}
#[doc = " Internal data structure storing the trTCM RFC4115 run-time context per"]
#[doc = " metered traffic flow."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_meter_trtcm_rfc4115 {
    pub time_tc: u64,
    pub time_te: u64,
    pub tc: u64,
    pub te: u64,
}
#[doc = " Simplified GTP protocol header."]
#[doc = " Contains 8-bit header info, 8-bit message type,"]
#[doc = " 16-bit payload length after mandatory header, 32-bit TEID."]
#[doc = " No optional fields and next extension header."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_gtp_hdr {
    pub __bindgen_anon_1: rte_gtp_hdr__bindgen_ty_1,
    #[doc = "< GTP message type"]
    pub msg_type: u8,
    #[doc = "< Total payload length"]
    pub plen: rte_be16_t,
    #[doc = "< Tunnel endpoint ID"]
    pub teid: rte_be32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_gtp_hdr__bindgen_ty_1 {
    #[doc = "< GTP header info"]
    pub gtp_hdr_info: u8,
    pub __bindgen_anon_1: rte_gtp_hdr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_gtp_hdr__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl rte_gtp_hdr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn pn(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pn(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn s(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_s(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pt(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ver(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_ver(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pn: u8,
        s: u8,
        e: u8,
        res1: u8,
        pt: u8,
        ver: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pn: u8 = unsafe { ::std::mem::transmute(pn) };
            pn as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let s: u8 = unsafe { ::std::mem::transmute(s) };
            s as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let e: u8 = unsafe { ::std::mem::transmute(e) };
            e as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let res1: u8 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let pt: u8 = unsafe { ::std::mem::transmute(pt) };
            pt as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let ver: u8 = unsafe { ::std::mem::transmute(ver) };
            ver as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_gtp_hdr_ext_word {
    #[doc = "< Sequence Number."]
    pub sqn: rte_be16_t,
    #[doc = "< N-PDU number."]
    pub npdu: u8,
    #[doc = "< Next Extension Header Type."]
    pub next_ext: u8,
}
#[doc = " Optional extension for GTP with next_ext set to 0x85"]
#[doc = " defined based on RFC 38415-g30."]
#[repr(C, packed)]
#[derive(Debug)]
pub struct rte_gtp_psc_generic_hdr {
    #[doc = "< PDU ext hdr len in multiples of 4 bytes"]
    pub ext_hdr_len: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "< variable length data fields"]
    pub data: __IncompleteArrayField<u8>,
}
impl rte_gtp_psc_generic_hdr {
    #[inline]
    pub fn qfi(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_qfi(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn spare(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_spare(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pad(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn qmp(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_qmp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        qfi: u8,
        spare: u8,
        pad: u8,
        qmp: u8,
        type_: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let qfi: u8 = unsafe { ::std::mem::transmute(qfi) };
            qfi as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let spare: u8 = unsafe { ::std::mem::transmute(spare) };
            spare as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let pad: u8 = unsafe { ::std::mem::transmute(pad) };
            pad as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let qmp: u8 = unsafe { ::std::mem::transmute(qmp) };
            qmp as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let type_: u8 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Optional extension for GTP with next_ext set to 0x85"]
#[doc = " type0 defined based on RFC 38415-g30"]
#[repr(C, packed)]
#[derive(Debug)]
pub struct rte_gtp_psc_type0_hdr {
    #[doc = "< PDU ext hdr len in multiples of 4 bytes"]
    pub ext_hdr_len: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "< variable length data fields"]
    pub data: __IncompleteArrayField<u8>,
}
impl rte_gtp_psc_type0_hdr {
    #[inline]
    pub fn qfi(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_qfi(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn rqi(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rqi(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ppp(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ppp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn spare_dl1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_spare_dl1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn snp(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_snp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        qfi: u8,
        rqi: u8,
        ppp: u8,
        spare_dl1: u8,
        snp: u8,
        type_: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let qfi: u8 = unsafe { ::std::mem::transmute(qfi) };
            qfi as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rqi: u8 = unsafe { ::std::mem::transmute(rqi) };
            rqi as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ppp: u8 = unsafe { ::std::mem::transmute(ppp) };
            ppp as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let spare_dl1: u8 = unsafe { ::std::mem::transmute(spare_dl1) };
            spare_dl1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let snp: u8 = unsafe { ::std::mem::transmute(snp) };
            snp as u64
        });
        __bindgen_bitfield_unit.set(11usize, 4u8, {
            let type_: u8 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Optional extension for GTP with next_ext set to 0x85"]
#[doc = " type1 defined based on RFC 38415-g30"]
#[repr(C, packed)]
#[derive(Debug)]
pub struct rte_gtp_psc_type1_hdr {
    #[doc = "< PDU ext hdr len in multiples of 4 bytes"]
    pub ext_hdr_len: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "< variable length data fields"]
    pub data: __IncompleteArrayField<u8>,
}
impl rte_gtp_psc_type1_hdr {
    #[inline]
    pub fn qfi(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_qfi(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn spare_ul2(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_spare_ul2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn n_delay_ind(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_n_delay_ind(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn snp(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_snp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ul_delay_ind(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ul_delay_ind(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_delay_ind(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dl_delay_ind(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn qmp(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_qmp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        qfi: u8,
        spare_ul2: u8,
        n_delay_ind: u8,
        snp: u8,
        ul_delay_ind: u8,
        dl_delay_ind: u8,
        qmp: u8,
        type_: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let qfi: u8 = unsafe { ::std::mem::transmute(qfi) };
            qfi as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let spare_ul2: u8 = unsafe { ::std::mem::transmute(spare_ul2) };
            spare_ul2 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let n_delay_ind: u8 = unsafe { ::std::mem::transmute(n_delay_ind) };
            n_delay_ind as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let snp: u8 = unsafe { ::std::mem::transmute(snp) };
            snp as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ul_delay_ind: u8 = unsafe { ::std::mem::transmute(ul_delay_ind) };
            ul_delay_ind as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let dl_delay_ind: u8 = unsafe { ::std::mem::transmute(dl_delay_ind) };
            dl_delay_ind as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let qmp: u8 = unsafe { ::std::mem::transmute(qmp) };
            qmp as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let type_: u8 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " PPP Header"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ppp_hdr {
    #[doc = "< PPP address(8)"]
    pub addr: u8,
    #[doc = "< PPP control(8)"]
    pub ctrl: u8,
    #[doc = "< PPP protocol identifier(16)"]
    pub proto_id: rte_be16_t,
}
#[doc = " GRE Header"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_gre_hdr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "< Protocol Type"]
    pub proto: u16,
}
impl rte_gre_hdr {
    #[inline]
    pub fn res2(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn s(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_s(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn k(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_k(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn c(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_c(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ver(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_ver(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn res3(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_res3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        res2: u16,
        s: u16,
        k: u16,
        res1: u16,
        c: u16,
        ver: u16,
        res3: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let res2: u16 = unsafe { ::std::mem::transmute(res2) };
            res2 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let s: u16 = unsafe { ::std::mem::transmute(s) };
            s as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let k: u16 = unsafe { ::std::mem::transmute(k) };
            k as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let res1: u16 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let c: u16 = unsafe { ::std::mem::transmute(c) };
            c as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let ver: u16 = unsafe { ::std::mem::transmute(ver) };
            ver as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let res3: u16 = unsafe { ::std::mem::transmute(res3) };
            res3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Optional field checksum in GRE header"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_gre_hdr_opt_checksum_rsvd {
    pub checksum: rte_be16_t,
    pub reserved1: rte_be16_t,
}
#[doc = " Optional field key in GRE header"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_gre_hdr_opt_key {
    pub key: rte_be32_t,
}
#[doc = " Optional field sequence in GRE header"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_gre_hdr_opt_sequence {
    pub sequence: rte_be32_t,
}
#[doc = " Flow rule attributes."]
#[doc = ""]
#[doc = " Priorities are set on a per rule based within groups."]
#[doc = ""]
#[doc = " Lower values denote higher priority, the highest priority for a flow rule"]
#[doc = " is 0, so that a flow that matches for than one rule, the rule with the"]
#[doc = " lowest priority value will always be matched."]
#[doc = ""]
#[doc = " Although optional, applications are encouraged to group similar rules as"]
#[doc = " much as possible to fully take advantage of hardware capabilities"]
#[doc = " (e.g. optimized matching) and work around limitations (e.g. a single"]
#[doc = " pattern type possibly allowed in a given group). Applications should be"]
#[doc = " aware that groups are not linked by default, and that they must be"]
#[doc = " explicitly linked by the application using the JUMP action."]
#[doc = ""]
#[doc = " Priority levels are arbitrary and up to the application, they"]
#[doc = " do not need to be contiguous nor start from 0, however the maximum number"]
#[doc = " varies between devices and may be affected by existing flow rules."]
#[doc = ""]
#[doc = " If a packet is matched by several rules of a given group for a given"]
#[doc = " priority level, the outcome is undefined. It can take any path, may be"]
#[doc = " duplicated or even cause unrecoverable errors."]
#[doc = ""]
#[doc = " Note that support for more than a single group and priority level is not"]
#[doc = " guaranteed."]
#[doc = ""]
#[doc = " At vNIC / ethdev level, flow rules can apply to inbound and / or outbound"]
#[doc = " traffic (ingress / egress), with respect to the vNIC / ethdev in question."]
#[doc = " At embedded switch level, flow rules apply to all traffic seen by it"]
#[doc = " unless fitting meta items are used to set concrete traffic source(s)."]
#[doc = ""]
#[doc = " Several pattern items and actions are valid and can be used in both"]
#[doc = " directions. Those valid for only one direction are described as such."]
#[doc = ""]
#[doc = " At least one direction must be specified."]
#[doc = ""]
#[doc = " Specifying both directions at once for a given rule is not recommended"]
#[doc = " but may be valid in a few cases."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_attr {
    #[doc = "< Priority group."]
    pub group: u32,
    #[doc = "< Rule priority level within group."]
    pub priority: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rte_flow_attr {
    #[inline]
    pub fn ingress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transfer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transfer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ingress: u32,
        egress: u32,
        transfer: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ingress: u32 = unsafe { ::std::mem::transmute(ingress) };
            ingress as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let egress: u32 = unsafe { ::std::mem::transmute(egress) };
            egress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let transfer: u32 = unsafe { ::std::mem::transmute(transfer) };
            transfer as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(u32)]
#[doc = " Matching pattern item types."]
#[doc = ""]
#[doc = " Pattern items fall in two categories:"]
#[doc = ""]
#[doc = " - Matching protocol headers and packet data, usually associated with a"]
#[doc = "   specification structure. These must be stacked in the same order as the"]
#[doc = "   protocol layers to match inside packets, starting from the lowest."]
#[doc = ""]
#[doc = " - Matching meta-data or affecting pattern processing, often without a"]
#[doc = "   specification structure. Since they do not match packet contents, their"]
#[doc = "   position in the list is usually not relevant."]
#[doc = ""]
#[doc = " See the description of individual types for more information. Those"]
#[doc = " marked with [META] fall into the second category."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_flow_item_type {
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " End marker for item lists. Prevents further processing of items,"]
    #[doc = " thereby ending the pattern."]
    #[doc = ""]
    #[doc = " No associated specification structure."]
    RTE_FLOW_ITEM_TYPE_END = 0,
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Used as a placeholder for convenience. It is ignored and simply"]
    #[doc = " discarded by PMDs."]
    #[doc = ""]
    #[doc = " No associated specification structure."]
    RTE_FLOW_ITEM_TYPE_VOID = 1,
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Inverted matching, i.e. process packets that do not match the"]
    #[doc = " pattern."]
    #[doc = ""]
    #[doc = " No associated specification structure."]
    RTE_FLOW_ITEM_TYPE_INVERT = 2,
    #[doc = " Matches any protocol in place of the current layer, a single ANY"]
    #[doc = " may also stand for several protocol layers."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_any."]
    RTE_FLOW_ITEM_TYPE_ANY = 3,
    #[doc = " @deprecated"]
    #[doc = " @see RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR"]
    #[doc = " @see RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT"]
    #[doc = ""]
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Matches traffic originating from (ingress) or going to (egress)"]
    #[doc = " the physical function of the current device."]
    #[doc = ""]
    #[doc = " No associated specification structure."]
    RTE_FLOW_ITEM_TYPE_PF = 4,
    #[doc = " @deprecated"]
    #[doc = " @see RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR"]
    #[doc = " @see RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT"]
    #[doc = ""]
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Matches traffic originating from (ingress) or going to (egress) a"]
    #[doc = " given virtual function of the current device."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_vf."]
    RTE_FLOW_ITEM_TYPE_VF = 5,
    #[doc = " @deprecated"]
    #[doc = " @see RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR"]
    #[doc = " @see RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT"]
    #[doc = ""]
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Matches traffic originating from (ingress) or going to (egress) a"]
    #[doc = " physical port of the underlying device."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_phy_port."]
    RTE_FLOW_ITEM_TYPE_PHY_PORT = 6,
    #[doc = " @deprecated"]
    #[doc = " @see RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR"]
    #[doc = " @see RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT"]
    #[doc = ""]
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Matches traffic originating from (ingress) or going to (egress) a"]
    #[doc = " given DPDK port ID."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_port_id."]
    RTE_FLOW_ITEM_TYPE_PORT_ID = 7,
    #[doc = " Matches a byte string of a given length at a given offset."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_raw."]
    RTE_FLOW_ITEM_TYPE_RAW = 8,
    #[doc = " Matches an Ethernet header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_eth."]
    RTE_FLOW_ITEM_TYPE_ETH = 9,
    #[doc = " Matches an 802.1Q/ad VLAN tag."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_vlan."]
    RTE_FLOW_ITEM_TYPE_VLAN = 10,
    #[doc = " Matches an IPv4 header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_ipv4."]
    RTE_FLOW_ITEM_TYPE_IPV4 = 11,
    #[doc = " Matches an IPv6 header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_ipv6."]
    RTE_FLOW_ITEM_TYPE_IPV6 = 12,
    #[doc = " Matches an ICMP header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_icmp."]
    RTE_FLOW_ITEM_TYPE_ICMP = 13,
    #[doc = " Matches a UDP header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_udp."]
    RTE_FLOW_ITEM_TYPE_UDP = 14,
    #[doc = " Matches a TCP header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_tcp."]
    RTE_FLOW_ITEM_TYPE_TCP = 15,
    #[doc = " Matches a SCTP header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_sctp."]
    RTE_FLOW_ITEM_TYPE_SCTP = 16,
    #[doc = " Matches a VXLAN header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_vxlan."]
    RTE_FLOW_ITEM_TYPE_VXLAN = 17,
    #[doc = " Matches a E_TAG header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_e_tag."]
    RTE_FLOW_ITEM_TYPE_E_TAG = 18,
    #[doc = " Matches a NVGRE header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_nvgre."]
    RTE_FLOW_ITEM_TYPE_NVGRE = 19,
    #[doc = " Matches a MPLS header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_mpls."]
    RTE_FLOW_ITEM_TYPE_MPLS = 20,
    #[doc = " Matches a GRE header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_gre."]
    RTE_FLOW_ITEM_TYPE_GRE = 21,
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Fuzzy pattern match, expect faster than default."]
    #[doc = ""]
    #[doc = " This is for device that support fuzzy matching option."]
    #[doc = " Usually a fuzzy matching is fast but the cost is accuracy."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_fuzzy."]
    RTE_FLOW_ITEM_TYPE_FUZZY = 22,
    #[doc = " Matches a GTP header."]
    #[doc = ""]
    #[doc = " Configure flow for GTP packets."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_gtp."]
    RTE_FLOW_ITEM_TYPE_GTP = 23,
    #[doc = " Matches a GTP header."]
    #[doc = ""]
    #[doc = " Configure flow for GTP-C packets."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_gtp."]
    RTE_FLOW_ITEM_TYPE_GTPC = 24,
    #[doc = " Matches a GTP header."]
    #[doc = ""]
    #[doc = " Configure flow for GTP-U packets."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_gtp."]
    RTE_FLOW_ITEM_TYPE_GTPU = 25,
    #[doc = " Matches a ESP header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_esp."]
    RTE_FLOW_ITEM_TYPE_ESP = 26,
    #[doc = " Matches a GENEVE header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_geneve."]
    RTE_FLOW_ITEM_TYPE_GENEVE = 27,
    #[doc = " Matches a VXLAN-GPE header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_vxlan_gpe."]
    RTE_FLOW_ITEM_TYPE_VXLAN_GPE = 28,
    #[doc = " Matches an ARP header for Ethernet/IPv4."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_arp_eth_ipv4."]
    RTE_FLOW_ITEM_TYPE_ARP_ETH_IPV4 = 29,
    #[doc = " Matches the presence of any IPv6 extension header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_ipv6_ext."]
    RTE_FLOW_ITEM_TYPE_IPV6_EXT = 30,
    #[doc = " Matches any ICMPv6 header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_icmp6."]
    RTE_FLOW_ITEM_TYPE_ICMP6 = 31,
    #[doc = " Matches an ICMPv6 neighbor discovery solicitation."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_icmp6_nd_ns."]
    RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS = 32,
    #[doc = " Matches an ICMPv6 neighbor discovery advertisement."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_icmp6_nd_na."]
    RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA = 33,
    #[doc = " Matches the presence of any ICMPv6 neighbor discovery option."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_icmp6_nd_opt."]
    RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT = 34,
    #[doc = " Matches an ICMPv6 neighbor discovery source Ethernet link-layer"]
    #[doc = " address option."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_icmp6_nd_opt_sla_eth."]
    RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_SLA_ETH = 35,
    #[doc = " Matches an ICMPv6 neighbor discovery target Ethernet link-layer"]
    #[doc = " address option."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_icmp6_nd_opt_tla_eth."]
    RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_TLA_ETH = 36,
    #[doc = " Matches specified mark field."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_mark."]
    RTE_FLOW_ITEM_TYPE_MARK = 37,
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Matches a metadata value."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_meta."]
    RTE_FLOW_ITEM_TYPE_META = 38,
    #[doc = " Matches a GRE optional key field."]
    #[doc = ""]
    #[doc = " The value should a big-endian 32bit integer."]
    #[doc = ""]
    #[doc = " When this item present the K bit is implicitly matched as \"1\""]
    #[doc = " in the default mask."]
    #[doc = ""]
    #[doc = " @p spec/mask type:"]
    #[doc = " @code rte_be32_t * @endcode"]
    RTE_FLOW_ITEM_TYPE_GRE_KEY = 39,
    #[doc = " Matches a GTP extension header: PDU session container."]
    #[doc = ""]
    #[doc = " Configure flow for GTP packets with extension header type 0x85."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_gtp_psc."]
    RTE_FLOW_ITEM_TYPE_GTP_PSC = 40,
    #[doc = " Matches a PPPoE header."]
    #[doc = ""]
    #[doc = " Configure flow for PPPoE session packets."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_pppoe."]
    RTE_FLOW_ITEM_TYPE_PPPOES = 41,
    #[doc = " Matches a PPPoE header."]
    #[doc = ""]
    #[doc = " Configure flow for PPPoE discovery packets."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_pppoe."]
    RTE_FLOW_ITEM_TYPE_PPPOED = 42,
    #[doc = " Matches a PPPoE optional proto_id field."]
    #[doc = ""]
    #[doc = " It only applies to PPPoE session packets."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_pppoe_proto_id."]
    RTE_FLOW_ITEM_TYPE_PPPOE_PROTO_ID = 43,
    #[doc = " Matches Network service header (NSH)."]
    #[doc = " See struct rte_flow_item_nsh."]
    #[doc = ""]
    RTE_FLOW_ITEM_TYPE_NSH = 44,
    #[doc = " Matches Internet Group Management Protocol (IGMP)."]
    #[doc = " See struct rte_flow_item_igmp."]
    #[doc = ""]
    RTE_FLOW_ITEM_TYPE_IGMP = 45,
    #[doc = " Matches IP Authentication Header (AH)."]
    #[doc = " See struct rte_flow_item_ah."]
    #[doc = ""]
    RTE_FLOW_ITEM_TYPE_AH = 46,
    #[doc = " Matches a HIGIG header."]
    #[doc = " see struct rte_flow_item_higig2_hdr."]
    RTE_FLOW_ITEM_TYPE_HIGIG2 = 47,
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Matches a tag value."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_tag."]
    RTE_FLOW_ITEM_TYPE_TAG = 48,
    #[doc = " Matches a L2TPv3 over IP header."]
    #[doc = ""]
    #[doc = " Configure flow for L2TPv3 over IP packets."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_l2tpv3oip."]
    RTE_FLOW_ITEM_TYPE_L2TPV3OIP = 49,
    #[doc = " Matches PFCP Header."]
    #[doc = " See struct rte_flow_item_pfcp."]
    #[doc = ""]
    RTE_FLOW_ITEM_TYPE_PFCP = 50,
    #[doc = " Matches eCPRI Header."]
    #[doc = ""]
    #[doc = " Configure flow for eCPRI over ETH or UDP packets."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_ecpri."]
    RTE_FLOW_ITEM_TYPE_ECPRI = 51,
    #[doc = " Matches the presence of IPv6 fragment extension header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_ipv6_frag_ext."]
    RTE_FLOW_ITEM_TYPE_IPV6_FRAG_EXT = 52,
    #[doc = " Matches Geneve Variable Length Option"]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_geneve_opt"]
    RTE_FLOW_ITEM_TYPE_GENEVE_OPT = 53,
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Matches on packet integrity."]
    #[doc = " For some devices application needs to enable integration checks in HW"]
    #[doc = " before using this item."]
    #[doc = ""]
    #[doc = " @see struct rte_flow_item_integrity."]
    RTE_FLOW_ITEM_TYPE_INTEGRITY = 54,
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Matches conntrack state."]
    #[doc = ""]
    #[doc = " @see struct rte_flow_item_conntrack."]
    RTE_FLOW_ITEM_TYPE_CONNTRACK = 55,
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Matches traffic entering the embedded switch from the given ethdev."]
    #[doc = ""]
    #[doc = " @see struct rte_flow_item_ethdev"]
    RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR = 56,
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Matches traffic entering the embedded switch from"]
    #[doc = " the entity represented by the given ethdev."]
    #[doc = ""]
    #[doc = " @see struct rte_flow_item_ethdev"]
    RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT = 57,
    #[doc = " Matches a configured set of fields at runtime calculated offsets"]
    #[doc = " over the generic network header with variable length and"]
    #[doc = " flexible pattern"]
    #[doc = ""]
    #[doc = " @see struct rte_flow_item_flex."]
    RTE_FLOW_ITEM_TYPE_FLEX = 58,
    #[doc = " Matches L2TPv2 Header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_l2tpv2."]
    RTE_FLOW_ITEM_TYPE_L2TPV2 = 59,
    #[doc = " Matches PPP Header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_ppp."]
    RTE_FLOW_ITEM_TYPE_PPP = 60,
    #[doc = " Matches GRE optional fields."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_gre_opt."]
    RTE_FLOW_ITEM_TYPE_GRE_OPTION = 61,
}
#[doc = " RTE_FLOW_ITEM_TYPE_HIGIG2"]
#[doc = " Matches higig2 header"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_higig2_hdr {
    pub hdr: rte_higig2_hdr,
}
extern "C" {
    pub static rte_flow_item_higig2_hdr_mask: rte_flow_item_higig2_hdr;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ANY"]
#[doc = ""]
#[doc = " Matches any protocol in place of the current layer, a single ANY may also"]
#[doc = " stand for several protocol layers."]
#[doc = ""]
#[doc = " This is usually specified as the first pattern item when looking for a"]
#[doc = " protocol anywhere in a packet."]
#[doc = ""]
#[doc = " A zeroed mask stands for any number of layers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_any {
    #[doc = "< Number of layers covered."]
    pub num: u32,
}
extern "C" {
    pub static rte_flow_item_any_mask: rte_flow_item_any;
}
#[doc = " @deprecated"]
#[doc = " @see RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR"]
#[doc = " @see RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_VF"]
#[doc = ""]
#[doc = " Matches traffic originating from (ingress) or going to (egress) a given"]
#[doc = " virtual function of the current device."]
#[doc = ""]
#[doc = " If supported, should work even if the virtual function is not managed by"]
#[doc = " the application and thus not associated with a DPDK port ID."]
#[doc = ""]
#[doc = " Note this pattern item does not match VF representors traffic which, as"]
#[doc = " separate entities, should be addressed through their own DPDK port IDs."]
#[doc = ""]
#[doc = " - Can be specified multiple times to match traffic addressed to several"]
#[doc = "   VF IDs."]
#[doc = " - Can be combined with a PF item to match both PF and VF traffic."]
#[doc = ""]
#[doc = " A zeroed mask can be used to match any VF ID."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_vf {
    #[doc = "< VF ID."]
    pub id: u32,
}
extern "C" {
    pub static rte_flow_item_vf_mask: rte_flow_item_vf;
}
#[doc = " @deprecated"]
#[doc = " @see RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR"]
#[doc = " @see RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_PHY_PORT"]
#[doc = ""]
#[doc = " Matches traffic originating from (ingress) or going to (egress) a"]
#[doc = " physical port of the underlying device."]
#[doc = ""]
#[doc = " The first PHY_PORT item overrides the physical port normally associated"]
#[doc = " with the specified DPDK input port (port_id). This item can be provided"]
#[doc = " several times to match additional physical ports."]
#[doc = ""]
#[doc = " Note that physical ports are not necessarily tied to DPDK input ports"]
#[doc = " (port_id) when those are not under DPDK control. Possible values are"]
#[doc = " specific to each device, they are not necessarily indexed from zero and"]
#[doc = " may not be contiguous."]
#[doc = ""]
#[doc = " As a device property, the list of allowed values as well as the value"]
#[doc = " associated with a port_id should be retrieved by other means."]
#[doc = ""]
#[doc = " A zeroed mask can be used to match any port index."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_phy_port {
    #[doc = "< Physical port index."]
    pub index: u32,
}
extern "C" {
    pub static rte_flow_item_phy_port_mask: rte_flow_item_phy_port;
}
#[doc = " @deprecated"]
#[doc = " @see RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR"]
#[doc = " @see RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_PORT_ID"]
#[doc = ""]
#[doc = " Matches traffic originating from (ingress) or going to (egress) a given"]
#[doc = " DPDK port ID."]
#[doc = ""]
#[doc = " Normally only supported if the port ID in question is known by the"]
#[doc = " underlying PMD and related to the device the flow rule is created"]
#[doc = " against."]
#[doc = ""]
#[doc = " This must not be confused with @p PHY_PORT which refers to the physical"]
#[doc = " port of a device, whereas @p PORT_ID refers to a struct rte_eth_dev"]
#[doc = " object on the application side (also known as \"port representor\""]
#[doc = " depending on the kind of underlying device)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_port_id {
    #[doc = "< DPDK port ID."]
    pub id: u32,
}
extern "C" {
    pub static rte_flow_item_port_id_mask: rte_flow_item_port_id;
}
#[doc = " RTE_FLOW_ITEM_TYPE_RAW"]
#[doc = ""]
#[doc = " Matches a byte string of a given length at a given offset."]
#[doc = ""]
#[doc = " Offset is either absolute (using the start of the packet) or relative to"]
#[doc = " the end of the previous matched item in the stack, in which case negative"]
#[doc = " values are allowed."]
#[doc = ""]
#[doc = " If search is enabled, offset is used as the starting point. The search"]
#[doc = " area can be delimited by setting limit to a nonzero value, which is the"]
#[doc = " maximum number of bytes after offset where the pattern may start."]
#[doc = ""]
#[doc = " Matching a zero-length pattern is allowed, doing so resets the relative"]
#[doc = " offset for subsequent items."]
#[doc = ""]
#[doc = " This type does not support ranges (struct rte_flow_item.last)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_raw {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Absolute or relative offset for pattern."]
    pub offset: i32,
    #[doc = "< Search area limit for start of pattern."]
    pub limit: u16,
    #[doc = "< Pattern length."]
    pub length: u16,
    #[doc = "< Byte string to look for."]
    pub pattern: *const u8,
}
impl rte_flow_item_raw {
    #[inline]
    pub fn relative(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_relative(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn search(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_search(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        relative: u32,
        search: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let relative: u32 = unsafe { ::std::mem::transmute(relative) };
            relative as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let search: u32 = unsafe { ::std::mem::transmute(search) };
            search as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static rte_flow_item_raw_mask: rte_flow_item_raw;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ETH"]
#[doc = ""]
#[doc = " Matches an Ethernet header."]
#[doc = ""]
#[doc = " Inside @p hdr field, the sub-field @p ether_type stands either for EtherType"]
#[doc = " or TPID, depending on whether the item is followed by a VLAN item or not. If"]
#[doc = " two VLAN items follow, the sub-field refers to the outer one, which, in turn,"]
#[doc = " contains the inner TPID in the similar header field. The innermost VLAN item"]
#[doc = " contains a layer-3 EtherType. All of that follows the order seen on the wire."]
#[doc = ""]
#[doc = " If the field in question contains a TPID value, only tagged packets with the"]
#[doc = " specified TPID will match the pattern. Alternatively, it's possible to match"]
#[doc = " any type of tagged packets by means of the field @p has_vlan rather than use"]
#[doc = " the EtherType/TPID field. Also, it's possible to leave the two fields unused."]
#[doc = " If this is the case, both tagged and untagged packets will match the pattern."]
#[repr(C)]
#[repr(align(4))]
pub struct rte_flow_item_eth {
    pub __bindgen_anon_1: rte_flow_item_eth__bindgen_ty_1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(C)]
pub struct rte_flow_item_eth__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<rte_flow_item_eth__bindgen_ty_1__bindgen_ty_1>,
    pub hdr: __BindgenUnionField<rte_ether_hdr>,
    pub bindgen_union_field: [u16; 7usize],
}
#[repr(C)]
pub struct rte_flow_item_eth__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Destination MAC."]
    pub dst: rte_ether_addr,
    #[doc = "< Source MAC."]
    pub src: rte_ether_addr,
    #[doc = "< EtherType or TPID."]
    pub type_: rte_be16_t,
}
impl rte_flow_item_eth {
    #[inline]
    pub fn has_vlan(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_vlan(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(has_vlan: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_vlan: u32 = unsafe { ::std::mem::transmute(has_vlan) };
            has_vlan as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static rte_flow_item_eth_mask: rte_flow_item_eth;
}
#[doc = " RTE_FLOW_ITEM_TYPE_VLAN"]
#[doc = ""]
#[doc = " Matches an 802.1Q/ad VLAN tag."]
#[doc = ""]
#[doc = " The corresponding standard outer EtherType (TPID) values are"]
#[doc = " RTE_ETHER_TYPE_VLAN or RTE_ETHER_TYPE_QINQ. It can be overridden by"]
#[doc = " the preceding pattern item."]
#[doc = " If a @p VLAN item is present in the pattern, then only tagged packets will"]
#[doc = " match the pattern."]
#[doc = " The field @p has_more_vlan can be used to match any type of tagged packets,"]
#[doc = " instead of using the @p eth_proto field of @p hdr."]
#[doc = " If the @p eth_proto of @p hdr and @p has_more_vlan fields are not specified,"]
#[doc = " then any tagged packets will match the pattern."]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct rte_flow_item_vlan {
    pub __bindgen_anon_1: rte_flow_item_vlan__bindgen_ty_1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_item_vlan__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_flow_item_vlan__bindgen_ty_1__bindgen_ty_1,
    pub hdr: rte_vlan_hdr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_vlan__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Tag control information."]
    pub tci: rte_be16_t,
    #[doc = "< Inner EtherType or TPID."]
    pub inner_type: rte_be16_t,
}
impl rte_flow_item_vlan {
    #[inline]
    pub fn has_more_vlan(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_more_vlan(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        has_more_vlan: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_more_vlan: u32 = unsafe { ::std::mem::transmute(has_more_vlan) };
            has_more_vlan as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static rte_flow_item_vlan_mask: rte_flow_item_vlan;
}
#[doc = " RTE_FLOW_ITEM_TYPE_IPV4"]
#[doc = ""]
#[doc = " Matches an IPv4 header."]
#[doc = ""]
#[doc = " Note: IPv4 options are handled by dedicated pattern items."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_ipv4 {
    #[doc = "< IPv4 header definition."]
    pub hdr: rte_ipv4_hdr,
}
extern "C" {
    pub static rte_flow_item_ipv4_mask: rte_flow_item_ipv4;
}
#[doc = " RTE_FLOW_ITEM_TYPE_IPV6."]
#[doc = ""]
#[doc = " Matches an IPv6 header."]
#[doc = ""]
#[doc = " Dedicated flags indicate if header contains specific extension headers."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_ipv6 {
    #[doc = "< IPv6 header definition."]
    pub hdr: rte_ipv6_hdr,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rte_flow_item_ipv6 {
    #[inline]
    pub fn has_hop_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_hop_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_route_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_route_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_frag_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_frag_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_auth_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_auth_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_esp_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_esp_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_dest_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_dest_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_mobil_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_mobil_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_hip_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_hip_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_shim6_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_shim6_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        has_hop_ext: u32,
        has_route_ext: u32,
        has_frag_ext: u32,
        has_auth_ext: u32,
        has_esp_ext: u32,
        has_dest_ext: u32,
        has_mobil_ext: u32,
        has_hip_ext: u32,
        has_shim6_ext: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_hop_ext: u32 = unsafe { ::std::mem::transmute(has_hop_ext) };
            has_hop_ext as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_route_ext: u32 = unsafe { ::std::mem::transmute(has_route_ext) };
            has_route_ext as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let has_frag_ext: u32 = unsafe { ::std::mem::transmute(has_frag_ext) };
            has_frag_ext as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let has_auth_ext: u32 = unsafe { ::std::mem::transmute(has_auth_ext) };
            has_auth_ext as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let has_esp_ext: u32 = unsafe { ::std::mem::transmute(has_esp_ext) };
            has_esp_ext as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let has_dest_ext: u32 = unsafe { ::std::mem::transmute(has_dest_ext) };
            has_dest_ext as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let has_mobil_ext: u32 = unsafe { ::std::mem::transmute(has_mobil_ext) };
            has_mobil_ext as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let has_hip_ext: u32 = unsafe { ::std::mem::transmute(has_hip_ext) };
            has_hip_ext as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let has_shim6_ext: u32 = unsafe { ::std::mem::transmute(has_shim6_ext) };
            has_shim6_ext as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static rte_flow_item_ipv6_mask: rte_flow_item_ipv6;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP."]
#[doc = ""]
#[doc = " Matches an ICMP header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_icmp {
    #[doc = "< ICMP header definition."]
    pub hdr: rte_icmp_hdr,
}
extern "C" {
    pub static rte_flow_item_icmp_mask: rte_flow_item_icmp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_UDP."]
#[doc = ""]
#[doc = " Matches a UDP header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_udp {
    #[doc = "< UDP header definition."]
    pub hdr: rte_udp_hdr,
}
extern "C" {
    pub static rte_flow_item_udp_mask: rte_flow_item_udp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_TCP."]
#[doc = ""]
#[doc = " Matches a TCP header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_tcp {
    #[doc = "< TCP header definition."]
    pub hdr: rte_tcp_hdr,
}
extern "C" {
    pub static rte_flow_item_tcp_mask: rte_flow_item_tcp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_SCTP."]
#[doc = ""]
#[doc = " Matches a SCTP header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_sctp {
    #[doc = "< SCTP header definition."]
    pub hdr: rte_sctp_hdr,
}
extern "C" {
    pub static rte_flow_item_sctp_mask: rte_flow_item_sctp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_VXLAN."]
#[doc = ""]
#[doc = " Matches a VXLAN header (RFC 7348)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_vxlan {
    pub __bindgen_anon_1: rte_flow_item_vxlan__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_item_vxlan__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_flow_item_vxlan__bindgen_ty_1__bindgen_ty_1,
    pub hdr: rte_vxlan_hdr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_vxlan__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Normally 0x08 (I flag)."]
    pub flags: u8,
    #[doc = "< Reserved, normally 0x000000."]
    pub rsvd0: [u8; 3usize],
    #[doc = "< VXLAN identifier."]
    pub vni: [u8; 3usize],
    #[doc = "< Reserved, normally 0x00."]
    pub rsvd1: u8,
}
extern "C" {
    pub static rte_flow_item_vxlan_mask: rte_flow_item_vxlan;
}
#[doc = " RTE_FLOW_ITEM_TYPE_E_TAG."]
#[doc = ""]
#[doc = " Matches a E-tag header."]
#[doc = ""]
#[doc = " The corresponding standard outer EtherType (TPID) value is"]
#[doc = " RTE_ETHER_TYPE_ETAG. It can be overridden by the preceding pattern item."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_e_tag {
    #[doc = " E-Tag control information (E-TCI)."]
    #[doc = " E-PCP (3b), E-DEI (1b), ingress E-CID base (12b)."]
    pub epcp_edei_in_ecid_b: rte_be16_t,
    #[doc = " Reserved (2b), GRP (2b), E-CID base (12b)."]
    pub rsvd_grp_ecid_b: rte_be16_t,
    #[doc = "< Ingress E-CID ext."]
    pub in_ecid_e: u8,
    #[doc = "< E-CID ext."]
    pub ecid_e: u8,
    #[doc = "< Inner EtherType or TPID."]
    pub inner_type: rte_be16_t,
}
extern "C" {
    pub static rte_flow_item_e_tag_mask: rte_flow_item_e_tag;
}
#[doc = " RTE_FLOW_ITEM_TYPE_NVGRE."]
#[doc = ""]
#[doc = " Matches a NVGRE header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_nvgre {
    #[doc = " Checksum (1b), undefined (1b), key bit (1b), sequence number (1b),"]
    #[doc = " reserved 0 (9b), version (3b)."]
    #[doc = ""]
    #[doc = " c_k_s_rsvd0_ver must have value 0x2000 according to RFC 7637."]
    pub c_k_s_rsvd0_ver: rte_be16_t,
    #[doc = "< Protocol type (0x6558)."]
    pub protocol: rte_be16_t,
    #[doc = "< Virtual subnet ID."]
    pub tni: [u8; 3usize],
    #[doc = "< Flow ID."]
    pub flow_id: u8,
}
extern "C" {
    pub static rte_flow_item_nvgre_mask: rte_flow_item_nvgre;
}
#[doc = " RTE_FLOW_ITEM_TYPE_MPLS."]
#[doc = ""]
#[doc = " Matches a MPLS header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_mpls {
    #[doc = " Label (20b), TC (3b), Bottom of Stack (1b)."]
    pub label_tc_s: [u8; 3usize],
    pub ttl: u8,
}
extern "C" {
    pub static rte_flow_item_mpls_mask: rte_flow_item_mpls;
}
#[doc = " RTE_FLOW_ITEM_TYPE_GRE."]
#[doc = ""]
#[doc = " Matches a GRE header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_gre {
    #[doc = " Checksum (1b), reserved 0 (12b), version (3b)."]
    #[doc = " Refer to RFC 2784."]
    pub c_rsvd0_ver: rte_be16_t,
    #[doc = "< Protocol type."]
    pub protocol: rte_be16_t,
}
extern "C" {
    pub static rte_flow_item_gre_mask: rte_flow_item_gre;
}
#[doc = " RTE_FLOW_ITEM_TYPE_GRE_OPTION."]
#[doc = ""]
#[doc = " Matches GRE optional fields in header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_gre_opt {
    pub checksum_rsvd: rte_gre_hdr_opt_checksum_rsvd,
    pub key: rte_gre_hdr_opt_key,
    pub sequence: rte_gre_hdr_opt_sequence,
}
#[doc = " RTE_FLOW_ITEM_TYPE_FUZZY"]
#[doc = ""]
#[doc = " Fuzzy pattern match, expect faster than default."]
#[doc = ""]
#[doc = " This is for device that support fuzzy match option."]
#[doc = " Usually a fuzzy match is fast but the cost is accuracy."]
#[doc = " i.e. Signature Match only match pattern's hash value, but it is"]
#[doc = " possible two different patterns have the same hash value."]
#[doc = ""]
#[doc = " Matching accuracy level can be configure by threshold."]
#[doc = " Driver can divide the range of threshold and map to different"]
#[doc = " accuracy levels that device support."]
#[doc = ""]
#[doc = " Threshold 0 means perfect match (no fuzziness), while threshold"]
#[doc = " 0xffffffff means fuzziest match."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_fuzzy {
    #[doc = "< Accuracy threshold."]
    pub thresh: u32,
}
extern "C" {
    pub static rte_flow_item_fuzzy_mask: rte_flow_item_fuzzy;
}
#[doc = " RTE_FLOW_ITEM_TYPE_GTP."]
#[doc = ""]
#[doc = " Matches a GTPv1 header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_gtp {
    #[doc = " Version (3b), protocol type (1b), reserved (1b),"]
    #[doc = " Extension header flag (1b),"]
    #[doc = " Sequence number flag (1b),"]
    #[doc = " N-PDU number flag (1b)."]
    pub v_pt_rsv_flags: u8,
    #[doc = "< Message type."]
    pub msg_type: u8,
    #[doc = "< Message length."]
    pub msg_len: rte_be16_t,
    #[doc = "< Tunnel endpoint identifier."]
    pub teid: rte_be32_t,
}
extern "C" {
    pub static rte_flow_item_gtp_mask: rte_flow_item_gtp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ESP"]
#[doc = ""]
#[doc = " Matches an ESP header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_esp {
    #[doc = "< ESP header definition."]
    pub hdr: rte_esp_hdr,
}
extern "C" {
    pub static rte_flow_item_esp_mask: rte_flow_item_esp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_GENEVE."]
#[doc = ""]
#[doc = " Matches a GENEVE header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_geneve {
    #[doc = " Version (2b), length of the options fields (6b), OAM packet (1b),"]
    #[doc = " critical options present (1b), reserved 0 (6b)."]
    pub ver_opt_len_o_c_rsvd0: rte_be16_t,
    #[doc = "< Protocol type."]
    pub protocol: rte_be16_t,
    #[doc = "< Virtual Network Identifier."]
    pub vni: [u8; 3usize],
    #[doc = "< Reserved, normally 0x00."]
    pub rsvd1: u8,
}
extern "C" {
    pub static rte_flow_item_geneve_mask: rte_flow_item_geneve;
}
#[doc = " RTE_FLOW_ITEM_TYPE_VXLAN_GPE (draft-ietf-nvo3-vxlan-gpe-05)."]
#[doc = ""]
#[doc = " Matches a VXLAN-GPE header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_vxlan_gpe {
    #[doc = "< Normally 0x0c (I and P flags)."]
    pub flags: u8,
    #[doc = "< Reserved, normally 0x0000."]
    pub rsvd0: [u8; 2usize],
    #[doc = "< Protocol type."]
    pub protocol: u8,
    #[doc = "< VXLAN identifier."]
    pub vni: [u8; 3usize],
    #[doc = "< Reserved, normally 0x00."]
    pub rsvd1: u8,
}
extern "C" {
    pub static rte_flow_item_vxlan_gpe_mask: rte_flow_item_vxlan_gpe;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ARP_ETH_IPV4"]
#[doc = ""]
#[doc = " Matches an ARP header for Ethernet/IPv4."]
#[repr(C)]
pub struct rte_flow_item_arp_eth_ipv4 {
    #[doc = "< Hardware type, normally 1."]
    pub hrd: rte_be16_t,
    #[doc = "< Protocol type, normally 0x0800."]
    pub pro: rte_be16_t,
    #[doc = "< Hardware address length, normally 6."]
    pub hln: u8,
    #[doc = "< Protocol address length, normally 4."]
    pub pln: u8,
    #[doc = "< Opcode (1 for request, 2 for reply)."]
    pub op: rte_be16_t,
    #[doc = "< Sender hardware address."]
    pub sha: rte_ether_addr,
    #[doc = "< Sender IPv4 address."]
    pub spa: rte_be32_t,
    #[doc = "< Target hardware address."]
    pub tha: rte_ether_addr,
    #[doc = "< Target IPv4 address."]
    pub tpa: rte_be32_t,
}
extern "C" {
    pub static rte_flow_item_arp_eth_ipv4_mask: rte_flow_item_arp_eth_ipv4;
}
#[doc = " RTE_FLOW_ITEM_TYPE_IPV6_EXT"]
#[doc = ""]
#[doc = " Matches the presence of any IPv6 extension header."]
#[doc = ""]
#[doc = " Normally preceded by any of:"]
#[doc = ""]
#[doc = " - RTE_FLOW_ITEM_TYPE_IPV6"]
#[doc = " - RTE_FLOW_ITEM_TYPE_IPV6_EXT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_ipv6_ext {
    #[doc = "< Next header."]
    pub next_hdr: u8,
}
extern "C" {
    pub static rte_flow_item_ipv6_ext_mask: rte_flow_item_ipv6_ext;
}
#[doc = " RTE_FLOW_ITEM_TYPE_IPV6_FRAG_EXT"]
#[doc = ""]
#[doc = " Matches the presence of IPv6 fragment extension header."]
#[doc = ""]
#[doc = " Preceded by any of:"]
#[doc = ""]
#[doc = " - RTE_FLOW_ITEM_TYPE_IPV6"]
#[doc = " - RTE_FLOW_ITEM_TYPE_IPV6_EXT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_ipv6_frag_ext {
    pub hdr: rte_ipv6_fragment_ext,
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6"]
#[doc = ""]
#[doc = " Matches any ICMPv6 header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_icmp6 {
    #[doc = "< ICMPv6 type."]
    pub type_: u8,
    #[doc = "< ICMPv6 code."]
    pub code: u8,
    #[doc = "< ICMPv6 checksum."]
    pub checksum: u16,
}
extern "C" {
    pub static rte_flow_item_icmp6_mask: rte_flow_item_icmp6;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS"]
#[doc = ""]
#[doc = " Matches an ICMPv6 neighbor discovery solicitation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_icmp6_nd_ns {
    #[doc = "< ICMPv6 type, normally 135."]
    pub type_: u8,
    #[doc = "< ICMPv6 code, normally 0."]
    pub code: u8,
    #[doc = "< ICMPv6 checksum."]
    pub checksum: rte_be16_t,
    #[doc = "< Reserved, normally 0."]
    pub reserved: rte_be32_t,
    #[doc = "< Target address."]
    pub target_addr: [u8; 16usize],
}
extern "C" {
    pub static rte_flow_item_icmp6_nd_ns_mask: rte_flow_item_icmp6_nd_ns;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA"]
#[doc = ""]
#[doc = " Matches an ICMPv6 neighbor discovery advertisement."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_icmp6_nd_na {
    #[doc = "< ICMPv6 type, normally 136."]
    pub type_: u8,
    #[doc = "< ICMPv6 code, normally 0."]
    pub code: u8,
    #[doc = "< ICMPv6 checksum."]
    pub checksum: rte_be16_t,
    #[doc = " Route flag (1b), solicited flag (1b), override flag (1b),"]
    #[doc = " reserved (29b)."]
    pub rso_reserved: rte_be32_t,
    #[doc = "< Target address."]
    pub target_addr: [u8; 16usize],
}
extern "C" {
    pub static rte_flow_item_icmp6_nd_na_mask: rte_flow_item_icmp6_nd_na;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT"]
#[doc = ""]
#[doc = " Matches the presence of any ICMPv6 neighbor discovery option."]
#[doc = ""]
#[doc = " Normally preceded by any of:"]
#[doc = ""]
#[doc = " - RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA"]
#[doc = " - RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS"]
#[doc = " - RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_icmp6_nd_opt {
    #[doc = "< ND option type."]
    pub type_: u8,
    #[doc = "< ND option length."]
    pub length: u8,
}
extern "C" {
    pub static rte_flow_item_icmp6_nd_opt_mask: rte_flow_item_icmp6_nd_opt;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_SLA_ETH"]
#[doc = ""]
#[doc = " Matches an ICMPv6 neighbor discovery source Ethernet link-layer address"]
#[doc = " option."]
#[doc = ""]
#[doc = " Normally preceded by any of:"]
#[doc = ""]
#[doc = " - RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA"]
#[doc = " - RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT"]
#[repr(C)]
pub struct rte_flow_item_icmp6_nd_opt_sla_eth {
    #[doc = "< ND option type, normally 1."]
    pub type_: u8,
    #[doc = "< ND option length, normally 1."]
    pub length: u8,
    #[doc = "< Source Ethernet LLA."]
    pub sla: rte_ether_addr,
}
extern "C" {
    pub static rte_flow_item_icmp6_nd_opt_sla_eth_mask: rte_flow_item_icmp6_nd_opt_sla_eth;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_TLA_ETH"]
#[doc = ""]
#[doc = " Matches an ICMPv6 neighbor discovery target Ethernet link-layer address"]
#[doc = " option."]
#[doc = ""]
#[doc = " Normally preceded by any of:"]
#[doc = ""]
#[doc = " - RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS"]
#[doc = " - RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT"]
#[repr(C)]
pub struct rte_flow_item_icmp6_nd_opt_tla_eth {
    #[doc = "< ND option type, normally 2."]
    pub type_: u8,
    #[doc = "< ND option length, normally 1."]
    pub length: u8,
    #[doc = "< Target Ethernet LLA."]
    pub tla: rte_ether_addr,
}
extern "C" {
    pub static rte_flow_item_icmp6_nd_opt_tla_eth_mask: rte_flow_item_icmp6_nd_opt_tla_eth;
}
#[doc = " RTE_FLOW_ITEM_TYPE_META"]
#[doc = ""]
#[doc = " Matches a specified metadata value. On egress, metadata can be set"]
#[doc = " either by mbuf dynamic metadata field with RTE_MBUF_DYNFLAG_TX_METADATA flag"]
#[doc = " or RTE_FLOW_ACTION_TYPE_SET_META. On ingress, RTE_FLOW_ACTION_TYPE_SET_META"]
#[doc = " sets metadata for a packet and the metadata will be reported via mbuf"]
#[doc = " metadata dynamic field with RTE_MBUF_DYNFLAG_RX_METADATA flag. The dynamic"]
#[doc = " mbuf field must be registered in advance by"]
#[doc = " rte_flow_dynf_metadata_register()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_meta {
    pub data: u32,
}
extern "C" {
    pub static rte_flow_item_meta_mask: rte_flow_item_meta;
}
#[doc = " RTE_FLOW_ITEM_TYPE_GTP_PSC."]
#[doc = ""]
#[doc = " Matches a GTP PDU extension header with type 0x85."]
#[repr(C)]
#[derive(Debug)]
pub struct rte_flow_item_gtp_psc {
    #[doc = "< gtp psc generic hdr."]
    pub hdr: rte_gtp_psc_generic_hdr,
}
extern "C" {
    pub static rte_flow_item_gtp_psc_mask: rte_flow_item_gtp_psc;
}
#[doc = " RTE_FLOW_ITEM_TYPE_PPPOE."]
#[doc = ""]
#[doc = " Matches a PPPoE header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_pppoe {
    #[doc = " Version (4b), type (4b)."]
    pub version_type: u8,
    #[doc = "< Message type."]
    pub code: u8,
    #[doc = "< Session identifier."]
    pub session_id: rte_be16_t,
    #[doc = "< Payload length."]
    pub length: rte_be16_t,
}
#[doc = " RTE_FLOW_ITEM_TYPE_PPPOE_PROTO_ID."]
#[doc = ""]
#[doc = " Matches a PPPoE optional proto_id field."]
#[doc = ""]
#[doc = " It only applies to PPPoE session packets."]
#[doc = ""]
#[doc = " Normally preceded by any of:"]
#[doc = ""]
#[doc = " - RTE_FLOW_ITEM_TYPE_PPPOE"]
#[doc = " - RTE_FLOW_ITEM_TYPE_PPPOE_PROTO_ID"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_pppoe_proto_id {
    #[doc = "< PPP protocol identifier."]
    pub proto_id: rte_be16_t,
}
extern "C" {
    pub static rte_flow_item_pppoe_proto_id_mask: rte_flow_item_pppoe_proto_id;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_TAG"]
#[doc = ""]
#[doc = " Matches a specified tag value at the specified index."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_tag {
    pub data: u32,
    pub index: u8,
}
extern "C" {
    pub static rte_flow_item_tag_mask: rte_flow_item_tag;
}
#[doc = " RTE_FLOW_ITEM_TYPE_L2TPV3OIP."]
#[doc = ""]
#[doc = " Matches a L2TPv3 over IP header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_l2tpv3oip {
    #[doc = "< Session ID."]
    pub session_id: rte_be32_t,
}
extern "C" {
    pub static rte_flow_item_l2tpv3oip_mask: rte_flow_item_l2tpv3oip;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_MARK"]
#[doc = ""]
#[doc = " Matches an arbitrary integer value which was set using the ``MARK`` action"]
#[doc = " in a previously matched rule."]
#[doc = ""]
#[doc = " This item can only be specified once as a match criteria as the ``MARK``"]
#[doc = " action can only be specified once in a flow action."]
#[doc = ""]
#[doc = " This value is arbitrary and application-defined. Maximum allowed value"]
#[doc = " depends on the underlying implementation."]
#[doc = ""]
#[doc = " Depending on the underlying implementation the MARK item may be supported on"]
#[doc = " the physical device, with virtual groups in the PMD or not at all."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_mark {
    #[doc = "< Integer value to match against."]
    pub id: u32,
}
extern "C" {
    pub static rte_flow_item_mark_mask: rte_flow_item_mark;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_NSH"]
#[doc = ""]
#[doc = " Match network service header (NSH), RFC 8300"]
#[doc = ""]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_nsh {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl rte_flow_item_nsh {
    #[inline]
    pub fn version(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn oam_pkt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oam_pkt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ttl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_ttl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn length(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mdtype(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mdtype(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn next_proto(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_next_proto(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn spi(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_spi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn sindex(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sindex(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        version: u32,
        oam_pkt: u32,
        reserved: u32,
        ttl: u32,
        length: u32,
        reserved1: u32,
        mdtype: u32,
        next_proto: u32,
        spi: u32,
        sindex: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let oam_pkt: u32 = unsafe { ::std::mem::transmute(oam_pkt) };
            oam_pkt as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(4usize, 6u8, {
            let ttl: u32 = unsafe { ::std::mem::transmute(ttl) };
            ttl as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let length: u32 = unsafe { ::std::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let mdtype: u32 = unsafe { ::std::mem::transmute(mdtype) };
            mdtype as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let next_proto: u32 = unsafe { ::std::mem::transmute(next_proto) };
            next_proto as u64
        });
        __bindgen_bitfield_unit.set(32usize, 24u8, {
            let spi: u32 = unsafe { ::std::mem::transmute(spi) };
            spi as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let sindex: u32 = unsafe { ::std::mem::transmute(sindex) };
            sindex as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static rte_flow_item_nsh_mask: rte_flow_item_nsh;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_IGMP"]
#[doc = ""]
#[doc = " Match Internet Group Management Protocol (IGMP), RFC 2236"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_igmp {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub group_addr: u32,
}
impl rte_flow_item_igmp {
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn max_resp_time(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_max_resp_time(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn checksum(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_checksum(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: u32,
        max_resp_time: u32,
        checksum: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let max_resp_time: u32 = unsafe { ::std::mem::transmute(max_resp_time) };
            max_resp_time as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let checksum: u32 = unsafe { ::std::mem::transmute(checksum) };
            checksum as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static rte_flow_item_igmp_mask: rte_flow_item_igmp;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_AH"]
#[doc = ""]
#[doc = " Match IP Authentication Header (AH), RFC 4302"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_ah {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub spi: u32,
    pub seq_num: u32,
}
impl rte_flow_item_ah {
    #[inline]
    pub fn next_hdr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_next_hdr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn payload_len(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_payload_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        next_hdr: u32,
        payload_len: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let next_hdr: u32 = unsafe { ::std::mem::transmute(next_hdr) };
            next_hdr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let payload_len: u32 = unsafe { ::std::mem::transmute(payload_len) };
            payload_len as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static rte_flow_item_ah_mask: rte_flow_item_ah;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_PFCP"]
#[doc = ""]
#[doc = " Match PFCP Header"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_pfcp {
    pub s_field: u8,
    pub msg_type: u8,
    pub msg_len: rte_be16_t,
    pub seid: rte_be64_t,
}
extern "C" {
    pub static rte_flow_item_pfcp_mask: rte_flow_item_pfcp;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_ECPRI"]
#[doc = ""]
#[doc = " Match eCPRI Header"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_ecpri {
    pub hdr: rte_ecpri_combined_msg_hdr,
}
extern "C" {
    pub static rte_flow_item_ecpri_mask: rte_flow_item_ecpri;
}
#[doc = " RTE_FLOW_ITEM_TYPE_GENEVE_OPT"]
#[doc = ""]
#[doc = " Matches a GENEVE Variable Length Option"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_geneve_opt {
    pub option_class: rte_be16_t,
    pub option_type: u8,
    pub option_len: u8,
    pub data: *mut u32,
}
extern "C" {
    pub static rte_flow_item_geneve_opt_mask: rte_flow_item_geneve_opt;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_INTEGRITY"]
#[doc = ""]
#[doc = " Match on packet integrity check result."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_integrity {
    #[doc = " Tunnel encapsulation level the item should apply to."]
    #[doc = " @see rte_flow_action_rss"]
    pub level: u32,
    pub __bindgen_anon_1: rte_flow_item_integrity__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_item_integrity__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_flow_item_integrity__bindgen_ty_1__bindgen_ty_1,
    pub value: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_integrity__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl rte_flow_item_integrity__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn packet_ok(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_packet_ok(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l2_ok(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_l2_ok(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l3_ok(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_l3_ok(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_ok(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_l4_ok(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l2_crc_ok(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_l2_crc_ok(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ipv4_csum_ok(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ipv4_csum_ok(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_csum_ok(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_l4_csum_ok(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l3_len_ok(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_l3_len_ok(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        packet_ok: u64,
        l2_ok: u64,
        l3_ok: u64,
        l4_ok: u64,
        l2_crc_ok: u64,
        ipv4_csum_ok: u64,
        l4_csum_ok: u64,
        l3_len_ok: u64,
        reserved: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let packet_ok: u64 = unsafe { ::std::mem::transmute(packet_ok) };
            packet_ok as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let l2_ok: u64 = unsafe { ::std::mem::transmute(l2_ok) };
            l2_ok as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let l3_ok: u64 = unsafe { ::std::mem::transmute(l3_ok) };
            l3_ok as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let l4_ok: u64 = unsafe { ::std::mem::transmute(l4_ok) };
            l4_ok as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let l2_crc_ok: u64 = unsafe { ::std::mem::transmute(l2_crc_ok) };
            l2_crc_ok as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ipv4_csum_ok: u64 = unsafe { ::std::mem::transmute(ipv4_csum_ok) };
            ipv4_csum_ok as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let l4_csum_ok: u64 = unsafe { ::std::mem::transmute(l4_csum_ok) };
            l4_csum_ok as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let l3_len_ok: u64 = unsafe { ::std::mem::transmute(l3_len_ok) };
            l3_len_ok as u64
        });
        __bindgen_bitfield_unit.set(8usize, 56u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static rte_flow_item_integrity_mask: rte_flow_item_integrity;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_CONNTRACK"]
#[doc = ""]
#[doc = " Matches the state of a packet after it passed the connection tracking"]
#[doc = " examination. The state is a bitmap of one RTE_FLOW_CONNTRACK_PKT_STATE*"]
#[doc = " or a reasonable combination of these bits."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_conntrack {
    pub flags: u32,
}
extern "C" {
    pub static rte_flow_item_conntrack_mask: rte_flow_item_conntrack;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " Provides an ethdev port ID for use with the following items:"]
#[doc = " RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR,"]
#[doc = " RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_ethdev {
    #[doc = "< ethdev port ID"]
    pub port_id: u16,
}
extern "C" {
    pub static rte_flow_item_ethdev_mask: rte_flow_item_ethdev;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_L2TPV2"]
#[doc = ""]
#[doc = " Matches L2TPv2 Header"]
#[repr(C)]
pub struct rte_flow_item_l2tpv2 {
    pub hdr: rte_l2tpv2_combined_msg_hdr,
}
extern "C" {
    pub static rte_flow_item_l2tpv2_mask: rte_flow_item_l2tpv2;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_PPP"]
#[doc = ""]
#[doc = " Matches PPP Header"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_ppp {
    pub hdr: rte_ppp_hdr,
}
extern "C" {
    pub static rte_flow_item_ppp_mask: rte_flow_item_ppp;
}
#[doc = " Matching pattern item definition."]
#[doc = ""]
#[doc = " A pattern is formed by stacking items starting from the lowest protocol"]
#[doc = " layer to match. This stacking restriction does not apply to meta items"]
#[doc = " which can be placed anywhere in the stack without affecting the meaning"]
#[doc = " of the resulting pattern."]
#[doc = ""]
#[doc = " Patterns are terminated by END items."]
#[doc = ""]
#[doc = " The spec field should be a valid pointer to a structure of the related"]
#[doc = " item type. It may remain unspecified (NULL) in many cases to request"]
#[doc = " broad (nonspecific) matching. In such cases, last and mask must also be"]
#[doc = " set to NULL."]
#[doc = ""]
#[doc = " Optionally, last can point to a structure of the same type to define an"]
#[doc = " inclusive range. This is mostly supported by integer and address fields,"]
#[doc = " may cause errors otherwise. Fields that do not support ranges must be set"]
#[doc = " to 0 or to the same value as the corresponding fields in spec."]
#[doc = ""]
#[doc = " Only the fields defined to nonzero values in the default masks (see"]
#[doc = " rte_flow_item_{name}_mask constants) are considered relevant by"]
#[doc = " default. This can be overridden by providing a mask structure of the"]
#[doc = " same type with applicable bits set to one. It can also be used to"]
#[doc = " partially filter out specific fields (e.g. as an alternate mean to match"]
#[doc = " ranges of IP addresses)."]
#[doc = ""]
#[doc = " Mask is a simple bit-mask applied before interpreting the contents of"]
#[doc = " spec and last, which may yield unexpected results if not used"]
#[doc = " carefully. For example, if for an IPv4 address field, spec provides"]
#[doc = " 10.1.2.3, last provides 10.3.4.5 and mask provides 255.255.0.0, the"]
#[doc = " effective range becomes 10.1.0.0 to 10.3.255.255."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item {
    #[doc = "< Item type."]
    pub type_: rte_flow_item_type,
    #[doc = "< Pointer to item specification structure."]
    pub spec: *const ::std::os::raw::c_void,
    #[doc = "< Defines an inclusive range (spec to last)."]
    pub last: *const ::std::os::raw::c_void,
    #[doc = "< Bit-mask applied to spec and last."]
    pub mask: *const ::std::os::raw::c_void,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_FLEX"]
#[doc = ""]
#[doc = " Matches a specified set of fields within the network protocol"]
#[doc = " header. Each field is presented as set of bits with specified width, and"]
#[doc = " bit offset from the header beginning."]
#[doc = ""]
#[doc = " The pattern is concatenation of bit fields configured at item creation"]
#[doc = " by rte_flow_flex_item_create(). At configuration the fields are presented"]
#[doc = " by sample_data array."]
#[doc = ""]
#[doc = " This type does not support ranges (struct rte_flow_item.last)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_flex {
    #[doc = "< Opaque item handle."]
    pub handle: *mut rte_flow_item_flex_handle,
    #[doc = "< Pattern length in bytes."]
    pub length: u32,
    #[doc = "< Combined bitfields pattern to match."]
    pub pattern: *const u8,
}
#[repr(u32)]
#[doc = " Field bit offset calculation mode."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_flow_item_flex_field_mode {
    #[doc = " Dummy field, used for byte boundary alignment in pattern."]
    #[doc = " Pattern mask and data are ignored in the match. All configuration"]
    #[doc = " parameters besides field size are ignored."]
    FIELD_MODE_DUMMY = 0,
    #[doc = " Fixed offset field. The bit offset from header beginning"]
    #[doc = " is permanent and defined by field_base parameter."]
    FIELD_MODE_FIXED = 1,
    #[doc = " The field bit offset is extracted from other header field (indirect"]
    #[doc = " offset field). The resulting field offset to match is calculated as:"]
    #[doc = ""]
    #[doc = "    field_base + (*offset_base & offset_mask) << offset_shift"]
    FIELD_MODE_OFFSET = 2,
    #[doc = " The field bit offset is extracted from other header field (indirect"]
    #[doc = " offset field), the latter is considered as bitmask containing some"]
    #[doc = " number of one bits, the resulting field offset to match is"]
    #[doc = " calculated as:"]
    #[doc = ""]
    #[doc = "    field_base + bitcount(*offset_base & offset_mask) << offset_shift"]
    FIELD_MODE_BITMASK = 3,
}
#[repr(u32)]
#[doc = " Flex item field tunnel mode"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_flow_item_flex_tunnel_mode {
    #[doc = " The protocol header can be present in the packet only once."]
    #[doc = " No multiple flex item flow inclusions (for inner/outer) are allowed."]
    #[doc = " No any relations with tunnel protocols are imposed. The drivers"]
    #[doc = " can optimize hardware resource usage to handle match on single flex"]
    #[doc = " item of specific type."]
    FLEX_TUNNEL_MODE_SINGLE = 0,
    #[doc = " Flex item presents outer header only."]
    FLEX_TUNNEL_MODE_OUTER = 1,
    #[doc = " Flex item presents inner header only."]
    FLEX_TUNNEL_MODE_INNER = 2,
    #[doc = " Flex item presents either inner or outer header. The driver"]
    #[doc = " handles as many multiple inners as hardware supports."]
    FLEX_TUNNEL_MODE_MULTI = 3,
    #[doc = " Flex item presents tunnel protocol header."]
    FLEX_TUNNEL_MODE_TUNNEL = 4,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_flex_field {
    #[doc = " Defines how match field offset is calculated over the packet."]
    pub field_mode: rte_flow_item_flex_field_mode,
    #[doc = "< Field size in bits."]
    pub field_size: u32,
    #[doc = "< Field offset in bits."]
    pub field_base: i32,
    #[doc = "< Indirect offset field offset in bits."]
    pub offset_base: u32,
    #[doc = "< Indirect offset field bit mask."]
    pub offset_mask: u32,
    #[doc = "< Indirect offset multiply factor."]
    pub offset_shift: i32,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rte_flow_item_flex_field {
    #[inline]
    pub fn field_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_field_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(field_id: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let field_id: u32 = unsafe { ::std::mem::transmute(field_id) };
            field_id as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_flex_link {
    #[doc = " Preceding/following header. The item type must be always provided."]
    #[doc = " For preceding one item must specify the header value/mask to match"]
    #[doc = " for the link be taken and start the flex item header parsing."]
    pub item: rte_flow_item,
    #[doc = " Next field value to match to continue with one of the configured"]
    #[doc = " next protocols."]
    pub next: u32,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_flex_conf {
    #[doc = " Specifies the flex item and tunnel relations and tells the PMD"]
    #[doc = " whether flex item can be used for inner, outer or both headers,"]
    #[doc = " or whether flex item presents the tunnel protocol itself."]
    pub tunnel: rte_flow_item_flex_tunnel_mode,
    #[doc = " The next header offset, it presents the network header size covered"]
    #[doc = " by the flex item and can be obtained with all supported offset"]
    #[doc = " calculating methods (fixed, dedicated field, bitmask, etc)."]
    pub next_header: rte_flow_item_flex_field,
    #[doc = " Specifies the next protocol field to match with link next protocol"]
    #[doc = " values and continue packet parsing with matching link."]
    pub next_protocol: rte_flow_item_flex_field,
    #[doc = " The fields will be sampled and presented for explicit match"]
    #[doc = " with pattern in the rte_flow_flex_item. There can be multiple"]
    #[doc = " fields descriptors, the number should be specified by nb_samples."]
    pub sample_data: *mut rte_flow_item_flex_field,
    #[doc = " Number of field descriptors in the sample_data array."]
    pub nb_samples: u32,
    #[doc = " Input link defines the flex item relation with preceding"]
    #[doc = " header. It specified the preceding item type and provides pattern"]
    #[doc = " to match. The flex item will continue parsing and will provide the"]
    #[doc = " data to flow match in case if there is the match with one of input"]
    #[doc = " links."]
    pub input_link: *mut rte_flow_item_flex_link,
    #[doc = " Number of link descriptors in the input link array."]
    pub nb_inputs: u32,
    #[doc = " Output link defines the next protocol field value to match and"]
    #[doc = " the following protocol header to continue packet parsing. Also"]
    #[doc = " defines the tunnel-related behaviour."]
    pub output_link: *mut rte_flow_item_flex_link,
    #[doc = " Number of link descriptors in the output link array."]
    pub nb_outputs: u32,
}
#[repr(u32)]
#[doc = " Action types."]
#[doc = ""]
#[doc = " Each possible action is represented by a type."]
#[doc = " An action can have an associated configuration object."]
#[doc = " Several actions combined in a list can be assigned"]
#[doc = " to a flow rule and are performed in order."]
#[doc = ""]
#[doc = " They fall in three categories:"]
#[doc = ""]
#[doc = " - Actions that modify the fate of matching traffic, for instance by"]
#[doc = "   dropping or assigning it a specific destination."]
#[doc = ""]
#[doc = " - Actions that modify matching traffic contents or its properties. This"]
#[doc = "   includes adding/removing encapsulation, encryption, compression and"]
#[doc = "   marks."]
#[doc = ""]
#[doc = " - Actions related to the flow rule itself, such as updating counters or"]
#[doc = "   making it non-terminating."]
#[doc = ""]
#[doc = " Flow rules being terminating by default, not specifying any action of the"]
#[doc = " fate kind results in undefined behavior. This applies to both ingress and"]
#[doc = " egress."]
#[doc = ""]
#[doc = " PASSTHRU, when supported, makes a flow rule non-terminating."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_flow_action_type {
    #[doc = " End marker for action lists. Prevents further processing of"]
    #[doc = " actions, thereby ending the list."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    RTE_FLOW_ACTION_TYPE_END = 0,
    #[doc = " Used as a placeholder for convenience. It is ignored and simply"]
    #[doc = " discarded by PMDs."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    RTE_FLOW_ACTION_TYPE_VOID = 1,
    #[doc = " Leaves traffic up for additional processing by subsequent flow"]
    #[doc = " rules; makes a flow rule non-terminating."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    RTE_FLOW_ACTION_TYPE_PASSTHRU = 2,
    #[doc = " RTE_FLOW_ACTION_TYPE_JUMP"]
    #[doc = ""]
    #[doc = " Redirects packets to a group on the current device."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_jump."]
    RTE_FLOW_ACTION_TYPE_JUMP = 3,
    #[doc = " Attaches an integer value to packets and sets RTE_MBUF_F_RX_FDIR and"]
    #[doc = " RTE_MBUF_F_RX_FDIR_ID mbuf flags."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_mark."]
    #[doc = ""]
    #[doc = " One should negotiate mark delivery from the NIC to the PMD."]
    #[doc = " @see rte_eth_rx_metadata_negotiate()"]
    #[doc = " @see RTE_ETH_RX_METADATA_USER_MARK"]
    RTE_FLOW_ACTION_TYPE_MARK = 4,
    #[doc = " Flags packets. Similar to MARK without a specific value; only"]
    #[doc = " sets the RTE_MBUF_F_RX_FDIR mbuf flag."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    #[doc = ""]
    #[doc = " One should negotiate flag delivery from the NIC to the PMD."]
    #[doc = " @see rte_eth_rx_metadata_negotiate()"]
    #[doc = " @see RTE_ETH_RX_METADATA_USER_FLAG"]
    RTE_FLOW_ACTION_TYPE_FLAG = 5,
    #[doc = " Assigns packets to a given queue index."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_queue."]
    RTE_FLOW_ACTION_TYPE_QUEUE = 6,
    #[doc = " Drops packets."]
    #[doc = ""]
    #[doc = " PASSTHRU overrides this action if both are specified."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    RTE_FLOW_ACTION_TYPE_DROP = 7,
    #[doc = " Enables counters for this flow rule."]
    #[doc = ""]
    #[doc = " These counters can be retrieved and reset through rte_flow_query() or"]
    #[doc = " rte_flow_action_handle_query() if the action provided via handle,"]
    #[doc = " see struct rte_flow_query_count."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_count."]
    RTE_FLOW_ACTION_TYPE_COUNT = 8,
    #[doc = " Similar to QUEUE, except RSS is additionally performed on packets"]
    #[doc = " to spread them among several queues according to the provided"]
    #[doc = " parameters."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_rss."]
    RTE_FLOW_ACTION_TYPE_RSS = 9,
    #[doc = " @deprecated"]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR"]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT"]
    #[doc = ""]
    #[doc = " Directs matching traffic to the physical function (PF) of the"]
    #[doc = " current device."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    RTE_FLOW_ACTION_TYPE_PF = 10,
    #[doc = " @deprecated"]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR"]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT"]
    #[doc = ""]
    #[doc = " Directs matching traffic to a given virtual function of the"]
    #[doc = " current device."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_vf."]
    RTE_FLOW_ACTION_TYPE_VF = 11,
    #[doc = " @deprecated"]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR"]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT"]
    #[doc = ""]
    #[doc = " Directs packets to a given physical port index of the underlying"]
    #[doc = " device."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_phy_port."]
    RTE_FLOW_ACTION_TYPE_PHY_PORT = 12,
    #[doc = " @deprecated"]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR"]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT"]
    #[doc = ""]
    #[doc = " Directs matching traffic to a given DPDK port ID."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_port_id."]
    RTE_FLOW_ACTION_TYPE_PORT_ID = 13,
    #[doc = " Traffic metering and policing (MTR)."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_meter."]
    #[doc = " See file rte_mtr.h for MTR object configuration."]
    RTE_FLOW_ACTION_TYPE_METER = 14,
    #[doc = " Redirects packets to security engine of current device for security"]
    #[doc = " processing as specified by security session."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_security."]
    RTE_FLOW_ACTION_TYPE_SECURITY = 15,
    #[doc = " @deprecated"]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Implements OFPAT_SET_MPLS_TTL (\"MPLS TTL\") as defined by the"]
    #[doc = " OpenFlow Switch Specification."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_of_set_mpls_ttl."]
    RTE_FLOW_ACTION_TYPE_OF_SET_MPLS_TTL = 16,
    #[doc = " @deprecated"]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Implements OFPAT_DEC_MPLS_TTL (\"decrement MPLS TTL\") as defined"]
    #[doc = " by the OpenFlow Switch Specification."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    RTE_FLOW_ACTION_TYPE_OF_DEC_MPLS_TTL = 17,
    #[doc = " @deprecated"]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Implements OFPAT_SET_NW_TTL (\"IP TTL\") as defined by the OpenFlow"]
    #[doc = " Switch Specification."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_of_set_nw_ttl."]
    RTE_FLOW_ACTION_TYPE_OF_SET_NW_TTL = 18,
    #[doc = " @warning This is a legacy action."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Implements OFPAT_DEC_NW_TTL (\"decrement IP TTL\") as defined by"]
    #[doc = " the OpenFlow Switch Specification."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    RTE_FLOW_ACTION_TYPE_OF_DEC_NW_TTL = 19,
    #[doc = " @deprecated"]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Implements OFPAT_COPY_TTL_OUT (\"copy TTL \"outwards\" -- from"]
    #[doc = " next-to-outermost to outermost\") as defined by the OpenFlow"]
    #[doc = " Switch Specification."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    RTE_FLOW_ACTION_TYPE_OF_COPY_TTL_OUT = 20,
    #[doc = " @deprecated"]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Implements OFPAT_COPY_TTL_IN (\"copy TTL \"inwards\" -- from"]
    #[doc = " outermost to next-to-outermost\") as defined by the OpenFlow"]
    #[doc = " Switch Specification."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    RTE_FLOW_ACTION_TYPE_OF_COPY_TTL_IN = 21,
    #[doc = " Implements OFPAT_POP_VLAN (\"pop the outer VLAN tag\") as defined"]
    #[doc = " by the OpenFlow Switch Specification."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    RTE_FLOW_ACTION_TYPE_OF_POP_VLAN = 22,
    #[doc = " Implements OFPAT_PUSH_VLAN (\"push a new VLAN tag\") as defined by"]
    #[doc = " the OpenFlow Switch Specification."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_of_push_vlan."]
    RTE_FLOW_ACTION_TYPE_OF_PUSH_VLAN = 23,
    #[doc = " Implements OFPAT_SET_VLAN_VID (\"set the 802.1q VLAN ID\") as"]
    #[doc = " defined by the OpenFlow Switch Specification."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_of_set_vlan_vid."]
    RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_VID = 24,
    #[doc = " Implements OFPAT_SET_LAN_PCP (\"set the 802.1q priority\") as"]
    #[doc = " defined by the OpenFlow Switch Specification."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_of_set_vlan_pcp."]
    RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_PCP = 25,
    #[doc = " Implements OFPAT_POP_MPLS (\"pop the outer MPLS tag\") as defined"]
    #[doc = " by the OpenFlow Switch Specification."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_of_pop_mpls."]
    RTE_FLOW_ACTION_TYPE_OF_POP_MPLS = 26,
    #[doc = " Implements OFPAT_PUSH_MPLS (\"push a new MPLS tag\") as defined by"]
    #[doc = " the OpenFlow Switch Specification."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_of_push_mpls."]
    RTE_FLOW_ACTION_TYPE_OF_PUSH_MPLS = 27,
    #[doc = " Encapsulate flow in VXLAN tunnel as defined in"]
    #[doc = " rte_flow_action_vxlan_encap action structure."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_vxlan_encap."]
    RTE_FLOW_ACTION_TYPE_VXLAN_ENCAP = 28,
    #[doc = " Decapsulate outer most VXLAN tunnel from matched flow."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid VXLAN tunnel (as specified by"]
    #[doc = " RFC7348) then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION"]
    #[doc = " error."]
    RTE_FLOW_ACTION_TYPE_VXLAN_DECAP = 29,
    #[doc = " Encapsulate flow in NVGRE tunnel defined in the"]
    #[doc = " rte_flow_action_nvgre_encap action structure."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_nvgre_encap."]
    RTE_FLOW_ACTION_TYPE_NVGRE_ENCAP = 30,
    #[doc = " Decapsulate outer most NVGRE tunnel from matched flow."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid NVGRE tunnel (as specified by"]
    #[doc = " RFC7637) then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION"]
    #[doc = " error."]
    RTE_FLOW_ACTION_TYPE_NVGRE_DECAP = 31,
    #[doc = " Add outer header whose template is provided in its data buffer"]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_raw_encap."]
    RTE_FLOW_ACTION_TYPE_RAW_ENCAP = 32,
    #[doc = " Remove outer header whose template is provided in its data buffer."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_raw_decap"]
    RTE_FLOW_ACTION_TYPE_RAW_DECAP = 33,
    #[doc = " @warning This is a legacy action."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Modify IPv4 source address in the outermost IPv4 header."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV4,"]
    #[doc = " then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_ipv4."]
    RTE_FLOW_ACTION_TYPE_SET_IPV4_SRC = 34,
    #[doc = " @warning This is a legacy action."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Modify IPv4 destination address in the outermost IPv4 header."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV4,"]
    #[doc = " then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_ipv4."]
    RTE_FLOW_ACTION_TYPE_SET_IPV4_DST = 35,
    #[doc = " @warning This is a legacy action."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Modify IPv6 source address in the outermost IPv6 header."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV6,"]
    #[doc = " then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_ipv6."]
    RTE_FLOW_ACTION_TYPE_SET_IPV6_SRC = 36,
    #[doc = " @warning This is a legacy action."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Modify IPv6 destination address in the outermost IPv6 header."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV6,"]
    #[doc = " then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_ipv6."]
    RTE_FLOW_ACTION_TYPE_SET_IPV6_DST = 37,
    #[doc = " @warning This is a legacy action."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Modify source port number in the outermost TCP/UDP header."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_TCP"]
    #[doc = " or RTE_FLOW_ITEM_TYPE_UDP, then the PMD should return a"]
    #[doc = " RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_tp."]
    RTE_FLOW_ACTION_TYPE_SET_TP_SRC = 38,
    #[doc = " @warning This is a legacy action."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Modify destination port number in the outermost TCP/UDP header."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_TCP"]
    #[doc = " or RTE_FLOW_ITEM_TYPE_UDP, then the PMD should return a"]
    #[doc = " RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_tp."]
    RTE_FLOW_ACTION_TYPE_SET_TP_DST = 39,
    #[doc = " Swap the source and destination MAC addresses in the outermost"]
    #[doc = " Ethernet header."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_ETH,"]
    #[doc = " then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    RTE_FLOW_ACTION_TYPE_MAC_SWAP = 40,
    #[doc = " @warning This is a legacy action."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Decrease TTL value directly"]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    RTE_FLOW_ACTION_TYPE_DEC_TTL = 41,
    #[doc = " @warning This is a legacy action."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Set TTL value"]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_ttl"]
    RTE_FLOW_ACTION_TYPE_SET_TTL = 42,
    #[doc = " @warning This is a legacy action."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Set source MAC address from matched flow."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_ETH,"]
    #[doc = " the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_mac."]
    RTE_FLOW_ACTION_TYPE_SET_MAC_SRC = 43,
    #[doc = " @warning This is a legacy action."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Set destination MAC address from matched flow."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_ETH,"]
    #[doc = " the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_mac."]
    RTE_FLOW_ACTION_TYPE_SET_MAC_DST = 44,
    #[doc = " @warning This is a legacy action."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Increase sequence number in the outermost TCP header."]
    #[doc = ""]
    #[doc = " Action configuration specifies the value to increase"]
    #[doc = " TCP sequence number as a big-endian 32 bit integer."]
    #[doc = ""]
    #[doc = " @p conf type:"]
    #[doc = " @code rte_be32_t * @endcode"]
    #[doc = ""]
    #[doc = " Using this action on non-matching traffic will result in"]
    #[doc = " undefined behavior."]
    RTE_FLOW_ACTION_TYPE_INC_TCP_SEQ = 45,
    #[doc = " @warning This is a legacy action."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Decrease sequence number in the outermost TCP header."]
    #[doc = ""]
    #[doc = " Action configuration specifies the value to decrease"]
    #[doc = " TCP sequence number as a big-endian 32 bit integer."]
    #[doc = ""]
    #[doc = " @p conf type:"]
    #[doc = " @code rte_be32_t * @endcode"]
    #[doc = ""]
    #[doc = " Using this action on non-matching traffic will result in"]
    #[doc = " undefined behavior."]
    RTE_FLOW_ACTION_TYPE_DEC_TCP_SEQ = 46,
    #[doc = " @warning This is a legacy action."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Increase acknowledgment number in the outermost TCP header."]
    #[doc = ""]
    #[doc = " Action configuration specifies the value to increase"]
    #[doc = " TCP acknowledgment number as a big-endian 32 bit integer."]
    #[doc = ""]
    #[doc = " @p conf type:"]
    #[doc = " @code rte_be32_t * @endcode"]
    #[doc = ""]
    #[doc = " Using this action on non-matching traffic will result in"]
    #[doc = " undefined behavior."]
    RTE_FLOW_ACTION_TYPE_INC_TCP_ACK = 47,
    #[doc = " @warning This is a legacy action."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Decrease acknowledgment number in the outermost TCP header."]
    #[doc = ""]
    #[doc = " Action configuration specifies the value to decrease"]
    #[doc = " TCP acknowledgment number as a big-endian 32 bit integer."]
    #[doc = ""]
    #[doc = " @p conf type:"]
    #[doc = " @code rte_be32_t * @endcode"]
    #[doc = ""]
    #[doc = " Using this action on non-matching traffic will result in"]
    #[doc = " undefined behavior."]
    RTE_FLOW_ACTION_TYPE_DEC_TCP_ACK = 48,
    #[doc = " @warning This is a legacy action."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Set Tag."]
    #[doc = ""]
    #[doc = " Tag is for internal flow usage only and"]
    #[doc = " is not delivered to the application."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_tag."]
    RTE_FLOW_ACTION_TYPE_SET_TAG = 49,
    #[doc = " @warning This is a legacy action."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Set metadata on ingress or egress path."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_meta."]
    RTE_FLOW_ACTION_TYPE_SET_META = 50,
    #[doc = " @warning This is a legacy action."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Modify IPv4 DSCP in the outermost IP header."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV4,"]
    #[doc = " then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_dscp."]
    RTE_FLOW_ACTION_TYPE_SET_IPV4_DSCP = 51,
    #[doc = " @warning This is a legacy action."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
    #[doc = ""]
    #[doc = " Modify IPv6 DSCP in the outermost IP header."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV6,"]
    #[doc = " then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_dscp."]
    RTE_FLOW_ACTION_TYPE_SET_IPV6_DSCP = 52,
    #[doc = " Report as aged flow if timeout passed without any matching on the"]
    #[doc = " flow."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_age."]
    #[doc = " See function rte_flow_get_aged_flows"]
    #[doc = " see enum RTE_ETH_EVENT_FLOW_AGED"]
    #[doc = " See struct rte_flow_query_age"]
    RTE_FLOW_ACTION_TYPE_AGE = 53,
    #[doc = " The matching packets will be duplicated with specified ratio and"]
    #[doc = " applied with own set of actions with a fate action."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_sample."]
    RTE_FLOW_ACTION_TYPE_SAMPLE = 54,
    #[doc = " @deprecated"]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_INDIRECT"]
    #[doc = ""]
    #[doc = " Describe action shared across multiple flow rules."]
    #[doc = ""]
    #[doc = " Allow multiple rules reference the same action by handle (see"]
    #[doc = " struct rte_flow_shared_action)."]
    RTE_FLOW_ACTION_TYPE_SHARED = 55,
    #[doc = " Modify a packet header field, tag, mark or metadata."]
    #[doc = ""]
    #[doc = " Allow the modification of an arbitrary header field via"]
    #[doc = " set, add and sub operations or copying its content into"]
    #[doc = " tag, meta or mark for future processing."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_modify_field."]
    RTE_FLOW_ACTION_TYPE_MODIFY_FIELD = 56,
    #[doc = " An action handle is referenced in a rule through an indirect action."]
    #[doc = ""]
    #[doc = " The same action handle may be used in multiple rules for the same"]
    #[doc = " or different ethdev ports."]
    RTE_FLOW_ACTION_TYPE_INDIRECT = 57,
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Enable tracking a TCP connection state."]
    #[doc = ""]
    #[doc = " @see struct rte_flow_action_conntrack."]
    RTE_FLOW_ACTION_TYPE_CONNTRACK = 58,
    #[doc = " Color the packet to reflect the meter color result."]
    #[doc = " Set the meter color in the mbuf to the selected color."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_meter_color."]
    RTE_FLOW_ACTION_TYPE_METER_COLOR = 59,
    #[doc = " At embedded switch level, sends matching traffic to the given ethdev."]
    #[doc = ""]
    #[doc = " @see struct rte_flow_action_ethdev"]
    RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR = 60,
    #[doc = " At embedded switch level, send matching traffic to"]
    #[doc = " the entity represented by the given ethdev."]
    #[doc = ""]
    #[doc = " @see struct rte_flow_action_ethdev"]
    RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT = 61,
}
#[doc = " RTE_FLOW_ACTION_TYPE_MARK"]
#[doc = ""]
#[doc = " Attaches an integer value to packets and sets RTE_MBUF_F_RX_FDIR and"]
#[doc = " RTE_MBUF_F_RX_FDIR_ID mbuf flags."]
#[doc = ""]
#[doc = " This value is arbitrary and application-defined. Maximum allowed value"]
#[doc = " depends on the underlying implementation. It is returned in the"]
#[doc = " hash.fdir.hi mbuf field."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_mark {
    #[doc = "< Integer value to return with packets."]
    pub id: u32,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_JUMP"]
#[doc = ""]
#[doc = " Redirects packets to a group on the current device."]
#[doc = ""]
#[doc = " In a hierarchy of groups, which can be used to represent physical or logical"]
#[doc = " flow tables on the device, this action allows the action to be a redirect to"]
#[doc = " a group on that device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_jump {
    pub group: u32,
}
#[doc = " RTE_FLOW_ACTION_TYPE_QUEUE"]
#[doc = ""]
#[doc = " Assign packets to a given queue index."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_queue {
    #[doc = "< Queue index to use."]
    pub index: u16,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_AGE"]
#[doc = ""]
#[doc = " Report flow as aged-out if timeout passed without any matching"]
#[doc = " on the flow. RTE_ETH_EVENT_FLOW_AGED event is triggered when a"]
#[doc = " port detects new aged-out flows."]
#[doc = ""]
#[doc = " The flow context and the flow handle will be reported by the"]
#[doc = " rte_flow_get_aged_flows API."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_age {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " The user flow context, NULL means the rte_flow pointer."]
    pub context: *mut ::std::os::raw::c_void,
}
impl rte_flow_action_age {
    #[inline]
    pub fn timeout(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_timeout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(timeout: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let timeout: u32 = unsafe { ::std::mem::transmute(timeout) };
            timeout as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " RTE_FLOW_ACTION_TYPE_AGE (query)"]
#[doc = ""]
#[doc = " Query structure to retrieve the aging status information of a"]
#[doc = " shared AGE action, or a flow rule using the AGE action."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_query_age {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rte_flow_query_age {
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn aged(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aged(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sec_since_last_hit_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sec_since_last_hit_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sec_since_last_hit(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_sec_since_last_hit(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: u32,
        aged: u32,
        sec_since_last_hit_valid: u32,
        sec_since_last_hit: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let aged: u32 = unsafe { ::std::mem::transmute(aged) };
            aged as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sec_since_last_hit_valid: u32 =
                unsafe { ::std::mem::transmute(sec_since_last_hit_valid) };
            sec_since_last_hit_valid as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let sec_since_last_hit: u32 = unsafe { ::std::mem::transmute(sec_since_last_hit) };
            sec_since_last_hit as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_COUNT"]
#[doc = ""]
#[doc = " Adds a counter action to a matched flow."]
#[doc = ""]
#[doc = " If more than one count action is specified in a single flow rule, then each"]
#[doc = " action must specify a unique ID."]
#[doc = ""]
#[doc = " Counters can be retrieved and reset through ``rte_flow_query()``, see"]
#[doc = " ``struct rte_flow_query_count``."]
#[doc = ""]
#[doc = " For ports within the same switch domain then the counter ID namespace extends"]
#[doc = " to all ports within that switch domain."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_count {
    #[doc = "< Counter ID."]
    pub id: u32,
}
#[doc = " RTE_FLOW_ACTION_TYPE_COUNT (query)"]
#[doc = ""]
#[doc = " Query structure to retrieve and reset flow rule counters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_query_count {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Number of hits for this rule [out]."]
    pub hits: u64,
    #[doc = "< Number of bytes through this rule [out]."]
    pub bytes: u64,
}
impl rte_flow_query_count {
    #[inline]
    pub fn reset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hits_set(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hits_set(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bytes_set(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bytes_set(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reset: u32,
        hits_set: u32,
        bytes_set: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reset: u32 = unsafe { ::std::mem::transmute(reset) };
            reset as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hits_set: u32 = unsafe { ::std::mem::transmute(hits_set) };
            hits_set as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bytes_set: u32 = unsafe { ::std::mem::transmute(bytes_set) };
            bytes_set as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(u32)]
#[doc = " Hash function types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_eth_hash_function {
    RTE_ETH_HASH_FUNCTION_DEFAULT = 0,
    #[doc = "< Toeplitz"]
    RTE_ETH_HASH_FUNCTION_TOEPLITZ = 1,
    #[doc = "< Simple XOR"]
    RTE_ETH_HASH_FUNCTION_SIMPLE_XOR = 2,
    #[doc = " Symmetric Toeplitz: src, dst will be replaced by"]
    #[doc = " xor(src, dst). For the case with src/dst only,"]
    #[doc = " src or dst address will xor with zero pair."]
    RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ = 3,
    #[doc = " Symmetric Toeplitz: src, dst will be replaced by"]
    #[doc = " xor(src, dst). For the case with src/dst only,"]
    #[doc = " src or dst address will xor with zero pair."]
    RTE_ETH_HASH_FUNCTION_MAX = 4,
}
#[doc = " RTE_FLOW_ACTION_TYPE_RSS"]
#[doc = ""]
#[doc = " Similar to QUEUE, except RSS is additionally performed on packets to"]
#[doc = " spread them among several queues according to the provided parameters."]
#[doc = ""]
#[doc = " Unlike global RSS settings used by other DPDK APIs, unsetting the"]
#[doc = " @p types field does not disable RSS in a flow rule. Doing so instead"]
#[doc = " requests safe unspecified \"best-effort\" settings from the underlying PMD,"]
#[doc = " which depending on the flow rule, may result in anything ranging from"]
#[doc = " empty (single queue) to all-inclusive RSS."]
#[doc = ""]
#[doc = " Note: RSS hash result is stored in the hash.rss mbuf field which overlaps"]
#[doc = " hash.fdir.lo. Since the MARK action sets the hash.fdir.hi field only,"]
#[doc = " both can be requested simultaneously."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_rss {
    #[doc = "< RSS hash function to apply."]
    pub func: rte_eth_hash_function,
    #[doc = " Packet encapsulation level RSS hash @p types apply to."]
    #[doc = ""]
    #[doc = " - @p 0 requests the default behavior. Depending on the packet"]
    #[doc = "   type, it can mean outermost, innermost, anything in between or"]
    #[doc = "   even no RSS."]
    #[doc = ""]
    #[doc = "   It basically stands for the innermost encapsulation level RSS"]
    #[doc = "   can be performed on according to PMD and device capabilities."]
    #[doc = ""]
    #[doc = " - @p 1 requests RSS to be performed on the outermost packet"]
    #[doc = "   encapsulation level."]
    #[doc = ""]
    #[doc = " - @p 2 and subsequent values request RSS to be performed on the"]
    #[doc = "   specified inner packet encapsulation level, from outermost to"]
    #[doc = "   innermost (lower to higher values)."]
    #[doc = ""]
    #[doc = " Values other than @p 0 are not necessarily supported."]
    #[doc = ""]
    #[doc = " Requesting a specific RSS level on unrecognized traffic results"]
    #[doc = " in undefined behavior. For predictable results, it is recommended"]
    #[doc = " to make the flow rule pattern match packet headers up to the"]
    #[doc = " requested encapsulation level so that only matching traffic goes"]
    #[doc = " through."]
    pub level: u32,
    #[doc = "< Specific RSS hash types (see RTE_ETH_RSS_*)."]
    pub types: u64,
    #[doc = "< Hash key length in bytes."]
    pub key_len: u32,
    #[doc = "< Number of entries in @p queue."]
    pub queue_num: u32,
    #[doc = "< Hash key."]
    pub key: *const u8,
    #[doc = "< Queue indices to use."]
    pub queue: *const u16,
}
#[doc = " @deprecated"]
#[doc = " @see RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR"]
#[doc = " @see RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_VF"]
#[doc = ""]
#[doc = " Directs matching traffic to a given virtual function of the current"]
#[doc = " device."]
#[doc = ""]
#[doc = " Packets matched by a VF pattern item can be redirected to their original"]
#[doc = " VF ID instead of the specified one. This parameter may not be available"]
#[doc = " and is not guaranteed to work properly if the VF part is matched by a"]
#[doc = " prior flow rule or if packets are not addressed to a VF in the first"]
#[doc = " place."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_vf {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< VF ID."]
    pub id: u32,
}
impl rte_flow_action_vf {
    #[inline]
    pub fn original(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_original(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(original: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let original: u32 = unsafe { ::std::mem::transmute(original) };
            original as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @deprecated"]
#[doc = " @see RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR"]
#[doc = " @see RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_PHY_PORT"]
#[doc = ""]
#[doc = " Directs packets to a given physical port index of the underlying"]
#[doc = " device."]
#[doc = ""]
#[doc = " @see RTE_FLOW_ITEM_TYPE_PHY_PORT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_phy_port {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Physical port index."]
    pub index: u32,
}
impl rte_flow_action_phy_port {
    #[inline]
    pub fn original(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_original(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(original: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let original: u32 = unsafe { ::std::mem::transmute(original) };
            original as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @deprecated"]
#[doc = " @see RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR"]
#[doc = " @see RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_PORT_ID"]
#[doc = ""]
#[doc = " Directs matching traffic to a given DPDK port ID."]
#[doc = ""]
#[doc = " @see RTE_FLOW_ITEM_TYPE_PORT_ID"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_port_id {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< DPDK port ID."]
    pub id: u32,
}
impl rte_flow_action_port_id {
    #[inline]
    pub fn original(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_original(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(original: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let original: u32 = unsafe { ::std::mem::transmute(original) };
            original as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " RTE_FLOW_ACTION_TYPE_METER"]
#[doc = ""]
#[doc = " Traffic metering and policing (MTR)."]
#[doc = ""]
#[doc = " Packets matched by items of this type can be either dropped or passed to the"]
#[doc = " next item with their color set by the MTR object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_meter {
    #[doc = "< MTR object ID created with rte_mtr_create()."]
    pub mtr_id: u32,
}
#[doc = " RTE_FLOW_ACTION_TYPE_SECURITY"]
#[doc = ""]
#[doc = " Perform the security action on flows matched by the pattern items"]
#[doc = " according to the configuration of the security session."]
#[doc = ""]
#[doc = " This action modifies the payload of matched flows. For INLINE_CRYPTO, the"]
#[doc = " security protocol headers and IV are fully provided by the application as"]
#[doc = " specified in the flow pattern. The payload of matching packets is"]
#[doc = " encrypted on egress, and decrypted and authenticated on ingress."]
#[doc = " For INLINE_PROTOCOL, the security protocol is fully offloaded to HW,"]
#[doc = " providing full encapsulation and decapsulation of packets in security"]
#[doc = " protocols. The flow pattern specifies both the outer security header fields"]
#[doc = " and the inner packet fields. The security session specified in the action"]
#[doc = " must match the pattern parameters."]
#[doc = ""]
#[doc = " The security session specified in the action must be created on the same"]
#[doc = " port as the flow action that is being specified."]
#[doc = ""]
#[doc = " The ingress/egress flow attribute should match that specified in the"]
#[doc = " security session if the security session supports the definition of the"]
#[doc = " direction."]
#[doc = ""]
#[doc = " Multiple flows can be configured to use the same security session."]
#[doc = ""]
#[doc = " The NULL value is allowed for security session. If security session is NULL,"]
#[doc = " then SPI field in ESP flow item and IP addresses in flow items 'IPv4' and"]
#[doc = " 'IPv6' will be allowed to be a range. The rule thus created can enable"]
#[doc = " security processing on multiple flows."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_security {
    #[doc = "< Pointer to security session structure."]
    pub security_session: *mut ::std::os::raw::c_void,
}
#[doc = " @deprecated"]
#[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_OF_SET_MPLS_TTL"]
#[doc = ""]
#[doc = " Implements OFPAT_SET_MPLS_TTL (\"MPLS TTL\") as defined by the OpenFlow"]
#[doc = " Switch Specification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_of_set_mpls_ttl {
    #[doc = "< MPLS TTL."]
    pub mpls_ttl: u8,
}
#[doc = " @deprecated"]
#[doc = " @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_OF_SET_NW_TTL"]
#[doc = ""]
#[doc = " Implements OFPAT_SET_NW_TTL (\"IP TTL\") as defined by the OpenFlow Switch"]
#[doc = " Specification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_of_set_nw_ttl {
    #[doc = "< IP TTL."]
    pub nw_ttl: u8,
}
#[doc = " RTE_FLOW_ACTION_TYPE_OF_PUSH_VLAN"]
#[doc = ""]
#[doc = " Implements OFPAT_PUSH_VLAN (\"push a new VLAN tag\") as defined by the"]
#[doc = " OpenFlow Switch Specification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_of_push_vlan {
    #[doc = "< EtherType."]
    pub ethertype: rte_be16_t,
}
#[doc = " RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_VID"]
#[doc = ""]
#[doc = " Implements OFPAT_SET_VLAN_VID (\"set the 802.1q VLAN ID\") as defined by"]
#[doc = " the OpenFlow Switch Specification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_of_set_vlan_vid {
    #[doc = "< VLAN ID."]
    pub vlan_vid: rte_be16_t,
}
#[doc = " RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_PCP"]
#[doc = ""]
#[doc = " Implements OFPAT_SET_LAN_PCP (\"set the 802.1q priority\") as defined by"]
#[doc = " the OpenFlow Switch Specification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_of_set_vlan_pcp {
    #[doc = "< VLAN priority."]
    pub vlan_pcp: u8,
}
#[doc = " RTE_FLOW_ACTION_TYPE_OF_POP_MPLS"]
#[doc = ""]
#[doc = " Implements OFPAT_POP_MPLS (\"pop the outer MPLS tag\") as defined by the"]
#[doc = " OpenFlow Switch Specification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_of_pop_mpls {
    #[doc = "< EtherType."]
    pub ethertype: rte_be16_t,
}
#[doc = " RTE_FLOW_ACTION_TYPE_OF_PUSH_MPLS"]
#[doc = ""]
#[doc = " Implements OFPAT_PUSH_MPLS (\"push a new MPLS tag\") as defined by the"]
#[doc = " OpenFlow Switch Specification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_of_push_mpls {
    #[doc = "< EtherType."]
    pub ethertype: rte_be16_t,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_VXLAN_ENCAP"]
#[doc = ""]
#[doc = " VXLAN tunnel end-point encapsulation data definition"]
#[doc = ""]
#[doc = " The tunnel definition is provided through the flow item pattern, the"]
#[doc = " provided pattern must conform to RFC7348 for the tunnel specified. The flow"]
#[doc = " definition must be provided in order from the RTE_FLOW_ITEM_TYPE_ETH"]
#[doc = " definition up the end item which is specified by RTE_FLOW_ITEM_TYPE_END."]
#[doc = ""]
#[doc = " The mask field allows user to specify which fields in the flow item"]
#[doc = " definitions can be ignored and which have valid data and can be used"]
#[doc = " verbatim."]
#[doc = ""]
#[doc = " Note: the last field is not used in the definition of a tunnel and can be"]
#[doc = " ignored."]
#[doc = ""]
#[doc = " Valid flow definition for RTE_FLOW_ACTION_TYPE_VXLAN_ENCAP include:"]
#[doc = ""]
#[doc = " - ETH / IPV4 / UDP / VXLAN / END"]
#[doc = " - ETH / IPV6 / UDP / VXLAN / END"]
#[doc = " - ETH / VLAN / IPV4 / UDP / VXLAN / END"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_vxlan_encap {
    #[doc = " Encapsulating vxlan tunnel definition"]
    #[doc = " (terminated by the END pattern item)."]
    pub definition: *mut rte_flow_item,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_NVGRE_ENCAP"]
#[doc = ""]
#[doc = " NVGRE tunnel end-point encapsulation data definition"]
#[doc = ""]
#[doc = " The tunnel definition is provided through the flow item pattern  the"]
#[doc = " provided pattern must conform with RFC7637. The flow definition must be"]
#[doc = " provided in order from the RTE_FLOW_ITEM_TYPE_ETH definition up the end item"]
#[doc = " which is specified by RTE_FLOW_ITEM_TYPE_END."]
#[doc = ""]
#[doc = " The mask field allows user to specify which fields in the flow item"]
#[doc = " definitions can be ignored and which have valid data and can be used"]
#[doc = " verbatim."]
#[doc = ""]
#[doc = " Note: the last field is not used in the definition of a tunnel and can be"]
#[doc = " ignored."]
#[doc = ""]
#[doc = " Valid flow definition for RTE_FLOW_ACTION_TYPE_NVGRE_ENCAP include:"]
#[doc = ""]
#[doc = " - ETH / IPV4 / NVGRE / END"]
#[doc = " - ETH / VLAN / IPV6 / NVGRE / END"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_nvgre_encap {
    #[doc = " Encapsulating vxlan tunnel definition"]
    #[doc = " (terminated by the END pattern item)."]
    pub definition: *mut rte_flow_item,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_RAW_ENCAP"]
#[doc = ""]
#[doc = " Raw tunnel end-point encapsulation data definition."]
#[doc = ""]
#[doc = " The data holds the headers definitions to be applied on the packet."]
#[doc = " The data must start with ETH header up to the tunnel item header itself."]
#[doc = " When used right after RAW_DECAP (for decapsulating L3 tunnel type for"]
#[doc = " example MPLSoGRE) the data will just hold layer 2 header."]
#[doc = ""]
#[doc = " The preserve parameter holds which bits in the packet the PMD is not allowed"]
#[doc = " to change, this parameter can also be NULL and then the PMD is allowed"]
#[doc = " to update any field."]
#[doc = ""]
#[doc = " size holds the number of bytes in @p data and @p preserve."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_raw_encap {
    #[doc = "< Encapsulation data."]
    pub data: *mut u8,
    #[doc = "< Bit-mask of @p data to preserve on output."]
    pub preserve: *mut u8,
    #[doc = "< Size of @p data and @p preserve."]
    pub size: size_t,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_RAW_DECAP"]
#[doc = ""]
#[doc = " Raw tunnel end-point decapsulation data definition."]
#[doc = ""]
#[doc = " The data holds the headers definitions to be removed from the packet."]
#[doc = " The data must start with ETH header up to the tunnel item header itself."]
#[doc = " When used right before RAW_DECAP (for encapsulating L3 tunnel type for"]
#[doc = " example MPLSoGRE) the data will just hold layer 2 header."]
#[doc = ""]
#[doc = " size holds the number of bytes in @p data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_raw_decap {
    #[doc = "< Encapsulation data."]
    pub data: *mut u8,
    #[doc = "< Size of @p data and @p preserve."]
    pub size: size_t,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_SET_IPV4_SRC"]
#[doc = " RTE_FLOW_ACTION_TYPE_SET_IPV4_DST"]
#[doc = ""]
#[doc = " Allows modification of IPv4 source (RTE_FLOW_ACTION_TYPE_SET_IPV4_SRC)"]
#[doc = " and destination address (RTE_FLOW_ACTION_TYPE_SET_IPV4_DST) in the"]
#[doc = " specified outermost IPv4 header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_set_ipv4 {
    pub ipv4_addr: rte_be32_t,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_SET_IPV6_SRC"]
#[doc = " RTE_FLOW_ACTION_TYPE_SET_IPV6_DST"]
#[doc = ""]
#[doc = " Allows modification of IPv6 source (RTE_FLOW_ACTION_TYPE_SET_IPV6_SRC)"]
#[doc = " and destination address (RTE_FLOW_ACTION_TYPE_SET_IPV6_DST) in the"]
#[doc = " specified outermost IPv6 header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_set_ipv6 {
    pub ipv6_addr: [u8; 16usize],
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_SET_TP_SRC"]
#[doc = " RTE_FLOW_ACTION_TYPE_SET_TP_DST"]
#[doc = ""]
#[doc = " Allows modification of source (RTE_FLOW_ACTION_TYPE_SET_TP_SRC)"]
#[doc = " and destination (RTE_FLOW_ACTION_TYPE_SET_TP_DST) port numbers"]
#[doc = " in the specified outermost TCP/UDP header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_set_tp {
    pub port: rte_be16_t,
}
#[doc = " RTE_FLOW_ACTION_TYPE_SET_TTL"]
#[doc = ""]
#[doc = " Set the TTL value directly for IPv4 or IPv6"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_set_ttl {
    pub ttl_value: u8,
}
#[doc = " RTE_FLOW_ACTION_TYPE_SET_MAC"]
#[doc = ""]
#[doc = " Set MAC address from the matched flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_set_mac {
    pub mac_addr: [u8; 6usize],
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_SET_TAG"]
#[doc = ""]
#[doc = " Set a tag which is a transient data used during flow matching. This is not"]
#[doc = " delivered to application. Multiple tags are supported by specifying index."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_set_tag {
    pub data: u32,
    pub mask: u32,
    pub index: u8,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_SET_META"]
#[doc = ""]
#[doc = " Set metadata. Metadata set by mbuf metadata dynamic field with"]
#[doc = " RTE_MBUF_DYNFLAG_TX_METADATA flag on egress will be overridden by this"]
#[doc = " action. On ingress, the metadata will be carried by mbuf metadata dynamic"]
#[doc = " field with RTE_MBUF_DYNFLAG_RX_METADATA flag if set.  The dynamic mbuf field"]
#[doc = " must be registered in advance by rte_flow_dynf_metadata_register()."]
#[doc = ""]
#[doc = " Altering partial bits is supported with mask. For bits which have never"]
#[doc = " been set, unpredictable value will be seen depending on driver"]
#[doc = " implementation. For loopback/hairpin packet, metadata set on Rx/Tx may"]
#[doc = " or may not be propagated to the other path depending on HW capability."]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_META matches metadata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_set_meta {
    pub data: u32,
    pub mask: u32,
}
#[doc = " RTE_FLOW_ACTION_TYPE_SET_IPV4_DSCP"]
#[doc = " RTE_FLOW_ACTION_TYPE_SET_IPV6_DSCP"]
#[doc = ""]
#[doc = " Set the DSCP value for IPv4/IPv6 header."]
#[doc = " DSCP in low 6 bits, rest ignored."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_set_dscp {
    pub dscp: u8,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_INDIRECT"]
#[doc = ""]
#[doc = " Opaque type returned after successfully creating an indirect action object."]
#[doc = " The definition of the object handle is different per driver or"]
#[doc = " per direct action type."]
#[doc = ""]
#[doc = " This handle can be used to manage and query the related direct action:"]
#[doc = " - referenced in single flow rule or across multiple flow rules"]
#[doc = "   over multiple ports"]
#[doc = " - update action object configuration"]
#[doc = " - query action object data"]
#[doc = " - destroy action object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_handle {
    _unused: [u8; 0],
}
#[repr(u32)]
#[doc = " The state of a TCP connection."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_flow_conntrack_state {
    #[doc = " SYN-ACK packet was seen."]
    RTE_FLOW_CONNTRACK_STATE_SYN_RECV = 0,
    #[doc = " 3-way handshake was done."]
    RTE_FLOW_CONNTRACK_STATE_ESTABLISHED = 1,
    #[doc = " First FIN packet was received to close the connection."]
    RTE_FLOW_CONNTRACK_STATE_FIN_WAIT = 2,
    #[doc = " First FIN was ACKed."]
    RTE_FLOW_CONNTRACK_STATE_CLOSE_WAIT = 3,
    #[doc = " Second FIN was received, waiting for the last ACK."]
    RTE_FLOW_CONNTRACK_STATE_LAST_ACK = 4,
    #[doc = " Second FIN was ACKed, connection was closed."]
    RTE_FLOW_CONNTRACK_STATE_TIME_WAIT = 5,
}
#[repr(u32)]
#[doc = " The last passed TCP packet flags of a connection."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_flow_conntrack_tcp_last_index {
    #[doc = "< No Flag."]
    RTE_FLOW_CONNTRACK_FLAG_NONE = 0,
    #[doc = "< With SYN flag."]
    RTE_FLOW_CONNTRACK_FLAG_SYN = 1,
    #[doc = "< With SYNACK flag."]
    RTE_FLOW_CONNTRACK_FLAG_SYNACK = 2,
    #[doc = "< With FIN flag."]
    RTE_FLOW_CONNTRACK_FLAG_FIN = 4,
    #[doc = "< With ACK flag."]
    RTE_FLOW_CONNTRACK_FLAG_ACK = 8,
    #[doc = "< With RST flag."]
    RTE_FLOW_CONNTRACK_FLAG_RST = 16,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " Configuration parameters for each direction of a TCP connection."]
#[doc = " All fields should be in host byte order."]
#[doc = " If needed, driver should convert all fields to network byte order"]
#[doc = " if HW needs them in that way."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_tcp_dir_param {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " Maximal value of sequence + payload length in sent"]
    #[doc = " packets (next ACK from the opposite direction)."]
    pub sent_end: u32,
    #[doc = " Maximal value of (ACK + window size) in received packet + length"]
    #[doc = " over sent packet (maximal sequence could be sent)."]
    pub reply_end: u32,
    #[doc = " Maximal value of actual window size in sent packets."]
    pub max_win: u32,
    #[doc = " Maximal value of ACK in sent packets."]
    pub max_ack: u32,
}
impl rte_flow_tcp_dir_param {
    #[inline]
    pub fn scale(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn close_initiated(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_initiated(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_ack_seen(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_ack_seen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn data_unacked(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_data_unacked(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        scale: u32,
        close_initiated: u32,
        last_ack_seen: u32,
        data_unacked: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let scale: u32 = unsafe { ::std::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let close_initiated: u32 = unsafe { ::std::mem::transmute(close_initiated) };
            close_initiated as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let last_ack_seen: u32 = unsafe { ::std::mem::transmute(last_ack_seen) };
            last_ack_seen as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let data_unacked: u32 = unsafe { ::std::mem::transmute(data_unacked) };
            data_unacked as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_CONNTRACK"]
#[doc = ""]
#[doc = " Configuration and initial state for the connection tracking module."]
#[doc = " This structure could be used for both setting and query."]
#[doc = " All fields should be in host byte order."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_conntrack {
    #[doc = " The peer port number, can be the same port."]
    pub peer_port: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " The current state of this connection."]
    pub state: rte_flow_conntrack_state,
    #[doc = " Scaling factor for maximal allowed ACK window."]
    pub max_ack_window: u8,
    #[doc = " Maximal allowed number of retransmission times."]
    pub retransmission_limit: u8,
    #[doc = " TCP parameters of the original direction."]
    pub original_dir: rte_flow_tcp_dir_param,
    #[doc = " TCP parameters of the reply direction."]
    pub reply_dir: rte_flow_tcp_dir_param,
    #[doc = " The window value of the last packet passed this conntrack."]
    pub last_window: u16,
    pub last_index: rte_flow_conntrack_tcp_last_index,
    #[doc = " The sequence of the last packet passed this conntrack."]
    pub last_seq: u32,
    #[doc = " The acknowledgment of the last packet passed this conntrack."]
    pub last_ack: u32,
    #[doc = " The total value ACK + payload length of the last packet"]
    #[doc = " passed this conntrack."]
    pub last_end: u32,
}
impl rte_flow_action_conntrack {
    #[inline]
    pub fn is_original_dir(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_original_dir(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn live_connection(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_live_connection(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn selective_ack(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_selective_ack(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn challenge_ack_passed(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_challenge_ack_passed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_direction(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_direction(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn liberal_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_liberal_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_original_dir: u32,
        enable: u32,
        live_connection: u32,
        selective_ack: u32,
        challenge_ack_passed: u32,
        last_direction: u32,
        liberal_mode: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_original_dir: u32 = unsafe { ::std::mem::transmute(is_original_dir) };
            is_original_dir as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enable: u32 = unsafe { ::std::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let live_connection: u32 = unsafe { ::std::mem::transmute(live_connection) };
            live_connection as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let selective_ack: u32 = unsafe { ::std::mem::transmute(selective_ack) };
            selective_ack as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let challenge_ack_passed: u32 = unsafe { ::std::mem::transmute(challenge_ack_passed) };
            challenge_ack_passed as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let last_direction: u32 = unsafe { ::std::mem::transmute(last_direction) };
            last_direction as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let liberal_mode: u32 = unsafe { ::std::mem::transmute(liberal_mode) };
            liberal_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " RTE_FLOW_ACTION_TYPE_CONNTRACK"]
#[doc = ""]
#[doc = " Wrapper structure for the context update interface."]
#[doc = " Ports cannot support updating, and the only valid solution is to"]
#[doc = " destroy the old context and create a new one instead."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_modify_conntrack {
    #[doc = " New connection tracking parameters to be updated."]
    pub new_ct: rte_flow_action_conntrack,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rte_flow_modify_conntrack {
    #[inline]
    pub fn direction(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_direction(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        direction: u32,
        state: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let direction: u32 = unsafe { ::std::mem::transmute(direction) };
            direction as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let state: u32 = unsafe { ::std::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_METER_COLOR"]
#[doc = ""]
#[doc = " The meter color should be set in the packet meta-data"]
#[doc = " (i.e. struct rte_mbuf::sched::color)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_meter_color {
    #[doc = "< Packet color."]
    pub color: rte_color,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " Provides an ethdev port ID for use with the following actions:"]
#[doc = " RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR,"]
#[doc = " RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_ethdev {
    #[doc = "< ethdev port ID"]
    pub port_id: u16,
}
#[repr(u32)]
#[doc = " Field IDs for MODIFY_FIELD action."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_flow_field_id {
    #[doc = "< Start of a packet."]
    RTE_FLOW_FIELD_START = 0,
    #[doc = "< Destination MAC Address."]
    RTE_FLOW_FIELD_MAC_DST = 1,
    #[doc = "< Source MAC Address."]
    RTE_FLOW_FIELD_MAC_SRC = 2,
    #[doc = "< 802.1Q Tag Identifier."]
    RTE_FLOW_FIELD_VLAN_TYPE = 3,
    #[doc = "< 802.1Q VLAN Identifier."]
    RTE_FLOW_FIELD_VLAN_ID = 4,
    #[doc = "< EtherType."]
    RTE_FLOW_FIELD_MAC_TYPE = 5,
    #[doc = "< IPv4 DSCP."]
    RTE_FLOW_FIELD_IPV4_DSCP = 6,
    #[doc = "< IPv4 Time To Live."]
    RTE_FLOW_FIELD_IPV4_TTL = 7,
    #[doc = "< IPv4 Source Address."]
    RTE_FLOW_FIELD_IPV4_SRC = 8,
    #[doc = "< IPv4 Destination Address."]
    RTE_FLOW_FIELD_IPV4_DST = 9,
    #[doc = "< IPv6 DSCP."]
    RTE_FLOW_FIELD_IPV6_DSCP = 10,
    #[doc = "< IPv6 Hop Limit."]
    RTE_FLOW_FIELD_IPV6_HOPLIMIT = 11,
    #[doc = "< IPv6 Source Address."]
    RTE_FLOW_FIELD_IPV6_SRC = 12,
    #[doc = "< IPv6 Destination Address."]
    RTE_FLOW_FIELD_IPV6_DST = 13,
    #[doc = "< TCP Source Port Number."]
    RTE_FLOW_FIELD_TCP_PORT_SRC = 14,
    #[doc = "< TCP Destination Port Number."]
    RTE_FLOW_FIELD_TCP_PORT_DST = 15,
    #[doc = "< TCP Sequence Number."]
    RTE_FLOW_FIELD_TCP_SEQ_NUM = 16,
    #[doc = "< TCP Acknowledgment Number."]
    RTE_FLOW_FIELD_TCP_ACK_NUM = 17,
    #[doc = "< TCP Flags."]
    RTE_FLOW_FIELD_TCP_FLAGS = 18,
    #[doc = "< UDP Source Port Number."]
    RTE_FLOW_FIELD_UDP_PORT_SRC = 19,
    #[doc = "< UDP Destination Port Number."]
    RTE_FLOW_FIELD_UDP_PORT_DST = 20,
    #[doc = "< VXLAN Network Identifier."]
    RTE_FLOW_FIELD_VXLAN_VNI = 21,
    #[doc = "< GENEVE Network Identifier."]
    RTE_FLOW_FIELD_GENEVE_VNI = 22,
    #[doc = "< GTP Tunnel Endpoint Identifier."]
    RTE_FLOW_FIELD_GTP_TEID = 23,
    #[doc = "< Tag value."]
    RTE_FLOW_FIELD_TAG = 24,
    #[doc = "< Mark value."]
    RTE_FLOW_FIELD_MARK = 25,
    #[doc = "< Metadata value."]
    RTE_FLOW_FIELD_META = 26,
    #[doc = "< Memory pointer."]
    RTE_FLOW_FIELD_POINTER = 27,
    #[doc = "< Immediate value."]
    RTE_FLOW_FIELD_VALUE = 28,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " Field description for MODIFY_FIELD action."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_modify_data {
    #[doc = "< Field or memory type ID."]
    pub field: rte_flow_field_id,
    pub __bindgen_anon_1: rte_flow_action_modify_data__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_action_modify_data__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_flow_action_modify_data__bindgen_ty_1__bindgen_ty_1,
    #[doc = " Immediate value for RTE_FLOW_FIELD_VALUE, presented in the"]
    #[doc = " same byte order and length as in relevant rte_flow_item_xxx."]
    #[doc = " The immediate source bitfield offset is inherited from"]
    #[doc = " the destination's one."]
    pub value: [u8; 16usize],
    #[doc = " Memory address for RTE_FLOW_FIELD_POINTER, memory layout"]
    #[doc = " should be the same as for relevant field in the"]
    #[doc = " rte_flow_item_xxx structure."]
    pub pvalue: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_modify_data__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Encapsulation level or tag index."]
    pub level: u32,
    #[doc = " Number of bits to skip from a field."]
    pub offset: u32,
}
#[repr(u32)]
#[doc = " Operation types for MODIFY_FIELD action."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_flow_modify_op {
    #[doc = "< Set a new value."]
    RTE_FLOW_MODIFY_SET = 0,
    #[doc = "< Add a value to a field."]
    RTE_FLOW_MODIFY_ADD = 1,
    #[doc = "< Subtract a value from a field."]
    RTE_FLOW_MODIFY_SUB = 2,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_MODIFY_FIELD"]
#[doc = ""]
#[doc = " Modify a destination header field according to the specified"]
#[doc = " operation. Another field of the packet can be used as a source as well"]
#[doc = " as tag, mark, metadata, immediate value or a pointer to it."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_modify_field {
    #[doc = "< Operation to perform."]
    pub operation: rte_flow_modify_op,
    #[doc = "< Destination field."]
    pub dst: rte_flow_action_modify_data,
    #[doc = "< Source field."]
    pub src: rte_flow_action_modify_data,
    #[doc = "< Number of bits to use from a source field."]
    pub width: u32,
}
extern "C" {
    pub static mut rte_flow_dynf_metadata_offs: i32;
}
extern "C" {
    pub static mut rte_flow_dynf_metadata_mask: u64;
}
#[doc = " Definition of a single action."]
#[doc = ""]
#[doc = " A list of actions is terminated by a END action."]
#[doc = ""]
#[doc = " For simple actions without a configuration object, conf remains NULL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action {
    #[doc = "< Action type."]
    pub type_: rte_flow_action_type,
    #[doc = "< Pointer to action configuration object."]
    pub conf: *const ::std::os::raw::c_void,
}
#[doc = " Opaque type returned after successfully creating a flow."]
#[doc = ""]
#[doc = " This handle can be used to manage and query the related flow (e.g. to"]
#[doc = " destroy it or retrieve counters)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow {
    _unused: [u8; 0],
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_SAMPLE"]
#[doc = ""]
#[doc = " Adds a sample action to a matched flow."]
#[doc = ""]
#[doc = " The matching packets will be duplicated with specified ratio and applied"]
#[doc = " with own set of actions with a fate action, the sampled packet could be"]
#[doc = " redirected to queue or port. All the packets continue processing on the"]
#[doc = " default flow path."]
#[doc = ""]
#[doc = " When the sample ratio is set to 1 then the packets will be 100% mirrored."]
#[doc = " Additional action list be supported to add for sampled or mirrored packets."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_sample {
    #[doc = "< packets sampled equals to '1/ratio'."]
    pub ratio: u32,
    #[doc = " sub-action list specific for the sampling hit cases."]
    pub actions: *const rte_flow_action,
}
#[repr(u32)]
#[doc = " Verbose error types."]
#[doc = ""]
#[doc = " Most of them provide the type of the object referenced by struct"]
#[doc = " rte_flow_error.cause."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_flow_error_type {
    #[doc = "< No error."]
    RTE_FLOW_ERROR_TYPE_NONE = 0,
    #[doc = "< Cause unspecified."]
    RTE_FLOW_ERROR_TYPE_UNSPECIFIED = 1,
    #[doc = "< Flow rule (handle)."]
    RTE_FLOW_ERROR_TYPE_HANDLE = 2,
    #[doc = "< Group field."]
    RTE_FLOW_ERROR_TYPE_ATTR_GROUP = 3,
    #[doc = "< Priority field."]
    RTE_FLOW_ERROR_TYPE_ATTR_PRIORITY = 4,
    #[doc = "< Ingress field."]
    RTE_FLOW_ERROR_TYPE_ATTR_INGRESS = 5,
    #[doc = "< Egress field."]
    RTE_FLOW_ERROR_TYPE_ATTR_EGRESS = 6,
    #[doc = "< Transfer field."]
    RTE_FLOW_ERROR_TYPE_ATTR_TRANSFER = 7,
    #[doc = "< Attributes structure."]
    RTE_FLOW_ERROR_TYPE_ATTR = 8,
    #[doc = "< Pattern length."]
    RTE_FLOW_ERROR_TYPE_ITEM_NUM = 9,
    #[doc = "< Item specification."]
    RTE_FLOW_ERROR_TYPE_ITEM_SPEC = 10,
    #[doc = "< Item specification range."]
    RTE_FLOW_ERROR_TYPE_ITEM_LAST = 11,
    #[doc = "< Item specification mask."]
    RTE_FLOW_ERROR_TYPE_ITEM_MASK = 12,
    #[doc = "< Specific pattern item."]
    RTE_FLOW_ERROR_TYPE_ITEM = 13,
    #[doc = "< Number of actions."]
    RTE_FLOW_ERROR_TYPE_ACTION_NUM = 14,
    #[doc = "< Action configuration."]
    RTE_FLOW_ERROR_TYPE_ACTION_CONF = 15,
    #[doc = "< Specific action."]
    RTE_FLOW_ERROR_TYPE_ACTION = 16,
    #[doc = "< Current device state."]
    RTE_FLOW_ERROR_TYPE_STATE = 17,
}
#[doc = " Verbose error structure definition."]
#[doc = ""]
#[doc = " This object is normally allocated by applications and set by PMDs, the"]
#[doc = " message points to a constant string which does not need to be freed by"]
#[doc = " the application, however its pointer can be considered valid only as long"]
#[doc = " as its associated DPDK port remains configured. Closing the underlying"]
#[doc = " device or unloading the PMD invalidates it."]
#[doc = ""]
#[doc = " Both cause and message may be NULL regardless of the error type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_error {
    #[doc = "< Cause field and error types."]
    pub type_: rte_flow_error_type,
    #[doc = "< Object responsible for the error."]
    pub cause: *const ::std::os::raw::c_void,
    #[doc = "< Human-readable error message."]
    pub message: *const ::std::os::raw::c_char,
}
#[doc = " Complete flow rule description."]
#[doc = ""]
#[doc = " This object type is used when converting a flow rule description."]
#[doc = ""]
#[doc = " @see RTE_FLOW_CONV_OP_RULE"]
#[doc = " @see rte_flow_conv()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_conv_rule {
    pub __bindgen_anon_1: rte_flow_conv_rule__bindgen_ty_1,
    pub __bindgen_anon_2: rte_flow_conv_rule__bindgen_ty_2,
    pub __bindgen_anon_3: rte_flow_conv_rule__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_conv_rule__bindgen_ty_1 {
    #[doc = "< RO attributes."]
    pub attr_ro: *const rte_flow_attr,
    #[doc = "< Attributes."]
    pub attr: *mut rte_flow_attr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_conv_rule__bindgen_ty_2 {
    #[doc = "< RO pattern."]
    pub pattern_ro: *const rte_flow_item,
    #[doc = "< Pattern items."]
    pub pattern: *mut rte_flow_item,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_conv_rule__bindgen_ty_3 {
    #[doc = "< RO actions."]
    pub actions_ro: *const rte_flow_action,
    #[doc = "< List of actions."]
    pub actions: *mut rte_flow_action,
}
#[repr(u32)]
#[doc = " Conversion operations for flow API objects."]
#[doc = ""]
#[doc = " @see rte_flow_conv()"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_flow_conv_op {
    #[doc = " No operation to perform."]
    #[doc = ""]
    #[doc = " rte_flow_conv() simply returns 0."]
    RTE_FLOW_CONV_OP_NONE = 0,
    #[doc = " Convert attributes structure."]
    #[doc = ""]
    #[doc = " This is a basic copy of an attributes structure."]
    #[doc = ""]
    #[doc = " - @p src type:"]
    #[doc = "   @code const struct rte_flow_attr * @endcode"]
    #[doc = " - @p dst type:"]
    #[doc = "   @code struct rte_flow_attr * @endcode"]
    RTE_FLOW_CONV_OP_ATTR = 1,
    #[doc = " Convert a single item."]
    #[doc = ""]
    #[doc = " Duplicates @p spec, @p last and @p mask but not outside objects."]
    #[doc = ""]
    #[doc = " - @p src type:"]
    #[doc = "   @code const struct rte_flow_item * @endcode"]
    #[doc = " - @p dst type:"]
    #[doc = "   @code struct rte_flow_item * @endcode"]
    RTE_FLOW_CONV_OP_ITEM = 2,
    #[doc = " Convert a single action."]
    #[doc = ""]
    #[doc = " Duplicates @p conf but not outside objects."]
    #[doc = ""]
    #[doc = " - @p src type:"]
    #[doc = "   @code const struct rte_flow_action * @endcode"]
    #[doc = " - @p dst type:"]
    #[doc = "   @code struct rte_flow_action * @endcode"]
    RTE_FLOW_CONV_OP_ACTION = 3,
    #[doc = " Convert an entire pattern."]
    #[doc = ""]
    #[doc = " Duplicates all pattern items at once with the same constraints as"]
    #[doc = " RTE_FLOW_CONV_OP_ITEM."]
    #[doc = ""]
    #[doc = " - @p src type:"]
    #[doc = "   @code const struct rte_flow_item * @endcode"]
    #[doc = " - @p dst type:"]
    #[doc = "   @code struct rte_flow_item * @endcode"]
    RTE_FLOW_CONV_OP_PATTERN = 4,
    #[doc = " Convert a list of actions."]
    #[doc = ""]
    #[doc = " Duplicates the entire list of actions at once with the same"]
    #[doc = " constraints as RTE_FLOW_CONV_OP_ACTION."]
    #[doc = ""]
    #[doc = " - @p src type:"]
    #[doc = "   @code const struct rte_flow_action * @endcode"]
    #[doc = " - @p dst type:"]
    #[doc = "   @code struct rte_flow_action * @endcode"]
    RTE_FLOW_CONV_OP_ACTIONS = 5,
    #[doc = " Convert a complete flow rule description."]
    #[doc = ""]
    #[doc = " Comprises attributes, pattern and actions together at once with"]
    #[doc = " the usual constraints."]
    #[doc = ""]
    #[doc = " - @p src type:"]
    #[doc = "   @code const struct rte_flow_conv_rule * @endcode"]
    #[doc = " - @p dst type:"]
    #[doc = "   @code struct rte_flow_conv_rule * @endcode"]
    RTE_FLOW_CONV_OP_RULE = 6,
    #[doc = " Convert item type to its name string."]
    #[doc = ""]
    #[doc = " Writes a NUL-terminated string to @p dst. Like snprintf(), the"]
    #[doc = " returned value excludes the terminator which is always written"]
    #[doc = " nonetheless."]
    #[doc = ""]
    #[doc = " - @p src type:"]
    #[doc = "   @code (const void *)enum rte_flow_item_type @endcode"]
    #[doc = " - @p dst type:"]
    #[doc = "   @code char * @endcode"]
    RTE_FLOW_CONV_OP_ITEM_NAME = 7,
    #[doc = " Convert action type to its name string."]
    #[doc = ""]
    #[doc = " Writes a NUL-terminated string to @p dst. Like snprintf(), the"]
    #[doc = " returned value excludes the terminator which is always written"]
    #[doc = " nonetheless."]
    #[doc = ""]
    #[doc = " - @p src type:"]
    #[doc = "   @code (const void *)enum rte_flow_action_type @endcode"]
    #[doc = " - @p dst type:"]
    #[doc = "   @code char * @endcode"]
    RTE_FLOW_CONV_OP_ACTION_NAME = 8,
    #[doc = " Convert item type to pointer to item name."]
    #[doc = ""]
    #[doc = " Retrieves item name pointer from its type. The string itself is"]
    #[doc = " not copied; instead, a unique pointer to an internal static"]
    #[doc = " constant storage is written to @p dst."]
    #[doc = ""]
    #[doc = " - @p src type:"]
    #[doc = "   @code (const void *)enum rte_flow_item_type @endcode"]
    #[doc = " - @p dst type:"]
    #[doc = "   @code const char ** @endcode"]
    RTE_FLOW_CONV_OP_ITEM_NAME_PTR = 9,
    #[doc = " Convert action type to pointer to action name."]
    #[doc = ""]
    #[doc = " Retrieves action name pointer from its type. The string itself is"]
    #[doc = " not copied; instead, a unique pointer to an internal static"]
    #[doc = " constant storage is written to @p dst."]
    #[doc = ""]
    #[doc = " - @p src type:"]
    #[doc = "   @code (const void *)enum rte_flow_action_type @endcode"]
    #[doc = " - @p dst type:"]
    #[doc = "   @code const char ** @endcode"]
    RTE_FLOW_CONV_OP_ACTION_NAME_PTR = 10,
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Dump hardware internal representation information of"]
    #[doc = " rte flow to file."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "    The port identifier of the Ethernet device."]
    #[doc = " @param[in] flow"]
    #[doc = "   The pointer of flow rule to dump. Dump all rules if NULL."]
    #[doc = " @param[in] file"]
    #[doc = "   A pointer to a file for output."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative value otherwise."]
    pub fn rte_flow_dev_dump(
        port_id: u16,
        flow: *mut rte_flow,
        file: *mut FILE,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register mbuf dynamic field and flag for metadata."]
    #[doc = ""]
    #[doc = " This function must be called prior to use SET_META action in order to"]
    #[doc = " register the dynamic mbuf field. Otherwise, the data cannot be delivered to"]
    #[doc = " application."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_dynf_metadata_register() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check whether a flow rule can be created on a given port."]
    #[doc = ""]
    #[doc = " The flow rule is validated for correctness and whether it could be accepted"]
    #[doc = " by the device given sufficient resources. The rule is checked against the"]
    #[doc = " current device mode and queue configuration. The flow rule may also"]
    #[doc = " optionally be validated against existing flow rules and device resources."]
    #[doc = " This function has no effect on the target device."]
    #[doc = ""]
    #[doc = " The returned value is guaranteed to remain valid only as long as no"]
    #[doc = " successful calls to rte_flow_create() or rte_flow_destroy() are made in"]
    #[doc = " the meantime and no device parameter affecting flow rules in any way are"]
    #[doc = " modified, due to possible collisions or resource limitations (although in"]
    #[doc = " such cases EINVAL should not be returned)."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] attr"]
    #[doc = "   Flow rule attributes."]
    #[doc = " @param[in] pattern"]
    #[doc = "   Pattern specification (list terminated by the END pattern item)."]
    #[doc = " @param[in] actions"]
    #[doc = "   Associated actions (list terminated by the END action)."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 if flow rule is valid and can be created. A negative errno value"]
    #[doc = "   otherwise (rte_errno is also set), the following errors are defined:"]
    #[doc = ""]
    #[doc = "   -ENOSYS: underlying device does not support this functionality."]
    #[doc = ""]
    #[doc = "   -EIO: underlying device is removed."]
    #[doc = ""]
    #[doc = "   -EINVAL: unknown or invalid rule specification."]
    #[doc = ""]
    #[doc = "   -ENOTSUP: valid but unsupported rule specification (e.g. partial"]
    #[doc = "   bit-masks are unsupported)."]
    #[doc = ""]
    #[doc = "   -EEXIST: collision with an existing rule. Only returned if device"]
    #[doc = "   supports flow rule collision checking and there was a flow rule"]
    #[doc = "   collision. Not receiving this return code is no guarantee that creating"]
    #[doc = "   the rule will not fail due to a collision."]
    #[doc = ""]
    #[doc = "   -ENOMEM: not enough memory to execute the function, or if the device"]
    #[doc = "   supports resource validation, resource limitation on the device."]
    #[doc = ""]
    #[doc = "   -EBUSY: action cannot be performed due to busy device resources, may"]
    #[doc = "   succeed if the affected queues or even the entire port are in a stopped"]
    #[doc = "   state (see rte_eth_dev_rx_queue_stop() and rte_eth_dev_stop())."]
    pub fn rte_flow_validate(
        port_id: u16,
        attr: *const rte_flow_attr,
        pattern: *const rte_flow_item,
        actions: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a flow rule on a given port."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] attr"]
    #[doc = "   Flow rule attributes."]
    #[doc = " @param[in] pattern"]
    #[doc = "   Pattern specification (list terminated by the END pattern item)."]
    #[doc = " @param[in] actions"]
    #[doc = "   Associated actions (list terminated by the END action)."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   A valid handle in case of success, NULL otherwise and rte_errno is set"]
    #[doc = "   to the positive version of one of the error codes defined for"]
    #[doc = "   rte_flow_validate()."]
    pub fn rte_flow_create(
        port_id: u16,
        attr: *const rte_flow_attr,
        pattern: *const rte_flow_item,
        actions: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow;
}
extern "C" {
    #[doc = " Destroy a flow rule on a given port."]
    #[doc = ""]
    #[doc = " Failure to destroy a flow rule handle may occur when other flow rules"]
    #[doc = " depend on it, and destroying it would result in an inconsistent state."]
    #[doc = ""]
    #[doc = " This function is only guaranteed to succeed if handles are destroyed in"]
    #[doc = " reverse order of their creation."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param flow"]
    #[doc = "   Flow rule handle to destroy."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_destroy(
        port_id: u16,
        flow: *mut rte_flow,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy all flow rules associated with a port."]
    #[doc = ""]
    #[doc = " In the unlikely event of failure, handles are still considered destroyed"]
    #[doc = " and no longer valid but the port must be assumed to be in an inconsistent"]
    #[doc = " state."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_flush(port_id: u16, error: *mut rte_flow_error) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Query an existing flow rule."]
    #[doc = ""]
    #[doc = " This function allows retrieving flow-specific data such as counters."]
    #[doc = " Data is gathered by special actions which must be present in the flow"]
    #[doc = " rule definition."]
    #[doc = ""]
    #[doc = " \\see RTE_FLOW_ACTION_TYPE_COUNT"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param flow"]
    #[doc = "   Flow rule handle to query."]
    #[doc = " @param action"]
    #[doc = "   Action definition as defined in original flow rule."]
    #[doc = " @param[in, out] data"]
    #[doc = "   Pointer to storage for the associated query data type."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_query(
        port_id: u16,
        flow: *mut rte_flow,
        action: *const rte_flow_action,
        data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Restrict ingress traffic to the defined flow rules."]
    #[doc = ""]
    #[doc = " Isolated mode guarantees that all ingress traffic comes from defined flow"]
    #[doc = " rules only (current and future)."]
    #[doc = ""]
    #[doc = " Besides making ingress more deterministic, it allows PMDs to safely reuse"]
    #[doc = " resources otherwise assigned to handle the remaining traffic, such as"]
    #[doc = " global RSS configuration settings, VLAN filters, MAC address entries,"]
    #[doc = " legacy filter API rules and so on in order to expand the set of possible"]
    #[doc = " flow rule types."]
    #[doc = ""]
    #[doc = " Calling this function as soon as possible after device initialization,"]
    #[doc = " ideally before the first call to rte_eth_dev_configure(), is recommended"]
    #[doc = " to avoid possible failures due to conflicting settings."]
    #[doc = ""]
    #[doc = " Once effective, leaving isolated mode may not be possible depending on"]
    #[doc = " PMD implementation."]
    #[doc = ""]
    #[doc = " Additionally, the following functionality has no effect on the underlying"]
    #[doc = " port and may return errors such as ENOTSUP (\"not supported\"):"]
    #[doc = ""]
    #[doc = " - Toggling promiscuous mode."]
    #[doc = " - Toggling allmulticast mode."]
    #[doc = " - Configuring MAC addresses."]
    #[doc = " - Configuring multicast addresses."]
    #[doc = " - Configuring VLAN filters."]
    #[doc = " - Configuring Rx filters through the legacy API (e.g. FDIR)."]
    #[doc = " - Configuring global RSS settings."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param set"]
    #[doc = "   Nonzero to enter isolated mode, attempt to leave it otherwise."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_isolate(
        port_id: u16,
        set: ::std::os::raw::c_int,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize flow error structure."]
    #[doc = ""]
    #[doc = " @param[out] error"]
    #[doc = "   Pointer to flow error structure (may be NULL)."]
    #[doc = " @param code"]
    #[doc = "   Related error code (rte_errno)."]
    #[doc = " @param type"]
    #[doc = "   Cause field and error types."]
    #[doc = " @param cause"]
    #[doc = "   Object responsible for the error."]
    #[doc = " @param message"]
    #[doc = "   Human-readable error message."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Negative error code (errno value) and rte_errno is set."]
    pub fn rte_flow_error_set(
        error: *mut rte_flow_error,
        code: ::std::os::raw::c_int,
        type_: rte_flow_error_type,
        cause: *const ::std::os::raw::c_void,
        message: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @deprecated"]
#[doc = " @see rte_flow_copy()"]
#[repr(C)]
#[derive(Debug)]
pub struct rte_flow_desc {
    #[doc = "< Allocated space including data[]."]
    pub size: size_t,
    #[doc = "< Attributes."]
    pub attr: rte_flow_attr,
    #[doc = "< Items."]
    pub items: *mut rte_flow_item,
    #[doc = "< Actions."]
    pub actions: *mut rte_flow_action,
    #[doc = "< Storage for items/actions."]
    pub data: __IncompleteArrayField<u8>,
}
extern "C" {
    #[doc = " @deprecated"]
    #[doc = " Copy an rte_flow rule description."]
    #[doc = ""]
    #[doc = " This interface is kept for compatibility with older applications but is"]
    #[doc = " implemented as a wrapper to rte_flow_conv(). It is deprecated due to its"]
    #[doc = " lack of flexibility and reliance on a type unusable with C++ programs"]
    #[doc = " (struct rte_flow_desc)."]
    #[doc = ""]
    #[doc = " @param[in] fd"]
    #[doc = "   Flow rule description."]
    #[doc = " @param[in] len"]
    #[doc = "   Total size of allocated data for the flow description."]
    #[doc = " @param[in] attr"]
    #[doc = "   Flow rule attributes."]
    #[doc = " @param[in] items"]
    #[doc = "   Pattern specification (list terminated by the END pattern item)."]
    #[doc = " @param[in] actions"]
    #[doc = "   Associated actions (list terminated by the END action)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   If len is greater or equal to the size of the flow, the total size of the"]
    #[doc = "   flow description and its data."]
    #[doc = "   If len is lower than the size of the flow, the number of bytes that would"]
    #[doc = "   have been written to desc had it been sufficient. Nothing is written."]
    pub fn rte_flow_copy(
        fd: *mut rte_flow_desc,
        len: size_t,
        attr: *const rte_flow_attr,
        items: *const rte_flow_item,
        actions: *const rte_flow_action,
    ) -> size_t;
}
extern "C" {
    #[doc = " Flow object conversion helper."]
    #[doc = ""]
    #[doc = " This function performs conversion of various flow API objects to a"]
    #[doc = " pre-allocated destination buffer. See enum rte_flow_conv_op for possible"]
    #[doc = " operations and details about each of them."]
    #[doc = ""]
    #[doc = " Since destination buffer must be large enough, it works in a manner"]
    #[doc = " reminiscent of snprintf():"]
    #[doc = ""]
    #[doc = " - If @p size is 0, @p dst may be a NULL pointer, otherwise @p dst must be"]
    #[doc = "   non-NULL."]
    #[doc = " - If positive, the returned value represents the number of bytes needed"]
    #[doc = "   to store the conversion of @p src to @p dst according to @p op"]
    #[doc = "   regardless of the @p size parameter."]
    #[doc = " - Since no more than @p size bytes can be written to @p dst, output is"]
    #[doc = "   truncated and may be inconsistent when the returned value is larger"]
    #[doc = "   than that."]
    #[doc = " - In case of conversion error, a negative error code is returned and"]
    #[doc = "   @p dst contents are unspecified."]
    #[doc = ""]
    #[doc = " @param op"]
    #[doc = "   Operation to perform, related to the object type of @p dst."]
    #[doc = " @param[out] dst"]
    #[doc = "   Destination buffer address. Must be suitably aligned by the caller."]
    #[doc = " @param size"]
    #[doc = "   Destination buffer size in bytes."]
    #[doc = " @param[in] src"]
    #[doc = "   Source object to copy. Depending on @p op, its type may differ from"]
    #[doc = "   that of @p dst."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. Initialized in case of"]
    #[doc = "   error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The number of bytes required to convert @p src to @p dst on success, a"]
    #[doc = "   negative errno value otherwise and rte_errno is set."]
    #[doc = ""]
    #[doc = " @see rte_flow_conv_op"]
    pub fn rte_flow_conv(
        op: rte_flow_conv_op,
        dst: *mut ::std::os::raw::c_void,
        size: size_t,
        src: *const ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get aged-out flows of a given port."]
    #[doc = ""]
    #[doc = " RTE_ETH_EVENT_FLOW_AGED event will be triggered when at least one new aged"]
    #[doc = " out flow was detected after the last call to rte_flow_get_aged_flows."]
    #[doc = " This function can be called to get the aged flows asynchronously from the"]
    #[doc = " event callback or synchronously regardless the event."]
    #[doc = " This is not safe to call rte_flow_get_aged_flows function with other flow"]
    #[doc = " functions from multiple threads simultaneously."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in, out] contexts"]
    #[doc = "   The address of an array of pointers to the aged-out flows contexts."]
    #[doc = " @param[in] nb_contexts"]
    #[doc = "   The length of context array pointers."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. Initialized in case of"]
    #[doc = "   error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   if nb_contexts is 0, return the amount of all aged contexts."]
    #[doc = "   if nb_contexts is not 0 , return the amount of aged flows reported"]
    #[doc = "   in the context array, otherwise negative errno value."]
    #[doc = ""]
    #[doc = " @see rte_flow_action_age"]
    #[doc = " @see RTE_ETH_EVENT_FLOW_AGED"]
    pub fn rte_flow_get_aged_flows(
        port_id: u16,
        contexts: *mut *mut ::std::os::raw::c_void,
        nb_contexts: u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Specify indirect action object configuration"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_indir_action_conf {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl rte_flow_indir_action_conf {
    #[inline]
    pub fn ingress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transfer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transfer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ingress: u32,
        egress: u32,
        transfer: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ingress: u32 = unsafe { ::std::mem::transmute(ingress) };
            ingress as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let egress: u32 = unsafe { ::std::mem::transmute(egress) };
            egress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let transfer: u32 = unsafe { ::std::mem::transmute(transfer) };
            transfer as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Create an indirect action object that can be used in flow rules"]
    #[doc = " via its handle."]
    #[doc = " The created object handle has single state and configuration"]
    #[doc = " across all the flow rules using it."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "    The port identifier of the Ethernet device."]
    #[doc = " @param[in] conf"]
    #[doc = "   Action configuration for the indirect action object creation."]
    #[doc = " @param[in] action"]
    #[doc = "   Specific configuration of the indirect action object."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = " @return"]
    #[doc = "   A valid handle in case of success, NULL otherwise and rte_errno is set"]
    #[doc = "   to one of the error codes defined:"]
    #[doc = "   - (ENODEV) if *port_id* invalid."]
    #[doc = "   - (ENOSYS) if underlying device does not support this functionality."]
    #[doc = "   - (EIO) if underlying device is removed."]
    #[doc = "   - (EINVAL) if *action* invalid."]
    #[doc = "   - (ENOTSUP) if *action* valid but unsupported."]
    pub fn rte_flow_action_handle_create(
        port_id: u16,
        conf: *const rte_flow_indir_action_conf,
        action: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow_action_handle;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Destroy indirect action by handle."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "    The port identifier of the Ethernet device."]
    #[doc = " @param[in] handle"]
    #[doc = "   Handle for the indirect action object to be destroyed."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = " @return"]
    #[doc = "   - (0) if success."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-ENOSYS) if underlying device does not support this functionality."]
    #[doc = "   - (-EIO) if underlying device is removed."]
    #[doc = "   - (-ENOENT) if action pointed by *action* handle was not found."]
    #[doc = "   - (-EBUSY) if action pointed by *action* handle still used by some rules"]
    #[doc = "   rte_errno is also set."]
    pub fn rte_flow_action_handle_destroy(
        port_id: u16,
        handle: *mut rte_flow_action_handle,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Update in-place the action configuration and / or state pointed"]
    #[doc = " by action *handle* with the configuration provided as *update* argument."]
    #[doc = " The update of the action configuration effects all flow rules reusing"]
    #[doc = " the action via *handle*."]
    #[doc = " The update general pointer provides the ability of partial updating."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "    The port identifier of the Ethernet device."]
    #[doc = " @param[in] handle"]
    #[doc = "   Handle for the indirect action object to be updated."]
    #[doc = " @param[in] update"]
    #[doc = "   Update profile specification used to modify the action pointed by handle."]
    #[doc = "   *update* could be with the same type of the immediate action corresponding"]
    #[doc = "   to the *handle* argument when creating, or a wrapper structure includes"]
    #[doc = "   action configuration to be updated and bit fields to indicate the member"]
    #[doc = "   of fields inside the action to update."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = " @return"]
    #[doc = "   - (0) if success."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-ENOSYS) if underlying device does not support this functionality."]
    #[doc = "   - (-EIO) if underlying device is removed."]
    #[doc = "   - (-EINVAL) if *update* invalid."]
    #[doc = "   - (-ENOTSUP) if *update* valid but unsupported."]
    #[doc = "   - (-ENOENT) if indirect action object pointed by *handle* was not found."]
    #[doc = "   rte_errno is also set."]
    pub fn rte_flow_action_handle_update(
        port_id: u16,
        handle: *mut rte_flow_action_handle,
        update: *const ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Query the direct action by corresponding indirect action object handle."]
    #[doc = ""]
    #[doc = " Retrieve action-specific data such as counters."]
    #[doc = " Data is gathered by special action which may be present/referenced in"]
    #[doc = " more than one flow rule definition."]
    #[doc = ""]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_COUNT"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] handle"]
    #[doc = "   Handle for the action object to query."]
    #[doc = " @param[in, out] data"]
    #[doc = "   Pointer to storage for the associated query data type."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_action_handle_query(
        port_id: u16,
        handle: *const rte_flow_action_handle,
        data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_tunnel {
    #[doc = " Tunnel type, for example RTE_FLOW_ITEM_TYPE_VXLAN,"]
    #[doc = " RTE_FLOW_ITEM_TYPE_NVGRE etc."]
    pub type_: rte_flow_item_type,
    #[doc = "< Tunnel identification."]
    pub tun_id: u64,
    pub __bindgen_anon_1: rte_flow_tunnel__bindgen_ty_1,
    #[doc = "< Tunnel port source."]
    pub tp_src: rte_be16_t,
    #[doc = "< Tunnel port destination."]
    pub tp_dst: rte_be16_t,
    #[doc = "< Tunnel flags."]
    pub tun_flags: u16,
    #[doc = "< True for valid IPv6 fields. Otherwise IPv4."]
    pub is_ipv6: bool,
    #[doc = "< TOS for IPv4, TC for IPv6."]
    pub tos: u8,
    #[doc = "< TTL for IPv4, HL for IPv6."]
    pub ttl: u8,
    #[doc = "< Flow Label for IPv6."]
    pub label: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_tunnel__bindgen_ty_1 {
    pub ipv4: rte_flow_tunnel__bindgen_ty_1__bindgen_ty_1,
    pub ipv6: rte_flow_tunnel__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_tunnel__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< IPv4 source address."]
    pub src_addr: rte_be32_t,
    #[doc = "< IPv4 destination address."]
    pub dst_addr: rte_be32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_tunnel__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< IPv6 source address."]
    pub src_addr: [u8; 16usize],
    #[doc = "< IPv6 destination address."]
    pub dst_addr: [u8; 16usize],
}
#[doc = " Restore information structure to communicate the current packet processing"]
#[doc = " state when some of the processing pipeline is done in hardware and should"]
#[doc = " continue in software."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_restore_info {
    #[doc = " Bitwise flags (RTE_FLOW_RESTORE_INFO_*) to indicate validation of"]
    #[doc = " other fields in struct rte_flow_restore_info."]
    pub flags: u64,
    #[doc = "< Group ID where packed missed"]
    pub group_id: u32,
    #[doc = "< Tunnel information."]
    pub tunnel: rte_flow_tunnel,
}
extern "C" {
    #[doc = " Allocate an array of actions to be used in rte_flow_create, to implement"]
    #[doc = " tunnel-decap-set for the given tunnel."]
    #[doc = " Sample usage:"]
    #[doc = "   actions vxlan_decap / tunnel-decap-set(tunnel properties) /"]
    #[doc = "            jump group 0 / end"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] tunnel"]
    #[doc = "   Tunnel properties."]
    #[doc = " @param[out] actions"]
    #[doc = "   Array of actions to be allocated by the PMD. This array should be"]
    #[doc = "   concatenated with the actions array provided to rte_flow_create."]
    #[doc = " @param[out] num_of_actions"]
    #[doc = "   Number of actions allocated."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_tunnel_decap_set(
        port_id: u16,
        tunnel: *mut rte_flow_tunnel,
        actions: *mut *mut rte_flow_action,
        num_of_actions: *mut u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate an array of items to be used in rte_flow_create, to implement"]
    #[doc = " tunnel-match for the given tunnel."]
    #[doc = " Sample usage:"]
    #[doc = "   pattern tunnel-match(tunnel properties) / outer-header-matches /"]
    #[doc = "           inner-header-matches / end"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] tunnel"]
    #[doc = "   Tunnel properties."]
    #[doc = " @param[out] items"]
    #[doc = "   Array of items to be allocated by the PMD. This array should be"]
    #[doc = "   concatenated with the items array provided to rte_flow_create."]
    #[doc = " @param[out] num_of_items"]
    #[doc = "   Number of items allocated."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_tunnel_match(
        port_id: u16,
        tunnel: *mut rte_flow_tunnel,
        items: *mut *mut rte_flow_item,
        num_of_items: *mut u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Populate the current packet processing state, if exists, for the given mbuf."]
    #[doc = ""]
    #[doc = " One should negotiate tunnel metadata delivery from the NIC to the HW."]
    #[doc = " @see rte_eth_rx_metadata_negotiate()"]
    #[doc = " @see RTE_ETH_RX_METADATA_TUNNEL_ID"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] m"]
    #[doc = "   Mbuf struct."]
    #[doc = " @param[out] info"]
    #[doc = "   Restore information. Upon success contains the HW state."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_get_restore_info(
        port_id: u16,
        m: *mut rte_mbuf,
        info: *mut rte_flow_restore_info,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release the action array as allocated by rte_flow_tunnel_decap_set."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] actions"]
    #[doc = "   Array of actions to be released."]
    #[doc = " @param[in] num_of_actions"]
    #[doc = "   Number of elements in actions array."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_tunnel_action_decap_release(
        port_id: u16,
        actions: *mut rte_flow_action,
        num_of_actions: u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release the item array as allocated by rte_flow_tunnel_match."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] items"]
    #[doc = "   Array of items to be released."]
    #[doc = " @param[in] num_of_items"]
    #[doc = "   Number of elements in item array."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_tunnel_item_release(
        port_id: u16,
        items: *mut rte_flow_item,
        num_of_items: u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Get a proxy port to manage \"transfer\" flows."]
    #[doc = ""]
    #[doc = " Managing \"transfer\" flows requires that the user communicate them"]
    #[doc = " via a port which has the privilege to control the embedded switch."]
    #[doc = " For some vendors, all ports in a given switching domain have"]
    #[doc = " this privilege. For other vendors, it's only one port."]
    #[doc = ""]
    #[doc = " This API indicates such a privileged port (a \"proxy\")"]
    #[doc = " for a given port in the same switching domain."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "   If the PMD serving @p port_id doesn't have the corresponding method"]
    #[doc = "   implemented, the API will return @p port_id via @p proxy_port_id."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Indicates the port to get a \"proxy\" for"]
    #[doc = " @param[out] proxy_port_id"]
    #[doc = "   Indicates the \"proxy\" port"]
    #[doc = " @param[out] error"]
    #[doc = "   If not NULL, allows the PMD to provide verbose report in case of error"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative error code otherwise"]
    pub fn rte_flow_pick_transfer_proxy(
        port_id: u16,
        proxy_port_id: *mut u16,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Create the flex item with specified configuration over"]
    #[doc = " the Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] conf"]
    #[doc = "   Item configuration."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Non-NULL opaque pointer on success, NULL otherwise and rte_errno is set."]
    pub fn rte_flow_flex_item_create(
        port_id: u16,
        conf: *const rte_flow_item_flex_conf,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow_item_flex_handle;
}
extern "C" {
    #[doc = " Release the flex item on the specified Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] handle"]
    #[doc = "   Handle of the item existing on the specified device."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_flex_item_release(
        port_id: u16,
        handle: *const rte_flow_item_flex_handle,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
#[doc = ""]
#[doc = " Information about flow engine resources."]
#[doc = " The zero value means a resource is not supported."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_port_info {
    #[doc = " Maximum number of queues for asynchronous operations."]
    pub max_nb_queues: u32,
    #[doc = " Maximum number of counters."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_COUNT"]
    pub max_nb_counters: u32,
    #[doc = " Maximum number of aging objects."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_AGE"]
    pub max_nb_aging_objects: u32,
    #[doc = " Maximum number traffic meters."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_METER"]
    pub max_nb_meters: u32,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
#[doc = ""]
#[doc = " Information about flow engine asynchronous queues."]
#[doc = " The value only valid if @p port_attr.max_nb_queues is not zero."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_queue_info {
    #[doc = " Maximum number of operations a queue can hold."]
    pub max_size: u32,
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Get information about flow engine resources."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[out] port_info"]
    #[doc = "   A pointer to a structure of type *rte_flow_port_info*"]
    #[doc = "   to be filled with the resources information of the port."]
    #[doc = " @param[out] queue_info"]
    #[doc = "   A pointer to a structure of type *rte_flow_queue_info*"]
    #[doc = "   to be filled with the asynchronous queues information."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL."]
    #[doc = "   PMDs initialize this structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_info_get(
        port_id: u16,
        port_info: *mut rte_flow_port_info,
        queue_info: *mut rte_flow_queue_info,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
#[doc = ""]
#[doc = " Flow engine resources settings."]
#[doc = " The zero value means on demand resource allocations only."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_port_attr {
    #[doc = " Number of counters to configure."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_COUNT"]
    pub nb_counters: u32,
    #[doc = " Number of aging objects to configure."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_AGE"]
    pub nb_aging_objects: u32,
    #[doc = " Number of traffic meters to configure."]
    #[doc = " @see RTE_FLOW_ACTION_TYPE_METER"]
    pub nb_meters: u32,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
#[doc = ""]
#[doc = " Flow engine asynchronous queues settings."]
#[doc = " The value means default value picked by PMD."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_queue_attr {
    #[doc = " Number of flow rule operations a queue can hold."]
    pub size: u32,
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Configure the port's flow API engine."]
    #[doc = ""]
    #[doc = " This API can only be invoked before the application"]
    #[doc = " starts using the rest of the flow library functions."]
    #[doc = ""]
    #[doc = " The API can be invoked multiple times to change the settings."]
    #[doc = " The port, however, may reject changes and keep the old config."]
    #[doc = ""]
    #[doc = " Parameters in configuration attributes must not exceed"]
    #[doc = " numbers of resources returned by the rte_flow_info_get API."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] port_attr"]
    #[doc = "   Port configuration attributes."]
    #[doc = " @param[in] nb_queue"]
    #[doc = "   Number of flow queues to be configured."]
    #[doc = " @param[in] queue_attr"]
    #[doc = "   Array that holds attributes for each flow queue."]
    #[doc = "   Number of elements is set in @p port_attr.nb_queues."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL."]
    #[doc = "   PMDs initialize this structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_configure(
        port_id: u16,
        port_attr: *const rte_flow_port_attr,
        nb_queue: u16,
        queue_attr: *mut *const rte_flow_queue_attr,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Opaque type returned after successful creation of pattern template."]
#[doc = " This handle can be used to manage the created pattern template."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_pattern_template {
    _unused: [u8; 0],
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
#[doc = ""]
#[doc = " Flow pattern template attributes."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_pattern_template_attr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl rte_flow_pattern_template_attr {
    #[inline]
    pub fn relaxed_matching(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_relaxed_matching(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ingress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transfer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transfer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        relaxed_matching: u32,
        ingress: u32,
        egress: u32,
        transfer: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let relaxed_matching: u32 = unsafe { ::std::mem::transmute(relaxed_matching) };
            relaxed_matching as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ingress: u32 = unsafe { ::std::mem::transmute(ingress) };
            ingress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let egress: u32 = unsafe { ::std::mem::transmute(egress) };
            egress as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let transfer: u32 = unsafe { ::std::mem::transmute(transfer) };
            transfer as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Create flow pattern template."]
    #[doc = ""]
    #[doc = " The pattern template defines common matching fields without values."]
    #[doc = " For example, matching on 5 tuple TCP flow, the template will be"]
    #[doc = " eth(null) + IPv4(source + dest) + TCP(s_port + d_port),"]
    #[doc = " while values for each rule will be set during the flow rule creation."]
    #[doc = " The number and order of items in the template must be the same"]
    #[doc = " at the rule creation."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] template_attr"]
    #[doc = "   Pattern template attributes."]
    #[doc = " @param[in] pattern"]
    #[doc = "   Pattern specification (list terminated by the END pattern item)."]
    #[doc = "   The spec member of an item is not used unless the end member is used."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL."]
    #[doc = "   PMDs initialize this structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Handle on success, NULL otherwise and rte_errno is set."]
    pub fn rte_flow_pattern_template_create(
        port_id: u16,
        template_attr: *const rte_flow_pattern_template_attr,
        pattern: *const rte_flow_item,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow_pattern_template;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Destroy flow pattern template."]
    #[doc = ""]
    #[doc = " This function may be called only when"]
    #[doc = " there are no more tables referencing this template."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] pattern_template"]
    #[doc = "   Handle of the template to be destroyed."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL."]
    #[doc = "   PMDs initialize this structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_pattern_template_destroy(
        port_id: u16,
        pattern_template: *mut rte_flow_pattern_template,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Opaque type returned after successful creation of actions template."]
#[doc = " This handle can be used to manage the created actions template."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_actions_template {
    _unused: [u8; 0],
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
#[doc = ""]
#[doc = " Flow actions template attributes."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_actions_template_attr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl rte_flow_actions_template_attr {
    #[inline]
    pub fn ingress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transfer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transfer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ingress: u32,
        egress: u32,
        transfer: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ingress: u32 = unsafe { ::std::mem::transmute(ingress) };
            ingress as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let egress: u32 = unsafe { ::std::mem::transmute(egress) };
            egress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let transfer: u32 = unsafe { ::std::mem::transmute(transfer) };
            transfer as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Create flow actions template."]
    #[doc = ""]
    #[doc = " The actions template holds a list of action types without values."]
    #[doc = " For example, the template to change TCP ports is TCP(s_port + d_port),"]
    #[doc = " while values for each rule will be set during the flow rule creation."]
    #[doc = " The number and order of actions in the template must be the same"]
    #[doc = " at the rule creation."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] template_attr"]
    #[doc = "   Template attributes."]
    #[doc = " @param[in] actions"]
    #[doc = "   Associated actions (list terminated by the END action)."]
    #[doc = "   The spec member is only used if @p masks spec is non-zero."]
    #[doc = " @param[in] masks"]
    #[doc = "   List of actions that marks which of the action's member is constant."]
    #[doc = "   A mask has the same format as the corresponding action."]
    #[doc = "   If the action field in @p masks is not 0,"]
    #[doc = "   the corresponding value in an action from @p actions will be the part"]
    #[doc = "   of the template and used in all flow rules."]
    #[doc = "   The order of actions in @p masks is the same as in @p actions."]
    #[doc = "   In case of indirect actions present in @p actions,"]
    #[doc = "   the actual action type should be present in @p mask."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL."]
    #[doc = "   PMDs initialize this structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Handle on success, NULL otherwise and rte_errno is set."]
    pub fn rte_flow_actions_template_create(
        port_id: u16,
        template_attr: *const rte_flow_actions_template_attr,
        actions: *const rte_flow_action,
        masks: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow_actions_template;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Destroy flow actions template."]
    #[doc = ""]
    #[doc = " This function may be called only when"]
    #[doc = " there are no more tables referencing this template."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] actions_template"]
    #[doc = "   Handle to the template to be destroyed."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL."]
    #[doc = "   PMDs initialize this structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_actions_template_destroy(
        port_id: u16,
        actions_template: *mut rte_flow_actions_template,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Opaque type returned after successful creation of a template table."]
#[doc = " This handle can be used to manage the created template table."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_template_table {
    _unused: [u8; 0],
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
#[doc = ""]
#[doc = " Table attributes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_template_table_attr {
    #[doc = " Flow attributes to be used in each rule generated from this table."]
    pub flow_attr: rte_flow_attr,
    #[doc = " Maximum number of flow rules that this table holds."]
    pub nb_flows: u32,
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Create flow template table."]
    #[doc = ""]
    #[doc = " A template table consists of multiple pattern templates and actions"]
    #[doc = " templates associated with a single set of rule attributes (group ID,"]
    #[doc = " priority and traffic direction)."]
    #[doc = ""]
    #[doc = " Each rule is free to use any combination of pattern and actions templates"]
    #[doc = " and specify particular values for items and actions it would like to change."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] table_attr"]
    #[doc = "   Template table attributes."]
    #[doc = " @param[in] pattern_templates"]
    #[doc = "   Array of pattern templates to be used in this table."]
    #[doc = " @param[in] nb_pattern_templates"]
    #[doc = "   The number of pattern templates in the pattern_templates array."]
    #[doc = " @param[in] actions_templates"]
    #[doc = "   Array of actions templates to be used in this table."]
    #[doc = " @param[in] nb_actions_templates"]
    #[doc = "   The number of actions templates in the actions_templates array."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL."]
    #[doc = "   PMDs initialize this structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Handle on success, NULL otherwise and rte_errno is set."]
    pub fn rte_flow_template_table_create(
        port_id: u16,
        table_attr: *const rte_flow_template_table_attr,
        pattern_templates: *mut *mut rte_flow_pattern_template,
        nb_pattern_templates: u8,
        actions_templates: *mut *mut rte_flow_actions_template,
        nb_actions_templates: u8,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow_template_table;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Destroy flow template table."]
    #[doc = ""]
    #[doc = " This function may be called only when"]
    #[doc = " there are no more flow rules referencing this table."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] template_table"]
    #[doc = "   Handle to the table to be destroyed."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL."]
    #[doc = "   PMDs initialize this structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_template_table_destroy(
        port_id: u16,
        template_table: *mut rte_flow_template_table,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
#[doc = ""]
#[doc = " Asynchronous operation attributes."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_op_attr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl rte_flow_op_attr {
    #[inline]
    pub fn postpone(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_postpone(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(postpone: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let postpone: u32 = unsafe { ::std::mem::transmute(postpone) };
            postpone as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Enqueue rule creation operation."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   Flow queue used to insert the rule."]
    #[doc = " @param[in] op_attr"]
    #[doc = "   Rule creation operation attributes."]
    #[doc = " @param[in] template_table"]
    #[doc = "   Template table to select templates from."]
    #[doc = " @param[in] pattern"]
    #[doc = "   List of pattern items to be used."]
    #[doc = "   The list order should match the order in the pattern template."]
    #[doc = "   The spec is the only relevant member of the item that is being used."]
    #[doc = " @param[in] pattern_template_index"]
    #[doc = "   Pattern template index in the table."]
    #[doc = " @param[in] actions"]
    #[doc = "   List of actions to be used."]
    #[doc = "   The list order should match the order in the actions template."]
    #[doc = " @param[in] actions_template_index"]
    #[doc = "   Actions template index in the table."]
    #[doc = " @param[in] user_data"]
    #[doc = "   The user data that will be returned on the completion events."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL."]
    #[doc = "   PMDs initialize this structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Handle on success, NULL otherwise and rte_errno is set."]
    #[doc = "   The rule handle doesn't mean that the rule has been populated."]
    #[doc = "   Only completion result indicates that if there was success or failure."]
    pub fn rte_flow_async_create(
        port_id: u16,
        queue_id: u32,
        op_attr: *const rte_flow_op_attr,
        template_table: *mut rte_flow_template_table,
        pattern: *const rte_flow_item,
        pattern_template_index: u8,
        actions: *const rte_flow_action,
        actions_template_index: u8,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Enqueue rule destruction operation."]
    #[doc = ""]
    #[doc = " This function enqueues a destruction operation on the queue."]
    #[doc = " Application should assume that after calling this function"]
    #[doc = " the rule handle is not valid anymore."]
    #[doc = " Completion indicates the full removal of the rule from the HW."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   Flow queue which is used to destroy the rule."]
    #[doc = "   This must match the queue on which the rule was created."]
    #[doc = " @param[in] op_attr"]
    #[doc = "   Rule destruction operation attributes."]
    #[doc = " @param[in] flow"]
    #[doc = "   Flow handle to be destroyed."]
    #[doc = " @param[in] user_data"]
    #[doc = "   The user data that will be returned on the completion events."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL."]
    #[doc = "   PMDs initialize this structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_async_destroy(
        port_id: u16,
        queue_id: u32,
        op_attr: *const rte_flow_op_attr,
        flow: *mut rte_flow,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Push all internally stored rules to the HW."]
    #[doc = " Postponed rules are rules that were inserted with the postpone flag set."]
    #[doc = " Can be used to notify the HW about batch of rules prepared by the SW to"]
    #[doc = " reduce the number of communications between the HW and SW."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   Flow queue to be pushed."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL."]
    #[doc = "   PMDs initialize this structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_push(
        port_id: u16,
        queue_id: u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
#[doc = ""]
#[doc = " Asynchronous operation status."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_flow_op_status {
    #[doc = " The operation was completed successfully."]
    RTE_FLOW_OP_SUCCESS = 0,
    #[doc = " The operation was not completed successfully."]
    RTE_FLOW_OP_ERROR = 1,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
#[doc = ""]
#[doc = " Asynchronous operation result."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_op_result {
    #[doc = " Returns the status of the operation that this completion signals."]
    pub status: rte_flow_op_status,
    #[doc = " The user data that will be returned on the completion events."]
    pub user_data: *mut ::std::os::raw::c_void,
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Pull a rte flow operation."]
    #[doc = " The application must invoke this function in order to complete"]
    #[doc = " the flow rule offloading and to retrieve the flow rule operation status."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   Flow queue which is used to pull the operation."]
    #[doc = " @param[out] res"]
    #[doc = "   Array of results that will be set."]
    #[doc = " @param[in] n_res"]
    #[doc = "   Maximum number of results that can be returned."]
    #[doc = "   This value is equal to the size of the res array."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL."]
    #[doc = "   PMDs initialize this structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Number of results that were pulled,"]
    #[doc = "   a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_pull(
        port_id: u16,
        queue_id: u32,
        res: *mut rte_flow_op_result,
        n_res: u16,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Enqueue indirect action creation operation."]
    #[doc = " @see rte_flow_action_handle_create"]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] queue_id"]
    #[doc = "   Flow queue which is used to create the rule."]
    #[doc = " @param[in] op_attr"]
    #[doc = "   Indirect action creation operation attributes."]
    #[doc = " @param[in] indir_action_conf"]
    #[doc = "   Action configuration for the indirect action object creation."]
    #[doc = " @param[in] action"]
    #[doc = "   Specific configuration of the indirect action object."]
    #[doc = " @param[in] user_data"]
    #[doc = "   The user data that will be returned on the completion events."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL."]
    #[doc = "   PMDs initialize this structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   A valid handle in case of success, NULL otherwise and rte_errno is set."]
    pub fn rte_flow_async_action_handle_create(
        port_id: u16,
        queue_id: u32,
        op_attr: *const rte_flow_op_attr,
        indir_action_conf: *const rte_flow_indir_action_conf,
        action: *const rte_flow_action,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow_action_handle;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Enqueue indirect action destruction operation."]
    #[doc = " The destroy queue must be the same"]
    #[doc = " as the queue on which the action was created."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] queue_id"]
    #[doc = "   Flow queue which is used to destroy the rule."]
    #[doc = " @param[in] op_attr"]
    #[doc = "   Indirect action destruction operation attributes."]
    #[doc = " @param[in] action_handle"]
    #[doc = "   Handle for the indirect action object to be destroyed."]
    #[doc = " @param[in] user_data"]
    #[doc = "   The user data that will be returned on the completion events."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL."]
    #[doc = "   PMDs initialize this structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_async_action_handle_destroy(
        port_id: u16,
        queue_id: u32,
        op_attr: *const rte_flow_op_attr,
        action_handle: *mut rte_flow_action_handle,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Enqueue indirect action update operation."]
    #[doc = " @see rte_flow_action_handle_create"]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] queue_id"]
    #[doc = "   Flow queue which is used to update the rule."]
    #[doc = " @param[in] op_attr"]
    #[doc = "   Indirect action update operation attributes."]
    #[doc = " @param[in] action_handle"]
    #[doc = "   Handle for the indirect action object to be updated."]
    #[doc = " @param[in] update"]
    #[doc = "   Update profile specification used to modify the action pointed by handle."]
    #[doc = "   *update* could be with the same type of the immediate action corresponding"]
    #[doc = "   to the *handle* argument when creating, or a wrapper structure includes"]
    #[doc = "   action configuration to be updated and bit fields to indicate the member"]
    #[doc = "   of fields inside the action to update."]
    #[doc = " @param[in] user_data"]
    #[doc = "   The user data that will be returned on the completion events."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL."]
    #[doc = "   PMDs initialize this structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_async_action_handle_update(
        port_id: u16,
        queue_id: u32,
        op_attr: *const rte_flow_op_attr,
        action_handle: *mut rte_flow_action_handle,
        update: *const ::std::os::raw::c_void,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " A structure used to define the ntuple filter entry"]
#[doc = " to support RTE_ETH_FILTER_NTUPLE data representation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_ntuple_filter {
    #[doc = "< Flags from RTE_NTUPLE_FLAGS_*"]
    pub flags: u16,
    #[doc = "< Destination IP address in big endian."]
    pub dst_ip: u32,
    #[doc = "< Mask of destination IP address."]
    pub dst_ip_mask: u32,
    #[doc = "< Source IP address in big endian."]
    pub src_ip: u32,
    #[doc = "< Mask of destination IP address."]
    pub src_ip_mask: u32,
    #[doc = "< Destination port in big endian."]
    pub dst_port: u16,
    #[doc = "< Mask of destination port."]
    pub dst_port_mask: u16,
    #[doc = "< Source Port in big endian."]
    pub src_port: u16,
    #[doc = "< Mask of source port."]
    pub src_port_mask: u16,
    #[doc = "< L4 protocol."]
    pub proto: u8,
    #[doc = "< Mask of L4 protocol."]
    pub proto_mask: u8,
    #[doc = " tcp_flags only meaningful when the proto is TCP."]
    #[doc = "The packet matched above ntuple fields and contain"]
    #[doc = "any set bit in tcp_flags will hit this filter."]
    pub tcp_flags: u8,
    #[doc = "< seven levels (001b-111b), 111b is highest,"]
    #[doc = "used when more than one filter matches."]
    pub priority: u16,
    #[doc = "< Queue assigned to when match"]
    pub queue: u16,
}
#[repr(u32)]
#[doc = " Input set fields for Flow Director and Hash filters"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_eth_input_set_field {
    RTE_ETH_INPUT_SET_UNKNOWN = 0,
    RTE_ETH_INPUT_SET_L2_SRC_MAC = 1,
    RTE_ETH_INPUT_SET_L2_DST_MAC = 2,
    RTE_ETH_INPUT_SET_L2_OUTER_VLAN = 3,
    RTE_ETH_INPUT_SET_L2_INNER_VLAN = 4,
    RTE_ETH_INPUT_SET_L2_ETHERTYPE = 5,
    RTE_ETH_INPUT_SET_L3_SRC_IP4 = 129,
    RTE_ETH_INPUT_SET_L3_DST_IP4 = 130,
    RTE_ETH_INPUT_SET_L3_SRC_IP6 = 131,
    RTE_ETH_INPUT_SET_L3_DST_IP6 = 132,
    RTE_ETH_INPUT_SET_L3_IP4_TOS = 133,
    RTE_ETH_INPUT_SET_L3_IP4_PROTO = 134,
    RTE_ETH_INPUT_SET_L3_IP6_TC = 135,
    RTE_ETH_INPUT_SET_L3_IP6_NEXT_HEADER = 136,
    RTE_ETH_INPUT_SET_L3_IP4_TTL = 137,
    RTE_ETH_INPUT_SET_L3_IP6_HOP_LIMITS = 138,
    RTE_ETH_INPUT_SET_L4_UDP_SRC_PORT = 257,
    RTE_ETH_INPUT_SET_L4_UDP_DST_PORT = 258,
    RTE_ETH_INPUT_SET_L4_TCP_SRC_PORT = 259,
    RTE_ETH_INPUT_SET_L4_TCP_DST_PORT = 260,
    RTE_ETH_INPUT_SET_L4_SCTP_SRC_PORT = 261,
    RTE_ETH_INPUT_SET_L4_SCTP_DST_PORT = 262,
    RTE_ETH_INPUT_SET_L4_SCTP_VERIFICATION_TAG = 263,
    RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_DST_MAC = 385,
    RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_SRC_MAC = 386,
    RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_VLAN = 387,
    RTE_ETH_INPUT_SET_TUNNEL_L4_UDP_KEY = 388,
    RTE_ETH_INPUT_SET_TUNNEL_GRE_KEY = 389,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_1ST_WORD = 641,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_2ND_WORD = 642,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_3RD_WORD = 643,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_4TH_WORD = 644,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_5TH_WORD = 645,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_6TH_WORD = 646,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_7TH_WORD = 647,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_8TH_WORD = 648,
    RTE_ETH_INPUT_SET_DEFAULT = 65533,
    RTE_ETH_INPUT_SET_NONE = 65534,
    RTE_ETH_INPUT_SET_MAX = 65535,
}
#[repr(u32)]
#[doc = " Filters input set operations"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_filter_input_set_op {
    RTE_ETH_INPUT_SET_OP_UNKNOWN = 0,
    #[doc = "< select input set"]
    RTE_ETH_INPUT_SET_SELECT = 1,
    #[doc = "< add input set entry"]
    RTE_ETH_INPUT_SET_ADD = 2,
    RTE_ETH_INPUT_SET_OP_MAX = 3,
}
#[doc = " A structure used to define the input set configuration for"]
#[doc = " flow director and hash filters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_input_set_conf {
    pub flow_type: u16,
    pub inset_size: u16,
    pub field: [rte_eth_input_set_field; 128usize],
    pub op: rte_filter_input_set_op,
}
#[doc = " A structure used to define the input for L2 flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_l2_flow {
    #[doc = "< Ether type in big endian"]
    pub ether_type: u16,
}
#[doc = " A structure used to define the input for IPV4 flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_ipv4_flow {
    #[doc = "< IPv4 source address in big endian."]
    pub src_ip: u32,
    #[doc = "< IPv4 destination address in big endian."]
    pub dst_ip: u32,
    #[doc = "< Type of service to match."]
    pub tos: u8,
    #[doc = "< Time to live to match."]
    pub ttl: u8,
    #[doc = "< Protocol, next header in big endian."]
    pub proto: u8,
}
#[doc = " A structure used to define the input for IPV4 UDP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_udpv4_flow {
    #[doc = "< IPv4 fields to match."]
    pub ip: rte_eth_ipv4_flow,
    #[doc = "< UDP source port in big endian."]
    pub src_port: u16,
    #[doc = "< UDP destination port in big endian."]
    pub dst_port: u16,
}
#[doc = " A structure used to define the input for IPV4 TCP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_tcpv4_flow {
    #[doc = "< IPv4 fields to match."]
    pub ip: rte_eth_ipv4_flow,
    #[doc = "< TCP source port in big endian."]
    pub src_port: u16,
    #[doc = "< TCP destination port in big endian."]
    pub dst_port: u16,
}
#[doc = " A structure used to define the input for IPV4 SCTP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_sctpv4_flow {
    #[doc = "< IPv4 fields to match."]
    pub ip: rte_eth_ipv4_flow,
    #[doc = "< SCTP source port in big endian."]
    pub src_port: u16,
    #[doc = "< SCTP destination port in big endian."]
    pub dst_port: u16,
    #[doc = "< Verify tag in big endian"]
    pub verify_tag: u32,
}
#[doc = " A structure used to define the input for IPV6 flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_ipv6_flow {
    #[doc = "< IPv6 source address in big endian."]
    pub src_ip: [u32; 4usize],
    #[doc = "< IPv6 destination address in big endian."]
    pub dst_ip: [u32; 4usize],
    #[doc = "< Traffic class to match."]
    pub tc: u8,
    #[doc = "< Protocol, next header to match."]
    pub proto: u8,
    #[doc = "< Hop limits to match."]
    pub hop_limits: u8,
}
#[doc = " A structure used to define the input for IPV6 UDP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_udpv6_flow {
    #[doc = "< IPv6 fields to match."]
    pub ip: rte_eth_ipv6_flow,
    #[doc = "< UDP source port in big endian."]
    pub src_port: u16,
    #[doc = "< UDP destination port in big endian."]
    pub dst_port: u16,
}
#[doc = " A structure used to define the input for IPV6 TCP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_tcpv6_flow {
    #[doc = "< IPv6 fields to match."]
    pub ip: rte_eth_ipv6_flow,
    #[doc = "< TCP source port to in big endian."]
    pub src_port: u16,
    #[doc = "< TCP destination port in big endian."]
    pub dst_port: u16,
}
#[doc = " A structure used to define the input for IPV6 SCTP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_sctpv6_flow {
    #[doc = "< IPv6 fields to match."]
    pub ip: rte_eth_ipv6_flow,
    #[doc = "< SCTP source port in big endian."]
    pub src_port: u16,
    #[doc = "< SCTP destination port in big endian."]
    pub dst_port: u16,
    #[doc = "< Verify tag in big endian."]
    pub verify_tag: u32,
}
#[doc = " A structure used to define the input for MAC VLAN flow"]
#[repr(C)]
pub struct rte_eth_mac_vlan_flow {
    #[doc = "< Mac address to match."]
    pub mac_addr: rte_ether_addr,
}
#[repr(u32)]
#[doc = " Tunnel type for flow director."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_eth_fdir_tunnel_type {
    RTE_FDIR_TUNNEL_TYPE_UNKNOWN = 0,
    RTE_FDIR_TUNNEL_TYPE_NVGRE = 1,
    RTE_FDIR_TUNNEL_TYPE_VXLAN = 2,
}
#[doc = " A structure used to define the input for tunnel flow, now it's VxLAN or"]
#[doc = " NVGRE"]
#[repr(C)]
pub struct rte_eth_tunnel_flow {
    #[doc = "< Tunnel type to match."]
    pub tunnel_type: rte_eth_fdir_tunnel_type,
    #[doc = " Tunnel ID to match. TNI, VNI... in big endian."]
    pub tunnel_id: u32,
    #[doc = "< Mac address to match."]
    pub mac_addr: rte_ether_addr,
}
#[doc = " An union contains the inputs for all types of flow"]
#[doc = " Items in flows need to be in big endian"]
#[repr(C)]
pub struct rte_eth_fdir_flow {
    pub l2_flow: __BindgenUnionField<rte_eth_l2_flow>,
    pub udp4_flow: __BindgenUnionField<rte_eth_udpv4_flow>,
    pub tcp4_flow: __BindgenUnionField<rte_eth_tcpv4_flow>,
    pub sctp4_flow: __BindgenUnionField<rte_eth_sctpv4_flow>,
    pub ip4_flow: __BindgenUnionField<rte_eth_ipv4_flow>,
    pub udp6_flow: __BindgenUnionField<rte_eth_udpv6_flow>,
    pub tcp6_flow: __BindgenUnionField<rte_eth_tcpv6_flow>,
    pub sctp6_flow: __BindgenUnionField<rte_eth_sctpv6_flow>,
    pub ipv6_flow: __BindgenUnionField<rte_eth_ipv6_flow>,
    pub mac_vlan_flow: __BindgenUnionField<rte_eth_mac_vlan_flow>,
    pub tunnel_flow: __BindgenUnionField<rte_eth_tunnel_flow>,
    pub bindgen_union_field: [u32; 11usize],
}
#[doc = " A structure used to contain extend input of flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_flow_ext {
    pub vlan_tci: u16,
    pub flexbytes: [u8; 16usize],
    #[doc = "< 1 for VF, 0 for port dev"]
    pub is_vf: u8,
    #[doc = "< VF ID, available when is_vf is 1"]
    pub dst_id: u16,
}
#[doc = " A structure used to define the input for a flow director filter entry"]
#[repr(C)]
pub struct rte_eth_fdir_input {
    pub flow_type: u16,
    pub flow: rte_eth_fdir_flow,
    pub flow_ext: rte_eth_fdir_flow_ext,
}
#[repr(u32)]
#[doc = " Behavior will be taken if FDIR match"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_eth_fdir_behavior {
    RTE_ETH_FDIR_ACCEPT = 0,
    RTE_ETH_FDIR_REJECT = 1,
    RTE_ETH_FDIR_PASSTHRU = 2,
}
#[repr(u32)]
#[doc = " Flow director report status"]
#[doc = " It defines what will be reported if FDIR entry is matched."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_eth_fdir_status {
    #[doc = "< Report nothing."]
    RTE_ETH_FDIR_NO_REPORT_STATUS = 0,
    #[doc = "< Only report FD ID."]
    RTE_ETH_FDIR_REPORT_ID = 1,
    #[doc = "< Report FD ID and 4 flex bytes."]
    RTE_ETH_FDIR_REPORT_ID_FLEX_4 = 2,
    #[doc = "< Report 8 flex bytes."]
    RTE_ETH_FDIR_REPORT_FLEX_8 = 3,
}
#[doc = " A structure used to define an action when match FDIR packet filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_action {
    #[doc = "< Queue assigned to if FDIR match."]
    pub rx_queue: u16,
    #[doc = "< Behavior will be taken"]
    pub behavior: rte_eth_fdir_behavior,
    #[doc = "< Status report option"]
    pub report_status: rte_eth_fdir_status,
    pub flex_off: u8,
}
#[doc = " A structure used to define the flow director filter entry."]
#[repr(C)]
pub struct rte_eth_fdir_filter {
    pub soft_id: u32,
    #[doc = "< Input set"]
    pub input: rte_eth_fdir_input,
    #[doc = "< Action taken when match"]
    pub action: rte_eth_fdir_action,
}
#[doc = "  A structure used to configure FDIR masks that are used by the device"]
#[doc = "  to match the various fields of Rx packet headers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_masks {
    #[doc = "< Bit mask for vlan_tci in big endian"]
    pub vlan_tci_mask: u16,
    #[doc = " Bit mask for ipv4 flow in big endian."]
    pub ipv4_mask: rte_eth_ipv4_flow,
    #[doc = " Bit mask for ipv6 flow in big endian."]
    pub ipv6_mask: rte_eth_ipv6_flow,
    #[doc = " Bit mask for L4 source port in big endian."]
    pub src_port_mask: u16,
    #[doc = " Bit mask for L4 destination port in big endian."]
    pub dst_port_mask: u16,
    #[doc = " 6 bit mask for proper 6 bytes of Mac address, bit 0 matches the"]
    #[doc = "first byte on the wire"]
    pub mac_addr_byte_mask: u8,
    #[doc = " Bit mask for tunnel ID in big endian."]
    pub tunnel_id_mask: u32,
    #[doc = "< 1 - Match tunnel type,"]
    #[doc = "0 - Ignore tunnel type."]
    pub tunnel_type_mask: u8,
}
#[repr(u32)]
#[doc = " Payload type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_eth_payload_type {
    RTE_ETH_PAYLOAD_UNKNOWN = 0,
    RTE_ETH_RAW_PAYLOAD = 1,
    RTE_ETH_L2_PAYLOAD = 2,
    RTE_ETH_L3_PAYLOAD = 3,
    RTE_ETH_L4_PAYLOAD = 4,
    RTE_ETH_PAYLOAD_MAX = 8,
}
#[doc = " A structure used to select bytes extracted from the protocol layers to"]
#[doc = " flexible payload for filter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_flex_payload_cfg {
    #[doc = "< Payload type"]
    pub type_: rte_eth_payload_type,
    pub src_offset: [u16; 16usize],
}
#[doc = " A structure used to define FDIR masks for flexible payload"]
#[doc = " for each flow type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_flex_mask {
    pub flow_type: u16,
    pub mask: [u8; 16usize],
}
#[doc = " A structure used to define all flexible payload related setting"]
#[doc = " include flex payload and flex mask"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_flex_conf {
    #[doc = "< The number of following payload cfg"]
    pub nb_payloads: u16,
    #[doc = "< The number of following mask"]
    pub nb_flexmasks: u16,
    pub flex_set: [rte_eth_flex_payload_cfg; 8usize],
    pub flex_mask: [rte_eth_fdir_flex_mask; 24usize],
}
#[repr(u32)]
#[doc = "  Flow Director setting modes: none, signature or perfect."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_fdir_mode {
    #[doc = "< Disable FDIR support."]
    RTE_FDIR_MODE_NONE = 0,
    #[doc = "< Enable FDIR signature filter mode."]
    RTE_FDIR_MODE_SIGNATURE = 1,
    #[doc = "< Enable FDIR perfect filter mode."]
    RTE_FDIR_MODE_PERFECT = 2,
    #[doc = "< Enable FDIR filter mode - MAC VLAN."]
    RTE_FDIR_MODE_PERFECT_MAC_VLAN = 3,
    #[doc = "< Enable FDIR filter mode - tunnel."]
    RTE_FDIR_MODE_PERFECT_TUNNEL = 4,
}
#[doc = " A structure used to get the information of flow director filter."]
#[doc = " It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_INFO operation."]
#[doc = " It includes the mode, flexible payload configuration information,"]
#[doc = " capabilities and supported flow types, flexible payload characters."]
#[doc = " It can be gotten to help taking specific configurations per device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_info {
    #[doc = "< Flow director mode"]
    pub mode: rte_fdir_mode,
    pub mask: rte_eth_fdir_masks,
    #[doc = " Flex payload configuration information"]
    pub flex_conf: rte_eth_fdir_flex_conf,
    #[doc = "< Guaranteed spaces."]
    pub guarant_spc: u32,
    #[doc = "< Best effort spaces."]
    pub best_spc: u32,
    #[doc = " Bit mask for every supported flow type."]
    pub flow_types_mask: [u64; 1usize],
    #[doc = "< Total flex payload in bytes."]
    pub max_flexpayload: u32,
    #[doc = " Flexible payload unit in bytes. Size and alignments of all flex"]
    #[doc = "payload segments should be multiplies of this value."]
    pub flex_payload_unit: u32,
    #[doc = " Max number of flexible payload continuous segments."]
    #[doc = "Each segment should be a multiple of flex_payload_unit."]
    pub max_flex_payload_segment_num: u32,
    #[doc = " Maximum src_offset in bytes allowed. It indicates that"]
    #[doc = "src_offset[i] in struct rte_eth_flex_payload_cfg should be less"]
    #[doc = "than this value."]
    pub flex_payload_limit: u16,
    #[doc = " Flex bitmask unit in bytes. Size of flex bitmasks should be a"]
    #[doc = "multiply of this value."]
    pub flex_bitmask_unit: u32,
    #[doc = " Max supported size of flex bitmasks in flex_bitmask_unit"]
    pub max_flex_bitmask_num: u32,
}
#[doc = " A structure used to define the statistics of flow director."]
#[doc = " It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_STATS operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_stats {
    #[doc = "< Number of filters with collision."]
    pub collision: u32,
    #[doc = "< Number of free filters."]
    pub free: u32,
    pub maxhash: u32,
    #[doc = "< Longest linked list of filters."]
    pub maxlen: u32,
    #[doc = "< Number of added filters."]
    pub add: u64,
    #[doc = "< Number of removed filters."]
    pub remove: u64,
    #[doc = "< Number of failed added filters."]
    pub f_add: u64,
    #[doc = "< Number of failed removed filters."]
    pub f_remove: u64,
    #[doc = "< Number of filters in guaranteed spaces."]
    pub guarant_cnt: u32,
    #[doc = "< Number of filters in best effort spaces."]
    pub best_cnt: u32,
}
#[repr(u32)]
#[doc = "  Memory space that can be configured to store Flow Director filters"]
#[doc = "  in the board memory."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_eth_fdir_pballoc_type {
    #[doc = "< 64k."]
    RTE_ETH_FDIR_PBALLOC_64K = 0,
    #[doc = "< 128k."]
    RTE_ETH_FDIR_PBALLOC_128K = 1,
    #[doc = "< 256k."]
    RTE_ETH_FDIR_PBALLOC_256K = 2,
}
#[repr(u32)]
#[doc = "  Select report mode of FDIR hash information in Rx descriptors."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_fdir_status_mode {
    #[doc = "< Never report FDIR hash."]
    RTE_FDIR_NO_REPORT_STATUS = 0,
    #[doc = "< Only report FDIR hash for matching pkts."]
    RTE_FDIR_REPORT_STATUS = 1,
    #[doc = "< Always report FDIR hash."]
    RTE_FDIR_REPORT_STATUS_ALWAYS = 2,
}
#[doc = " A structure used to configure the Flow Director (FDIR) feature"]
#[doc = " of an Ethernet port."]
#[doc = ""]
#[doc = " If mode is RTE_FDIR_MODE_NONE, the pballoc value is ignored."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_conf {
    #[doc = "< Flow Director mode."]
    pub mode: rte_fdir_mode,
    #[doc = "< Space for FDIR filters."]
    pub pballoc: rte_eth_fdir_pballoc_type,
    #[doc = "< How to report FDIR hash."]
    pub status: rte_fdir_status_mode,
    #[doc = " Rx queue of packets matching a \"drop\" filter in perfect mode."]
    pub drop_queue: u8,
    pub mask: rte_eth_fdir_masks,
    #[doc = " Flex payload configuration."]
    pub flex_conf: rte_eth_fdir_flex_conf,
}
#[doc = " UDP tunneling configuration."]
#[doc = ""]
#[doc = " Used to configure the classifier of a device,"]
#[doc = " associating an UDP port with a type of tunnel."]
#[doc = ""]
#[doc = " Some NICs may need such configuration to properly parse a tunnel"]
#[doc = " with any standard or custom UDP port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_udp_tunnel {
    #[doc = "< UDP port used for the tunnel."]
    pub udp_port: u16,
    #[doc = "< Tunnel type. @see rte_eth_tunnel_type"]
    pub prot_type: u8,
}
#[doc = " A structure used to enable/disable specific device interrupts."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_intr_conf {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl rte_eth_intr_conf {
    #[inline]
    pub fn lsc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lsc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rmv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rmv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(lsc: u32, rxq: u32, rmv: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lsc: u32 = unsafe { ::std::mem::transmute(lsc) };
            lsc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rxq: u32 = unsafe { ::std::mem::transmute(rxq) };
            rxq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rmv: u32 = unsafe { ::std::mem::transmute(rmv) };
            rmv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to configure an Ethernet port."]
#[doc = " Depending upon the Rx multi-queue mode, extra advanced"]
#[doc = " configuration settings may be needed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_conf {
    #[doc = "< bitmap of RTE_ETH_LINK_SPEED_XXX of speeds to be"]
    #[doc = "used. RTE_ETH_LINK_SPEED_FIXED disables link"]
    #[doc = "autonegotiation, and a unique speed shall be"]
    #[doc = "set. Otherwise, the bitmap defines the set of"]
    #[doc = "speeds to be advertised. If the special value"]
    #[doc = "RTE_ETH_LINK_SPEED_AUTONEG (0) is used, all speeds"]
    #[doc = "supported are advertised."]
    pub link_speeds: u32,
    #[doc = "< Port Rx configuration."]
    pub rxmode: rte_eth_rxmode,
    #[doc = "< Port Tx configuration."]
    pub txmode: rte_eth_txmode,
    #[doc = "< Loopback operation mode. By default the value"]
    #[doc = "is 0, meaning the loopback mode is disabled."]
    #[doc = "Read the datasheet of given Ethernet controller"]
    #[doc = "for details. The possible values of this field"]
    #[doc = "are defined in implementation of each driver."]
    pub lpbk_mode: u32,
    #[doc = "< Port Rx filtering configuration."]
    pub rx_adv_conf: rte_eth_conf__bindgen_ty_1,
    #[doc = "< Port Tx DCB configuration (union)."]
    pub tx_adv_conf: rte_eth_conf__bindgen_ty_2,
    #[doc = " Currently,Priority Flow Control(PFC) are supported,if DCB with PFC"]
    #[doc = "is needed,and the variable must be set RTE_ETH_DCB_PFC_SUPPORT."]
    pub dcb_capability_en: u32,
    #[doc = "< FDIR configuration. DEPRECATED"]
    pub fdir_conf: rte_eth_fdir_conf,
    #[doc = "< Interrupt mode configuration."]
    pub intr_conf: rte_eth_intr_conf,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_conf__bindgen_ty_1 {
    #[doc = "< Port RSS configuration"]
    pub rss_conf: rte_eth_rss_conf,
    #[doc = " Port VMDq+DCB configuration."]
    pub vmdq_dcb_conf: rte_eth_vmdq_dcb_conf,
    #[doc = " Port DCB Rx configuration."]
    pub dcb_rx_conf: rte_eth_dcb_rx_conf,
    #[doc = " Port VMDq Rx configuration."]
    pub vmdq_rx_conf: rte_eth_vmdq_rx_conf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_conf__bindgen_ty_2 {
    #[doc = " Port VMDq+DCB Tx configuration."]
    pub vmdq_dcb_tx_conf: rte_eth_vmdq_dcb_tx_conf,
    #[doc = " Port DCB Tx configuration."]
    pub dcb_tx_conf: rte_eth_dcb_tx_conf,
    #[doc = " Port VMDq Tx configuration."]
    pub vmdq_tx_conf: rte_eth_vmdq_tx_conf,
}
#[doc = " Preferred Rx/Tx port parameters."]
#[doc = " There are separate instances of this structure for transmission"]
#[doc = " and reception respectively."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_portconf {
    #[doc = "< Device-preferred burst size"]
    pub burst_size: u16,
    #[doc = "< Device-preferred size of queue rings"]
    pub ring_size: u16,
    #[doc = "< Device-preferred number of queues"]
    pub nb_queues: u16,
}
#[doc = " Ethernet device associated switch information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_switch_info {
    #[doc = "< switch name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< switch domain ID"]
    pub domain_id: u16,
    #[doc = " Mapping to the devices physical switch port as enumerated from the"]
    #[doc = " perspective of the embedded interconnect/switch. For SR-IOV enabled"]
    #[doc = " device this may correspond to the VF_ID of each virtual function,"]
    #[doc = " but each driver should explicitly define the mapping of switch"]
    #[doc = " port identifier to that physical interconnect/switch"]
    pub port_id: u16,
    #[doc = " Shared Rx queue sub-domain boundary. Only ports in same Rx domain"]
    #[doc = " and switch domain can share Rx queue. Valid only if device advertised"]
    #[doc = " RTE_ETH_DEV_CAPA_RXQ_SHARE capability."]
    pub rx_domain: u16,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice."]
#[doc = ""]
#[doc = " Ethernet device Rx buffer segmentation capabilities."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rxseg_capa {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Maximum amount of segments to split."]
    pub max_nseg: u16,
    #[doc = "< Reserved field."]
    pub reserved: u16,
}
impl rte_eth_rxseg_capa {
    #[inline]
    pub fn multi_pools(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_multi_pools(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offset_allowed(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_offset_allowed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offset_align_log2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_offset_align_log2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        multi_pools: u32,
        offset_allowed: u32,
        offset_align_log2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let multi_pools: u32 = unsafe { ::std::mem::transmute(multi_pools) };
            multi_pools as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let offset_allowed: u32 = unsafe { ::std::mem::transmute(offset_allowed) };
            offset_allowed as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let offset_align_log2: u32 = unsafe { ::std::mem::transmute(offset_align_log2) };
            offset_align_log2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(u32)]
#[doc = " Ethernet device representor port type."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_eth_representor_type {
    #[doc = "< not a representor."]
    RTE_ETH_REPRESENTOR_NONE = 0,
    #[doc = "< representor of Virtual Function."]
    RTE_ETH_REPRESENTOR_VF = 1,
    #[doc = "< representor of Sub Function."]
    RTE_ETH_REPRESENTOR_SF = 2,
    #[doc = "< representor of Physical Function."]
    RTE_ETH_REPRESENTOR_PF = 3,
}
#[doc = " A structure used to retrieve the contextual information of"]
#[doc = " an Ethernet device, such as the controlling driver of the"]
#[doc = " device, etc..."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_info {
    #[doc = "< Generic device information"]
    pub device: *mut rte_device,
    #[doc = "< Device Driver name."]
    pub driver_name: *const ::std::os::raw::c_char,
    #[doc = "< Index to bound host interface, or 0 if none."]
    #[doc = "Use if_indextoname() to translate into an interface name."]
    pub if_index: ::std::os::raw::c_uint,
    #[doc = "< Minimum MTU allowed"]
    pub min_mtu: u16,
    #[doc = "< Maximum MTU allowed"]
    pub max_mtu: u16,
    #[doc = "< Device flags"]
    pub dev_flags: *const u32,
    #[doc = "< Minimum size of Rx buffer."]
    pub min_rx_bufsize: u32,
    #[doc = "< Maximum configurable length of Rx pkt."]
    pub max_rx_pktlen: u32,
    #[doc = " Maximum configurable size of LRO aggregated packet."]
    pub max_lro_pkt_size: u32,
    #[doc = "< Maximum number of Rx queues."]
    pub max_rx_queues: u16,
    #[doc = "< Maximum number of Tx queues."]
    pub max_tx_queues: u16,
    #[doc = "< Maximum number of MAC addresses."]
    pub max_mac_addrs: u32,
    #[doc = " Maximum number of hash MAC addresses for MTA and UTA."]
    pub max_hash_mac_addrs: u32,
    #[doc = "< Maximum number of VFs."]
    pub max_vfs: u16,
    #[doc = "< Maximum number of VMDq pools."]
    pub max_vmdq_pools: u16,
    #[doc = "< Segmentation capability."]
    pub rx_seg_capa: rte_eth_rxseg_capa,
    #[doc = " All Rx offload capabilities including all per-queue ones"]
    pub rx_offload_capa: u64,
    #[doc = " All Tx offload capabilities including all per-queue ones"]
    pub tx_offload_capa: u64,
    #[doc = " Device per-queue Rx offload capabilities."]
    pub rx_queue_offload_capa: u64,
    #[doc = " Device per-queue Tx offload capabilities."]
    pub tx_queue_offload_capa: u64,
    #[doc = " Device redirection table size, the total number of entries."]
    pub reta_size: u16,
    #[doc = "< Hash key size in bytes"]
    pub hash_key_size: u8,
    #[doc = " Bit mask of RSS offloads, the bit offset also means flow type"]
    pub flow_type_rss_offloads: u64,
    #[doc = "< Default Rx configuration"]
    pub default_rxconf: rte_eth_rxconf,
    #[doc = "< Default Tx configuration"]
    pub default_txconf: rte_eth_txconf,
    #[doc = "< First queue ID for VMDq pools."]
    pub vmdq_queue_base: u16,
    #[doc = "< Queue number for VMDq pools."]
    pub vmdq_queue_num: u16,
    #[doc = "< First ID of VMDq pools."]
    pub vmdq_pool_base: u16,
    #[doc = "< Rx descriptors limits"]
    pub rx_desc_lim: rte_eth_desc_lim,
    #[doc = "< Tx descriptors limits"]
    pub tx_desc_lim: rte_eth_desc_lim,
    #[doc = "< Supported speeds bitmap (RTE_ETH_LINK_SPEED_)."]
    pub speed_capa: u32,
    #[doc = "< Number of Rx queues."]
    pub nb_rx_queues: u16,
    #[doc = "< Number of Tx queues."]
    pub nb_tx_queues: u16,
    #[doc = " Rx parameter recommendations"]
    pub default_rxportconf: rte_eth_dev_portconf,
    #[doc = " Tx parameter recommendations"]
    pub default_txportconf: rte_eth_dev_portconf,
    #[doc = " Generic device capabilities (RTE_ETH_DEV_CAPA_)."]
    pub dev_capa: u64,
    #[doc = " Switching information for ports on a device with a"]
    #[doc = " embedded managed interconnect/switch."]
    pub switch_info: rte_eth_switch_info,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[doc = " Ethernet device Rx queue information structure."]
#[doc = " Used to retrieve information about configured queue."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rxq_info {
    #[doc = "< mempool used by that queue."]
    pub mp: *mut rte_mempool,
    #[doc = "< queue config parameters."]
    pub conf: rte_eth_rxconf,
    #[doc = "< scattered packets Rx supported."]
    pub scattered_rx: u8,
    #[doc = "< one of RTE_ETH_QUEUE_STATE_*."]
    pub queue_state: u8,
    #[doc = "< configured number of RXDs."]
    pub nb_desc: u16,
    #[doc = "< hardware receive buffer size."]
    pub rx_buf_size: u16,
}
#[doc = " Ethernet device Tx queue information structure."]
#[doc = " Used to retrieve information about configured queue."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_txq_info {
    #[doc = "< queue config parameters."]
    pub conf: rte_eth_txconf,
    #[doc = "< configured number of TXDs."]
    pub nb_desc: u16,
    #[doc = "< one of RTE_ETH_QUEUE_STATE_*."]
    pub queue_state: u8,
}
#[doc = " Ethernet device Rx/Tx queue packet burst mode information structure."]
#[doc = " Used to retrieve information about packet burst mode setting."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_burst_mode {
    #[doc = "< The ORed values of RTE_ETH_BURST_FLAG_xxx"]
    pub flags: u64,
    #[doc = "< burst mode information"]
    pub info: [::std::os::raw::c_char; 1024usize],
}
#[doc = " An Ethernet device extended statistic structure"]
#[doc = ""]
#[doc = " This structure is used by rte_eth_xstats_get() to provide"]
#[doc = " statistics that are not provided in the generic *rte_eth_stats*"]
#[doc = " structure."]
#[doc = " It maps a name ID, corresponding to an index in the array returned"]
#[doc = " by rte_eth_xstats_get_names(), to a statistic value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_xstat {
    #[doc = "< The index in xstats name array."]
    pub id: u64,
    #[doc = "< The statistic counter value."]
    pub value: u64,
}
#[doc = " A name element for extended statistics."]
#[doc = ""]
#[doc = " An array of this structure is returned by rte_eth_xstats_get_names()."]
#[doc = " It lists the names of extended statistics for a PMD. The *rte_eth_xstat*"]
#[doc = " structure references these names by their array index."]
#[doc = ""]
#[doc = " The xstats should follow a common naming scheme."]
#[doc = " Some names are standardized in rte_stats_strings."]
#[doc = " Examples:"]
#[doc = "     - rx_missed_errors"]
#[doc = "     - tx_q3_bytes"]
#[doc = "     - tx_size_128_to_255_packets"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_xstat_name {
    #[doc = "< The statistic name."]
    pub name: [::std::os::raw::c_char; 64usize],
}
#[doc = " A structure used to get the information of queue and"]
#[doc = " TC mapping on both Tx and Rx paths."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping {
    pub tc_rxq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_1; 8usize]; 64usize],
    pub tc_txq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_2; 8usize]; 64usize],
}
#[doc = " Rx queues assigned to tc per Pool"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 {
    pub base: u16,
    pub nb_queue: u16,
}
#[doc = " Rx queues assigned to tc per Pool"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 {
    pub base: u16,
    pub nb_queue: u16,
}
#[doc = " A structure used to get the information of DCB."]
#[doc = " It includes TC UP mapping and queue TC mapping."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_info {
    #[doc = "< number of TCs"]
    pub nb_tcs: u8,
    #[doc = "< Priority to tc"]
    pub prio_tc: [u8; 8usize],
    #[doc = "< Tx BW percentage for each TC"]
    pub tc_bws: [u8; 8usize],
    #[doc = " Rx queues assigned to tc"]
    pub tc_queue: rte_eth_dcb_tc_queue_mapping,
}
#[repr(u32)]
#[doc = " This enum indicates the possible Forward Error Correction (FEC) modes"]
#[doc = " of an ethdev port."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_eth_fec_mode {
    #[doc = "< FEC is off"]
    RTE_ETH_FEC_NOFEC = 0,
    #[doc = "< FEC autonegotiation modes"]
    RTE_ETH_FEC_AUTO = 1,
    #[doc = "< FEC using common algorithm"]
    RTE_ETH_FEC_BASER = 2,
    #[doc = "< FEC using RS algorithm"]
    RTE_ETH_FEC_RS = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fec_capa {
    #[doc = "< Link speed (see RTE_ETH_SPEED_NUM_*)"]
    pub speed: u32,
    #[doc = "< FEC capabilities bitmask"]
    pub capa: u32,
}
#[doc = " Function type used for Rx packet processing packet callbacks."]
#[doc = ""]
#[doc = " The callback function is called on Rx with a burst of packets that have"]
#[doc = " been received on the given port and queue."]
#[doc = ""]
#[doc = " @param port_id"]
#[doc = "   The Ethernet port on which Rx is being performed."]
#[doc = " @param queue"]
#[doc = "   The queue on the Ethernet port which is being used to receive the packets."]
#[doc = " @param pkts"]
#[doc = "   The burst of packets that have just been received."]
#[doc = " @param nb_pkts"]
#[doc = "   The number of packets in the burst pointed to by \"pkts\"."]
#[doc = " @param max_pkts"]
#[doc = "   The max number of packets that can be stored in the \"pkts\" array."]
#[doc = " @param user_param"]
#[doc = "   The arbitrary user parameter passed in by the application when the callback"]
#[doc = "   was originally configured."]
#[doc = " @return"]
#[doc = "   The number of packets returned to the user."]
pub type rte_rx_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        queue: u16,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        max_pkts: u16,
        user_param: *mut ::std::os::raw::c_void,
    ) -> u16,
>;
#[doc = " Function type used for Tx packet processing packet callbacks."]
#[doc = ""]
#[doc = " The callback function is called on Tx with a burst of packets immediately"]
#[doc = " before the packets are put onto the hardware queue for transmission."]
#[doc = ""]
#[doc = " @param port_id"]
#[doc = "   The Ethernet port on which Tx is being performed."]
#[doc = " @param queue"]
#[doc = "   The queue on the Ethernet port which is being used to transmit the packets."]
#[doc = " @param pkts"]
#[doc = "   The burst of packets that are about to be transmitted."]
#[doc = " @param nb_pkts"]
#[doc = "   The number of packets in the burst pointed to by \"pkts\"."]
#[doc = " @param user_param"]
#[doc = "   The arbitrary user parameter passed in by the application when the callback"]
#[doc = "   was originally configured."]
#[doc = " @return"]
#[doc = "   The number of packets to be written to the NIC."]
pub type rte_tx_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        queue: u16,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        user_param: *mut ::std::os::raw::c_void,
    ) -> u16,
>;
#[repr(u32)]
#[doc = " Possible states of an ethdev port."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_eth_dev_state {
    #[doc = " Device is unused before being probed."]
    RTE_ETH_DEV_UNUSED = 0,
    #[doc = " Device is attached when allocated in probing."]
    RTE_ETH_DEV_ATTACHED = 1,
    #[doc = " Device is in removed state when plug-out is detected."]
    RTE_ETH_DEV_REMOVED = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_sriov {
    #[doc = "< SRIOV is active with 16, 32 or 64 pools"]
    pub active: u8,
    #[doc = "< Rx queue number per pool"]
    pub nb_q_per_pool: u8,
    #[doc = "< Default pool num used for PF"]
    pub def_vmdq_idx: u16,
    #[doc = "< Default pool queue start reg index"]
    pub def_pool_q_idx: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_owner {
    #[doc = "< The owner unique identifier."]
    pub id: u64,
    #[doc = "< The owner name."]
    pub name: [::std::os::raw::c_char; 64usize],
}
extern "C" {
    #[doc = " Iterates over valid ethdev ports owned by a specific owner."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The ID of the next possible valid owned port."]
    #[doc = " @param\towner_id"]
    #[doc = "  The owner identifier."]
    #[doc = "  RTE_ETH_DEV_NO_OWNER means iterate over all valid ownerless ports."]
    #[doc = " @return"]
    #[doc = "   Next valid port ID owned by owner_id, RTE_MAX_ETHPORTS if there is none."]
    pub fn rte_eth_find_next_owned_by(port_id: u16, owner_id: u64) -> u64;
}
extern "C" {
    #[doc = " Iterates over valid ethdev ports."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The ID of the next possible valid port."]
    #[doc = " @return"]
    #[doc = "   Next valid port ID, RTE_MAX_ETHPORTS if there is none."]
    pub fn rte_eth_find_next(port_id: u16) -> u16;
}
extern "C" {
    #[doc = " Iterates over ethdev ports of a specified device."]
    #[doc = ""]
    #[doc = " @param port_id_start"]
    #[doc = "   The ID of the next possible valid port."]
    #[doc = " @param parent"]
    #[doc = "   The generic device behind the ports to iterate."]
    #[doc = " @return"]
    #[doc = "   Next port ID of the device, possibly port_id_start,"]
    #[doc = "   RTE_MAX_ETHPORTS if there is none."]
    pub fn rte_eth_find_next_of(port_id_start: u16, parent: *const rte_device) -> u16;
}
extern "C" {
    #[doc = " Iterates over sibling ethdev ports (i.e. sharing the same rte_device)."]
    #[doc = ""]
    #[doc = " @param port_id_start"]
    #[doc = "   The ID of the next possible valid sibling port."]
    #[doc = " @param ref_port_id"]
    #[doc = "   The ID of a reference port to compare rte_device with."]
    #[doc = " @return"]
    #[doc = "   Next sibling port ID, possibly port_id_start or ref_port_id itself,"]
    #[doc = "   RTE_MAX_ETHPORTS if there is none."]
    pub fn rte_eth_find_next_sibling(port_id_start: u16, ref_port_id: u16) -> u16;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Get a new unique owner identifier."]
    #[doc = " An owner identifier is used to owns Ethernet devices by only one DPDK entity"]
    #[doc = " to avoid multiple management of device by different entities."]
    #[doc = ""]
    #[doc = " @param\towner_id"]
    #[doc = "   Owner identifier pointer."]
    #[doc = " @return"]
    #[doc = "   Negative errno value on error, 0 on success."]
    pub fn rte_eth_dev_owner_new(owner_id: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Set an Ethernet device owner."]
    #[doc = ""]
    #[doc = " @param\tport_id"]
    #[doc = "  The identifier of the port to own."]
    #[doc = " @param\towner"]
    #[doc = "  The owner pointer."]
    #[doc = " @return"]
    #[doc = "  Negative errno value on error, 0 on success."]
    pub fn rte_eth_dev_owner_set(
        port_id: u16,
        owner: *const rte_eth_dev_owner,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Unset Ethernet device owner to make the device ownerless."]
    #[doc = ""]
    #[doc = " @param\tport_id"]
    #[doc = "  The identifier of port to make ownerless."]
    #[doc = " @param\towner_id"]
    #[doc = "  The owner identifier."]
    #[doc = " @return"]
    #[doc = "  0 on success, negative errno value on error."]
    pub fn rte_eth_dev_owner_unset(port_id: u16, owner_id: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Remove owner from all Ethernet devices owned by a specific owner."]
    #[doc = ""]
    #[doc = " @param\towner_id"]
    #[doc = "  The owner identifier."]
    #[doc = " @return"]
    #[doc = "  0 on success, negative errno value on error."]
    pub fn rte_eth_dev_owner_delete(owner_id: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Get the owner of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param\tport_id"]
    #[doc = "  The port identifier."]
    #[doc = " @param\towner"]
    #[doc = "  The owner structure pointer to fill."]
    #[doc = " @return"]
    #[doc = "  0 on success, negative errno value on error.."]
    pub fn rte_eth_dev_owner_get(
        port_id: u16,
        owner: *mut rte_eth_dev_owner,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the number of ports which are usable for the application."]
    #[doc = ""]
    #[doc = " These devices must be iterated by using the macro"]
    #[doc = " ``RTE_ETH_FOREACH_DEV`` or ``RTE_ETH_FOREACH_DEV_OWNED_BY``"]
    #[doc = " to deal with non-contiguous ranges of devices."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The count of available Ethernet devices."]
    pub fn rte_eth_dev_count_avail() -> u16;
}
extern "C" {
    #[doc = " Get the total number of ports which are allocated."]
    #[doc = ""]
    #[doc = " Some devices may not be available for the application."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The total count of Ethernet devices."]
    pub fn rte_eth_dev_count_total() -> u16;
}
extern "C" {
    #[doc = " Convert a numerical speed in Mbps to a bitmap flag that can be used in"]
    #[doc = " the bitmap link_speeds of the struct rte_eth_conf"]
    #[doc = ""]
    #[doc = " @param speed"]
    #[doc = "   Numerical speed value in Mbps"]
    #[doc = " @param duplex"]
    #[doc = "   RTE_ETH_LINK_[HALF/FULL]_DUPLEX (only for 10/100M speeds)"]
    #[doc = " @return"]
    #[doc = "   0 if the speed cannot be mapped"]
    pub fn rte_eth_speed_bitflag(speed: u32, duplex: ::std::os::raw::c_int) -> u32;
}
extern "C" {
    #[doc = " Get RTE_ETH_RX_OFFLOAD_* flag name."]
    #[doc = ""]
    #[doc = " @param offload"]
    #[doc = "   Offload flag."]
    #[doc = " @return"]
    #[doc = "   Offload name or 'UNKNOWN' if the flag cannot be recognised."]
    pub fn rte_eth_dev_rx_offload_name(offload: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get RTE_ETH_TX_OFFLOAD_* flag name."]
    #[doc = ""]
    #[doc = " @param offload"]
    #[doc = "   Offload flag."]
    #[doc = " @return"]
    #[doc = "   Offload name or 'UNKNOWN' if the flag cannot be recognised."]
    pub fn rte_eth_dev_tx_offload_name(offload: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Get RTE_ETH_DEV_CAPA_* flag name."]
    #[doc = ""]
    #[doc = " @param capability"]
    #[doc = "   Capability flag."]
    #[doc = " @return"]
    #[doc = "   Capability name or 'UNKNOWN' if the flag cannot be recognized."]
    pub fn rte_eth_dev_capability_name(capability: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Configure an Ethernet device."]
    #[doc = " This function must be invoked first before any other function in the"]
    #[doc = " Ethernet API. This function can also be re-invoked when a device is in the"]
    #[doc = " stopped state."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device to configure."]
    #[doc = " @param nb_rx_queue"]
    #[doc = "   The number of receive queues to set up for the Ethernet device."]
    #[doc = " @param nb_tx_queue"]
    #[doc = "   The number of transmit queues to set up for the Ethernet device."]
    #[doc = " @param eth_conf"]
    #[doc = "   The pointer to the configuration data to be used for the Ethernet device."]
    #[doc = "   The *rte_eth_conf* structure includes:"]
    #[doc = "     -  the hardware offload features to activate, with dedicated fields for"]
    #[doc = "        each statically configurable offload hardware feature provided by"]
    #[doc = "        Ethernet devices, such as IP checksum or VLAN tag stripping for"]
    #[doc = "        example."]
    #[doc = "        The Rx offload bitfield API is obsolete and will be deprecated."]
    #[doc = "        Applications should set the ignore_bitfield_offloads bit on *rxmode*"]
    #[doc = "        structure and use offloads field to set per-port offloads instead."]
    #[doc = "     -  Any offloading set in eth_conf->[rt]xmode.offloads must be within"]
    #[doc = "        the [rt]x_offload_capa returned from rte_eth_dev_info_get()."]
    #[doc = "        Any type of device supported offloading set in the input argument"]
    #[doc = "        eth_conf->[rt]xmode.offloads to rte_eth_dev_configure() is enabled"]
    #[doc = "        on all queues and it can't be disabled in rte_eth_[rt]x_queue_setup()"]
    #[doc = "     -  the Receive Side Scaling (RSS) configuration when using multiple Rx"]
    #[doc = "        queues per port. Any RSS hash function set in eth_conf->rss_conf.rss_hf"]
    #[doc = "        must be within the flow_type_rss_offloads provided by drivers via"]
    #[doc = "        rte_eth_dev_info_get() API."]
    #[doc = ""]
    #[doc = "   Embedding all configuration information in a single data structure"]
    #[doc = "   is the more flexible method that allows the addition of new features"]
    #[doc = "   without changing the syntax of the API."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, device configured."]
    #[doc = "   - <0: Error code returned by the driver configuration function."]
    pub fn rte_eth_dev_configure(
        port_id: u16,
        nb_rx_queue: u16,
        nb_tx_queue: u16,
        eth_conf: *const rte_eth_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if an Ethernet device was physically removed."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   1 when the Ethernet device is removed, otherwise 0."]
    pub fn rte_eth_dev_is_removed(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate and set up a receive queue for an Ethernet device."]
    #[doc = ""]
    #[doc = " The function allocates a contiguous block of memory for *nb_rx_desc*"]
    #[doc = " receive descriptors from a memory zone associated with *socket_id*"]
    #[doc = " and initializes each receive descriptor with a network buffer allocated"]
    #[doc = " from the memory pool *mb_pool*."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the receive queue to set up."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param nb_rx_desc"]
    #[doc = "   The number of receive descriptors to allocate for the receive ring."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in case of NUMA."]
    #[doc = "   The value can be *SOCKET_ID_ANY* if there is no NUMA constraint for"]
    #[doc = "   the DMA memory allocated for the receive descriptors of the ring."]
    #[doc = " @param rx_conf"]
    #[doc = "   The pointer to the configuration data to be used for the receive queue."]
    #[doc = "   NULL value is allowed, in which case default Rx configuration"]
    #[doc = "   will be used."]
    #[doc = "   The *rx_conf* structure contains an *rx_thresh* structure with the values"]
    #[doc = "   of the Prefetch, Host, and Write-Back threshold registers of the receive"]
    #[doc = "   ring."]
    #[doc = "   In addition it contains the hardware offloads features to activate using"]
    #[doc = "   the RTE_ETH_RX_OFFLOAD_* flags."]
    #[doc = "   If an offloading set in rx_conf->offloads"]
    #[doc = "   hasn't been set in the input argument eth_conf->rxmode.offloads"]
    #[doc = "   to rte_eth_dev_configure(), it is a new added offloading, it must be"]
    #[doc = "   per-queue type and it is enabled for the queue."]
    #[doc = "   No need to repeat any bit in rx_conf->offloads which has already been"]
    #[doc = "   enabled in rte_eth_dev_configure() at port level. An offloading enabled"]
    #[doc = "   at port level can't be disabled at queue level."]
    #[doc = "   The configuration structure also contains the pointer to the array"]
    #[doc = "   of the receiving buffer segment descriptions, see rx_seg and rx_nseg"]
    #[doc = "   fields, this extended configuration might be used by split offloads like"]
    #[doc = "   RTE_ETH_RX_OFFLOAD_BUFFER_SPLIT. If mb_pool is not NULL,"]
    #[doc = "   the extended configuration fields must be set to NULL and zero."]
    #[doc = " @param mb_pool"]
    #[doc = "   The pointer to the memory pool from which to allocate *rte_mbuf* network"]
    #[doc = "   memory buffers to populate each descriptor of the receive ring. There are"]
    #[doc = "   two options to provide Rx buffer configuration:"]
    #[doc = "   - single pool:"]
    #[doc = "     mb_pool is not NULL, rx_conf.rx_nseg is 0."]
    #[doc = "   - multiple segments description:"]
    #[doc = "     mb_pool is NULL, rx_conf.rx_seg is not NULL, rx_conf.rx_nseg is not 0."]
    #[doc = "     Taken only if flag RTE_ETH_RX_OFFLOAD_BUFFER_SPLIT is set in offloads."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success, receive queue correctly set up."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENODEV: if *port_id* is invalid."]
    #[doc = "   - -EINVAL: The memory pool pointer is null or the size of network buffers"]
    #[doc = "      which can be allocated from this memory pool does not fit the various"]
    #[doc = "      buffer sizes allowed by the device controller."]
    #[doc = "   - -ENOMEM: Unable to allocate the receive ring descriptors or to"]
    #[doc = "      allocate network memory buffers from the memory pool when"]
    #[doc = "      initializing receive descriptors."]
    pub fn rte_eth_rx_queue_setup(
        port_id: u16,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        rx_conf: *const rte_eth_rxconf,
        mb_pool: *mut rte_mempool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Allocate and set up a hairpin receive queue for an Ethernet device."]
    #[doc = ""]
    #[doc = " The function set up the selected queue to be used in hairpin."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the receive queue to set up."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param nb_rx_desc"]
    #[doc = "   The number of receive descriptors to allocate for the receive ring."]
    #[doc = "   0 means the PMD will use default value."]
    #[doc = " @param conf"]
    #[doc = "   The pointer to the hairpin configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if *port_id* is invalid."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    #[doc = "   - (-ENOMEM) if unable to allocate the resources."]
    pub fn rte_eth_rx_hairpin_queue_setup(
        port_id: u16,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        conf: *const rte_eth_hairpin_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate and set up a transmit queue for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param tx_queue_id"]
    #[doc = "   The index of the transmit queue to set up."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param nb_tx_desc"]
    #[doc = "   The number of transmit descriptors to allocate for the transmit ring."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in case of NUMA."]
    #[doc = "   Its value can be *SOCKET_ID_ANY* if there is no NUMA constraint for"]
    #[doc = "   the DMA memory allocated for the transmit descriptors of the ring."]
    #[doc = " @param tx_conf"]
    #[doc = "   The pointer to the configuration data to be used for the transmit queue."]
    #[doc = "   NULL value is allowed, in which case default Tx configuration"]
    #[doc = "   will be used."]
    #[doc = "   The *tx_conf* structure contains the following data:"]
    #[doc = "   - The *tx_thresh* structure with the values of the Prefetch, Host, and"]
    #[doc = "     Write-Back threshold registers of the transmit ring."]
    #[doc = "     When setting Write-Back threshold to the value greater then zero,"]
    #[doc = "     *tx_rs_thresh* value should be explicitly set to one."]
    #[doc = "   - The *tx_free_thresh* value indicates the [minimum] number of network"]
    #[doc = "     buffers that must be pending in the transmit ring to trigger their"]
    #[doc = "     [implicit] freeing by the driver transmit function."]
    #[doc = "   - The *tx_rs_thresh* value indicates the [minimum] number of transmit"]
    #[doc = "     descriptors that must be pending in the transmit ring before setting the"]
    #[doc = "     RS bit on a descriptor by the driver transmit function."]
    #[doc = "     The *tx_rs_thresh* value should be less or equal then"]
    #[doc = "     *tx_free_thresh* value, and both of them should be less then"]
    #[doc = "     *nb_tx_desc* - 3."]
    #[doc = "   - The *offloads* member contains Tx offloads to be enabled."]
    #[doc = "     If an offloading set in tx_conf->offloads"]
    #[doc = "     hasn't been set in the input argument eth_conf->txmode.offloads"]
    #[doc = "     to rte_eth_dev_configure(), it is a new added offloading, it must be"]
    #[doc = "     per-queue type and it is enabled for the queue."]
    #[doc = "     No need to repeat any bit in tx_conf->offloads which has already been"]
    #[doc = "     enabled in rte_eth_dev_configure() at port level. An offloading enabled"]
    #[doc = "     at port level can't be disabled at queue level."]
    #[doc = ""]
    #[doc = "     Note that setting *tx_free_thresh* or *tx_rs_thresh* value to 0 forces"]
    #[doc = "     the transmit function to use default values."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, the transmit queue is correctly set up."]
    #[doc = "   - -ENOMEM: Unable to allocate the transmit ring descriptors."]
    pub fn rte_eth_tx_queue_setup(
        port_id: u16,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        tx_conf: *const rte_eth_txconf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Allocate and set up a transmit hairpin queue for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param tx_queue_id"]
    #[doc = "   The index of the transmit queue to set up."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param nb_tx_desc"]
    #[doc = "   The number of transmit descriptors to allocate for the transmit ring."]
    #[doc = "   0 to set default PMD value."]
    #[doc = " @param conf"]
    #[doc = "   The hairpin configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if *port_id* is invalid."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    #[doc = "   - (-ENOMEM) if unable to allocate the resources."]
    pub fn rte_eth_tx_hairpin_queue_setup(
        port_id: u16,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        conf: *const rte_eth_hairpin_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Get all the hairpin peer Rx / Tx ports of the current port."]
    #[doc = " The caller should ensure that the array is large enough to save the ports"]
    #[doc = " list."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param peer_ports"]
    #[doc = "   Pointer to the array to store the peer ports list."]
    #[doc = " @param len"]
    #[doc = "   Length of the array to store the port identifiers."]
    #[doc = " @param direction"]
    #[doc = "   Current port to peer port direction"]
    #[doc = "   positive - current used as Tx to get all peer Rx ports."]
    #[doc = "   zero - current used as Rx to get all peer Tx ports."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0 or positive) actual peer ports number."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    #[doc = "   - (-ENODEV) if *port_id* invalid"]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - Others detailed errors from PMDs."]
    pub fn rte_eth_hairpin_get_peer_ports(
        port_id: u16,
        peer_ports: *mut u16,
        len: size_t,
        direction: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Bind all hairpin Tx queues of one port to the Rx queues of the peer port."]
    #[doc = " It is only allowed to call this function after all hairpin queues are"]
    #[doc = " configured properly and the devices are in started state."]
    #[doc = ""]
    #[doc = " @param tx_port"]
    #[doc = "   The identifier of the Tx port."]
    #[doc = " @param rx_port"]
    #[doc = "   The identifier of peer Rx port."]
    #[doc = "   RTE_MAX_ETHPORTS is allowed for the traversal of all devices."]
    #[doc = "   Rx port ID could have the same value as Tx port ID."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if Tx port ID is invalid."]
    #[doc = "   - (-EBUSY) if device is not in started state."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - Others detailed errors from PMDs."]
    pub fn rte_eth_hairpin_bind(tx_port: u16, rx_port: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Unbind all hairpin Tx queues of one port from the Rx queues of the peer port."]
    #[doc = " This should be called before closing the Tx or Rx devices, if the bind"]
    #[doc = " function is called before."]
    #[doc = " After unbinding the hairpin ports pair, it is allowed to bind them again."]
    #[doc = " Changing queues configuration should be after stopping the device(s)."]
    #[doc = ""]
    #[doc = " @param tx_port"]
    #[doc = "   The identifier of the Tx port."]
    #[doc = " @param rx_port"]
    #[doc = "   The identifier of peer Rx port."]
    #[doc = "   RTE_MAX_ETHPORTS is allowed for traversal of all devices."]
    #[doc = "   Rx port ID could have the same value as Tx port ID."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if Tx port ID is invalid."]
    #[doc = "   - (-EBUSY) if device is in stopped state."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - Others detailed errors from PMDs."]
    pub fn rte_eth_hairpin_unbind(tx_port: u16, rx_port: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the NUMA socket to which an Ethernet device is connected"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @return"]
    #[doc = "   The NUMA socket ID to which the Ethernet device is connected or"]
    #[doc = "   a default of zero if the socket could not be determined."]
    #[doc = "   -1 is returned is the port_id value is out of range."]
    pub fn rte_eth_dev_socket_id(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if port_id of device is attached"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @return"]
    #[doc = "   - 0 if port is out of range or not attached"]
    #[doc = "   - 1 if device is attached"]
    pub fn rte_eth_dev_is_valid_port(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start specified Rx queue of a port. It is used when rx_deferred_start"]
    #[doc = " flag of the specified queue is true."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the Rx queue to update the ring."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, the receive queue is started."]
    #[doc = "   - -ENODEV: if *port_id* is invalid."]
    #[doc = "   - -EINVAL: The queue_id out of range or belong to hairpin."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function not supported in PMD."]
    pub fn rte_eth_dev_rx_queue_start(port_id: u16, rx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop specified Rx queue of a port"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the Rx queue to update the ring."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, the receive queue is stopped."]
    #[doc = "   - -ENODEV: if *port_id* is invalid."]
    #[doc = "   - -EINVAL: The queue_id out of range or belong to hairpin."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function not supported in PMD."]
    pub fn rte_eth_dev_rx_queue_stop(port_id: u16, rx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start Tx for specified queue of a port. It is used when tx_deferred_start"]
    #[doc = " flag of the specified queue is true."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @param tx_queue_id"]
    #[doc = "   The index of the Tx queue to update the ring."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, the transmit queue is started."]
    #[doc = "   - -ENODEV: if *port_id* is invalid."]
    #[doc = "   - -EINVAL: The queue_id out of range or belong to hairpin."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function not supported in PMD."]
    pub fn rte_eth_dev_tx_queue_start(port_id: u16, tx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop specified Tx queue of a port"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @param tx_queue_id"]
    #[doc = "   The index of the Tx queue to update the ring."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, the transmit queue is stopped."]
    #[doc = "   - -ENODEV: if *port_id* is invalid."]
    #[doc = "   - -EINVAL: The queue_id out of range or belong to hairpin."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function not supported in PMD."]
    pub fn rte_eth_dev_tx_queue_stop(port_id: u16, tx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start an Ethernet device."]
    #[doc = ""]
    #[doc = " The device start step is the last one and consists of setting the configured"]
    #[doc = " offload features and in starting the transmit and the receive units of the"]
    #[doc = " device."]
    #[doc = ""]
    #[doc = " Device RTE_ETH_DEV_NOLIVE_MAC_ADDR flag causes MAC address to be set before"]
    #[doc = " PMD port start callback function is invoked."]
    #[doc = ""]
    #[doc = " On success, all basic functions exported by the Ethernet API (link status,"]
    #[doc = " receive/transmit, and so on) can be invoked."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, Ethernet device started."]
    #[doc = "   - <0: Error code of the driver device start function."]
    pub fn rte_eth_dev_start(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop an Ethernet device. The device can be restarted with a call to"]
    #[doc = " rte_eth_dev_start()"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, Ethernet device stopped."]
    #[doc = "   - <0: Error code of the driver device stop function."]
    pub fn rte_eth_dev_stop(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Link up an Ethernet device."]
    #[doc = ""]
    #[doc = " Set device link up will re-enable the device Rx/Tx"]
    #[doc = " functionality after it is previously set device linked down."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, Ethernet device linked up."]
    #[doc = "   - <0: Error code of the driver device link up function."]
    pub fn rte_eth_dev_set_link_up(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Link down an Ethernet device."]
    #[doc = " The device Rx/Tx functionality will be disabled if success,"]
    #[doc = " and it can be re-enabled with a call to"]
    #[doc = " rte_eth_dev_set_link_up()"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    pub fn rte_eth_dev_set_link_down(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close a stopped Ethernet device. The device cannot be restarted!"]
    #[doc = " The function frees all port resources."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - Zero if the port is closed successfully."]
    #[doc = "   - Negative if something went wrong."]
    pub fn rte_eth_dev_close(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset a Ethernet device and keep its port ID."]
    #[doc = ""]
    #[doc = " When a port has to be reset passively, the DPDK application can invoke"]
    #[doc = " this function. For example when a PF is reset, all its VFs should also"]
    #[doc = " be reset. Normally a DPDK application can invoke this function when"]
    #[doc = " RTE_ETH_EVENT_INTR_RESET event is detected, but can also use it to start"]
    #[doc = " a port reset in other circumstances."]
    #[doc = ""]
    #[doc = " When this function is called, it first stops the port and then calls the"]
    #[doc = " PMD specific dev_uninit( ) and dev_init( ) to return the port to initial"]
    #[doc = " state, in which no Tx and Rx queues are setup, as if the port has been"]
    #[doc = " reset and not started. The port keeps the port ID it had before the"]
    #[doc = " function call."]
    #[doc = ""]
    #[doc = " After calling rte_eth_dev_reset( ), the application should use"]
    #[doc = " rte_eth_dev_configure( ), rte_eth_rx_queue_setup( ),"]
    #[doc = " rte_eth_tx_queue_setup( ), and rte_eth_dev_start( )"]
    #[doc = " to reconfigure the device as appropriate."]
    #[doc = ""]
    #[doc = " Note: To avoid unexpected behavior, the application should stop calling"]
    #[doc = " Tx and Rx functions before calling rte_eth_dev_reset( ). For thread"]
    #[doc = " safety, all these controlling functions should be called from the same"]
    #[doc = " thread."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if *port_id* is invalid."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support this function."]
    #[doc = "   - (-EPERM) if not ran from the primary process."]
    #[doc = "   - (-EIO) if re-initialisation failed or device is removed."]
    #[doc = "   - (-ENOMEM) if the reset failed due to OOM."]
    #[doc = "   - (-EAGAIN) if the reset temporarily failed and should be retried later."]
    pub fn rte_eth_dev_reset(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable receipt in promiscuous mode for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if support for promiscuous_enable() does not exist"]
    #[doc = "     for the device."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_promiscuous_enable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disable receipt in promiscuous mode for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if support for promiscuous_disable() does not exist"]
    #[doc = "     for the device."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_promiscuous_disable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the value of promiscuous mode for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (1) if promiscuous is enabled"]
    #[doc = "   - (0) if promiscuous is disabled."]
    #[doc = "   - (-1) on error"]
    pub fn rte_eth_promiscuous_get(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable the receipt of any multicast frame by an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if support for allmulticast_enable() does not exist"]
    #[doc = "     for the device."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_allmulticast_enable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disable the receipt of all multicast frames by an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if support for allmulticast_disable() does not exist"]
    #[doc = "     for the device."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_allmulticast_disable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the value of allmulticast mode for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (1) if allmulticast is enabled"]
    #[doc = "   - (0) if allmulticast is disabled."]
    #[doc = "   - (-1) on error"]
    pub fn rte_eth_allmulticast_get(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the link status (up/down), the duplex mode (half/full),"]
    #[doc = " the negotiation (auto/fixed), and if available, the speed (Mbps)."]
    #[doc = ""]
    #[doc = " It might need to wait up to 9 seconds."]
    #[doc = " @see rte_eth_link_get_nowait."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param link"]
    #[doc = "   Link information written back."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if the function is not supported in PMD."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_link_get(port_id: u16, link: *mut rte_eth_link) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the link status (up/down), the duplex mode (half/full),"]
    #[doc = " the negotiation (auto/fixed), and if available, the speed (Mbps)."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param link"]
    #[doc = "   Link information written back."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if the function is not supported in PMD."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_link_get_nowait(port_id: u16, link: *mut rte_eth_link) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " The function converts a link_speed to a string. It handles all special"]
    #[doc = " values like unknown or none speed."]
    #[doc = ""]
    #[doc = " @param link_speed"]
    #[doc = "   link_speed of rte_eth_link struct"]
    #[doc = " @return"]
    #[doc = "   Link speed in textual format. It's pointer to immutable memory."]
    #[doc = "   No free is required."]
    pub fn rte_eth_link_speed_to_str(link_speed: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " The function converts a rte_eth_link struct representing a link status to"]
    #[doc = " a string."]
    #[doc = ""]
    #[doc = " @param str"]
    #[doc = "   A pointer to a string to be filled with textual representation of"]
    #[doc = "   device status. At least RTE_ETH_LINK_MAX_STR_LEN bytes should be allocated to"]
    #[doc = "   store default link status text."]
    #[doc = " @param len"]
    #[doc = "   Length of available memory at 'str' string."]
    #[doc = " @param eth_link"]
    #[doc = "   Link status returned by rte_eth_link_get function"]
    #[doc = " @return"]
    #[doc = "   Number of bytes written to str array or -EINVAL if bad parameter."]
    pub fn rte_eth_link_to_str(
        str_: *mut ::std::os::raw::c_char,
        len: size_t,
        eth_link: *const rte_eth_link,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the general I/O statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param stats"]
    #[doc = "   A pointer to a structure of type *rte_eth_stats* to be filled with"]
    #[doc = "   the values of device counters for the following set of statistics:"]
    #[doc = "   - *ipackets* with the total of successfully received packets."]
    #[doc = "   - *opackets* with the total of successfully transmitted packets."]
    #[doc = "   - *ibytes*   with the total of successfully received bytes."]
    #[doc = "   - *obytes*   with the total of successfully transmitted bytes."]
    #[doc = "   - *ierrors*  with the total of erroneous received packets."]
    #[doc = "   - *oerrors*  with the total of failed transmitted packets."]
    #[doc = " @return"]
    #[doc = "   Zero if successful. Non-zero otherwise."]
    pub fn rte_eth_stats_get(port_id: u16, stats: *mut rte_eth_stats) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset the general I/O statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if device notified to reset stats."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (<0): Error code of the driver stats reset function."]
    pub fn rte_eth_stats_reset(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve names of extended statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " There is an assumption that 'xstat_names' and 'xstats' arrays are matched"]
    #[doc = " by array index:"]
    #[doc = "  xstats_names[i].name => xstats[i].value"]
    #[doc = ""]
    #[doc = " And the array index is same with id field of 'struct rte_eth_xstat':"]
    #[doc = "  xstats[i].id == i"]
    #[doc = ""]
    #[doc = " This assumption makes key-value pair matching less flexible but simpler."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param xstats_names"]
    #[doc = "   An rte_eth_xstat_name array of at least *size* elements to"]
    #[doc = "   be filled. If set to NULL, the function returns the required number"]
    #[doc = "   of elements."]
    #[doc = " @param size"]
    #[doc = "   The size of the xstats_names array (number of elements)."]
    #[doc = " @return"]
    #[doc = "   - A positive value lower or equal to size: success. The return value"]
    #[doc = "     is the number of entries filled in the stats table."]
    #[doc = "   - A positive value higher than size: error, the given statistics table"]
    #[doc = "     is too small. The return value corresponds to the size that should"]
    #[doc = "     be given to succeed. The entries in the table are not valid and"]
    #[doc = "     shall not be used by the caller."]
    #[doc = "   - A negative value on error (invalid port ID)."]
    pub fn rte_eth_xstats_get_names(
        port_id: u16,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve extended statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " There is an assumption that 'xstat_names' and 'xstats' arrays are matched"]
    #[doc = " by array index:"]
    #[doc = "  xstats_names[i].name => xstats[i].value"]
    #[doc = ""]
    #[doc = " And the array index is same with id field of 'struct rte_eth_xstat':"]
    #[doc = "  xstats[i].id == i"]
    #[doc = ""]
    #[doc = " This assumption makes key-value pair matching less flexible but simpler."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param xstats"]
    #[doc = "   A pointer to a table of structure of type *rte_eth_xstat*"]
    #[doc = "   to be filled with device statistics ids and values."]
    #[doc = "   This parameter can be set to NULL if n is 0."]
    #[doc = " @param n"]
    #[doc = "   The size of the xstats array (number of elements)."]
    #[doc = " @return"]
    #[doc = "   - A positive value lower or equal to n: success. The return value"]
    #[doc = "     is the number of entries filled in the stats table."]
    #[doc = "   - A positive value higher than n: error, the given statistics table"]
    #[doc = "     is too small. The return value corresponds to the size that should"]
    #[doc = "     be given to succeed. The entries in the table are not valid and"]
    #[doc = "     shall not be used by the caller."]
    #[doc = "   - A negative value on error (invalid port ID)."]
    pub fn rte_eth_xstats_get(
        port_id: u16,
        xstats: *mut rte_eth_xstat,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve names of extended statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param xstats_names"]
    #[doc = "   Array to be filled in with names of requested device statistics."]
    #[doc = "   Must not be NULL if @p ids are specified (not NULL)."]
    #[doc = " @param size"]
    #[doc = "   Number of elements in @p xstats_names array (if not NULL) and in"]
    #[doc = "   @p ids array (if not NULL). Must be 0 if both array pointers are NULL."]
    #[doc = " @param ids"]
    #[doc = "   IDs array given by app to retrieve specific statistics. May be NULL to"]
    #[doc = "   retrieve names of all available statistics or, if @p xstats_names is"]
    #[doc = "   NULL as well, just the number of available statistics."]
    #[doc = " @return"]
    #[doc = "   - A positive value lower or equal to size: success. The return value"]
    #[doc = "     is the number of entries filled in the stats table."]
    #[doc = "   - A positive value higher than size: success. The given statistics table"]
    #[doc = "     is too small. The return value corresponds to the size that should"]
    #[doc = "     be given to succeed. The entries in the table are not valid and"]
    #[doc = "     shall not be used by the caller."]
    #[doc = "   - A negative value on error."]
    pub fn rte_eth_xstats_get_names_by_id(
        port_id: u16,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
        ids: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve extended statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param ids"]
    #[doc = "   IDs array given by app to retrieve specific statistics. May be NULL to"]
    #[doc = "   retrieve all available statistics or, if @p values is NULL as well,"]
    #[doc = "   just the number of available statistics."]
    #[doc = " @param values"]
    #[doc = "   Array to be filled in with requested device statistics."]
    #[doc = "   Must not be NULL if ids are specified (not NULL)."]
    #[doc = " @param size"]
    #[doc = "   Number of elements in @p values array (if not NULL) and in @p ids"]
    #[doc = "   array (if not NULL). Must be 0 if both array pointers are NULL."]
    #[doc = " @return"]
    #[doc = "   - A positive value lower or equal to size: success. The return value"]
    #[doc = "     is the number of entries filled in the stats table."]
    #[doc = "   - A positive value higher than size: success: The given statistics table"]
    #[doc = "     is too small. The return value corresponds to the size that should"]
    #[doc = "     be given to succeed. The entries in the table are not valid and"]
    #[doc = "     shall not be used by the caller."]
    #[doc = "   - A negative value on error."]
    pub fn rte_eth_xstats_get_by_id(
        port_id: u16,
        ids: *const u64,
        values: *mut u64,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the ID of a statistic from its name."]
    #[doc = ""]
    #[doc = " This function searches for the statistics using string compares, and"]
    #[doc = " as such should not be used on the fast-path. For fast-path retrieval of"]
    #[doc = " specific statistics, store the ID as provided in *id* from this function,"]
    #[doc = " and pass the ID to rte_eth_xstats_get()"]
    #[doc = ""]
    #[doc = " @param port_id The port to look up statistics from"]
    #[doc = " @param xstat_name The name of the statistic to return"]
    #[doc = " @param[out] id A pointer to an app-supplied uint64_t which should be"]
    #[doc = "                set to the ID of the stat if the stat exists."]
    #[doc = " @return"]
    #[doc = "    0 on success"]
    #[doc = "    -ENODEV for invalid port_id,"]
    #[doc = "    -EIO if device is removed,"]
    #[doc = "    -EINVAL if the xstat_name doesn't exist in port_id"]
    #[doc = "    -ENOMEM if bad parameter."]
    pub fn rte_eth_xstats_get_id_by_name(
        port_id: u16,
        xstat_name: *const ::std::os::raw::c_char,
        id: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset extended statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if device notified to reset extended stats."]
    #[doc = "   - (-ENOTSUP) if pmd doesn't support both"]
    #[doc = "     extended stats and basic stats reset."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (<0): Error code of the driver xstats reset function."]
    pub fn rte_eth_xstats_reset(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set a mapping for the specified transmit queue to the specified per-queue"]
    #[doc = "  statistics counter."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param tx_queue_id"]
    #[doc = "   The index of the transmit queue for which a queue stats mapping is required."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param stat_idx"]
    #[doc = "   The per-queue packet statistics functionality number that the transmit"]
    #[doc = "   queue is to be assigned."]
    #[doc = "   The value must be in the range [0, RTE_ETHDEV_QUEUE_STAT_CNTRS - 1]."]
    #[doc = "   Max RTE_ETHDEV_QUEUE_STAT_CNTRS being 256."]
    #[doc = " @return"]
    #[doc = "   Zero if successful. Non-zero otherwise."]
    pub fn rte_eth_dev_set_tx_queue_stats_mapping(
        port_id: u16,
        tx_queue_id: u16,
        stat_idx: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set a mapping for the specified receive queue to the specified per-queue"]
    #[doc = "  statistics counter."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the receive queue for which a queue stats mapping is required."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param stat_idx"]
    #[doc = "   The per-queue packet statistics functionality number that the receive"]
    #[doc = "   queue is to be assigned."]
    #[doc = "   The value must be in the range [0, RTE_ETHDEV_QUEUE_STAT_CNTRS - 1]."]
    #[doc = "   Max RTE_ETHDEV_QUEUE_STAT_CNTRS being 256."]
    #[doc = " @return"]
    #[doc = "   Zero if successful. Non-zero otherwise."]
    pub fn rte_eth_dev_set_rx_queue_stats_mapping(
        port_id: u16,
        rx_queue_id: u16,
        stat_idx: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the Ethernet address of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mac_addr"]
    #[doc = "   A pointer to a structure of type *ether_addr* to be filled with"]
    #[doc = "   the Ethernet address of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful"]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_macaddr_get(
        port_id: u16,
        mac_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Retrieve the Ethernet addresses of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param ma"]
    #[doc = "   A pointer to an array of structures of type *ether_addr* to be filled with"]
    #[doc = "   the Ethernet addresses of the Ethernet device."]
    #[doc = " @param num"]
    #[doc = "   Number of elements in the @p ma array."]
    #[doc = "   Note that  rte_eth_dev_info::max_mac_addrs can be used to retrieve"]
    #[doc = "   max number of Ethernet addresses for given port."]
    #[doc = " @return"]
    #[doc = "   - number of retrieved addresses if successful"]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_macaddrs_get(
        port_id: u16,
        ma: *mut rte_ether_addr,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the contextual information of an Ethernet device."]
    #[doc = ""]
    #[doc = " As part of this function, a number of of fields in dev_info will be"]
    #[doc = " initialized as follows:"]
    #[doc = ""]
    #[doc = " rx_desc_lim = lim"]
    #[doc = " tx_desc_lim = lim"]
    #[doc = ""]
    #[doc = " Where lim is defined within the rte_eth_dev_info_get as"]
    #[doc = ""]
    #[doc = "  const struct rte_eth_desc_lim lim = {"]
    #[doc = "      .nb_max = UINT16_MAX,"]
    #[doc = "      .nb_min = 0,"]
    #[doc = "      .nb_align = 1,"]
    #[doc = "\t.nb_seg_max = UINT16_MAX,"]
    #[doc = "\t.nb_mtu_seg_max = UINT16_MAX,"]
    #[doc = "  };"]
    #[doc = ""]
    #[doc = " device = dev->device"]
    #[doc = " min_mtu = RTE_ETHER_MIN_LEN - RTE_ETHER_HDR_LEN - RTE_ETHER_CRC_LEN"]
    #[doc = " max_mtu = UINT16_MAX"]
    #[doc = ""]
    #[doc = " The following fields will be populated if support for dev_infos_get()"]
    #[doc = " exists for the device and the rte_eth_dev 'dev' has been populated"]
    #[doc = " successfully with a call to it:"]
    #[doc = ""]
    #[doc = " driver_name = dev->device->driver->name"]
    #[doc = " nb_rx_queues = dev->data->nb_rx_queues"]
    #[doc = " nb_tx_queues = dev->data->nb_tx_queues"]
    #[doc = " dev_flags = &dev->data->dev_flags"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param dev_info"]
    #[doc = "   A pointer to a structure of type *rte_eth_dev_info* to be filled with"]
    #[doc = "   the contextual information of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if support for dev_infos_get() does not exist for the device."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_info_get(
        port_id: u16,
        dev_info: *mut rte_eth_dev_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Retrieve the configuration of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param dev_conf"]
    #[doc = "   Location for Ethernet device configuration to be filled in."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_conf_get(port_id: u16, dev_conf: *mut rte_eth_conf)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the firmware version of a device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the device."]
    #[doc = " @param fw_version"]
    #[doc = "   A pointer to a string array storing the firmware version of a device,"]
    #[doc = "   the string includes terminating null. This pointer is allocated by caller."]
    #[doc = " @param fw_size"]
    #[doc = "   The size of the string array pointed by fw_version, which should be"]
    #[doc = "   large enough to store firmware version of the device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if operation is not supported."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    #[doc = "   - (>0) if *fw_size* is not enough to store firmware version, return"]
    #[doc = "          the size of the non truncated string."]
    pub fn rte_eth_dev_fw_version_get(
        port_id: u16,
        fw_version: *mut ::std::os::raw::c_char,
        fw_size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the supported packet types of an Ethernet device."]
    #[doc = ""]
    #[doc = " When a packet type is announced as supported, it *must* be recognized by"]
    #[doc = " the PMD. For instance, if RTE_PTYPE_L2_ETHER, RTE_PTYPE_L2_ETHER_VLAN"]
    #[doc = " and RTE_PTYPE_L3_IPV4 are announced, the PMD must return the following"]
    #[doc = " packet types for these packets:"]
    #[doc = " - Ether/IPv4              -> RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4"]
    #[doc = " - Ether/VLAN/IPv4         -> RTE_PTYPE_L2_ETHER_VLAN | RTE_PTYPE_L3_IPV4"]
    #[doc = " - Ether/[anything else]   -> RTE_PTYPE_L2_ETHER"]
    #[doc = " - Ether/VLAN/[anything else] -> RTE_PTYPE_L2_ETHER_VLAN"]
    #[doc = ""]
    #[doc = " When a packet is received by a PMD, the most precise type must be"]
    #[doc = " returned among the ones supported. However a PMD is allowed to set"]
    #[doc = " packet type that is not in the supported list, at the condition that it"]
    #[doc = " is more precise. Therefore, a PMD announcing no supported packet types"]
    #[doc = " can still set a matching packet type in a received packet."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "   Better to invoke this API after the device is already started or Rx burst"]
    #[doc = "   function is decided, to obtain correct supported ptypes."]
    #[doc = " @note"]
    #[doc = "   if a given PMD does not report what ptypes it supports, then the supported"]
    #[doc = "   ptype count is reported as 0."]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param ptype_mask"]
    #[doc = "   A hint of what kind of packet type which the caller is interested in."]
    #[doc = " @param ptypes"]
    #[doc = "   An array pointer to store adequate packet types, allocated by caller."]
    #[doc = " @param num"]
    #[doc = "  Size of the array pointed by param ptypes."]
    #[doc = " @return"]
    #[doc = "   - (>=0) Number of supported ptypes. If the number of types exceeds num,"]
    #[doc = "           only num entries will be filled into the ptypes array, but the full"]
    #[doc = "           count of supported ptypes will be returned."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_get_supported_ptypes(
        port_id: u16,
        ptype_mask: u32,
        ptypes: *mut u32,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Inform Ethernet device about reduced range of packet types to handle."]
    #[doc = ""]
    #[doc = " Application can use this function to set only specific ptypes that it's"]
    #[doc = " interested. This information can be used by the PMD to optimize Rx path."]
    #[doc = ""]
    #[doc = " The function accepts an array `set_ptypes` allocated by the caller to"]
    #[doc = " store the packet types set by the driver, the last element of the array"]
    #[doc = " is set to RTE_PTYPE_UNKNOWN. The size of the `set_ptype` array should be"]
    #[doc = " `rte_eth_dev_get_supported_ptypes() + 1` else it might only be filled"]
    #[doc = " partially."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param ptype_mask"]
    #[doc = "   The ptype family that application is interested in should be bitwise OR of"]
    #[doc = "   RTE_PTYPE_*_MASK or 0."]
    #[doc = " @param set_ptypes"]
    #[doc = "   An array pointer to store set packet types, allocated by caller. The"]
    #[doc = "   function marks the end of array with RTE_PTYPE_UNKNOWN."]
    #[doc = " @param num"]
    #[doc = "   Size of the array pointed by param ptypes."]
    #[doc = "   Should be rte_eth_dev_get_supported_ptypes() + 1 to accommodate the"]
    #[doc = "   set ptypes."]
    #[doc = " @return"]
    #[doc = "   - (0) if Success."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if *ptype_mask* is invalid (or) set_ptypes is NULL and"]
    #[doc = "     num > 0."]
    pub fn rte_eth_dev_set_ptypes(
        port_id: u16,
        ptype_mask: u32,
        set_ptypes: *mut u32,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the MTU of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mtu"]
    #[doc = "   A pointer to a uint16_t where the retrieved MTU is to be stored."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_get_mtu(port_id: u16, mtu: *mut u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change the MTU of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mtu"]
    #[doc = "   A uint16_t for the MTU to be applied."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if operation is not supported."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-EINVAL) if *mtu* invalid, validation of mtu can occur within"]
    #[doc = "     rte_eth_dev_set_mtu if dev_infos_get is supported by the device or"]
    #[doc = "     when the mtu is set using dev->dev_ops->mtu_set."]
    #[doc = "   - (-EBUSY) if operation is not allowed when the port is running"]
    pub fn rte_eth_dev_set_mtu(port_id: u16, mtu: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable/Disable hardware filtering by an Ethernet device of received"]
    #[doc = " VLAN packets tagged with a given VLAN Tag Identifier."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param vlan_id"]
    #[doc = "   The VLAN Tag Identifier whose filtering must be enabled or disabled."]
    #[doc = " @param on"]
    #[doc = "   If > 0, enable VLAN filtering of VLAN packets tagged with *vlan_id*."]
    #[doc = "   Otherwise, disable VLAN filtering of VLAN packets tagged with *vlan_id*."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware-assisted VLAN filtering not configured."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENOSYS) if VLAN filtering on *port_id* disabled."]
    #[doc = "   - (-EINVAL) if *vlan_id* > 4095."]
    pub fn rte_eth_dev_vlan_filter(
        port_id: u16,
        vlan_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable/Disable hardware VLAN Strip by a Rx queue of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the receive queue for which a queue stats mapping is required."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param on"]
    #[doc = "   If 1, Enable VLAN Stripping of the receive queue of the Ethernet port."]
    #[doc = "   If 0, Disable VLAN Stripping of the receive queue of the Ethernet port."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware-assisted VLAN stripping not configured."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if *rx_queue_id* invalid."]
    pub fn rte_eth_dev_set_vlan_strip_on_queue(
        port_id: u16,
        rx_queue_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the Outer VLAN Ether Type by an Ethernet device, it can be inserted to"]
    #[doc = " the VLAN header."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param vlan_type"]
    #[doc = "   The VLAN type."]
    #[doc = " @param tag_type"]
    #[doc = "   The Tag Protocol ID"]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware-assisted VLAN TPID setup is not supported."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_set_vlan_ether_type(
        port_id: u16,
        vlan_type: rte_vlan_type,
        tag_type: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set VLAN offload configuration on an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param offload_mask"]
    #[doc = "   The VLAN Offload bit mask can be mixed use with \"OR\""]
    #[doc = "       RTE_ETH_VLAN_STRIP_OFFLOAD"]
    #[doc = "       RTE_ETH_VLAN_FILTER_OFFLOAD"]
    #[doc = "       RTE_ETH_VLAN_EXTEND_OFFLOAD"]
    #[doc = "       RTE_ETH_QINQ_STRIP_OFFLOAD"]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware-assisted VLAN filtering not configured."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_set_vlan_offload(
        port_id: u16,
        offload_mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read VLAN Offload configuration from an Ethernet device"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (>0) if successful. Bit mask to indicate"]
    #[doc = "       RTE_ETH_VLAN_STRIP_OFFLOAD"]
    #[doc = "       RTE_ETH_VLAN_FILTER_OFFLOAD"]
    #[doc = "       RTE_ETH_VLAN_EXTEND_OFFLOAD"]
    #[doc = "       RTE_ETH_QINQ_STRIP_OFFLOAD"]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_dev_get_vlan_offload(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set port based Tx VLAN insertion on or off."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "  The port identifier of the Ethernet device."]
    #[doc = " @param pvid"]
    #[doc = "  Port based Tx VLAN identifier together with user priority."]
    #[doc = " @param on"]
    #[doc = "  Turn on or off the port based Tx VLAN insertion."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - negative if failed."]
    pub fn rte_eth_dev_set_vlan_pvid(
        port_id: u16,
        pvid: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type buffer_tx_error_fn = ::std::option::Option<
    unsafe extern "C" fn(
        unsent: *mut *mut rte_mbuf,
        count: u16,
        userdata: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Structure used to buffer packets for future Tx"]
#[doc = " Used by APIs rte_eth_tx_buffer and rte_eth_tx_buffer_flush"]
#[repr(C)]
#[derive(Debug)]
pub struct rte_eth_dev_tx_buffer {
    pub error_callback: buffer_tx_error_fn,
    pub error_userdata: *mut ::std::os::raw::c_void,
    #[doc = "< Size of buffer for buffered Tx"]
    pub size: u16,
    #[doc = "< Number of packets in the array"]
    pub length: u16,
    #[doc = " Pending packets to be sent on explicit flush or when full"]
    pub pkts: __IncompleteArrayField<*mut rte_mbuf>,
}
extern "C" {
    #[doc = " Initialize default values for buffered transmitting"]
    #[doc = ""]
    #[doc = " @param buffer"]
    #[doc = "   Tx buffer to be initialized."]
    #[doc = " @param size"]
    #[doc = "   Buffer size"]
    #[doc = " @return"]
    #[doc = "   0 if no error"]
    pub fn rte_eth_tx_buffer_init(
        buffer: *mut rte_eth_dev_tx_buffer,
        size: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configure a callback for buffered packets which cannot be sent"]
    #[doc = ""]
    #[doc = " Register a specific callback to be called when an attempt is made to send"]
    #[doc = " all packets buffered on an Ethernet port, but not all packets can"]
    #[doc = " successfully be sent. The callback registered here will be called only"]
    #[doc = " from calls to rte_eth_tx_buffer() and rte_eth_tx_buffer_flush() APIs."]
    #[doc = " The default callback configured for each queue by default just frees the"]
    #[doc = " packets back to the calling mempool. If additional behaviour is required,"]
    #[doc = " for example, to count dropped packets, or to retry transmission of packets"]
    #[doc = " which cannot be sent, this function should be used to register a suitable"]
    #[doc = " callback function to implement the desired behaviour."]
    #[doc = " The example callback \"rte_eth_count_unsent_packet_callback()\" is also"]
    #[doc = " provided as reference."]
    #[doc = ""]
    #[doc = " @param buffer"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param callback"]
    #[doc = "   The function to be used as the callback."]
    #[doc = " @param userdata"]
    #[doc = "   Arbitrary parameter to be passed to the callback function"]
    #[doc = " @return"]
    #[doc = "   0 on success, or -EINVAL if bad parameter"]
    pub fn rte_eth_tx_buffer_set_err_callback(
        buffer: *mut rte_eth_dev_tx_buffer,
        callback: buffer_tx_error_fn,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Callback function for silently dropping unsent buffered packets."]
    #[doc = ""]
    #[doc = " This function can be passed to rte_eth_tx_buffer_set_err_callback() to"]
    #[doc = " adjust the default behavior when buffered packets cannot be sent. This"]
    #[doc = " function drops any unsent packets silently and is used by Tx buffered"]
    #[doc = " operations as default behavior."]
    #[doc = ""]
    #[doc = " NOTE: this function should not be called directly, instead it should be used"]
    #[doc = "       as a callback for packet buffering."]
    #[doc = ""]
    #[doc = " NOTE: when configuring this function as a callback with"]
    #[doc = "       rte_eth_tx_buffer_set_err_callback(), the final, userdata parameter"]
    #[doc = "       should point to an uint64_t value."]
    #[doc = ""]
    #[doc = " @param pkts"]
    #[doc = "   The previously buffered packets which could not be sent"]
    #[doc = " @param unsent"]
    #[doc = "   The number of unsent packets in the pkts array"]
    #[doc = " @param userdata"]
    #[doc = "   Not used"]
    pub fn rte_eth_tx_buffer_drop_callback(
        pkts: *mut *mut rte_mbuf,
        unsent: u16,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Callback function for tracking unsent buffered packets."]
    #[doc = ""]
    #[doc = " This function can be passed to rte_eth_tx_buffer_set_err_callback() to"]
    #[doc = " adjust the default behavior when buffered packets cannot be sent. This"]
    #[doc = " function drops any unsent packets, but also updates a user-supplied counter"]
    #[doc = " to track the overall number of packets dropped. The counter should be an"]
    #[doc = " uint64_t variable."]
    #[doc = ""]
    #[doc = " NOTE: this function should not be called directly, instead it should be used"]
    #[doc = "       as a callback for packet buffering."]
    #[doc = ""]
    #[doc = " NOTE: when configuring this function as a callback with"]
    #[doc = "       rte_eth_tx_buffer_set_err_callback(), the final, userdata parameter"]
    #[doc = "       should point to an uint64_t value."]
    #[doc = ""]
    #[doc = " @param pkts"]
    #[doc = "   The previously buffered packets which could not be sent"]
    #[doc = " @param unsent"]
    #[doc = "   The number of unsent packets in the pkts array"]
    #[doc = " @param userdata"]
    #[doc = "   Pointer to an uint64_t value, which will be incremented by unsent"]
    pub fn rte_eth_tx_buffer_count_callback(
        pkts: *mut *mut rte_mbuf,
        unsent: u16,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Request the driver to free mbufs currently cached by the driver. The"]
    #[doc = " driver will only free the mbuf if it is no longer in use. It is the"]
    #[doc = " application's responsibility to ensure rte_eth_tx_buffer_flush(..) is"]
    #[doc = " called if needed."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the transmit queue through which output packets must be"]
    #[doc = "   sent."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param free_cnt"]
    #[doc = "   Maximum number of packets to free. Use 0 to indicate all possible packets"]
    #[doc = "   should be freed. Note that a packet may be using multiple mbufs."]
    #[doc = " @return"]
    #[doc = "   Failure: < 0"]
    #[doc = "     -ENODEV: Invalid interface"]
    #[doc = "     -EIO: device is removed"]
    #[doc = "     -ENOTSUP: Driver does not support function"]
    #[doc = "   Success: >= 0"]
    #[doc = "     0-n: Number of packets freed. More packets may still remain in ring that"]
    #[doc = "     are in use."]
    pub fn rte_eth_tx_done_cleanup(
        port_id: u16,
        queue_id: u16,
        free_cnt: u32,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " Subtypes for IPsec offload event(@ref RTE_ETH_EVENT_IPSEC) raised by"]
#[doc = " eth device."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_eth_event_ipsec_subtype {
    #[doc = " Unknown event type"]
    RTE_ETH_EVENT_IPSEC_UNKNOWN = 0,
    #[doc = " Sequence number overflow"]
    RTE_ETH_EVENT_IPSEC_ESN_OVERFLOW = 1,
    #[doc = " Soft time expiry of SA"]
    RTE_ETH_EVENT_IPSEC_SA_TIME_EXPIRY = 2,
    #[doc = " Soft byte expiry of SA"]
    RTE_ETH_EVENT_IPSEC_SA_BYTE_EXPIRY = 3,
    #[doc = " Max value of this enum"]
    RTE_ETH_EVENT_IPSEC_MAX = 4,
}
#[doc = " Descriptor for @ref RTE_ETH_EVENT_IPSEC event. Used by eth dev to send extra"]
#[doc = " information of the IPsec offload event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_event_ipsec_desc {
    #[doc = " Type of RTE_ETH_EVENT_IPSEC_* event"]
    pub subtype: rte_eth_event_ipsec_subtype,
    #[doc = " Event specific metadata."]
    #[doc = ""]
    #[doc = " For the following events, *userdata* registered"]
    #[doc = " with the *rte_security_session* would be returned"]
    #[doc = " as metadata,"]
    #[doc = ""]
    #[doc = " - @ref RTE_ETH_EVENT_IPSEC_ESN_OVERFLOW"]
    #[doc = " - @ref RTE_ETH_EVENT_IPSEC_SA_TIME_EXPIRY"]
    #[doc = " - @ref RTE_ETH_EVENT_IPSEC_SA_BYTE_EXPIRY"]
    #[doc = ""]
    #[doc = " @see struct rte_security_session_conf"]
    #[doc = ""]
    pub metadata: u64,
}
#[repr(u32)]
#[doc = " The eth device event type for interrupt, and maybe others in the future."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_eth_event_type {
    #[doc = "< unknown event type"]
    RTE_ETH_EVENT_UNKNOWN = 0,
    #[doc = "< lsc interrupt event"]
    RTE_ETH_EVENT_INTR_LSC = 1,
    #[doc = " queue state event (enabled/disabled)"]
    RTE_ETH_EVENT_QUEUE_STATE = 2,
    #[doc = " reset interrupt event, sent to VF on PF reset"]
    RTE_ETH_EVENT_INTR_RESET = 3,
    #[doc = "< message from the VF received by PF"]
    RTE_ETH_EVENT_VF_MBOX = 4,
    #[doc = "< MACsec offload related event"]
    RTE_ETH_EVENT_MACSEC = 5,
    #[doc = "< device removal event"]
    RTE_ETH_EVENT_INTR_RMV = 6,
    #[doc = "< port is probed"]
    RTE_ETH_EVENT_NEW = 7,
    #[doc = "< port is released"]
    RTE_ETH_EVENT_DESTROY = 8,
    #[doc = "< IPsec offload related event"]
    RTE_ETH_EVENT_IPSEC = 9,
    #[doc = "< New aged-out flows is detected"]
    RTE_ETH_EVENT_FLOW_AGED = 10,
    #[doc = "< max value of this enum"]
    RTE_ETH_EVENT_MAX = 11,
}
#[doc = " User application callback to be registered for interrupts."]
pub type rte_eth_dev_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        event: rte_eth_event_type,
        cb_arg: *mut ::std::os::raw::c_void,
        ret_param: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Register a callback function for port event."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "  Port ID."]
    #[doc = "  RTE_ETH_ALL means register the event for all port ids."]
    #[doc = " @param event"]
    #[doc = "  Event interested."]
    #[doc = " @param cb_fn"]
    #[doc = "  User supplied callback function to be called."]
    #[doc = " @param cb_arg"]
    #[doc = "  Pointer to the parameters for the registered callback."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_eth_dev_callback_register(
        port_id: u16,
        event: rte_eth_event_type,
        cb_fn: rte_eth_dev_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unregister a callback function for port event."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "  Port ID."]
    #[doc = "  RTE_ETH_ALL means unregister the event for all port ids."]
    #[doc = " @param event"]
    #[doc = "  Event interested."]
    #[doc = " @param cb_fn"]
    #[doc = "  User supplied callback function to be called."]
    #[doc = " @param cb_arg"]
    #[doc = "  Pointer to the parameters for the registered callback. -1 means to"]
    #[doc = "  remove all for the same callback address and same event."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_eth_dev_callback_unregister(
        port_id: u16,
        event: rte_eth_event_type,
        cb_fn: rte_eth_dev_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " When there is no Rx packet coming in Rx Queue for a long time, we can"]
    #[doc = " sleep lcore related to Rx Queue for power saving, and enable Rx interrupt"]
    #[doc = " to be triggered when Rx packet arrives."]
    #[doc = ""]
    #[doc = " The rte_eth_dev_rx_intr_enable() function enables Rx queue"]
    #[doc = " interrupt on specific Rx queue of a port."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the receive queue from which to retrieve input packets."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if underlying hardware OR driver doesn't support"]
    #[doc = "     that operation."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_rx_intr_enable(port_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " When lcore wakes up from Rx interrupt indicating packet coming, disable Rx"]
    #[doc = " interrupt and returns to polling mode."]
    #[doc = ""]
    #[doc = " The rte_eth_dev_rx_intr_disable() function disables Rx queue"]
    #[doc = " interrupt on specific Rx queue of a port."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the receive queue from which to retrieve input packets."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if underlying hardware OR driver doesn't support"]
    #[doc = "     that operation."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_rx_intr_disable(port_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Rx Interrupt control per port."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param epfd"]
    #[doc = "   Epoll instance fd which the intr vector associated to."]
    #[doc = "   Using RTE_EPOLL_PER_THREAD allows to use per thread epoll instance."]
    #[doc = " @param op"]
    #[doc = "   The operation be performed for the vector."]
    #[doc = "   Operation type of {RTE_INTR_EVENT_ADD, RTE_INTR_EVENT_DEL}."]
    #[doc = " @param data"]
    #[doc = "   User raw data."]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_eth_dev_rx_intr_ctl(
        port_id: u16,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Rx Interrupt control per queue."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the receive queue from which to retrieve input packets."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param epfd"]
    #[doc = "   Epoll instance fd which the intr vector associated to."]
    #[doc = "   Using RTE_EPOLL_PER_THREAD allows to use per thread epoll instance."]
    #[doc = " @param op"]
    #[doc = "   The operation be performed for the vector."]
    #[doc = "   Operation type of {RTE_INTR_EVENT_ADD, RTE_INTR_EVENT_DEL}."]
    #[doc = " @param data"]
    #[doc = "   User raw data."]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_eth_dev_rx_intr_ctl_q(
        port_id: u16,
        queue_id: u16,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get interrupt fd per Rx queue."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the receive queue from which to retrieve input packets."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - (>=0) the interrupt fd associated to the requested Rx queue if"]
    #[doc = "           successful."]
    #[doc = "   - (-1) on error."]
    pub fn rte_eth_dev_rx_intr_ctl_q_get_fd(port_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Turn on the LED on the Ethernet device."]
    #[doc = " This function turns on the LED on the Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if underlying hardware OR driver doesn't support"]
    #[doc = "     that operation."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    pub fn rte_eth_led_on(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Turn off the LED on the Ethernet device."]
    #[doc = " This function turns off the LED on the Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if underlying hardware OR driver doesn't support"]
    #[doc = "     that operation."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    pub fn rte_eth_led_off(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Get Forward Error Correction(FEC) capability."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param speed_fec_capa"]
    #[doc = "   speed_fec_capa is out only with per-speed capabilities."]
    #[doc = "   If set to NULL, the function returns the required number"]
    #[doc = "   of required array entries."]
    #[doc = " @param num"]
    #[doc = "   a number of elements in an speed_fec_capa array."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - A non-negative value lower or equal to num: success. The return value"]
    #[doc = "     is the number of entries filled in the fec capa array."]
    #[doc = "   - A non-negative value higher than num: error, the given fec capa array"]
    #[doc = "     is too small. The return value corresponds to the num that should"]
    #[doc = "     be given to succeed. The entries in fec capa array are not valid and"]
    #[doc = "     shall not be used by the caller."]
    #[doc = "   - (-ENOTSUP) if underlying hardware OR driver doesn't support."]
    #[doc = "     that operation."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENODEV)  if *port_id* invalid."]
    #[doc = "   - (-EINVAL)  if *num* or *speed_fec_capa* invalid"]
    pub fn rte_eth_fec_get_capability(
        port_id: u16,
        speed_fec_capa: *mut rte_eth_fec_capa,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Get current Forward Error Correction(FEC) mode."]
    #[doc = " If link is down and AUTO is enabled, AUTO is returned, otherwise,"]
    #[doc = " configured FEC mode is returned."]
    #[doc = " If link is up, current FEC mode is returned."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param fec_capa"]
    #[doc = "   A bitmask of enabled FEC modes. If AUTO bit is set, other"]
    #[doc = "   bits specify FEC modes which may be negotiated. If AUTO"]
    #[doc = "   bit is clear, specify FEC modes to be used (only one valid"]
    #[doc = "   mode per speed may be set)."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if underlying hardware OR driver doesn't support."]
    #[doc = "     that operation."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENODEV)  if *port_id* invalid."]
    pub fn rte_eth_fec_get(port_id: u16, fec_capa: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Set Forward Error Correction(FEC) mode."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param fec_capa"]
    #[doc = "   A bitmask of allowed FEC modes. If AUTO bit is set, other"]
    #[doc = "   bits specify FEC modes which may be negotiated. If AUTO"]
    #[doc = "   bit is clear, specify FEC modes to be used (only one valid"]
    #[doc = "   mode per speed may be set)."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-EINVAL) if the FEC mode is not valid."]
    #[doc = "   - (-ENOTSUP) if underlying hardware OR driver doesn't support."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENODEV)  if *port_id* invalid."]
    pub fn rte_eth_fec_set(port_id: u16, fec_capa: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get current status of the Ethernet link flow control for Ethernet device"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param fc_conf"]
    #[doc = "   The pointer to the structure where to store the flow control parameters."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support flow control."]
    #[doc = "   - (-ENODEV)  if *port_id* invalid."]
    #[doc = "   - (-EIO)  if device is removed."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_flow_ctrl_get(
        port_id: u16,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configure the Ethernet link flow control for Ethernet device"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param fc_conf"]
    #[doc = "   The pointer to the structure of the flow control parameters."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support flow control mode."]
    #[doc = "   - (-ENODEV)  if *port_id* invalid."]
    #[doc = "   - (-EINVAL)  if bad parameter"]
    #[doc = "   - (-EIO)     if flow control setup failure or device is removed."]
    pub fn rte_eth_dev_flow_ctrl_set(
        port_id: u16,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configure the Ethernet priority flow control under DCB environment"]
    #[doc = " for Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = " The port identifier of the Ethernet device."]
    #[doc = " @param pfc_conf"]
    #[doc = " The pointer to the structure of the priority flow control parameters."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support priority flow control mode."]
    #[doc = "   - (-ENODEV)  if *port_id* invalid."]
    #[doc = "   - (-EINVAL)  if bad parameter"]
    #[doc = "   - (-EIO)     if flow control setup failure or device is removed."]
    pub fn rte_eth_dev_priority_flow_ctrl_set(
        port_id: u16,
        pfc_conf: *mut rte_eth_pfc_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a MAC address to the set used for filtering incoming packets."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mac_addr"]
    #[doc = "   The MAC address to add."]
    #[doc = " @param pool"]
    #[doc = "   VMDq pool index to associate address with (if VMDq is enabled). If VMDq is"]
    #[doc = "   not enabled, this should be set to 0."]
    #[doc = " @return"]
    #[doc = "   - (0) if successfully added or *mac_addr* was already added."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support this feature."]
    #[doc = "   - (-ENODEV) if *port* is invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENOSPC) if no more MAC addresses can be added."]
    #[doc = "   - (-EINVAL) if MAC address is invalid."]
    pub fn rte_eth_dev_mac_addr_add(
        port_id: u16,
        mac_addr: *mut rte_ether_addr,
        pool: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Retrieve the information for queue based PFC."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param pfc_queue_info"]
    #[doc = "   A pointer to a structure of type *rte_eth_pfc_queue_info* to be filled with"]
    #[doc = "   the information about queue based PFC."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if support for priority_flow_ctrl_queue_info_get does not exist."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_priority_flow_ctrl_queue_info_get(
        port_id: u16,
        pfc_queue_info: *mut rte_eth_pfc_queue_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Configure the queue based priority flow control for a given queue"]
    #[doc = " for Ethernet device."]
    #[doc = ""]
    #[doc = " @note When an ethdev port switches to queue based PFC mode, the"]
    #[doc = " unconfigured queues shall be configured by the driver with"]
    #[doc = " default values such as lower priority value for TC etc."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param pfc_queue_conf"]
    #[doc = "   The pointer to the structure of the priority flow control parameters"]
    #[doc = "   for the queue."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support queue based PFC mode."]
    #[doc = "   - (-ENODEV)  if *port_id* invalid."]
    #[doc = "   - (-EINVAL)  if bad parameter"]
    #[doc = "   - (-EIO)     if flow control setup queue failure"]
    pub fn rte_eth_dev_priority_flow_ctrl_queue_configure(
        port_id: u16,
        pfc_queue_conf: *mut rte_eth_pfc_queue_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a MAC address from the internal array of addresses."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mac_addr"]
    #[doc = "   MAC address to remove."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful, or *mac_addr* didn't exist."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port* invalid."]
    #[doc = "   - (-EADDRINUSE) if attempting to remove the default MAC address."]
    #[doc = "   - (-EINVAL) if MAC address is invalid."]
    pub fn rte_eth_dev_mac_addr_remove(
        port_id: u16,
        mac_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the default MAC address."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mac_addr"]
    #[doc = "   New default MAC address."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful, or *mac_addr* didn't exist."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port* invalid."]
    #[doc = "   - (-EINVAL) if MAC address is invalid."]
    pub fn rte_eth_dev_default_mac_addr_set(
        port_id: u16,
        mac_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Update Redirection Table(RETA) of Receive Side Scaling of Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param reta_conf"]
    #[doc = "   RETA to update."]
    #[doc = " @param reta_size"]
    #[doc = "   Redirection table size. The table size can be queried by"]
    #[doc = "   rte_eth_dev_info_get()."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if *port_id* is invalid."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    #[doc = "   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_rss_reta_update(
        port_id: u16,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Query Redirection Table(RETA) of Receive Side Scaling of Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param reta_conf"]
    #[doc = "   RETA to query. For each requested reta entry, corresponding bit"]
    #[doc = "   in mask must be set."]
    #[doc = " @param reta_size"]
    #[doc = "   Redirection table size. The table size can be queried by"]
    #[doc = "   rte_eth_dev_info_get()."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if *port_id* is invalid."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    #[doc = "   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_rss_reta_query(
        port_id: u16,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Updates unicast hash table for receiving packet with the given destination"]
    #[doc = " MAC address, and the packet is routed to all VFs for which the Rx mode is"]
    #[doc = " accept packets that match the unicast hash table."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param addr"]
    #[doc = "   Unicast MAC address."]
    #[doc = " @param on"]
    #[doc = "    1 - Set an unicast hash bit for receiving packets with the MAC address."]
    #[doc = "    0 - Clear an unicast hash bit."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "  - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_uc_hash_table_set(
        port_id: u16,
        addr: *mut rte_ether_addr,
        on: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Updates all unicast hash bitmaps for receiving packet with any Unicast"]
    #[doc = " Ethernet MAC addresses,the packet is routed to all VFs for which the Rx"]
    #[doc = " mode is accept packets that match the unicast hash table."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param on"]
    #[doc = "    1 - Set all unicast hash bitmaps for receiving all the Ethernet"]
    #[doc = "         MAC addresses"]
    #[doc = "    0 - Clear all unicast hash bitmaps"]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "  - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_uc_all_hash_table_set(port_id: u16, on: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the rate limitation for a queue on an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_idx"]
    #[doc = "   The queue ID."]
    #[doc = " @param tx_rate"]
    #[doc = "   The Tx rate in Mbps. Allocated from the total port link speed."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support this feature."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_set_queue_rate_limit(
        port_id: u16,
        queue_idx: u16,
        tx_rate: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configuration of Receive Side Scaling hash computation of Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rss_conf"]
    #[doc = "   The new configuration to use for RSS hash computation on the port."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if port identifier is invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_rss_hash_update(
        port_id: u16,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve current configuration of Receive Side Scaling hash computation"]
    #[doc = " of Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rss_conf"]
    #[doc = "   Where to store the current RSS hash configuration of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if port identifier is invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support RSS."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_rss_hash_conf_get(
        port_id: u16,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add UDP tunneling port for a type of tunnel."]
    #[doc = ""]
    #[doc = " Some NICs may require such configuration to properly parse a tunnel"]
    #[doc = " with any standard or custom UDP port."]
    #[doc = " The packets with this UDP port will be parsed for this type of tunnel."]
    #[doc = " The device parser will also check the rest of the tunnel headers"]
    #[doc = " before classifying the packet."]
    #[doc = ""]
    #[doc = " With some devices, this API will affect packet classification, i.e.:"]
    #[doc = "     - mbuf.packet_type reported on Rx"]
    #[doc = "     - rte_flow rules with tunnel items"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param tunnel_udp"]
    #[doc = "   UDP tunneling configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if port identifier is invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support tunnel type."]
    pub fn rte_eth_dev_udp_tunnel_port_add(
        port_id: u16,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete UDP tunneling port for a type of tunnel."]
    #[doc = ""]
    #[doc = " The packets with this UDP port will not be classified as this type of tunnel"]
    #[doc = " anymore if the device use such mapping for tunnel packet classification."]
    #[doc = ""]
    #[doc = " @see rte_eth_dev_udp_tunnel_port_add"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param tunnel_udp"]
    #[doc = "   UDP tunneling configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if port identifier is invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support tunnel type."]
    pub fn rte_eth_dev_udp_tunnel_port_delete(
        port_id: u16,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get DCB information on an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param dcb_info"]
    #[doc = "   DCB information."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if port identifier is invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_get_dcb_info(
        port_id: u16,
        dcb_info: *mut rte_eth_dcb_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a callback to be called on packet Rx on a given port and queue."]
    #[doc = ""]
    #[doc = " This API configures a function to be called for each burst of"]
    #[doc = " packets received on a given NIC port queue. The return value is a pointer"]
    #[doc = " that can be used to later remove the callback using"]
    #[doc = " rte_eth_remove_rx_callback()."]
    #[doc = ""]
    #[doc = " Multiple functions are called in the order that they are added."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The queue on the Ethernet device on which the callback is to be added."]
    #[doc = " @param fn"]
    #[doc = "   The callback function"]
    #[doc = " @param user_param"]
    #[doc = "   A generic pointer parameter which will be passed to each invocation of the"]
    #[doc = "   callback function on this port and queue. Inter-thread synchronization"]
    #[doc = "   of any user data changes is the responsibility of the user."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   NULL on error."]
    #[doc = "   On success, a pointer value which can later be used to remove the callback."]
    pub fn rte_eth_add_rx_callback(
        port_id: u16,
        queue_id: u16,
        fn_: rte_rx_callback_fn,
        user_param: *mut ::std::os::raw::c_void,
    ) -> *const rte_eth_rxtx_callback;
}
extern "C" {
    #[doc = " Add a callback that must be called first on packet Rx on a given port"]
    #[doc = " and queue."]
    #[doc = ""]
    #[doc = " This API configures a first function to be called for each burst of"]
    #[doc = " packets received on a given NIC port queue. The return value is a pointer"]
    #[doc = " that can be used to later remove the callback using"]
    #[doc = " rte_eth_remove_rx_callback()."]
    #[doc = ""]
    #[doc = " Multiple functions are called in the order that they are added."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The queue on the Ethernet device on which the callback is to be added."]
    #[doc = " @param fn"]
    #[doc = "   The callback function"]
    #[doc = " @param user_param"]
    #[doc = "   A generic pointer parameter which will be passed to each invocation of the"]
    #[doc = "   callback function on this port and queue. Inter-thread synchronization"]
    #[doc = "   of any user data changes is the responsibility of the user."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   NULL on error."]
    #[doc = "   On success, a pointer value which can later be used to remove the callback."]
    pub fn rte_eth_add_first_rx_callback(
        port_id: u16,
        queue_id: u16,
        fn_: rte_rx_callback_fn,
        user_param: *mut ::std::os::raw::c_void,
    ) -> *const rte_eth_rxtx_callback;
}
extern "C" {
    #[doc = " Add a callback to be called on packet Tx on a given port and queue."]
    #[doc = ""]
    #[doc = " This API configures a function to be called for each burst of"]
    #[doc = " packets sent on a given NIC port queue. The return value is a pointer"]
    #[doc = " that can be used to later remove the callback using"]
    #[doc = " rte_eth_remove_tx_callback()."]
    #[doc = ""]
    #[doc = " Multiple functions are called in the order that they are added."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The queue on the Ethernet device on which the callback is to be added."]
    #[doc = " @param fn"]
    #[doc = "   The callback function"]
    #[doc = " @param user_param"]
    #[doc = "   A generic pointer parameter which will be passed to each invocation of the"]
    #[doc = "   callback function on this port and queue. Inter-thread synchronization"]
    #[doc = "   of any user data changes is the responsibility of the user."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   NULL on error."]
    #[doc = "   On success, a pointer value which can later be used to remove the callback."]
    pub fn rte_eth_add_tx_callback(
        port_id: u16,
        queue_id: u16,
        fn_: rte_tx_callback_fn,
        user_param: *mut ::std::os::raw::c_void,
    ) -> *const rte_eth_rxtx_callback;
}
extern "C" {
    #[doc = " Remove an Rx packet callback from a given port and queue."]
    #[doc = ""]
    #[doc = " This function is used to removed callbacks that were added to a NIC port"]
    #[doc = " queue using rte_eth_add_rx_callback()."]
    #[doc = ""]
    #[doc = " Note: the callback is removed from the callback list but it isn't freed"]
    #[doc = " since the it may still be in use. The memory for the callback can be"]
    #[doc = " subsequently freed back by the application by calling rte_free():"]
    #[doc = ""]
    #[doc = " - Immediately - if the port is stopped, or the user knows that no"]
    #[doc = "   callbacks are in flight e.g. if called from the thread doing Rx/Tx"]
    #[doc = "   on that queue."]
    #[doc = ""]
    #[doc = " - After a short delay - where the delay is sufficient to allow any"]
    #[doc = "   in-flight callbacks to complete. Alternately, the RCU mechanism can be"]
    #[doc = "   used to detect when data plane threads have ceased referencing the"]
    #[doc = "   callback memory."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The queue on the Ethernet device from which the callback is to be removed."]
    #[doc = " @param user_cb"]
    #[doc = "   User supplied callback created via rte_eth_add_rx_callback()."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success. Callback was removed."]
    #[doc = "   - -ENODEV:  If *port_id* is invalid."]
    #[doc = "   - -ENOTSUP: Callback support is not available."]
    #[doc = "   - -EINVAL:  The queue_id is out of range, or the callback"]
    #[doc = "               is NULL or not found for the port/queue."]
    pub fn rte_eth_remove_rx_callback(
        port_id: u16,
        queue_id: u16,
        user_cb: *const rte_eth_rxtx_callback,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a Tx packet callback from a given port and queue."]
    #[doc = ""]
    #[doc = " This function is used to removed callbacks that were added to a NIC port"]
    #[doc = " queue using rte_eth_add_tx_callback()."]
    #[doc = ""]
    #[doc = " Note: the callback is removed from the callback list but it isn't freed"]
    #[doc = " since the it may still be in use. The memory for the callback can be"]
    #[doc = " subsequently freed back by the application by calling rte_free():"]
    #[doc = ""]
    #[doc = " - Immediately - if the port is stopped, or the user knows that no"]
    #[doc = "   callbacks are in flight e.g. if called from the thread doing Rx/Tx"]
    #[doc = "   on that queue."]
    #[doc = ""]
    #[doc = " - After a short delay - where the delay is sufficient to allow any"]
    #[doc = "   in-flight callbacks to complete. Alternately, the RCU mechanism can be"]
    #[doc = "   used to detect when data plane threads have ceased referencing the"]
    #[doc = "   callback memory."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The queue on the Ethernet device from which the callback is to be removed."]
    #[doc = " @param user_cb"]
    #[doc = "   User supplied callback created via rte_eth_add_tx_callback()."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success. Callback was removed."]
    #[doc = "   - -ENODEV:  If *port_id* is invalid."]
    #[doc = "   - -ENOTSUP: Callback support is not available."]
    #[doc = "   - -EINVAL:  The queue_id is out of range, or the callback"]
    #[doc = "               is NULL or not found for the port/queue."]
    pub fn rte_eth_remove_tx_callback(
        port_id: u16,
        queue_id: u16,
        user_cb: *const rte_eth_rxtx_callback,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve information about given port's Rx queue."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The Rx queue on the Ethernet device for which information"]
    #[doc = "   will be retrieved."]
    #[doc = " @param qinfo"]
    #[doc = "   A pointer to a structure of type *rte_eth_rxq_info_info* to be filled with"]
    #[doc = "   the information of the Ethernet device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - -ENODEV:  If *port_id* is invalid."]
    #[doc = "   - -ENOTSUP: routine is not supported by the device PMD."]
    #[doc = "   - -EINVAL:  The queue_id is out of range, or the queue"]
    #[doc = "               is hairpin queue."]
    pub fn rte_eth_rx_queue_info_get(
        port_id: u16,
        queue_id: u16,
        qinfo: *mut rte_eth_rxq_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve information about given port's Tx queue."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The Tx queue on the Ethernet device for which information"]
    #[doc = "   will be retrieved."]
    #[doc = " @param qinfo"]
    #[doc = "   A pointer to a structure of type *rte_eth_txq_info_info* to be filled with"]
    #[doc = "   the information of the Ethernet device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - -ENODEV:  If *port_id* is invalid."]
    #[doc = "   - -ENOTSUP: routine is not supported by the device PMD."]
    #[doc = "   - -EINVAL:  The queue_id is out of range, or the queue"]
    #[doc = "               is hairpin queue."]
    pub fn rte_eth_tx_queue_info_get(
        port_id: u16,
        queue_id: u16,
        qinfo: *mut rte_eth_txq_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve information about the Rx packet burst mode."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The Rx queue on the Ethernet device for which information"]
    #[doc = "   will be retrieved."]
    #[doc = " @param mode"]
    #[doc = "   A pointer to a structure of type *rte_eth_burst_mode* to be filled"]
    #[doc = "   with the information of the packet burst mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - -ENODEV:  If *port_id* is invalid."]
    #[doc = "   - -ENOTSUP: routine is not supported by the device PMD."]
    #[doc = "   - -EINVAL:  The queue_id is out of range."]
    pub fn rte_eth_rx_burst_mode_get(
        port_id: u16,
        queue_id: u16,
        mode: *mut rte_eth_burst_mode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve information about the Tx packet burst mode."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The Tx queue on the Ethernet device for which information"]
    #[doc = "   will be retrieved."]
    #[doc = " @param mode"]
    #[doc = "   A pointer to a structure of type *rte_eth_burst_mode* to be filled"]
    #[doc = "   with the information of the packet burst mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - -ENODEV:  If *port_id* is invalid."]
    #[doc = "   - -ENOTSUP: routine is not supported by the device PMD."]
    #[doc = "   - -EINVAL:  The queue_id is out of range."]
    pub fn rte_eth_tx_burst_mode_get(
        port_id: u16,
        queue_id: u16,
        mode: *mut rte_eth_burst_mode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Retrieve the monitor condition for a given receive queue."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The Rx queue on the Ethernet device for which information"]
    #[doc = "   will be retrieved."]
    #[doc = " @param pmc"]
    #[doc = "   The pointer to power-optimized monitoring condition structure."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   -ENOTSUP: Operation not supported."]
    #[doc = "   -EINVAL: Invalid parameters."]
    #[doc = "   -ENODEV: Invalid port ID."]
    pub fn rte_eth_get_monitor_addr(
        port_id: u16,
        queue_id: u16,
        pmc: *mut rte_power_monitor_cond,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve device registers and register attributes (number of registers and"]
    #[doc = " register size)"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param info"]
    #[doc = "   Pointer to rte_dev_reg_info structure to fill in. If info->data is"]
    #[doc = "   NULL the function fills in the width and length fields. If non-NULL"]
    #[doc = "   the registers are put into the buffer pointed at by the data field."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_reg_info(
        port_id: u16,
        info: *mut rte_dev_reg_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve size of device EEPROM"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (>=0) EEPROM size if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_eeprom_length(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve EEPROM and EEPROM attribute"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param info"]
    #[doc = "   The template includes buffer for return EEPROM data and"]
    #[doc = "   EEPROM attributes to be filled."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_eeprom(
        port_id: u16,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Program EEPROM with provided data"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param info"]
    #[doc = "   The template includes EEPROM data for programming and"]
    #[doc = "   EEPROM attributes to be filled"]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_set_eeprom(
        port_id: u16,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Retrieve the type and size of plugin module EEPROM"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param modinfo"]
    #[doc = "   The type and size of plugin module EEPROM."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_module_info(
        port_id: u16,
        modinfo: *mut rte_eth_dev_module_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Retrieve the data of plugin module EEPROM"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param info"]
    #[doc = "   The template includes the plugin module EEPROM attributes, and the"]
    #[doc = "   buffer for return plugin module EEPROM data."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_module_eeprom(
        port_id: u16,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the list of multicast addresses to filter on an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mc_addr_set"]
    #[doc = "   The array of multicast addresses to set. Equal to NULL when the function"]
    #[doc = "   is invoked to flush the set of filtered addresses."]
    #[doc = " @param nb_mc_addr"]
    #[doc = "   The number of multicast addresses in the *mc_addr_set* array. Equal to 0"]
    #[doc = "   when the function is invoked to flush the set of filtered addresses."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENOTSUP) if PMD of *port_id* doesn't support multicast filtering."]
    #[doc = "   - (-ENOSPC) if *port_id* has not enough multicast filtering resources."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_set_mc_addr_list(
        port_id: u16,
        mc_addr_set: *mut rte_ether_addr,
        nb_mc_addr: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable IEEE1588/802.1AS timestamping for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - -ENODEV: The port ID is invalid."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_enable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disable IEEE1588/802.1AS timestamping for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - -ENODEV: The port ID is invalid."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_disable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read an IEEE1588/802.1AS Rx timestamp from an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param timestamp"]
    #[doc = "   Pointer to the timestamp struct."]
    #[doc = " @param flags"]
    #[doc = "   Device specific flags. Used to pass the Rx timesync register index to"]
    #[doc = "   i40e. Unused in igb/ixgbe, pass 0 instead."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - -EINVAL: No timestamp is available."]
    #[doc = "   - -ENODEV: The port ID is invalid."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_read_rx_timestamp(
        port_id: u16,
        timestamp: *mut timespec,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read an IEEE1588/802.1AS Tx timestamp from an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param timestamp"]
    #[doc = "   Pointer to the timestamp struct."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - -EINVAL: No timestamp is available."]
    #[doc = "   - -ENODEV: The port ID is invalid."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_read_tx_timestamp(
        port_id: u16,
        timestamp: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Adjust the timesync clock on an Ethernet device."]
    #[doc = ""]
    #[doc = " This is usually used in conjunction with other Ethdev timesync functions to"]
    #[doc = " synchronize the device time using the IEEE1588/802.1AS protocol."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param delta"]
    #[doc = "   The adjustment in nanoseconds."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - -ENODEV: The port ID is invalid."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_adjust_time(port_id: u16, delta: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read the time from the timesync clock on an Ethernet device."]
    #[doc = ""]
    #[doc = " This is usually used in conjunction with other Ethdev timesync functions to"]
    #[doc = " synchronize the device time using the IEEE1588/802.1AS protocol."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param time"]
    #[doc = "   Pointer to the timespec struct that holds the time."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - -EINVAL: Bad parameter."]
    pub fn rte_eth_timesync_read_time(port_id: u16, time: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the time of the timesync clock on an Ethernet device."]
    #[doc = ""]
    #[doc = " This is usually used in conjunction with other Ethdev timesync functions to"]
    #[doc = " synchronize the device time using the IEEE1588/802.1AS protocol."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param time"]
    #[doc = "   Pointer to the timespec struct that holds the time."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - -EINVAL: No timestamp is available."]
    #[doc = "   - -ENODEV: The port ID is invalid."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_write_time(
        port_id: u16,
        time: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Read the current clock counter of an Ethernet device"]
    #[doc = ""]
    #[doc = " This returns the current raw clock value of an Ethernet device. It is"]
    #[doc = " a raw amount of ticks, with no given time reference."]
    #[doc = " The value returned here is from the same clock than the one"]
    #[doc = " filling timestamp field of Rx packets when using hardware timestamp"]
    #[doc = " offload. Therefore it can be used to compute a precise conversion of"]
    #[doc = " the device clock to the real time."]
    #[doc = ""]
    #[doc = " E.g, a simple heuristic to derivate the frequency would be:"]
    #[doc = " uint64_t start, end;"]
    #[doc = " rte_eth_read_clock(port, start);"]
    #[doc = " rte_delay_ms(100);"]
    #[doc = " rte_eth_read_clock(port, end);"]
    #[doc = " double freq = (end - start) * 10;"]
    #[doc = ""]
    #[doc = " Compute a common reference with:"]
    #[doc = " uint64_t base_time_sec = current_time();"]
    #[doc = " uint64_t base_clock;"]
    #[doc = " rte_eth_read_clock(port, base_clock);"]
    #[doc = ""]
    #[doc = " Then, convert the raw mbuf timestamp with:"]
    #[doc = " base_time_sec + (double)(*timestamp_dynfield(mbuf) - base_clock) / freq;"]
    #[doc = ""]
    #[doc = " This simple example will not provide a very good accuracy. One must"]
    #[doc = " at least measure multiple times the frequency and do a regression."]
    #[doc = " To avoid deviation from the system time, the common reference can"]
    #[doc = " be repeated from time to time. The integer division can also be"]
    #[doc = " converted by a multiplication and a shift for better performance."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param clock"]
    #[doc = "   Pointer to the uint64_t that holds the raw clock value."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - -ENODEV: The port ID is invalid."]
    #[doc = "   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    #[doc = "   - -EINVAL: if bad parameter."]
    pub fn rte_eth_read_clock(port_id: u16, clock: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the port ID from device name. The device name should be specified"]
    #[doc = " as below:"]
    #[doc = " - PCIe address (Domain:Bus:Device.Function), for example- 0000:2:00.0"]
    #[doc = " - SoC device name, for example- fsl-gmac0"]
    #[doc = " - vdev dpdk name, for example- net_[pcap0|null0|tap0]"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "  pci address or name of the device"]
    #[doc = " @param port_id"]
    #[doc = "   pointer to port identifier of the device"]
    #[doc = " @return"]
    #[doc = "   - (0) if successful and port_id is filled."]
    #[doc = "   - (-ENODEV or -EINVAL) on failure."]
    pub fn rte_eth_dev_get_port_by_name(
        name: *const ::std::os::raw::c_char,
        port_id: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the device name from port ID. The device name is specified as below:"]
    #[doc = " - PCIe address (Domain:Bus:Device.Function), for example- 0000:02:00.0"]
    #[doc = " - SoC device name, for example- fsl-gmac0"]
    #[doc = " - vdev dpdk name, for example- net_[pcap0|null0|tun0|tap0]"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of the device."]
    #[doc = " @param name"]
    #[doc = "   Buffer of size RTE_ETH_NAME_MAX_LEN to store the name."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if *port_id* is invalid."]
    #[doc = "   - (-EINVAL) on failure."]
    pub fn rte_eth_dev_get_name_by_port(
        port_id: u16,
        name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check that numbers of Rx and Tx descriptors satisfy descriptors limits from"]
    #[doc = " the Ethernet device information, otherwise adjust them to boundaries."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param nb_rx_desc"]
    #[doc = "   A pointer to a uint16_t where the number of receive"]
    #[doc = "   descriptors stored."]
    #[doc = " @param nb_tx_desc"]
    #[doc = "   A pointer to a uint16_t where the number of transmit"]
    #[doc = "   descriptors stored."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP, -ENODEV or -EINVAL) on failure."]
    pub fn rte_eth_dev_adjust_nb_rx_tx_desc(
        port_id: u16,
        nb_rx_desc: *mut u16,
        nb_tx_desc: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test if a port supports specific mempool ops."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of the Ethernet device."]
    #[doc = " @param [in] pool"]
    #[doc = "   The name of the pool operations to test."]
    #[doc = " @return"]
    #[doc = "   - 0: best mempool ops choice for this port."]
    #[doc = "   - 1: mempool ops are supported for this port."]
    #[doc = "   - -ENOTSUP: mempool ops not supported for this port."]
    #[doc = "   - -ENODEV: Invalid port Identifier."]
    #[doc = "   - -EINVAL: Pool param is null."]
    pub fn rte_eth_dev_pool_ops_supported(
        port_id: u16,
        pool: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the security context for the Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of the Ethernet device"]
    #[doc = " @return"]
    #[doc = "   - NULL on error."]
    #[doc = "   - pointer to security context on success."]
    pub fn rte_eth_dev_get_sec_ctx(port_id: u16) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Query the device hairpin capabilities."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param cap"]
    #[doc = "   Pointer to a structure that will hold the hairpin capabilities."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_hairpin_capability_get(
        port_id: u16,
        cap: *mut rte_eth_hairpin_cap,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice."]
#[doc = ""]
#[doc = " Ethernet device representor ID range entry"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_representor_range {
    #[doc = "< Representor type"]
    pub type_: rte_eth_representor_type,
    #[doc = "< Controller index"]
    pub controller: ::std::os::raw::c_int,
    #[doc = "< Physical function index"]
    pub pf: ::std::os::raw::c_int,
    pub __bindgen_anon_1: rte_eth_representor_range__bindgen_ty_1,
    #[doc = "< Representor ID start index"]
    pub id_base: u32,
    #[doc = "< Representor ID end index"]
    pub id_end: u32,
    #[doc = "< Representor name"]
    pub name: [::std::os::raw::c_char; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_representor_range__bindgen_ty_1 {
    #[doc = "< VF start index"]
    pub vf: ::std::os::raw::c_int,
    #[doc = "< SF start index"]
    pub sf: ::std::os::raw::c_int,
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice."]
#[doc = ""]
#[doc = " Ethernet device representor information"]
#[repr(C)]
pub struct rte_eth_representor_info {
    #[doc = "< Controller ID of caller device."]
    pub controller: u16,
    #[doc = "< Physical function ID of caller device."]
    pub pf: u16,
    #[doc = "< Size of the ranges array."]
    pub nb_ranges_alloc: u32,
    #[doc = "< Number of initialized ranges."]
    pub nb_ranges: u32,
    #[doc = "< Representor ID range."]
    pub ranges: __IncompleteArrayField<rte_eth_representor_range>,
}
extern "C" {
    #[doc = " Retrieve the representor info of the device."]
    #[doc = ""]
    #[doc = " Get device representor info to be able to calculate a unique"]
    #[doc = " representor ID. @see rte_eth_representor_id_get helper."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the device."]
    #[doc = " @param info"]
    #[doc = "   A pointer to a representor info structure."]
    #[doc = "   NULL to return number of range entries and allocate memory"]
    #[doc = "   for next call to store detail."]
    #[doc = "   The number of ranges that were written into this structure"]
    #[doc = "   will be placed into its nb_ranges field. This number cannot be"]
    #[doc = "   larger than the nb_ranges_alloc that by the user before calling"]
    #[doc = "   this function. It can be smaller than the value returned by the"]
    #[doc = "   function, however."]
    #[doc = " @return"]
    #[doc = "   - (-ENOTSUP) if operation is not supported."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (>=0) number of available representor range entries."]
    pub fn rte_eth_representor_info_get(
        port_id: u16,
        info: *mut rte_eth_representor_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Negotiate the NIC's ability to deliver specific kinds of metadata to the PMD."]
    #[doc = ""]
    #[doc = " Invoke this API before the first rte_eth_dev_configure() invocation"]
    #[doc = " to let the PMD make preparations that are inconvenient to do later."]
    #[doc = ""]
    #[doc = " The negotiation process is as follows:"]
    #[doc = ""]
    #[doc = " - the application requests features intending to use at least some of them;"]
    #[doc = " - the PMD responds with the guaranteed subset of the requested feature set;"]
    #[doc = " - the application can retry negotiation with another set of features;"]
    #[doc = " - the application can pass zero to clear the negotiation result;"]
    #[doc = " - the last negotiated result takes effect upon"]
    #[doc = "   the ethdev configure and start."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "   The PMD is supposed to first consider enabling the requested feature set"]
    #[doc = "   in its entirety. Only if it fails to do so, does it have the right to"]
    #[doc = "   respond with a smaller set of the originally requested features."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "   Return code (-ENOTSUP) does not necessarily mean that the requested"]
    #[doc = "   features are unsupported. In this case, the application should just"]
    #[doc = "   assume that these features can be used without prior negotiations."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port (ethdev) identifier"]
    #[doc = ""]
    #[doc = " @param[inout] features"]
    #[doc = "   Feature selection buffer"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (-EBUSY) if the port can't handle this in its current state;"]
    #[doc = "   - (-ENOTSUP) if the method itself is not supported by the PMD;"]
    #[doc = "   - (-ENODEV) if *port_id* is invalid;"]
    #[doc = "   - (-EINVAL) if *features* is NULL;"]
    #[doc = "   - (-EIO) if the device is removed;"]
    #[doc = "   - (0) on success"]
    pub fn rte_eth_rx_metadata_negotiate(port_id: u16, features: *mut u64)
        -> ::std::os::raw::c_int;
}
#[doc = " A structure used to get/set IP reassembly configuration. It is also used"]
#[doc = " to get the maximum capability values that a PMD can support."]
#[doc = ""]
#[doc = " If rte_eth_ip_reassembly_capability_get() returns 0, IP reassembly can be"]
#[doc = " enabled using rte_eth_ip_reassembly_conf_set() and params values lower than"]
#[doc = " capability params can be set in the PMD."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_ip_reassembly_params {
    #[doc = " Maximum time in ms which PMD can wait for other fragments."]
    pub timeout_ms: u32,
    #[doc = " Maximum number of fragments that can be reassembled."]
    pub max_frags: u16,
    #[doc = " Flags to enable reassembly of packet types -"]
    #[doc = " RTE_ETH_DEV_REASSEMBLY_F_xxx."]
    pub flags: u16,
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Get IP reassembly capabilities supported by the PMD. This is the first API"]
    #[doc = " to be called for enabling the IP reassembly offload feature. PMD will return"]
    #[doc = " the maximum values of parameters that PMD can support and user can call"]
    #[doc = " rte_eth_ip_reassembly_conf_set() with param values lower than capability."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the device."]
    #[doc = " @param capa"]
    #[doc = "   A pointer to rte_eth_ip_reassembly_params structure."]
    #[doc = " @return"]
    #[doc = "   - (-ENOTSUP) if offload configuration is not supported by device."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-EINVAL) if device is not configured or *capa* passed is NULL."]
    #[doc = "   - (0) on success."]
    pub fn rte_eth_ip_reassembly_capability_get(
        port_id: u16,
        capa: *mut rte_eth_ip_reassembly_params,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Get IP reassembly configuration parameters currently set in PMD."]
    #[doc = " The API will return error if the configuration is not already"]
    #[doc = " set using rte_eth_ip_reassembly_conf_set() before calling this API or if"]
    #[doc = " the device is not configured."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the device."]
    #[doc = " @param conf"]
    #[doc = "   A pointer to rte_eth_ip_reassembly_params structure."]
    #[doc = " @return"]
    #[doc = "   - (-ENOTSUP) if offload configuration is not supported by device."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-EINVAL) if device is not configured or if *conf* passed is NULL or if"]
    #[doc = "              configuration is not set using rte_eth_ip_reassembly_conf_set()."]
    #[doc = "   - (0) on success."]
    pub fn rte_eth_ip_reassembly_conf_get(
        port_id: u16,
        conf: *mut rte_eth_ip_reassembly_params,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Set IP reassembly configuration parameters if the PMD supports IP reassembly"]
    #[doc = " offload. User should first call rte_eth_ip_reassembly_capability_get() to"]
    #[doc = " check the maximum values supported by the PMD before setting the"]
    #[doc = " configuration. The use of this API is mandatory to enable this feature and"]
    #[doc = " should be called before rte_eth_dev_start()."]
    #[doc = ""]
    #[doc = " In datapath, PMD cannot guarantee that IP reassembly is always successful."]
    #[doc = " Hence, PMD shall register mbuf dynamic field and dynamic flag using"]
    #[doc = " rte_eth_ip_reassembly_dynfield_register() to denote incomplete IP reassembly."]
    #[doc = " If dynfield is not successfully registered, error will be returned and"]
    #[doc = " IP reassembly offload cannot be used."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the device."]
    #[doc = " @param conf"]
    #[doc = "   A pointer to rte_eth_ip_reassembly_params structure."]
    #[doc = " @return"]
    #[doc = "   - (-ENOTSUP) if offload configuration is not supported by device."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-EINVAL) if device is not configured or if device is already started or"]
    #[doc = "               if *conf* passed is NULL or if mbuf dynfield is not registered"]
    #[doc = "               successfully by the PMD."]
    #[doc = "   - (0) on success."]
    pub fn rte_eth_ip_reassembly_conf_set(
        port_id: u16,
        conf: *const rte_eth_ip_reassembly_params,
    ) -> ::std::os::raw::c_int;
}
#[doc = " In case of IP reassembly offload failure, packet will be updated with"]
#[doc = " dynamic flag - RTE_MBUF_DYNFLAG_IP_REASSEMBLY_INCOMPLETE_NAME and packets"]
#[doc = " will be returned without alteration."]
#[doc = " The application can retrieve the attached fragments using mbuf dynamic field"]
#[doc = " RTE_MBUF_DYNFIELD_IP_REASSEMBLY_NAME."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_ip_reassembly_dynfield_t {
    #[doc = " Next fragment packet. Application should fetch dynamic field of"]
    #[doc = " each fragment until a NULL is received and nb_frags is 0."]
    pub next_frag: *mut rte_mbuf,
    #[doc = " Time spent(in ms) by HW in waiting for further fragments."]
    pub time_spent: u16,
    #[doc = " Number of more fragments attached in mbuf dynamic fields."]
    pub nb_frags: u16,
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Dump private info from device to a file. Provided data and the order depends"]
    #[doc = " on the PMD."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param file"]
    #[doc = "   A pointer to a file for output."]
    #[doc = " @return"]
    #[doc = "   - (0) on success."]
    #[doc = "   - (-ENODEV) if *port_id* is invalid."]
    #[doc = "   - (-EINVAL) if null file."]
    #[doc = "   - (-ENOTSUP) if the device does not support this function."]
    #[doc = "   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_priv_dump(port_id: u16, file: *mut FILE) -> ::std::os::raw::c_int;
}
#[doc = " @file"]
#[doc = ""]
#[doc = " RTE Ethernet Device internal header."]
#[doc = ""]
#[doc = " This header contains internal data types. But they are still part of the"]
#[doc = " public API because they are used by inline functions in the published API."]
#[doc = ""]
#[doc = " Applications should not use these directly."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_callback {
    _unused: [u8; 0],
}
#[doc = " @internal Structure to keep track of registered callbacks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_cb_list {
    pub tqh_first: *mut rte_eth_dev_callback,
    pub tqh_last: *mut *mut rte_eth_dev_callback,
}
#[doc = " @internal Retrieve input packets from a receive queue of an Ethernet device."]
pub type eth_rx_burst_t = ::std::option::Option<
    unsafe extern "C" fn(
        rxq: *mut ::std::os::raw::c_void,
        rx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
#[doc = " @internal Send output packets on a transmit queue of an Ethernet device."]
pub type eth_tx_burst_t = ::std::option::Option<
    unsafe extern "C" fn(
        txq: *mut ::std::os::raw::c_void,
        tx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
#[doc = " @internal Prepare output packets on a transmit queue of an Ethernet device."]
pub type eth_tx_prep_t = ::std::option::Option<
    unsafe extern "C" fn(
        txq: *mut ::std::os::raw::c_void,
        tx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
#[doc = " @internal Get number of used descriptors on a receive queue."]
pub type eth_rx_queue_count_t =
    ::std::option::Option<unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void) -> u32>;
#[doc = " @internal Check the status of a Rx descriptor"]
pub type eth_rx_descriptor_status_t = ::std::option::Option<
    unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Check the status of a Tx descriptor"]
pub type eth_tx_descriptor_status_t = ::std::option::Option<
    unsafe extern "C" fn(txq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Structure used to hold opaque pointers to internal ethdev Rx/Tx"]
#[doc = " queues data."]
#[doc = " The main purpose to expose these pointers at all - allow compiler"]
#[doc = " to fetch this data for fast-path ethdev inline functions in advance."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ethdev_qdata {
    #[doc = " points to array of internal queue data pointers"]
    pub data: *mut *mut ::std::os::raw::c_void,
    #[doc = " points to array of queue callback data pointers"]
    pub clbk: *mut *mut ::std::os::raw::c_void,
}

extern "C" {
    pub static mut rte_eth_fp_ops: [rte_eth_fp_ops; 32usize];
}

#[doc = " @internal"]
#[doc = " fast-path ethdev functions and related data are hold in a flat array."]
#[doc = " One entry per ethdev."]
#[doc = " On 64-bit systems contents of this structure occupy exactly two 64B lines."]
#[doc = " On 32-bit systems contents of this structure fits into one 64B line."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fp_ops {
    #[doc = "@{*/"]
    #[doc = " Rx fast-path functions and related data."]
    #[doc = " 64-bit systems: occupies first 64B line"]
    pub rx_pkt_burst: eth_rx_burst_t,
    #[doc = " Get the number of used Rx descriptors."]
    pub rx_queue_count: eth_rx_queue_count_t,
    #[doc = " Check the status of a Rx descriptor."]
    pub rx_descriptor_status: eth_rx_descriptor_status_t,
    #[doc = " Rx queues data."]
    pub rxq: rte_ethdev_qdata,
    pub reserved1: [usize; 3usize],
    #[doc = "@{*/"]
    #[doc = " Tx fast-path functions and related data."]
    #[doc = " 64-bit systems: occupies second 64B line"]
    pub tx_pkt_burst: eth_tx_burst_t,
    #[doc = " PMD transmit prepare function."]
    pub tx_pkt_prepare: eth_tx_prep_t,
    #[doc = " Check the status of a Tx descriptor."]
    pub tx_descriptor_status: eth_tx_descriptor_status_t,
    #[doc = " Tx queues data."]
    pub txq: rte_ethdev_qdata,
    pub reserved2: [usize; 3usize],
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Helper routine for rte_eth_rx_burst()."]
    #[doc = " Should be called at exit from PMD's rte_eth_rx_bulk implementation."]
    #[doc = " Does necessary post-processing - invokes Rx callbacks if any, etc."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "  The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "  The index of the receive queue from which to retrieve input packets."]
    #[doc = " @param rx_pkts"]
    #[doc = "   The address of an array of pointers to *rte_mbuf* structures that"]
    #[doc = "   have been retrieved from the device."]
    #[doc = " @param nb_rx"]
    #[doc = "   The number of packets that were retrieved from the device."]
    #[doc = " @param nb_pkts"]
    #[doc = "   The number of elements in @p rx_pkts array."]
    #[doc = " @param opaque"]
    #[doc = "   Opaque pointer of Rx queue callback related data."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  The number of packets effectively supplied to the @p rx_pkts array."]
    pub fn rte_eth_call_rx_callbacks(
        port_id: u16,
        queue_id: u16,
        rx_pkts: *mut *mut rte_mbuf,
        nb_rx: u16,
        nb_pkts: u16,
        opaque: *mut ::std::os::raw::c_void,
    ) -> u16;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Helper routine for rte_eth_tx_burst()."]
    #[doc = " Should be called before entry PMD's rte_eth_tx_bulk implementation."]
    #[doc = " Does necessary pre-processing - invokes Tx callbacks if any, etc."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the transmit queue through which output packets must be"]
    #[doc = "   sent."]
    #[doc = " @param tx_pkts"]
    #[doc = "   The address of an array of *nb_pkts* pointers to *rte_mbuf* structures"]
    #[doc = "   which contain the output packets."]
    #[doc = " @param nb_pkts"]
    #[doc = "   The maximum number of packets to transmit."]
    #[doc = " @return"]
    #[doc = "   The number of output packets to transmit."]
    pub fn rte_eth_call_tx_callbacks(
        port_id: u16,
        queue_id: u16,
        tx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        opaque: *mut ::std::os::raw::c_void,
    ) -> u16;
}
extern "C" {
    pub static mut __rte_ethdev_trace_configure: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_ethdev_trace_rxq_setup: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_ethdev_trace_txq_setup: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_ethdev_trace_start: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_ethdev_trace_stop: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_ethdev_trace_close: rte_trace_point_t;
}
extern "C" {
    #[doc = " Set the platform supported pktmbuf HW mempool ops name"]
    #[doc = ""]
    #[doc = " This function allow the HW to register the actively supported HW mempool"]
    #[doc = " ops_name. Only one HW mempool ops can be registered at any point of time."]
    #[doc = ""]
    #[doc = " @param ops_name"]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_mbuf_set_platform_mempool_ops(
        ops_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get configured platform supported pktmbuf HW mempool ops name"]
    #[doc = ""]
    #[doc = " This function returns the platform supported mempool ops name."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - On success, platform pool ops name."]
    #[doc = "   - On failure, NULL."]
    pub fn rte_mbuf_platform_mempool_ops() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set the user preferred pktmbuf mempool ops name"]
    #[doc = ""]
    #[doc = " This function can be used by the user to configure user preferred"]
    #[doc = " mempool ops name."]
    #[doc = ""]
    #[doc = " @param ops_name"]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_mbuf_set_user_mempool_ops(
        ops_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get user preferred pool ops name for mbuf"]
    #[doc = ""]
    #[doc = " This function returns the user configured mempool ops name."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - On success, user pool ops name.."]
    #[doc = "   - On failure, NULL."]
    pub fn rte_mbuf_user_mempool_ops() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the best mempool ops name for pktmbuf."]
    #[doc = ""]
    #[doc = " This function is used to determine the best options for mempool ops for"]
    #[doc = " pktmbuf allocations. Following are the priority order:"]
    #[doc = " 1. User defined, 2. Platform HW supported, 3. Compile time configured."]
    #[doc = " This function is also used by the rte_pktmbuf_pool_create to get the best"]
    #[doc = " mempool ops name."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   returns preferred mbuf pool ops name"]
    pub fn rte_mbuf_best_mempool_ops() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __rte_eventdev_trace_deq_burst: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eventdev_trace_enq_burst: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eventdev_trace_maintain: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eventdev_trace_eth_tx_adapter_enqueue: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eventdev_trace_crypto_adapter_enqueue: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eventdev_trace_timer_arm_burst: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eventdev_trace_timer_arm_tmo_tick_burst: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_eventdev_trace_timer_cancel_burst: rte_trace_point_t;
}
extern "C" {
    #[doc = " Get the total number of event devices that have been successfully"]
    #[doc = " initialised."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The total number of usable event devices."]
    pub fn rte_event_dev_count() -> u8;
}
extern "C" {
    #[doc = " Get the device identifier for the named event device."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Event device name to select the event device identifier."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Returns event device identifier on success."]
    #[doc = "   - <0: Failure to find named event device."]
    pub fn rte_event_dev_get_dev_id(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the NUMA socket to which a device is connected."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @return"]
    #[doc = "   The NUMA socket id to which the device is connected or"]
    #[doc = "   a default of zero if the socket could not be determined."]
    #[doc = "   -(-EINVAL)  dev_id value is out of range."]
    pub fn rte_event_dev_socket_id(dev_id: u8) -> ::std::os::raw::c_int;
}
#[doc = " Event device information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_event_dev_info {
    #[doc = "< Event driver name"]
    pub driver_name: *const ::std::os::raw::c_char,
    #[doc = "< Device information"]
    pub dev: *mut rte_device,
    pub min_dequeue_timeout_ns: u32,
    pub max_dequeue_timeout_ns: u32,
    pub dequeue_timeout_ns: u32,
    pub max_event_queues: u8,
    pub max_event_queue_flows: u32,
    pub max_event_queue_priority_levels: u8,
    pub max_event_priority_levels: u8,
    pub max_event_ports: u8,
    pub max_event_port_dequeue_depth: u8,
    pub max_event_port_enqueue_depth: u32,
    pub max_event_port_links: u8,
    pub max_num_events: i32,
    pub event_dev_cap: u32,
    pub max_single_link_event_port_queue_pairs: u8,
}
extern "C" {
    #[doc = " Retrieve the contextual information of an event device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @param[out] dev_info"]
    #[doc = "   A pointer to a structure of type *rte_event_dev_info* to be filled with the"]
    #[doc = "   contextual information of the device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success, driver updates the contextual information of the event device"]
    #[doc = "   - <0: Error code returned by the driver info get function."]
    #[doc = ""]
    pub fn rte_event_dev_info_get(
        dev_id: u8,
        dev_info: *mut rte_event_dev_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get an attribute from a device."]
    #[doc = ""]
    #[doc = " @param dev_id Eventdev id"]
    #[doc = " @param attr_id The attribute ID to retrieve"]
    #[doc = " @param[out] attr_value A pointer that will be filled in with the attribute"]
    #[doc = "             value if successful."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Successfully retrieved attribute value"]
    #[doc = "   - -EINVAL: Invalid device or  *attr_id* provided, or *attr_value* is NULL"]
    pub fn rte_event_dev_attr_get(
        dev_id: u8,
        attr_id: u32,
        attr_value: *mut u32,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Event device configuration structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_event_dev_config {
    pub dequeue_timeout_ns: u32,
    pub nb_events_limit: i32,
    pub nb_event_queues: u8,
    pub nb_event_ports: u8,
    pub nb_event_queue_flows: u32,
    pub nb_event_port_dequeue_depth: u32,
    pub nb_event_port_enqueue_depth: u32,
    pub event_dev_cfg: u32,
    pub nb_single_link_event_port_queues: u8,
}
extern "C" {
    #[doc = " Configure an event device."]
    #[doc = ""]
    #[doc = " This function must be invoked first before any other function in the"]
    #[doc = " API. This function can also be re-invoked when a device is in the"]
    #[doc = " stopped state."]
    #[doc = ""]
    #[doc = " The caller may use rte_event_dev_info_get() to get the capability of each"]
    #[doc = " resources available for this event device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device to configure."]
    #[doc = " @param dev_conf"]
    #[doc = "   The event device configuration structure."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success, device configured."]
    #[doc = "   - <0: Error code returned by the driver configuration function."]
    pub fn rte_event_dev_configure(
        dev_id: u8,
        dev_conf: *const rte_event_dev_config,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Event queue configuration structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_event_queue_conf {
    pub nb_atomic_flows: u32,
    pub nb_atomic_order_sequences: u32,
    pub event_queue_cfg: u32,
    pub schedule_type: u8,
    pub priority: u8,
}
extern "C" {
    #[doc = " Retrieve the default configuration information of an event queue designated"]
    #[doc = " by its *queue_id* from the event driver for an event device."]
    #[doc = ""]
    #[doc = " This function intended to be used in conjunction with rte_event_queue_setup()"]
    #[doc = " where caller needs to set up the queue by overriding few default values."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the event queue to get the configuration information."]
    #[doc = "   The value must be in the range [0, nb_event_queues - 1]"]
    #[doc = "   previously supplied to rte_event_dev_configure()."]
    #[doc = " @param[out] queue_conf"]
    #[doc = "   The pointer to the default event queue configuration data."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, driver updates the default event queue configuration data."]
    #[doc = "   - <0: Error code returned by the driver info get function."]
    #[doc = ""]
    #[doc = " @see rte_event_queue_setup()"]
    #[doc = ""]
    pub fn rte_event_queue_default_conf_get(
        dev_id: u8,
        queue_id: u8,
        queue_conf: *mut rte_event_queue_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate and set up an event queue for an event device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the event queue to setup. The value must be in the range"]
    #[doc = "   [0, nb_event_queues - 1] previously supplied to rte_event_dev_configure()."]
    #[doc = " @param queue_conf"]
    #[doc = "   The pointer to the configuration data to be used for the event queue."]
    #[doc = "   NULL value is allowed, in which case default configuration\tused."]
    #[doc = ""]
    #[doc = " @see rte_event_queue_default_conf_get()"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success, event queue correctly set up."]
    #[doc = "   - <0: event queue configuration failed"]
    pub fn rte_event_queue_setup(
        dev_id: u8,
        queue_id: u8,
        queue_conf: *const rte_event_queue_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get an attribute from a queue."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Eventdev id"]
    #[doc = " @param queue_id"]
    #[doc = "   Eventdev queue id"]
    #[doc = " @param attr_id"]
    #[doc = "   The attribute ID to retrieve"]
    #[doc = " @param[out] attr_value"]
    #[doc = "   A pointer that will be filled in with the attribute value if successful"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Successfully returned value"]
    #[doc = "   - -EINVAL: invalid device, queue or attr_id provided, or attr_value was"]
    #[doc = "\t\tNULL"]
    #[doc = "   - -EOVERFLOW: returned when attr_id is set to"]
    #[doc = "   RTE_EVENT_QUEUE_ATTR_SCHEDULE_TYPE and event_queue_cfg is set to"]
    #[doc = "   RTE_EVENT_QUEUE_CFG_ALL_TYPES"]
    pub fn rte_event_queue_attr_get(
        dev_id: u8,
        queue_id: u8,
        attr_id: u32,
        attr_value: *mut u32,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Event port configuration structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_event_port_conf {
    pub new_event_threshold: i32,
    pub dequeue_depth: u16,
    pub enqueue_depth: u16,
    #[doc = "< Port cfg flags(EVENT_PORT_CFG_)"]
    pub event_port_cfg: u32,
}
extern "C" {
    #[doc = " Retrieve the default configuration information of an event port designated"]
    #[doc = " by its *port_id* from the event driver for an event device."]
    #[doc = ""]
    #[doc = " This function intended to be used in conjunction with rte_event_port_setup()"]
    #[doc = " where caller needs to set up the port by overriding few default values."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param port_id"]
    #[doc = "   The index of the event port to get the configuration information."]
    #[doc = "   The value must be in the range [0, nb_event_ports - 1]"]
    #[doc = "   previously supplied to rte_event_dev_configure()."]
    #[doc = " @param[out] port_conf"]
    #[doc = "   The pointer to the default event port configuration data"]
    #[doc = " @return"]
    #[doc = "   - 0: Success, driver updates the default event port configuration data."]
    #[doc = "   - <0: Error code returned by the driver info get function."]
    #[doc = ""]
    #[doc = " @see rte_event_port_setup()"]
    #[doc = ""]
    pub fn rte_event_port_default_conf_get(
        dev_id: u8,
        port_id: u8,
        port_conf: *mut rte_event_port_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate and set up an event port for an event device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param port_id"]
    #[doc = "   The index of the event port to setup. The value must be in the range"]
    #[doc = "   [0, nb_event_ports - 1] previously supplied to rte_event_dev_configure()."]
    #[doc = " @param port_conf"]
    #[doc = "   The pointer to the configuration data to be used for the queue."]
    #[doc = "   NULL value is allowed, in which case default configuration\tused."]
    #[doc = ""]
    #[doc = " @see rte_event_port_default_conf_get()"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success, event port correctly set up."]
    #[doc = "   - <0: Port configuration failed"]
    #[doc = "   - (-EDQUOT) Quota exceeded(Application tried to link the queue configured"]
    #[doc = "   with RTE_EVENT_QUEUE_CFG_SINGLE_LINK to more than one event ports)"]
    pub fn rte_event_port_setup(
        dev_id: u8,
        port_id: u8,
        port_conf: *const rte_event_port_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get an attribute from a port."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Eventdev id"]
    #[doc = " @param port_id"]
    #[doc = "   Eventdev port id"]
    #[doc = " @param attr_id"]
    #[doc = "   The attribute ID to retrieve"]
    #[doc = " @param[out] attr_value"]
    #[doc = "   A pointer that will be filled in with the attribute value if successful"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Successfully returned value"]
    #[doc = "   - (-EINVAL) Invalid device, port or attr_id, or attr_value was NULL"]
    pub fn rte_event_port_attr_get(
        dev_id: u8,
        port_id: u8,
        attr_id: u32,
        attr_value: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start an event device."]
    #[doc = ""]
    #[doc = " The device start step is the last one and consists of setting the event"]
    #[doc = " queues to start accepting the events and schedules to event ports."]
    #[doc = ""]
    #[doc = " On success, all basic functions exported by the API (event enqueue,"]
    #[doc = " event dequeue and so on) can be invoked."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Event device identifier"]
    #[doc = " @return"]
    #[doc = "   - 0: Success, device started."]
    #[doc = "   - -ESTALE : Not all ports of the device are configured"]
    #[doc = "   - -ENOLINK: Not all queues are linked, which could lead to deadlock."]
    pub fn rte_event_dev_start(dev_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop an event device."]
    #[doc = ""]
    #[doc = " This function causes all queued events to be drained, including those"]
    #[doc = " residing in event ports. While draining events out of the device, this"]
    #[doc = " function calls the user-provided flush callback (if one was registered) once"]
    #[doc = " per event."]
    #[doc = ""]
    #[doc = " The device can be restarted with a call to rte_event_dev_start(). Threads"]
    #[doc = " that continue to enqueue/dequeue while the device is stopped, or being"]
    #[doc = " stopped, will result in undefined behavior. This includes event adapters,"]
    #[doc = " which must be stopped prior to stopping the eventdev."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Event device identifier."]
    #[doc = ""]
    #[doc = " @see rte_event_dev_stop_flush_callback_register()"]
    pub fn rte_event_dev_stop(dev_id: u8);
}
pub type eventdev_stop_flush_t = ::std::option::Option<
    unsafe extern "C" fn(dev_id: u8, event: rte_event, arg: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Registers a callback function to be invoked during rte_event_dev_stop() for"]
    #[doc = " each flushed event. This function can be used to properly dispose of queued"]
    #[doc = " events, for example events containing memory pointers."]
    #[doc = ""]
    #[doc = " The callback function is only registered for the calling process. The"]
    #[doc = " callback function must be registered in every process that can call"]
    #[doc = " rte_event_dev_stop()."]
    #[doc = ""]
    #[doc = " To unregister a callback, call this function with a NULL callback pointer."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param callback"]
    #[doc = "   Callback function invoked once per flushed event."]
    #[doc = " @param userdata"]
    #[doc = "   Argument supplied to callback."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 on success."]
    #[doc = "  - -EINVAL if *dev_id* is invalid"]
    #[doc = ""]
    #[doc = " @see rte_event_dev_stop()"]
    pub fn rte_event_dev_stop_flush_callback_register(
        dev_id: u8,
        callback: eventdev_stop_flush_t,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close an event device. The device cannot be restarted!"]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Event device identifier"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 on successfully closing device"]
    #[doc = "  - <0 on failure to close device"]
    #[doc = "  - (-EAGAIN) if device is busy"]
    pub fn rte_event_dev_close(dev_id: u8) -> ::std::os::raw::c_int;
}
#[doc = " Event vector structure."]
#[repr(C)]
#[repr(align(16))]
pub struct rte_event_vector {
    pub nb_elem: u16,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_anon_1: rte_event_vector__bindgen_ty_1,
    pub impl_opaque: u64,
    pub __bindgen_anon_2: rte_event_vector__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_event_vector__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_event_vector__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_event_vector__bindgen_ty_1__bindgen_ty_1 {
    pub port: u16,
    pub queue: u16,
}
#[repr(C)]
#[repr(align(16))]
pub struct rte_event_vector__bindgen_ty_2 {
    pub mbufs: __BindgenUnionField<[*mut rte_mbuf; 0usize]>,
    pub ptrs: __BindgenUnionField<[*mut ::std::os::raw::c_void; 0usize]>,
    pub u64s: __BindgenUnionField<[*mut u64; 0usize]>,
    pub bindgen_union_field: [u128; 0usize],
}
impl rte_event_vector {
    #[inline]
    pub fn rsvd(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_rsvd(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn attr_valid(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_attr_valid(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(rsvd: u16, attr_valid: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let rsvd: u16 = unsafe { ::std::mem::transmute(rsvd) };
            rsvd as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let attr_valid: u16 = unsafe { ::std::mem::transmute(attr_valid) };
            attr_valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " The generic *rte_event* structure to hold the event attributes"]
#[doc = " for dequeue and enqueue operation"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_event {
    pub __bindgen_anon_1: rte_event__bindgen_ty_1,
    pub __bindgen_anon_2: rte_event__bindgen_ty_2,
}
#[doc = " WORD0"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_event__bindgen_ty_1 {
    pub event: u64,
    pub __bindgen_anon_1: rte_event__bindgen_ty_1__bindgen_ty_1,
}
#[doc = " Event attributes for dequeue or enqueue operation"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_event__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize]>,
    pub queue_id: u8,
    pub priority: u8,
    pub impl_opaque: u8,
}
impl rte_event__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn flow_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_flow_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn sub_event_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sub_event_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn event_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_event_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn op(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_op(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_sched_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flow_id: u32,
        sub_event_type: u32,
        event_type: u32,
        op: u8,
        rsvd: u8,
        sched_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let flow_id: u32 = unsafe { ::std::mem::transmute(flow_id) };
            flow_id as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let sub_event_type: u32 = unsafe { ::std::mem::transmute(sub_event_type) };
            sub_event_type as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let event_type: u32 = unsafe { ::std::mem::transmute(event_type) };
            event_type as u64
        });
        __bindgen_bitfield_unit.set(32usize, 2u8, {
            let op: u8 = unsafe { ::std::mem::transmute(op) };
            op as u64
        });
        __bindgen_bitfield_unit.set(34usize, 4u8, {
            let rsvd: u8 = unsafe { ::std::mem::transmute(rsvd) };
            rsvd as u64
        });
        __bindgen_bitfield_unit.set(38usize, 2u8, {
            let sched_type: u8 = unsafe { ::std::mem::transmute(sched_type) };
            sched_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " WORD1"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_event__bindgen_ty_2 {
    pub u64_: u64,
    pub event_ptr: *mut ::std::os::raw::c_void,
    pub mbuf: *mut rte_mbuf,
    pub vec: *mut rte_event_vector,
}
extern "C" {
    #[doc = " Retrieve the event device's ethdev Rx adapter capabilities for the"]
    #[doc = " specified ethernet port"]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @param eth_port_id"]
    #[doc = "   The identifier of the ethernet device."]
    #[doc = ""]
    #[doc = " @param[out] caps"]
    #[doc = "   A pointer to memory filled with Rx event adapter capabilities."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success, driver provides Rx event adapter capabilities for the"]
    #[doc = "\tethernet device."]
    #[doc = "   - <0: Error code returned by the driver function."]
    #[doc = ""]
    pub fn rte_event_eth_rx_adapter_caps_get(
        dev_id: u8,
        eth_port_id: u16,
        caps: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the event device's timer adapter capabilities."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @param[out] caps"]
    #[doc = "   A pointer to memory to be filled with event timer adapter capabilities."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success, driver provided event timer adapter capabilities."]
    #[doc = "   - <0: Error code returned by the driver function."]
    pub fn rte_event_timer_adapter_caps_get(dev_id: u8, caps: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the event device's crypto adapter capabilities for the"]
    #[doc = " specified cryptodev device"]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @param cdev_id"]
    #[doc = "   The identifier of the cryptodev device."]
    #[doc = ""]
    #[doc = " @param[out] caps"]
    #[doc = "   A pointer to memory filled with event adapter capabilities."]
    #[doc = "   It is expected to be pre-allocated & initialized by caller."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success, driver provides event adapter capabilities for the"]
    #[doc = "     cryptodev device."]
    #[doc = "   - <0: Error code returned by the driver function."]
    #[doc = ""]
    pub fn rte_event_crypto_adapter_caps_get(
        dev_id: u8,
        cdev_id: u8,
        caps: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the event device's eth Tx adapter capabilities"]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @param eth_port_id"]
    #[doc = "   The identifier of the ethernet device."]
    #[doc = ""]
    #[doc = " @param[out] caps"]
    #[doc = "   A pointer to memory filled with eth Tx adapter capabilities."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success, driver provides eth Tx adapter capabilities."]
    #[doc = "   - <0: Error code returned by the driver function."]
    #[doc = ""]
    pub fn rte_event_eth_tx_adapter_caps_get(
        dev_id: u8,
        eth_port_id: u16,
        caps: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Converts nanoseconds to *timeout_ticks* value for rte_event_dequeue_burst()"]
    #[doc = ""]
    #[doc = " If the device is configured with RTE_EVENT_DEV_CFG_PER_DEQUEUE_TIMEOUT flag"]
    #[doc = " then application can use this function to convert timeout value in"]
    #[doc = " nanoseconds to implementations specific timeout value supplied in"]
    #[doc = " rte_event_dequeue_burst()"]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param ns"]
    #[doc = "   Wait time in nanosecond"]
    #[doc = " @param[out] timeout_ticks"]
    #[doc = "   Value for the *timeout_ticks* parameter in rte_event_dequeue_burst()"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 on success."]
    #[doc = "  - -ENOTSUP if the device doesn't support timeouts"]
    #[doc = "  - -EINVAL if *dev_id* is invalid or *timeout_ticks* is NULL"]
    #[doc = "  - other values < 0 on failure."]
    #[doc = ""]
    #[doc = " @see rte_event_dequeue_burst(), RTE_EVENT_DEV_CFG_PER_DEQUEUE_TIMEOUT"]
    #[doc = " @see rte_event_dev_configure()"]
    #[doc = ""]
    pub fn rte_event_dequeue_timeout_ticks(
        dev_id: u8,
        ns: u64,
        timeout_ticks: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Link multiple source event queues supplied in *queues* to the destination"]
    #[doc = " event port designated by its *port_id* with associated service priority"]
    #[doc = " supplied in *priorities* on the event device designated by its *dev_id*."]
    #[doc = ""]
    #[doc = " The link establishment shall enable the event port *port_id* from"]
    #[doc = " receiving events from the specified event queue(s) supplied in *queues*"]
    #[doc = ""]
    #[doc = " An event queue may link to one or more event ports."]
    #[doc = " The number of links can be established from an event queue to event port is"]
    #[doc = " implementation defined."]
    #[doc = ""]
    #[doc = " Event queue(s) to event port link establishment can be changed at runtime"]
    #[doc = " without re-configuring the device to support scaling and to reduce the"]
    #[doc = " latency of critical work by establishing the link with more event ports"]
    #[doc = " at runtime."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Event port identifier to select the destination port to link."]
    #[doc = ""]
    #[doc = " @param queues"]
    #[doc = "   Points to an array of *nb_links* event queues to be linked"]
    #[doc = "   to the event port."]
    #[doc = "   NULL value is allowed, in which case this function links all the configured"]
    #[doc = "   event queues *nb_event_queues* which previously supplied to"]
    #[doc = "   rte_event_dev_configure() to the event port *port_id*"]
    #[doc = ""]
    #[doc = " @param priorities"]
    #[doc = "   Points to an array of *nb_links* service priorities associated with each"]
    #[doc = "   event queue link to event port."]
    #[doc = "   The priority defines the event port's servicing priority for"]
    #[doc = "   event queue, which may be ignored by an implementation."]
    #[doc = "   The requested priority should in the range of"]
    #[doc = "   [RTE_EVENT_DEV_PRIORITY_HIGHEST, RTE_EVENT_DEV_PRIORITY_LOWEST]."]
    #[doc = "   The implementation shall normalize the requested priority to"]
    #[doc = "   implementation supported priority value."]
    #[doc = "   NULL value is allowed, in which case this function links the event queues"]
    #[doc = "   with RTE_EVENT_DEV_PRIORITY_NORMAL servicing priority"]
    #[doc = ""]
    #[doc = " @param nb_links"]
    #[doc = "   The number of links to establish. This parameter is ignored if queues is"]
    #[doc = "   NULL."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " The number of links actually established. The return value can be less than"]
    #[doc = " the value of the *nb_links* parameter when the implementation has the"]
    #[doc = " limitation on specific queue to port link establishment or if invalid"]
    #[doc = " parameters are specified in *queues*"]
    #[doc = " If the return value is less than *nb_links*, the remaining links at the end"]
    #[doc = " of link[] are not established, and the caller has to take care of them."]
    #[doc = " If return value is less than *nb_links* then implementation shall update the"]
    #[doc = " rte_errno accordingly, Possible rte_errno values are"]
    #[doc = " (EDQUOT) Quota exceeded(Application tried to link the queue configured with"]
    #[doc = "  RTE_EVENT_QUEUE_CFG_SINGLE_LINK to more than one event ports)"]
    #[doc = " (EINVAL) Invalid parameter"]
    #[doc = ""]
    pub fn rte_event_port_link(
        dev_id: u8,
        port_id: u8,
        queues: *const u8,
        priorities: *const u8,
        nb_links: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unlink multiple source event queues supplied in *queues* from the destination"]
    #[doc = " event port designated by its *port_id* on the event device designated"]
    #[doc = " by its *dev_id*."]
    #[doc = ""]
    #[doc = " The unlink call issues an async request to disable the event port *port_id*"]
    #[doc = " from receiving events from the specified event queue *queue_id*."]
    #[doc = " Event queue(s) to event port unlink establishment can be changed at runtime"]
    #[doc = " without re-configuring the device."]
    #[doc = ""]
    #[doc = " @see rte_event_port_unlinks_in_progress() to poll for completed unlinks."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Event port identifier to select the destination port to unlink."]
    #[doc = ""]
    #[doc = " @param queues"]
    #[doc = "   Points to an array of *nb_unlinks* event queues to be unlinked"]
    #[doc = "   from the event port."]
    #[doc = "   NULL value is allowed, in which case this function unlinks all the"]
    #[doc = "   event queue(s) from the event port *port_id*."]
    #[doc = ""]
    #[doc = " @param nb_unlinks"]
    #[doc = "   The number of unlinks to establish. This parameter is ignored if queues is"]
    #[doc = "   NULL."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " The number of unlinks successfully requested. The return value can be less"]
    #[doc = " than the value of the *nb_unlinks* parameter when the implementation has the"]
    #[doc = " limitation on specific queue to port unlink establishment or"]
    #[doc = " if invalid parameters are specified."]
    #[doc = " If the return value is less than *nb_unlinks*, the remaining queues at the"]
    #[doc = " end of queues[] are not unlinked, and the caller has to take care of them."]
    #[doc = " If return value is less than *nb_unlinks* then implementation shall update"]
    #[doc = " the rte_errno accordingly, Possible rte_errno values are"]
    #[doc = " (EINVAL) Invalid parameter"]
    pub fn rte_event_port_unlink(
        dev_id: u8,
        port_id: u8,
        queues: *mut u8,
        nb_unlinks: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of unlinks in progress."]
    #[doc = ""]
    #[doc = " This function provides the application with a method to detect when an"]
    #[doc = " unlink has been completed by the implementation."]
    #[doc = ""]
    #[doc = " @see rte_event_port_unlink() to issue unlink requests."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Event port identifier to select port to check for unlinks in progress."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " The number of unlinks that are in progress. A return of zero indicates that"]
    #[doc = " there are no outstanding unlink requests. A positive return value indicates"]
    #[doc = " the number of unlinks that are in progress, but are not yet complete."]
    #[doc = " A negative return value indicates an error, -EINVAL indicates an invalid"]
    #[doc = " parameter passed for *dev_id* or *port_id*."]
    pub fn rte_event_port_unlinks_in_progress(dev_id: u8, port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the list of source event queues and its associated service priority"]
    #[doc = " linked to the destination event port designated by its *port_id*"]
    #[doc = " on the event device designated by its *dev_id*."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Event port identifier."]
    #[doc = ""]
    #[doc = " @param[out] queues"]
    #[doc = "   Points to an array of *queues* for output."]
    #[doc = "   The caller has to allocate *RTE_EVENT_MAX_QUEUES_PER_DEV* bytes to"]
    #[doc = "   store the event queue(s) linked with event port *port_id*"]
    #[doc = ""]
    #[doc = " @param[out] priorities"]
    #[doc = "   Points to an array of *priorities* for output."]
    #[doc = "   The caller has to allocate *RTE_EVENT_MAX_QUEUES_PER_DEV* bytes to"]
    #[doc = "   store the service priority associated with each event queue linked"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " The number of links established on the event port designated by its"]
    #[doc = "  *port_id*."]
    #[doc = " - <0 on failure."]
    #[doc = ""]
    pub fn rte_event_port_links_get(
        dev_id: u8,
        port_id: u8,
        queues: *mut u8,
        priorities: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the service ID of the event dev. If the adapter doesn't use"]
    #[doc = " a rte_service function, this function returns -ESRCH."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @param [out] service_id"]
    #[doc = "   A pointer to a uint32_t, to be filled in with the service id."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - <0: Error code on failure, if the event dev doesn't use a rte_service"]
    #[doc = "   function, this function returns -ESRCH."]
    pub fn rte_event_dev_service_id_get(dev_id: u8, service_id: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump internal information about *dev_id* to the FILE* provided in *f*."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: on success"]
    #[doc = "   - <0: on failure."]
    pub fn rte_event_dev_dump(dev_id: u8, f: *mut FILE) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " Selects the component of the eventdev to retrieve statistics from."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_event_dev_xstats_mode {
    RTE_EVENT_DEV_XSTATS_DEVICE = 0,
    RTE_EVENT_DEV_XSTATS_PORT = 1,
    RTE_EVENT_DEV_XSTATS_QUEUE = 2,
}
#[doc = " A name-key lookup element for extended statistics."]
#[doc = ""]
#[doc = " This structure is used to map between names and ID numbers"]
#[doc = " for extended ethdev statistics."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_event_dev_xstats_name {
    pub name: [::std::os::raw::c_char; 64usize],
}
extern "C" {
    #[doc = " Retrieve names of extended statistics of an event device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the event device."]
    #[doc = " @param mode"]
    #[doc = "   The mode of statistics to retrieve. Choices include the device statistics,"]
    #[doc = "   port statistics or queue statistics."]
    #[doc = " @param queue_port_id"]
    #[doc = "   Used to specify the port or queue number in queue or port mode, and is"]
    #[doc = "   ignored in device mode."]
    #[doc = " @param[out] xstats_names"]
    #[doc = "   Block of memory to insert names into. Must be at least size in capacity."]
    #[doc = "   If set to NULL, function returns required capacity."]
    #[doc = " @param[out] ids"]
    #[doc = "   Block of memory to insert ids into. Must be at least size in capacity."]
    #[doc = "   If set to NULL, function returns required capacity. The id values returned"]
    #[doc = "   can be passed to *rte_event_dev_xstats_get* to select statistics."]
    #[doc = " @param size"]
    #[doc = "   Capacity of xstats_names (number of names)."]
    #[doc = " @return"]
    #[doc = "   - positive value lower or equal to size: success. The return value"]
    #[doc = "     is the number of entries filled in the stats table."]
    #[doc = "   - positive value higher than size: error, the given statistics table"]
    #[doc = "     is too small. The return value corresponds to the size that should"]
    #[doc = "     be given to succeed. The entries in the table are not valid and"]
    #[doc = "     shall not be used by the caller."]
    #[doc = "   - negative value on error:"]
    #[doc = "        -ENODEV for invalid *dev_id*"]
    #[doc = "        -EINVAL for invalid mode, queue port or id parameters"]
    #[doc = "        -ENOTSUP if the device doesn't support this function."]
    pub fn rte_event_dev_xstats_names_get(
        dev_id: u8,
        mode: rte_event_dev_xstats_mode,
        queue_port_id: u8,
        xstats_names: *mut rte_event_dev_xstats_name,
        ids: *mut ::std::os::raw::c_uint,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve extended statistics of an event device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param mode"]
    #[doc = "  The mode of statistics to retrieve. Choices include the device statistics,"]
    #[doc = "  port statistics or queue statistics."]
    #[doc = " @param queue_port_id"]
    #[doc = "   Used to specify the port or queue number in queue or port mode, and is"]
    #[doc = "   ignored in device mode."]
    #[doc = " @param ids"]
    #[doc = "   The id numbers of the stats to get. The ids can be got from the stat"]
    #[doc = "   position in the stat list from rte_event_dev_get_xstats_names(), or"]
    #[doc = "   by using rte_event_dev_xstats_by_name_get()."]
    #[doc = " @param[out] values"]
    #[doc = "   The values for each stats request by ID."]
    #[doc = " @param n"]
    #[doc = "   The number of stats requested"]
    #[doc = " @return"]
    #[doc = "   - positive value: number of stat entries filled into the values array"]
    #[doc = "   - negative value on error:"]
    #[doc = "        -ENODEV for invalid *dev_id*"]
    #[doc = "        -EINVAL for invalid mode, queue port or id parameters"]
    #[doc = "        -ENOTSUP if the device doesn't support this function."]
    pub fn rte_event_dev_xstats_get(
        dev_id: u8,
        mode: rte_event_dev_xstats_mode,
        queue_port_id: u8,
        ids: *const ::std::os::raw::c_uint,
        values: *mut u64,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the value of a single stat by requesting it by name."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device"]
    #[doc = " @param name"]
    #[doc = "   The stat name to retrieve"]
    #[doc = " @param[out] id"]
    #[doc = "   If non-NULL, the numerical id of the stat will be returned, so that further"]
    #[doc = "   requests for the stat can be got using rte_event_dev_xstats_get, which will"]
    #[doc = "   be faster as it doesn't need to scan a list of names for the stat."]
    #[doc = "   If the stat cannot be found, the id returned will be (unsigned)-1."]
    #[doc = " @return"]
    #[doc = "   - positive value or zero: the stat value"]
    #[doc = "   - negative value: -EINVAL if stat not found, -ENOTSUP if not supported."]
    pub fn rte_event_dev_xstats_by_name_get(
        dev_id: u8,
        name: *const ::std::os::raw::c_char,
        id: *mut ::std::os::raw::c_uint,
    ) -> u64;
}
extern "C" {
    #[doc = " Reset the values of the xstats of the selected component in the device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device"]
    #[doc = " @param mode"]
    #[doc = "   The mode of the statistics to reset. Choose from device, queue or port."]
    #[doc = " @param queue_port_id"]
    #[doc = "   The queue or port to reset. 0 and positive values select ports and queues,"]
    #[doc = "   while -1 indicates all ports or queues."]
    #[doc = " @param ids"]
    #[doc = "   Selects specific statistics to be reset. When NULL, all statistics selected"]
    #[doc = "   by *mode* will be reset. If non-NULL, must point to array of at least"]
    #[doc = "   *nb_ids* size."]
    #[doc = " @param nb_ids"]
    #[doc = "   The number of ids available from the *ids* array. Ignored when ids is NULL."]
    #[doc = " @return"]
    #[doc = "   - zero: successfully reset the statistics to zero"]
    #[doc = "   - negative value: -EINVAL invalid parameters, -ENOTSUP if not supported."]
    pub fn rte_event_dev_xstats_reset(
        dev_id: u8,
        mode: rte_event_dev_xstats_mode,
        queue_port_id: i16,
        ids: *const u32,
        nb_ids: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Trigger the eventdev self test."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device"]
    #[doc = " @return"]
    #[doc = "   - 0: Selftest successful"]
    #[doc = "   - -ENOTSUP if the device doesn't support selftest"]
    #[doc = "   - other values < 0 on failure."]
    pub fn rte_event_dev_selftest(dev_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the memory required per event vector based on the number of elements per"]
    #[doc = " vector."]
    #[doc = " This should be used to create the mempool that holds the event vectors."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the vector pool."]
    #[doc = " @param n"]
    #[doc = "   The number of elements in the mbuf pool."]
    #[doc = " @param cache_size"]
    #[doc = "   Size of the per-core object cache. See rte_mempool_create() for"]
    #[doc = "   details."]
    #[doc = " @param nb_elem"]
    #[doc = "   The number of elements that a single event vector should be able to hold."]
    #[doc = " @param socket_id"]
    #[doc = "   The socket identifier where the memory should be allocated. The"]
    #[doc = "   value can be *SOCKET_ID_ANY* if there is no NUMA constraint for the"]
    #[doc = "   reserved zone"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The pointer to the newly allocated mempool, on success. NULL on error"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - EINVAL - cache size provided is too large, or priv_size is not aligned."]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    #[doc = "    - ENAMETOOLONG - mempool name requested is too long."]
    pub fn rte_event_vector_pool_create(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        nb_elem: u16,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_mempool;
}
pub type event_enqueue_t = ::std::option::Option<
    unsafe extern "C" fn(port: *mut ::std::os::raw::c_void, ev: *const rte_event) -> u16,
>;
pub type event_enqueue_burst_t = ::std::option::Option<
    unsafe extern "C" fn(
        port: *mut ::std::os::raw::c_void,
        ev: *const rte_event,
        nb_events: u16,
    ) -> u16,
>;
pub type event_dequeue_t = ::std::option::Option<
    unsafe extern "C" fn(
        port: *mut ::std::os::raw::c_void,
        ev: *mut rte_event,
        timeout_ticks: u64,
    ) -> u16,
>;
pub type event_dequeue_burst_t = ::std::option::Option<
    unsafe extern "C" fn(
        port: *mut ::std::os::raw::c_void,
        ev: *mut rte_event,
        nb_events: u16,
        timeout_ticks: u64,
    ) -> u16,
>;
pub type event_maintain_t = ::std::option::Option<
    unsafe extern "C" fn(port: *mut ::std::os::raw::c_void, op: ::std::os::raw::c_int),
>;
pub type event_tx_adapter_enqueue_t = ::std::option::Option<
    unsafe extern "C" fn(
        port: *mut ::std::os::raw::c_void,
        ev: *mut rte_event,
        nb_events: u16,
    ) -> u16,
>;
pub type event_crypto_adapter_enqueue_t = ::std::option::Option<
    unsafe extern "C" fn(
        port: *mut ::std::os::raw::c_void,
        ev: *mut rte_event,
        nb_events: u16,
    ) -> u16,
>;
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_event_fp_ops {
    pub data: *mut *mut ::std::os::raw::c_void,
    pub enqueue: event_enqueue_t,
    pub enqueue_burst: event_enqueue_burst_t,
    pub enqueue_new_burst: event_enqueue_burst_t,
    pub enqueue_forward_burst: event_enqueue_burst_t,
    pub dequeue: event_dequeue_t,
    pub dequeue_burst: event_dequeue_burst_t,
    pub maintain: event_maintain_t,
    pub txa_enqueue: event_tx_adapter_enqueue_t,
    pub txa_enqueue_same_dest: event_tx_adapter_enqueue_t,
    pub ca_enqueue: event_crypto_adapter_enqueue_t,
    pub reserved: [usize; 6usize],
}
extern "C" {
    pub static mut rte_event_fp_ops: [rte_event_fp_ops; 16usize];
}
extern "C" {
    #[doc = " Return the number of services registered."]
    #[doc = ""]
    #[doc = " @return The number of services registered."]
    pub fn rte_service_get_count() -> u32;
}
extern "C" {
    #[doc = " Return the id of a service by name."]
    #[doc = ""]
    #[doc = " This function provides the id of the service using the service name as"]
    #[doc = " lookup key. The service id is to be passed to other functions in the"]
    #[doc = " rte_service_* API."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code"]
    #[doc = "      uint32_t service_id;"]
    #[doc = "      int32_t ret = rte_service_get_by_name(\"service_X\", &service_id);"]
    #[doc = "      if (ret) {"]
    #[doc = "              // handle error"]
    #[doc = "      }"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @param name The name of the service to retrieve"]
    #[doc = " @param[out] service_id A pointer to a uint32_t, to be filled in with the id."]
    #[doc = " @retval 0 Success. The service id is provided in *service_id*."]
    #[doc = " @retval -EINVAL Null *service_id* pointer provided"]
    #[doc = " @retval -ENODEV No such service registered"]
    pub fn rte_service_get_by_name(
        name: *const ::std::os::raw::c_char,
        service_id: *mut u32,
    ) -> i32;
}
extern "C" {
    #[doc = " Return the name of the service."]
    #[doc = ""]
    #[doc = " @return A pointer to the name of the service. The returned pointer remains"]
    #[doc = "         in ownership of the service, and the application must not free it."]
    pub fn rte_service_get_name(id: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Check if a service has a specific capability."]
    #[doc = ""]
    #[doc = " This function returns if *service* has implements *capability*."]
    #[doc = " See RTE_SERVICE_CAP_* defines for a list of valid capabilities."]
    #[doc = " @retval 1 Capability supported by this service instance"]
    #[doc = " @retval 0 Capability not supported by this service instance"]
    pub fn rte_service_probe_capability(id: u32, capability: u32) -> i32;
}
extern "C" {
    #[doc = " Map or unmap a lcore to a service."]
    #[doc = ""]
    #[doc = " Each core can be added or removed from running a specific service. This"]
    #[doc = " function enables or disables *lcore* to run *service_id*."]
    #[doc = ""]
    #[doc = " If multiple cores are enabled on a service, a lock is used to ensure that"]
    #[doc = " only one core runs the service at a time. The exception to this is when"]
    #[doc = " a service indicates that it is multi-thread safe by setting the capability"]
    #[doc = " called RTE_SERVICE_CAP_MT_SAFE. With the multi-thread safe capability set,"]
    #[doc = " the service function can be run on multiple threads at the same time."]
    #[doc = ""]
    #[doc = " If the service is known to be mapped to a single lcore, setting the"]
    #[doc = " capability of the service to RTE_SERVICE_CAP_MT_SAFE can achieve"]
    #[doc = " better performance by avoiding the use of lock."]
    #[doc = ""]
    #[doc = " @param service_id the service to apply the lcore to"]
    #[doc = " @param lcore The lcore that will be mapped to service"]
    #[doc = " @param enable Zero to unmap or disable the core, non-zero to enable"]
    #[doc = ""]
    #[doc = " @retval 0 lcore map updated successfully"]
    #[doc = " @retval -EINVAL An invalid service or lcore was provided."]
    pub fn rte_service_map_lcore_set(service_id: u32, lcore: u32, enable: u32) -> i32;
}
extern "C" {
    #[doc = " Retrieve the mapping of an lcore to a service."]
    #[doc = ""]
    #[doc = " @param service_id the service to apply the lcore to"]
    #[doc = " @param lcore The lcore that will be mapped to service"]
    #[doc = ""]
    #[doc = " @retval 1 lcore is mapped to service"]
    #[doc = " @retval 0 lcore is not mapped to service"]
    #[doc = " @retval -EINVAL An invalid service or lcore was provided."]
    pub fn rte_service_map_lcore_get(service_id: u32, lcore: u32) -> i32;
}
extern "C" {
    #[doc = " Set the runstate of the service."]
    #[doc = ""]
    #[doc = " Each service is either running or stopped. Setting a non-zero runstate"]
    #[doc = " enables the service to run, while setting runstate zero disables it."]
    #[doc = ""]
    #[doc = " @param id The id of the service"]
    #[doc = " @param runstate The run state to apply to the service"]
    #[doc = ""]
    #[doc = " @retval 0 The service was successfully started"]
    #[doc = " @retval -EINVAL Invalid service id"]
    pub fn rte_service_runstate_set(id: u32, runstate: u32) -> i32;
}
extern "C" {
    #[doc = " Get the runstate for the service with *id*. See *rte_service_runstate_set*"]
    #[doc = " for details of runstates. A service can call this function to ensure that"]
    #[doc = " the application has indicated that it will receive CPU cycles. Either a"]
    #[doc = " service-core is mapped (default case), or the application has explicitly"]
    #[doc = " disabled the check that a service-cores is mapped to the service and takes"]
    #[doc = " responsibility to run the service manually using the available function"]
    #[doc = " *rte_service_run_iter_on_app_lcore* to do so."]
    #[doc = ""]
    #[doc = " @retval 1 Service is running"]
    #[doc = " @retval 0 Service is stopped"]
    #[doc = " @retval -EINVAL Invalid service id"]
    pub fn rte_service_runstate_get(id: u32) -> i32;
}
extern "C" {
    #[doc = " This function returns whether the service may be currently executing on"]
    #[doc = " at least one lcore, or definitely is not. This function can be used to"]
    #[doc = " determine if, after setting the service runstate to stopped, the service"]
    #[doc = " is still executing a service lcore."]
    #[doc = ""]
    #[doc = " Care must be taken if calling this function when the service runstate is"]
    #[doc = " running, since the result of this function may be incorrect by the time the"]
    #[doc = " function returns due to service cores running in parallel."]
    #[doc = ""]
    #[doc = " @retval 1 Service may be running on one or more lcores"]
    #[doc = " @retval 0 Service is not running on any lcore"]
    #[doc = " @retval -EINVAL Invalid service id"]
    pub fn rte_service_may_be_active(id: u32) -> i32;
}
extern "C" {
    #[doc = " Enable or disable the check for a service-core being mapped to the service."]
    #[doc = " An application can disable the check when takes the responsibility to run a"]
    #[doc = " service itself using *rte_service_run_iter_on_app_lcore*."]
    #[doc = ""]
    #[doc = " @param id The id of the service to set the check on"]
    #[doc = " @param enable When zero, the check is disabled. Non-zero enables the check."]
    #[doc = ""]
    #[doc = " @retval 0 Success"]
    #[doc = " @retval -EINVAL Invalid service ID"]
    pub fn rte_service_set_runstate_mapped_check(id: u32, enable: i32) -> i32;
}
extern "C" {
    #[doc = " This function runs a service callback from a non-service lcore."]
    #[doc = ""]
    #[doc = " This function is designed to enable gradual porting to service cores, and"]
    #[doc = " to enable unit tests to verify a service behaves as expected."]
    #[doc = ""]
    #[doc = " When called, this function ensures that the service identified by *id* is"]
    #[doc = " safe to run on this lcore. Multi-thread safe services are invoked even if"]
    #[doc = " other cores are simultaneously running them as they are multi-thread safe."]
    #[doc = ""]
    #[doc = " Multi-thread unsafe services are handled depending on the variable"]
    #[doc = " *serialize_multithread_unsafe*:"]
    #[doc = " - When set, the function will check if a service is already being invoked"]
    #[doc = "   on another lcore, refusing to run it and returning -EBUSY."]
    #[doc = " - When zero, the application takes responsibility to ensure that the service"]
    #[doc = "   indicated by *id* is not going to be invoked by another lcore. This setting"]
    #[doc = "   avoids atomic operations, so is likely to be more performant."]
    #[doc = ""]
    #[doc = " @param id The ID of the service to run"]
    #[doc = " @param serialize_multithread_unsafe This parameter indicates to the service"]
    #[doc = "           cores library if it is required to use atomics to serialize access"]
    #[doc = "           to mult-thread unsafe services. As there is an overhead in using"]
    #[doc = "           atomics, applications can choose to enable or disable this feature"]
    #[doc = ""]
    #[doc = " Note that any thread calling this function MUST be a DPDK EAL thread, as"]
    #[doc = " the *rte_lcore_id* function is used to access internal data structures."]
    #[doc = ""]
    #[doc = " @retval 0 Service was run on the calling thread successfully"]
    #[doc = " @retval -EBUSY Another lcore is executing the service, and it is not a"]
    #[doc = "         multi-thread safe service, so the service was not run on this lcore"]
    #[doc = " @retval -ENOEXEC Service is not in a run-able state"]
    #[doc = " @retval -EINVAL Invalid service id"]
    pub fn rte_service_run_iter_on_app_lcore(id: u32, serialize_multithread_unsafe: u32) -> i32;
}
extern "C" {
    #[doc = " Start a service core."]
    #[doc = ""]
    #[doc = " Starting a core makes the core begin polling. Any services assigned to it"]
    #[doc = " will be run as fast as possible. The application must ensure that the lcore"]
    #[doc = " is in a launchable state: e.g. call *rte_eal_lcore_wait* on the lcore_id"]
    #[doc = " before calling this function."]
    #[doc = ""]
    #[doc = " @retval 0 Success"]
    #[doc = " @retval -EINVAL Failed to start core. The *lcore_id* passed in is not"]
    #[doc = "          currently assigned to be a service core."]
    pub fn rte_service_lcore_start(lcore_id: u32) -> i32;
}
extern "C" {
    #[doc = " Stop a service core."]
    #[doc = ""]
    #[doc = " Stopping a core makes the core become idle, but remains  assigned as a"]
    #[doc = " service core. Note that the service lcore thread may not have returned from"]
    #[doc = " the service it is running when this API returns."]
    #[doc = ""]
    #[doc = " The *rte_service_lcore_may_be_active* API can be used to check if the"]
    #[doc = " service lcore is * still active."]
    #[doc = ""]
    #[doc = " @retval 0 Success"]
    #[doc = " @retval -EINVAL Invalid *lcore_id* provided"]
    #[doc = " @retval -EALREADY Already stopped core"]
    #[doc = " @retval -EBUSY Failed to stop core, as it would cause a service to not"]
    #[doc = "          be run, as this is the only core currently running the service."]
    #[doc = "          The application must stop the service first, and then stop the"]
    #[doc = "          lcore."]
    pub fn rte_service_lcore_stop(lcore_id: u32) -> i32;
}
extern "C" {
    #[doc = " Reports if a service lcore is currently running."]
    #[doc = ""]
    #[doc = " This function returns if the core has finished service cores code, and has"]
    #[doc = " returned to EAL control. If *rte_service_lcore_stop* has been called but"]
    #[doc = " the lcore has not returned to EAL yet, it might be required to wait and call"]
    #[doc = " this function again. The amount of time to wait before the core returns"]
    #[doc = " depends on the duration of the services being run."]
    #[doc = ""]
    #[doc = " @retval 0 Service thread is not active, and lcore has been returned to EAL."]
    #[doc = " @retval 1 Service thread is in the service core polling loop."]
    #[doc = " @retval -EINVAL Invalid *lcore_id* provided."]
    pub fn rte_service_lcore_may_be_active(lcore_id: u32) -> i32;
}
extern "C" {
    #[doc = " Adds lcore to the list of service cores."]
    #[doc = ""]
    #[doc = " This functions can be used at runtime in order to modify the service core"]
    #[doc = " mask."]
    #[doc = ""]
    #[doc = " @retval 0 Success"]
    #[doc = " @retval -EBUSY lcore is busy, and not available for service core duty"]
    #[doc = " @retval -EALREADY lcore is already added to the service core list"]
    #[doc = " @retval -EINVAL Invalid lcore provided"]
    pub fn rte_service_lcore_add(lcore: u32) -> i32;
}
extern "C" {
    #[doc = " Removes lcore from the list of service cores."]
    #[doc = ""]
    #[doc = " This can fail if the core is not stopped, see *rte_service_core_stop*."]
    #[doc = ""]
    #[doc = " @retval 0 Success"]
    #[doc = " @retval -EBUSY Lcore is not stopped, stop service core before removing."]
    #[doc = " @retval -EINVAL failed to add lcore to service core mask."]
    pub fn rte_service_lcore_del(lcore: u32) -> i32;
}
extern "C" {
    #[doc = " Retrieve the number of service cores currently available."]
    #[doc = ""]
    #[doc = " This function returns the integer count of service cores available. The"]
    #[doc = " service core count can be used in mapping logic when creating mappings"]
    #[doc = " from service cores to services."]
    #[doc = ""]
    #[doc = " See *rte_service_lcore_list* for details on retrieving the lcore_id of each"]
    #[doc = " service core."]
    #[doc = ""]
    #[doc = " @return The number of service cores currently configured."]
    pub fn rte_service_lcore_count() -> i32;
}
extern "C" {
    #[doc = " Resets all service core mappings. This does not remove the service cores"]
    #[doc = " from duty, just unmaps all services / cores, and stops() the service cores."]
    #[doc = " The runstate of services is not modified."]
    #[doc = ""]
    #[doc = " The cores that are stopped with this call, are in WAIT state."]
    #[doc = ""]
    #[doc = " @retval 0 Success"]
    pub fn rte_service_lcore_reset_all() -> i32;
}
extern "C" {
    #[doc = " Enable or disable statistics collection for *service*."]
    #[doc = ""]
    #[doc = " This function enables per core, per-service cycle count collection."]
    #[doc = " @param id The service to enable statistics gathering on."]
    #[doc = " @param enable Zero to disable statistics, non-zero to enable."]
    #[doc = " @retval 0 Success"]
    #[doc = " @retval -EINVAL Invalid service pointer passed"]
    pub fn rte_service_set_stats_enable(id: u32, enable: i32) -> i32;
}
extern "C" {
    #[doc = " Retrieve the list of currently enabled service cores."]
    #[doc = ""]
    #[doc = " This function fills in an application supplied array, with each element"]
    #[doc = " indicating the lcore_id of a service core."]
    #[doc = ""]
    #[doc = " Adding and removing service cores can be performed using"]
    #[doc = " *rte_service_lcore_add* and *rte_service_lcore_del*."]
    #[doc = " @param [out] array An array of at least *rte_service_lcore_count* items."]
    #[doc = "              If statically allocating the buffer, use RTE_MAX_LCORE."]
    #[doc = " @param [out] n The size of *array*."]
    #[doc = " @retval >=0 Number of service cores that have been populated in the array"]
    #[doc = " @retval -ENOMEM The provided array is not large enough to fill in the"]
    #[doc = "          service core list. No items have been populated, call this function"]
    #[doc = "          with a size of at least *rte_service_core_count* items."]
    pub fn rte_service_lcore_list(array: *mut u32, n: u32) -> i32;
}
extern "C" {
    #[doc = " Get the number of services running on the supplied lcore."]
    #[doc = ""]
    #[doc = " @param lcore Id of the service core."]
    #[doc = " @retval >=0 Number of services registered to this core."]
    #[doc = " @retval -EINVAL Invalid lcore provided"]
    #[doc = " @retval -ENOTSUP The provided lcore is not a service core."]
    pub fn rte_service_lcore_count_services(lcore: u32) -> i32;
}
extern "C" {
    #[doc = " Dumps any information available about the service. When id is UINT32_MAX,"]
    #[doc = " this function dumps info for all services."]
    #[doc = ""]
    #[doc = " @retval 0 Statistics have been successfully dumped"]
    #[doc = " @retval -EINVAL Invalid service id provided"]
    pub fn rte_service_dump(f: *mut FILE, id: u32) -> i32;
}
extern "C" {
    #[doc = " Get an attribute from a service."]
    #[doc = ""]
    #[doc = " @retval 0 Success, the attribute value has been written to *attr_value*."]
    #[doc = "         -EINVAL Invalid id, attr_id or attr_value was NULL."]
    pub fn rte_service_attr_get(id: u32, attr_id: u32, attr_value: *mut u64) -> i32;
}
extern "C" {
    #[doc = " Reset all attribute values of a service."]
    #[doc = ""]
    #[doc = " @param id The service to reset all statistics of"]
    #[doc = " @retval 0 Successfully reset attributes"]
    #[doc = "         -EINVAL Invalid service id provided"]
    pub fn rte_service_attr_reset_all(id: u32) -> i32;
}
extern "C" {
    #[doc = " Get an attribute from a service core."]
    #[doc = ""]
    #[doc = " @param lcore Id of the service core."]
    #[doc = " @param attr_id Id of the attribute to be retrieved."]
    #[doc = " @param [out] attr_value Pointer to storage in which to write retrieved value."]
    #[doc = " @retval 0 Success, the attribute value has been written to *attr_value*."]
    #[doc = "         -EINVAL Invalid lcore, attr_id or attr_value was NULL."]
    #[doc = "         -ENOTSUP lcore is not a service core."]
    pub fn rte_service_lcore_attr_get(lcore: u32, attr_id: u32, attr_value: *mut u64) -> i32;
}
extern "C" {
    #[doc = " Reset all attribute values of a service core."]
    #[doc = ""]
    #[doc = " @param lcore The service core to reset all the statistics of"]
    #[doc = " @retval 0 Successfully reset attributes"]
    #[doc = "         -EINVAL Invalid service id provided"]
    #[doc = "         -ENOTSUP lcore is not a service core."]
    pub fn rte_service_lcore_attr_reset_all(lcore: u32) -> i32;
}
#[doc = " Adapter configuration structure that the adapter configuration callback"]
#[doc = " function is expected to fill out"]
#[doc = " @see rte_event_eth_rx_adapter_conf_cb"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_event_eth_rx_adapter_conf {
    pub event_port_id: u8,
    pub max_nb_rx: u32,
}
#[doc = " Function type used for adapter configuration callback. The callback is"]
#[doc = " used to fill in members of the struct rte_event_eth_rx_adapter_conf, this"]
#[doc = " callback is invoked when creating a SW service for packet transfer from"]
#[doc = " ethdev queues to the event device. The SW service is created within the"]
#[doc = " rte_event_eth_rx_adapter_queue_add() function if SW based packet transfers"]
#[doc = " from ethdev queues to the event device are required."]
#[doc = ""]
#[doc = " @param id"]
#[doc = "  Adapter identifier."]
#[doc = ""]
#[doc = " @param dev_id"]
#[doc = "  Event device identifier."]
#[doc = ""]
#[doc = " @param [out] conf"]
#[doc = "  Structure that needs to be populated by this callback."]
#[doc = ""]
#[doc = " @param arg"]
#[doc = "  Argument to the callback. This is the same as the conf_arg passed to the"]
#[doc = "  rte_event_eth_rx_adapter_create_ext()."]
pub type rte_event_eth_rx_adapter_conf_cb = ::std::option::Option<
    unsafe extern "C" fn(
        id: u8,
        dev_id: u8,
        conf: *mut rte_event_eth_rx_adapter_conf,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Rx queue configuration structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_event_eth_rx_adapter_queue_conf {
    pub rx_queue_flags: u32,
    pub servicing_weight: u16,
    pub ev: rte_event,
    pub vector_sz: u16,
    pub vector_timeout_ns: u64,
    pub vector_mp: *mut rte_mempool,
    pub event_buf_size: u16,
}
#[doc = " A structure used to retrieve statistics for an"]
#[doc = " eth rx adapter queue."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_event_eth_rx_adapter_queue_stats {
    pub rx_event_buf_count: u64,
    pub rx_event_buf_size: u64,
    pub rx_poll_count: u64,
    pub rx_packets: u64,
    pub rx_dropped: u64,
}
#[doc = " A structure used to retrieve statistics for an eth rx adapter instance."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_event_eth_rx_adapter_stats {
    pub rx_poll_count: u64,
    pub rx_packets: u64,
    pub rx_enq_count: u64,
    pub rx_enq_retry: u64,
    pub rx_dropped: u64,
    pub rx_enq_start_ts: u64,
    pub rx_enq_block_cycles: u64,
    pub rx_enq_end_ts: u64,
    pub rx_intr_packets: u64,
    pub rx_event_buf_count: u64,
    pub rx_event_buf_size: u64,
}
#[doc = " A structure used to retrieve eth rx adapter vector limits."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_event_eth_rx_adapter_vector_limits {
    pub min_sz: u16,
    pub max_sz: u16,
    pub log2_sz: u8,
    pub min_timeout_ns: u64,
    pub max_timeout_ns: u64,
}
#[doc = " A structure to hold adapter config params"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_event_eth_rx_adapter_params {
    pub event_buf_size: u16,
    pub use_queue_event_buf: bool,
}
#[doc = " Callback function invoked by the SW adapter before it continues"]
#[doc = " to process events. The callback is passed the size of the enqueue"]
#[doc = " buffer in the SW adapter and the occupancy of the buffer. The"]
#[doc = " callback can use these values to decide which events are"]
#[doc = " enqueued to the event device by the SW adapter. The callback may"]
#[doc = " also enqueue events internally using its own event port. The SW"]
#[doc = " adapter populates the event information based on the Rx queue"]
#[doc = " configuration in the adapter. The callback can modify the this event"]
#[doc = " information for the events to be enqueued by the SW adapter."]
#[doc = ""]
#[doc = " The callback return value is the number of events from the"]
#[doc = " beginning of the event array that are to be enqueued by"]
#[doc = " the SW adapter. It is the callback's responsibility to arrange"]
#[doc = " these events at the beginning of the array, if these events are"]
#[doc = " not contiguous in the original array. The *nb_dropped* parameter is"]
#[doc = " a pointer to the number of events dropped by the callback, this"]
#[doc = " number is used by the adapter to indicate the number of dropped packets"]
#[doc = " as part of its statistics."]
#[doc = ""]
#[doc = " @param eth_dev_id"]
#[doc = "  Port identifier of the Ethernet device."]
#[doc = " @param queue_id"]
#[doc = "  Receive queue index."]
#[doc = " @param enqueue_buf_size"]
#[doc = "  Total enqueue buffer size."]
#[doc = " @param enqueue_buf_count"]
#[doc = "  Event count in enqueue buffer."]
#[doc = " @param[in, out] ev"]
#[doc = "  Event array."]
#[doc = " @param nb_event"]
#[doc = "  Event array length."]
#[doc = " @param cb_arg"]
#[doc = "  Callback argument."]
#[doc = " @param[out] nb_dropped"]
#[doc = "  Packets dropped by callback."]
#[doc = " @return"]
#[doc = "  - The number of events to be enqueued by the SW adapter."]
pub type rte_event_eth_rx_adapter_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        eth_dev_id: u16,
        queue_id: u16,
        enqueue_buf_size: u32,
        enqueue_buf_count: u32,
        ev: *mut rte_event,
        nb_event: u16,
        cb_arg: *mut ::std::os::raw::c_void,
        nb_dropped: *mut u16,
    ) -> u16,
>;
extern "C" {
    #[doc = " Create a new ethernet Rx event adapter with the specified identifier."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  The identifier of the ethernet Rx event adapter."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "  The identifier of the device to configure."]
    #[doc = ""]
    #[doc = " @param conf_cb"]
    #[doc = "  Callback function that fills in members of a"]
    #[doc = "  struct rte_event_eth_rx_adapter_conf struct passed into"]
    #[doc = "  it."]
    #[doc = ""]
    #[doc = " @param conf_arg"]
    #[doc = "  Argument that is passed to the conf_cb function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - <0: Error code on failure"]
    pub fn rte_event_eth_rx_adapter_create_ext(
        id: u8,
        dev_id: u8,
        conf_cb: rte_event_eth_rx_adapter_conf_cb,
        conf_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new ethernet Rx event adapter with the specified identifier."]
    #[doc = " This function uses an internal configuration function that creates an event"]
    #[doc = " port. This default function reconfigures the event device with an"]
    #[doc = " additional event port and setups up the event port using the port_config"]
    #[doc = " parameter passed into this function. In case the application needs more"]
    #[doc = " control in configuration of the service, it should use the"]
    #[doc = " rte_event_eth_rx_adapter_create_ext() version."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  The identifier of the ethernet Rx event adapter."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "  The identifier of the device to configure."]
    #[doc = ""]
    #[doc = " @param port_config"]
    #[doc = "  Argument of type *rte_event_port_conf* that is passed to the conf_cb"]
    #[doc = "  function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - <0: Error code on failure"]
    pub fn rte_event_eth_rx_adapter_create(
        id: u8,
        dev_id: u8,
        port_config: *mut rte_event_port_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This is a variant of rte_event_eth_rx_adapter_create() with additional"]
    #[doc = " adapter params specified in ``struct rte_event_eth_rx_adapter_params``."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  The identifier of the ethernet Rx event adapter."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "  The identifier of the event device to configure."]
    #[doc = ""]
    #[doc = " @param port_config"]
    #[doc = "  Argument of type *rte_event_port_conf* that is passed to the conf_cb"]
    #[doc = "  function."]
    #[doc = ""]
    #[doc = " @param rxa_params"]
    #[doc = "  Pointer to struct rte_event_eth_rx_adapter_params."]
    #[doc = "  In case of NULL, default values are used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - <0: Error code on failure"]
    pub fn rte_event_eth_rx_adapter_create_with_params(
        id: u8,
        dev_id: u8,
        port_config: *mut rte_event_port_conf,
        rxa_params: *mut rte_event_eth_rx_adapter_params,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free an event adapter"]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter identifier."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - <0: Error code on failure, If the adapter still has Rx queues"]
    #[doc = "      added to it, the function returns -EBUSY."]
    pub fn rte_event_eth_rx_adapter_free(id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add receive queue to an event adapter. After a queue has been"]
    #[doc = " added to the event adapter, the result of the application calling"]
    #[doc = " rte_eth_rx_burst(eth_dev_id, rx_queue_id, ..) is undefined."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter identifier."]
    #[doc = ""]
    #[doc = " @param eth_dev_id"]
    #[doc = "  Port identifier of Ethernet device."]
    #[doc = ""]
    #[doc = " @param rx_queue_id"]
    #[doc = "  Ethernet device receive queue index."]
    #[doc = "  If rx_queue_id is -1, then all Rx queues configured for"]
    #[doc = "  the device are added. If the ethdev Rx queues can only be"]
    #[doc = "  connected to a single event queue then rx_queue_id is"]
    #[doc = "  required to be -1."]
    #[doc = " @see RTE_EVENT_ETH_RX_ADAPTER_CAP_MULTI_EVENTQ"]
    #[doc = ""]
    #[doc = " @param conf"]
    #[doc = "  Additional configuration structure of type *rte_event_eth_rx_adapter_conf*"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0: Success, Receive queue added correctly."]
    #[doc = "  - <0: Error code on failure."]
    #[doc = "  - (-EIO) device reconfiguration and restart error. The adapter reconfigures"]
    #[doc = "  the event device with an additional port if it is required to use a service"]
    #[doc = "  function for packet transfer from the ethernet device to the event device."]
    #[doc = "  If the device had been started before this call, this error code indicates"]
    #[doc = "  an error in restart following an error in reconfiguration, i.e., a"]
    #[doc = "  combination of the two error codes."]
    pub fn rte_event_eth_rx_adapter_queue_add(
        id: u8,
        eth_dev_id: u16,
        rx_queue_id: i32,
        conf: *const rte_event_eth_rx_adapter_queue_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete receive queue from an event adapter."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter identifier."]
    #[doc = ""]
    #[doc = " @param eth_dev_id"]
    #[doc = "  Port identifier of Ethernet device."]
    #[doc = ""]
    #[doc = " @param rx_queue_id"]
    #[doc = "  Ethernet device receive queue index."]
    #[doc = "  If rx_queue_id is -1, then all Rx queues configured for"]
    #[doc = "  the device are deleted. If the ethdev Rx queues can only be"]
    #[doc = "  connected to a single event queue then rx_queue_id is"]
    #[doc = "  required to be -1."]
    #[doc = " @see RTE_EVENT_ETH_RX_ADAPTER_CAP_MULTI_EVENTQ"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0: Success, Receive queue deleted correctly."]
    #[doc = "  - <0: Error code on failure."]
    pub fn rte_event_eth_rx_adapter_queue_del(
        id: u8,
        eth_dev_id: u16,
        rx_queue_id: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start ethernet Rx event adapter"]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter identifier."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0: Success, Adapter started correctly."]
    #[doc = "  - <0: Error code on failure."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "  The eventdev to which the event_eth_rx_adapter is connected needs to"]
    #[doc = "  be started before calling rte_event_eth_rx_adapter_start()."]
    pub fn rte_event_eth_rx_adapter_start(id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop  ethernet Rx event adapter"]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter identifier."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0: Success, Adapter started correctly."]
    #[doc = "  - <0: Error code on failure."]
    pub fn rte_event_eth_rx_adapter_stop(id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve statistics for an adapter"]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter identifier."]
    #[doc = ""]
    #[doc = " @param [out] stats"]
    #[doc = "  A pointer to structure used to retrieve statistics for an adapter."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0: Success, retrieved successfully."]
    #[doc = "  - <0: Error code on failure."]
    pub fn rte_event_eth_rx_adapter_stats_get(
        id: u8,
        stats: *mut rte_event_eth_rx_adapter_stats,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset statistics for an adapter."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter identifier."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0: Success, statistics reset successfully."]
    #[doc = "  - <0: Error code on failure."]
    pub fn rte_event_eth_rx_adapter_stats_reset(id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the service ID of an adapter. If the adapter doesn't use"]
    #[doc = " a rte_service function, this function returns -ESRCH."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter identifier."]
    #[doc = ""]
    #[doc = " @param [out] service_id"]
    #[doc = "  A pointer to a uint32_t, to be filled in with the service id."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0: Success"]
    #[doc = "  - <0: Error code on failure, if the adapter doesn't use a rte_service"]
    #[doc = " function, this function returns -ESRCH."]
    pub fn rte_event_eth_rx_adapter_service_id_get(
        id: u8,
        service_id: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register callback to process Rx packets, this is supported for"]
    #[doc = " SW based packet transfers."]
    #[doc = " @see rte_event_eth_rx_cb_fn"]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter identifier."]
    #[doc = " @param eth_dev_id"]
    #[doc = "  Port identifier of Ethernet device."]
    #[doc = " @param cb_fn"]
    #[doc = "  Callback function."]
    #[doc = " @param cb_arg"]
    #[doc = "  Callback arg."]
    #[doc = " @return"]
    #[doc = "  - 0: Success"]
    #[doc = "  - <0: Error code on failure."]
    pub fn rte_event_eth_rx_adapter_cb_register(
        id: u8,
        eth_dev_id: u16,
        cb_fn: rte_event_eth_rx_adapter_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve vector limits for a given event dev and eth dev pair."]
    #[doc = " @see rte_event_eth_rx_adapter_vector_limits"]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "  Event device identifier."]
    #[doc = " @param eth_port_id"]
    #[doc = "  Port identifier of the ethernet device."]
    #[doc = " @param [out] limits"]
    #[doc = "  A pointer to rte_event_eth_rx_adapter_vector_limits structure that has to"]
    #[doc = " be filled."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0: Success."]
    #[doc = "  - <0: Error code on failure."]
    pub fn rte_event_eth_rx_adapter_vector_limits_get(
        dev_id: u8,
        eth_port_id: u16,
        limits: *mut rte_event_eth_rx_adapter_vector_limits,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve Rx queue config information."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter identifier."]
    #[doc = ""]
    #[doc = " @param eth_dev_id"]
    #[doc = "  Port identifier of Ethernet device."]
    #[doc = ""]
    #[doc = " @param rx_queue_id"]
    #[doc = "  Ethernet device receive queue index."]
    #[doc = ""]
    #[doc = " @param[out] queue_conf"]
    #[doc = "  Pointer to struct rte_event_eth_rx_adapter_queue_conf"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0: Success, Receive queue added correctly."]
    #[doc = "  - <0: Error code on failure."]
    pub fn rte_event_eth_rx_adapter_queue_conf_get(
        id: u8,
        eth_dev_id: u16,
        rx_queue_id: u16,
        queue_conf: *mut rte_event_eth_rx_adapter_queue_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve Rx queue statistics."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter identifier."]
    #[doc = ""]
    #[doc = " @param eth_dev_id"]
    #[doc = "  Port identifier of Ethernet device."]
    #[doc = ""]
    #[doc = " @param rx_queue_id"]
    #[doc = "  Ethernet device receive queue index."]
    #[doc = ""]
    #[doc = " @param[out] stats"]
    #[doc = "  Pointer to struct rte_event_eth_rx_adapter_queue_stats"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0: Success, queue buffer stats retrieved."]
    #[doc = "  - <0: Error code on failure."]
    pub fn rte_event_eth_rx_adapter_queue_stats_get(
        id: u8,
        eth_dev_id: u16,
        rx_queue_id: u16,
        stats: *mut rte_event_eth_rx_adapter_queue_stats,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset Rx queue statistics."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter identifier."]
    #[doc = ""]
    #[doc = " @param eth_dev_id"]
    #[doc = "  Port identifier of Ethernet device."]
    #[doc = ""]
    #[doc = " @param rx_queue_id"]
    #[doc = "  Ethernet device receive queue index."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0: Success, queue buffer stats retrieved."]
    #[doc = "  - <0: Error code on failure."]
    pub fn rte_event_eth_rx_adapter_queue_stats_reset(
        id: u8,
        eth_dev_id: u16,
        rx_queue_id: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the event port ID of an adapter. If the adapter doesn't use"]
    #[doc = " a rte_service function, this function returns -ESRCH."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter identifier."]
    #[doc = ""]
    #[doc = " @param [out] event_port_id"]
    #[doc = "  A pointer to a uint8_t, to be filled in with the port id."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0: Success"]
    #[doc = "  - <0: Error code on failure, if the adapter doesn't use a rte_service"]
    #[doc = " function, this function returns -ESRCH."]
    pub fn rte_event_eth_rx_adapter_event_port_get(
        id: u8,
        event_port_id: *mut u8,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Adapter configuration structure"]
#[doc = ""]
#[doc = " @see rte_event_eth_tx_adapter_create_ext"]
#[doc = " @see rte_event_eth_tx_adapter_conf_cb"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_event_eth_tx_adapter_conf {
    pub event_port_id: u8,
    pub max_nb_tx: u32,
}
#[doc = " Function type used for adapter configuration callback. The callback is"]
#[doc = " used to fill in members of the struct rte_event_eth_tx_adapter_conf, this"]
#[doc = " callback is invoked when creating a RTE service function based"]
#[doc = " adapter implementation."]
#[doc = ""]
#[doc = " @param id"]
#[doc = "  Adapter identifier."]
#[doc = " @param dev_id"]
#[doc = "  Event device identifier."]
#[doc = " @param [out] conf"]
#[doc = "  Structure that needs to be populated by this callback."]
#[doc = " @param arg"]
#[doc = "  Argument to the callback. This is the same as the conf_arg passed to the"]
#[doc = "  rte_event_eth_tx_adapter_create_ext()."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   - 0: Success"]
#[doc = "   - <0: Error code on failure"]
pub type rte_event_eth_tx_adapter_conf_cb = ::std::option::Option<
    unsafe extern "C" fn(
        id: u8,
        dev_id: u8,
        conf: *mut rte_event_eth_tx_adapter_conf,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A structure used to retrieve statistics for an ethernet Tx adapter instance."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_event_eth_tx_adapter_stats {
    pub tx_retry: u64,
    pub tx_packets: u64,
    pub tx_dropped: u64,
}
extern "C" {
    #[doc = " Create a new ethernet Tx adapter with the specified identifier."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  The identifier of the ethernet Tx adapter."]
    #[doc = " @param dev_id"]
    #[doc = "  The event device identifier."]
    #[doc = " @param port_config"]
    #[doc = "  Event port configuration, the adapter uses this configuration to"]
    #[doc = "  create an event port if needed."]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - <0: Error code on failure"]
    pub fn rte_event_eth_tx_adapter_create(
        id: u8,
        dev_id: u8,
        port_config: *mut rte_event_port_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new ethernet Tx adapter with the specified identifier."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  The identifier of the ethernet Tx adapter."]
    #[doc = " @param dev_id"]
    #[doc = "  The event device identifier."]
    #[doc = " @param conf_cb"]
    #[doc = "  Callback function that initializes members of the"]
    #[doc = "  struct rte_event_eth_tx_adapter_conf struct passed into"]
    #[doc = "  it."]
    #[doc = " @param conf_arg"]
    #[doc = "  Argument that is passed to the conf_cb function."]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - <0: Error code on failure"]
    pub fn rte_event_eth_tx_adapter_create_ext(
        id: u8,
        dev_id: u8,
        conf_cb: rte_event_eth_tx_adapter_conf_cb,
        conf_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free an ethernet Tx adapter"]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter identifier."]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - <0: Error code on failure, If the adapter still has Tx queues"]
    #[doc = "      added to it, the function returns -EBUSY."]
    pub fn rte_event_eth_tx_adapter_free(id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start ethernet Tx adapter"]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter identifier."]
    #[doc = " @return"]
    #[doc = "  - 0: Success, Adapter started correctly."]
    #[doc = "  - <0: Error code on failure."]
    pub fn rte_event_eth_tx_adapter_start(id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop ethernet Tx adapter"]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter identifier."]
    #[doc = " @return"]
    #[doc = "  - 0: Success."]
    #[doc = "  - <0: Error code on failure."]
    pub fn rte_event_eth_tx_adapter_stop(id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a Tx queue to the adapter."]
    #[doc = " A queue value of -1 is used to indicate all"]
    #[doc = " queues within the device."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter identifier."]
    #[doc = " @param eth_dev_id"]
    #[doc = "  Ethernet Port Identifier."]
    #[doc = " @param queue"]
    #[doc = "  Tx queue index."]
    #[doc = " @return"]
    #[doc = "  - 0: Success, Queues added successfully."]
    #[doc = "  - <0: Error code on failure."]
    pub fn rte_event_eth_tx_adapter_queue_add(
        id: u8,
        eth_dev_id: u16,
        queue: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete a Tx queue from the adapter."]
    #[doc = " A queue value of -1 is used to indicate all"]
    #[doc = " queues within the device, that have been added to this"]
    #[doc = " adapter."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter identifier."]
    #[doc = " @param eth_dev_id"]
    #[doc = "  Ethernet Port Identifier."]
    #[doc = " @param queue"]
    #[doc = "  Tx queue index."]
    #[doc = " @return"]
    #[doc = "  - 0: Success, Queues deleted successfully."]
    #[doc = "  - <0: Error code on failure."]
    pub fn rte_event_eth_tx_adapter_queue_del(
        id: u8,
        eth_dev_id: u16,
        queue: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the adapter event port. The adapter creates an event port if"]
    #[doc = " the #RTE_EVENT_ETH_TX_ADAPTER_CAP_INTERNAL_PORT is not set in the"]
    #[doc = " ethernet Tx capabilities of the event device."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter Identifier."]
    #[doc = " @param[out] event_port_id"]
    #[doc = "  Event port pointer."]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - <0: Error code on failure."]
    pub fn rte_event_eth_tx_adapter_event_port_get(
        id: u8,
        event_port_id: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve statistics for an adapter"]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter identifier."]
    #[doc = " @param [out] stats"]
    #[doc = "  A pointer to structure used to retrieve statistics for an adapter."]
    #[doc = " @return"]
    #[doc = "  - 0: Success, statistics retrieved successfully."]
    #[doc = "  - <0: Error code on failure."]
    pub fn rte_event_eth_tx_adapter_stats_get(
        id: u8,
        stats: *mut rte_event_eth_tx_adapter_stats,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset statistics for an adapter."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter identifier."]
    #[doc = " @return"]
    #[doc = "  - 0: Success, statistics reset successfully."]
    #[doc = "  - <0: Error code on failure."]
    pub fn rte_event_eth_tx_adapter_stats_reset(id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the service ID of an adapter. If the adapter doesn't use"]
    #[doc = " a rte_service function, this function returns -ESRCH."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "  Adapter identifier."]
    #[doc = " @param [out] service_id"]
    #[doc = "  A pointer to a uint32_t, to be filled in with the service id."]
    #[doc = " @return"]
    #[doc = "  - 0: Success"]
    #[doc = "  - <0: Error code on failure, if the adapter doesn't use a rte_service"]
    #[doc = " function, this function returns -ESRCH."]
    pub fn rte_event_eth_tx_adapter_service_id_get(
        id: u8,
        service_id: *mut u32,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Generic ring structure for passing rte_event objects from core to core."]
#[doc = ""]
#[doc = " Based on the primitives given in the rte_ring library. Designed to be"]
#[doc = " used inside software eventdev implementations and by applications"]
#[doc = " directly as needed."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_event_ring {
    pub r: rte_ring,
}
extern "C" {
    pub fn rte_event_ring_init(
        r: *mut rte_event_ring,
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_event_ring_create(
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_event_ring;
}
extern "C" {
    #[doc = " Search for an event ring based on its name"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the ring."]
    #[doc = " @return"]
    #[doc = "   The pointer to the ring matching the name, or NULL if not found,"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - ENOENT - required entry not available to return."]
    pub fn rte_event_ring_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_event_ring;
}
extern "C" {
    #[doc = " De-allocate all memory used by the ring."]
    #[doc = ""]
    #[doc = " @param r"]
    #[doc = "   Ring to free"]
    pub fn rte_event_ring_free(r: *mut rte_event_ring);
}
#[repr(u32)]
#[doc = " Timer adapter clock source"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_event_timer_adapter_clk_src {
    RTE_EVENT_TIMER_ADAPTER_CPU_CLK = 0,
    RTE_EVENT_TIMER_ADAPTER_EXT_CLK0 = 1,
    RTE_EVENT_TIMER_ADAPTER_EXT_CLK1 = 2,
    RTE_EVENT_TIMER_ADAPTER_EXT_CLK2 = 3,
    RTE_EVENT_TIMER_ADAPTER_EXT_CLK3 = 4,
}
#[doc = " Timer adapter configuration structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_event_timer_adapter_conf {
    pub event_dev_id: u8,
    pub timer_adapter_id: u16,
    pub socket_id: u32,
    pub clk_src: rte_event_timer_adapter_clk_src,
    pub timer_tick_ns: u64,
    pub max_tmo_ns: u64,
    pub nb_timers: u64,
    pub flags: u64,
}
#[doc = " Event timer adapter stats structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_event_timer_adapter_stats {
    pub evtim_exp_count: u64,
    pub ev_enq_count: u64,
    pub ev_inv_count: u64,
    pub evtim_retry_count: u64,
    pub adapter_tick_count: u64,
}
#[doc = " Callback function type for producer port creation."]
pub type rte_event_timer_adapter_port_conf_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        id: u16,
        event_dev_id: u8,
        event_port_id: *mut u8,
        conf_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Create an event timer adapter."]
    #[doc = ""]
    #[doc = " This function must be invoked first before any other function in the API."]
    #[doc = ""]
    #[doc = " @param conf"]
    #[doc = "   The event timer adapter configuration structure."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   A pointer to the new allocated event timer adapter on success."]
    #[doc = "   NULL on error with rte_errno set appropriately."]
    #[doc = "   Possible rte_errno values include:"]
    #[doc = "   - ERANGE: timer_tick_ns is not in supported range."]
    #[doc = "   - ENOMEM: unable to allocate sufficient memory for adapter instances"]
    #[doc = "   - EINVAL: invalid event device identifier specified in config"]
    #[doc = "   - ENOSPC: maximum number of adapters already created"]
    #[doc = "   - EIO: event device reconfiguration and restart error.  The adapter"]
    #[doc = "   reconfigures the event device with an additional port by default if it is"]
    #[doc = "   required to use a service to manage timers. If the device had been started"]
    #[doc = "   before this call, this error code indicates an error in restart following"]
    #[doc = "   an error in reconfiguration, i.e., a combination of the two error codes."]
    pub fn rte_event_timer_adapter_create(
        conf: *const rte_event_timer_adapter_conf,
    ) -> *mut rte_event_timer_adapter;
}
extern "C" {
    #[doc = " Create a timer adapter with the supplied callback."]
    #[doc = ""]
    #[doc = " This function can be used to have a more granular control over the timer"]
    #[doc = " adapter creation.  If a built-in port is absent, then the function uses the"]
    #[doc = " callback provided to create and get the port id to be used as a producer"]
    #[doc = " port."]
    #[doc = ""]
    #[doc = " @param conf"]
    #[doc = "   The timer adapter configuration structure"]
    #[doc = " @param conf_cb"]
    #[doc = "   The port config callback function."]
    #[doc = " @param conf_arg"]
    #[doc = "   Opaque pointer to the argument for the callback function"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   A pointer to the new allocated event timer adapter on success."]
    #[doc = "   NULL on error with rte_errno set appropriately."]
    #[doc = "   Possible rte_errno values include:"]
    #[doc = "   - ERANGE: timer_tick_ns is not in supported range."]
    #[doc = "   - ENOMEM: unable to allocate sufficient memory for adapter instances"]
    #[doc = "   - EINVAL: invalid event device identifier specified in config"]
    #[doc = "   - ENOSPC: maximum number of adapters already created"]
    pub fn rte_event_timer_adapter_create_ext(
        conf: *const rte_event_timer_adapter_conf,
        conf_cb: rte_event_timer_adapter_port_conf_cb_t,
        conf_arg: *mut ::std::os::raw::c_void,
    ) -> *mut rte_event_timer_adapter;
}
#[doc = " Timer adapter info structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_event_timer_adapter_info {
    pub min_resolution_ns: u64,
    pub max_tmo_ns: u64,
    pub conf: rte_event_timer_adapter_conf,
    pub caps: u32,
    pub event_dev_port_id: i16,
}
extern "C" {
    #[doc = " Retrieve the contextual information of an event timer adapter."]
    #[doc = ""]
    #[doc = " @param adapter"]
    #[doc = "   A pointer to the event timer adapter structure."]
    #[doc = ""]
    #[doc = " @param[out] adapter_info"]
    #[doc = "   A pointer to a structure of type *rte_event_timer_adapter_info* to be"]
    #[doc = "   filled with the contextual information of the adapter."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success, driver updates the contextual information of the"]
    #[doc = "   timer adapter"]
    #[doc = "   - <0: Error code returned by the driver info get function."]
    #[doc = "   - -EINVAL: adapter identifier invalid"]
    #[doc = ""]
    #[doc = " @see RTE_EVENT_TIMER_ADAPTER_F_ADJUST_RES,"]
    #[doc = "   struct rte_event_timer_adapter_info"]
    #[doc = ""]
    pub fn rte_event_timer_adapter_get_info(
        adapter: *const rte_event_timer_adapter,
        adapter_info: *mut rte_event_timer_adapter_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start a timer adapter."]
    #[doc = ""]
    #[doc = " The adapter start step is the last one and consists of setting the timer"]
    #[doc = " adapter to start accepting the timers and schedules to event queues."]
    #[doc = ""]
    #[doc = " On success, all basic functions exported by the API (timer arm,"]
    #[doc = " timer cancel and so on) can be invoked."]
    #[doc = ""]
    #[doc = " @param adapter"]
    #[doc = "   A pointer to the event timer adapter structure."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success, adapter started."]
    #[doc = "   - <0: Error code returned by the driver start function."]
    #[doc = "   - -EINVAL if adapter identifier invalid"]
    #[doc = "   - -ENOENT if software adapter but no service core mapped"]
    #[doc = "   - -ENOTSUP if software adapter and more than one service core mapped"]
    #[doc = "   - -EALREADY if adapter has already been started"]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "  The eventdev to which the event_timer_adapter is connected needs to"]
    #[doc = "  be started before calling rte_event_timer_adapter_start()."]
    pub fn rte_event_timer_adapter_start(
        adapter: *const rte_event_timer_adapter,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop an event timer adapter."]
    #[doc = ""]
    #[doc = " The adapter can be restarted with a call to"]
    #[doc = " ``rte_event_timer_adapter_start()``."]
    #[doc = ""]
    #[doc = " @param adapter"]
    #[doc = "   A pointer to the event timer adapter structure."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success, adapter stopped."]
    #[doc = "   - <0: Error code returned by the driver stop function."]
    #[doc = "   - -EINVAL if adapter identifier invalid"]
    pub fn rte_event_timer_adapter_stop(
        adapter: *const rte_event_timer_adapter,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Lookup an event timer adapter using its identifier."]
    #[doc = ""]
    #[doc = " If an event timer adapter was created in another process with the same"]
    #[doc = " identifier, this function will locate its state and set up access to it"]
    #[doc = " so that it can be used in this process."]
    #[doc = ""]
    #[doc = " @param adapter_id"]
    #[doc = "  The event timer adapter identifier."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  A pointer to the event timer adapter matching the identifier on success."]
    #[doc = "  NULL on error with rte_errno set appropriately."]
    #[doc = "  Possible rte_errno values include:"]
    #[doc = "   - ENOENT - requested entry not available to return."]
    pub fn rte_event_timer_adapter_lookup(adapter_id: u16) -> *mut rte_event_timer_adapter;
}
extern "C" {
    #[doc = " Free an event timer adapter."]
    #[doc = ""]
    #[doc = " Destroy an event timer adapter, freeing all resources."]
    #[doc = ""]
    #[doc = " Before invoking this function, the application must wait for all the"]
    #[doc = " armed timers to expire or cancel the outstanding armed timers."]
    #[doc = ""]
    #[doc = " @param adapter"]
    #[doc = "   A pointer to an event timer adapter structure."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Successfully freed the event timer adapter resources."]
    #[doc = "   - <0: Failed to free the event timer adapter resources."]
    #[doc = "   - -EAGAIN:  adapter is busy; timers outstanding"]
    #[doc = "   - -EBUSY: stop hasn't been called for this adapter yet"]
    #[doc = "   - -EINVAL: adapter id invalid, or adapter invalid"]
    pub fn rte_event_timer_adapter_free(
        adapter: *mut rte_event_timer_adapter,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the service ID of the event timer adapter. If the adapter doesn't"]
    #[doc = " use an rte_service function, this function returns -ESRCH."]
    #[doc = ""]
    #[doc = " @param adapter"]
    #[doc = "   A pointer to an event timer adapter."]
    #[doc = ""]
    #[doc = " @param [out] service_id"]
    #[doc = "   A pointer to a uint32_t, to be filled in with the service id."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - <0: Error code on failure"]
    #[doc = "   - -ESRCH: the adapter does not require a service to operate"]
    pub fn rte_event_timer_adapter_service_id_get(
        adapter: *mut rte_event_timer_adapter,
        service_id: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve statistics for an event timer adapter instance."]
    #[doc = ""]
    #[doc = " @param adapter"]
    #[doc = "   A pointer to an event timer adapter structure."]
    #[doc = " @param[out] stats"]
    #[doc = "   A pointer to a structure to fill with statistics."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Successfully retrieved."]
    #[doc = "   - <0: Failure; error code returned."]
    pub fn rte_event_timer_adapter_stats_get(
        adapter: *mut rte_event_timer_adapter,
        stats: *mut rte_event_timer_adapter_stats,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset statistics for an event timer adapter instance."]
    #[doc = ""]
    #[doc = " @param adapter"]
    #[doc = "   A pointer to an event timer adapter structure."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Successfully reset;"]
    #[doc = "   - <0: Failure; error code returned."]
    pub fn rte_event_timer_adapter_stats_reset(
        adapter: *mut rte_event_timer_adapter,
    ) -> ::std::os::raw::c_int;
}
#[repr(i32)]
#[doc = " Event timer state."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_event_timer_state {
    RTE_EVENT_TIMER_NOT_ARMED = 0,
    RTE_EVENT_TIMER_ARMED = 1,
    RTE_EVENT_TIMER_CANCELED = 2,
    RTE_EVENT_TIMER_ERROR = -1,
    RTE_EVENT_TIMER_ERROR_TOOEARLY = -2,
    RTE_EVENT_TIMER_ERROR_TOOLATE = -3,
}
#[doc = " The generic *rte_event_timer* structure to hold the event timer attributes"]
#[doc = " for arm and cancel operations."]
#[repr(C)]
#[repr(align(64))]
pub struct rte_event_timer {
    pub ev: rte_event,
    pub timeout_ticks: u64,
    pub impl_opaque: [u64; 2usize],
    pub state: rte_event_timer_state,
    pub user_meta: __IncompleteArrayField<u8>,
}
pub type rte_event_timer_arm_burst_t = ::std::option::Option<
    unsafe extern "C" fn(
        adapter: *const rte_event_timer_adapter,
        tims: *mut *mut rte_event_timer,
        nb_tims: u16,
    ) -> u16,
>;
pub type rte_event_timer_arm_tmo_tick_burst_t = ::std::option::Option<
    unsafe extern "C" fn(
        adapter: *const rte_event_timer_adapter,
        tims: *mut *mut rte_event_timer,
        timeout_tick: u64,
        nb_tims: u16,
    ) -> u16,
>;
pub type rte_event_timer_cancel_burst_t = ::std::option::Option<
    unsafe extern "C" fn(
        adapter: *const rte_event_timer_adapter,
        tims: *mut *mut rte_event_timer,
        nb_tims: u16,
    ) -> u16,
>;
#[doc = " @internal Data structure associated with each event timer adapter."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_event_timer_adapter {
    pub arm_burst: rte_event_timer_arm_burst_t,
    pub arm_tmo_tick_burst: rte_event_timer_arm_tmo_tick_burst_t,
    pub cancel_burst: rte_event_timer_cancel_burst_t,
    pub data: *mut rte_event_timer_adapter_data,
    pub ops: *mut event_timer_adapter_ops,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 23usize],
}
impl rte_event_timer_adapter {
    #[inline]
    pub fn allocated(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_allocated(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(allocated: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let allocated: u8 = unsafe { ::std::mem::transmute(allocated) };
            allocated as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static mut crc32c_tables: [[u32; 256usize]; 8usize];
}
pub const crc32_alg: u8 = 1;
#[doc = " Type of function that can be used for calculating the hash value."]
pub type rte_fbk_hash_fn =
    ::std::option::Option<unsafe extern "C" fn(key: u32, init_val: u32) -> u32>;
#[doc = " Parameters used when creating four-byte key hash table."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_fbk_hash_params {
    #[doc = "< Name of the hash table."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Total number of entries."]
    pub entries: u32,
    #[doc = "< Number of entries in a bucket."]
    pub entries_per_bucket: u32,
    #[doc = "< Socket to allocate memory on."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< The hash function."]
    pub hash_func: rte_fbk_hash_fn,
    #[doc = "< For initialising hash function."]
    pub init_val: u32,
}
#[doc = " Individual entry in the four-byte key hash table."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_fbk_hash_entry {
    #[doc = "< For accessing entire entry."]
    pub whole_entry: u64,
    #[doc = "< For accessing each entry part."]
    pub entry: rte_fbk_hash_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_fbk_hash_entry__bindgen_ty_1 {
    #[doc = "< Non-zero if entry is active."]
    pub is_entry: u16,
    #[doc = "< Value returned by lookup."]
    pub value: u16,
    #[doc = "< Key used to find value."]
    pub key: u32,
}
#[doc = " The four-byte key hash table structure."]
#[repr(C)]
pub struct rte_fbk_hash_table {
    #[doc = "< Name of the hash."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Total number of entries."]
    pub entries: u32,
    #[doc = "< Number of entries in a bucket."]
    pub entries_per_bucket: u32,
    #[doc = "< How many entries are used."]
    pub used_entries: u32,
    #[doc = "< To find which bucket the key is in."]
    pub bucket_mask: u32,
    #[doc = "< Convert bucket to table offset."]
    pub bucket_shift: u32,
    #[doc = "< The hash function."]
    pub hash_func: rte_fbk_hash_fn,
    #[doc = "< For initialising hash function."]
    pub init_val: u32,
    #[doc = " A flat table of all buckets."]
    pub t: __IncompleteArrayField<rte_fbk_hash_entry>,
}
extern "C" {
    #[doc = " Performs a lookup for an existing hash table, and returns a pointer to"]
    #[doc = " the table if found."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Name of the hash table to find"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   pointer to hash table structure or NULL on error with rte_errno"]
    #[doc = "   set appropriately. Possible rte_errno values include:"]
    #[doc = "    - ENOENT - required entry not available to return."]
    pub fn rte_fbk_hash_find_existing(
        name: *const ::std::os::raw::c_char,
    ) -> *mut rte_fbk_hash_table;
}
extern "C" {
    #[doc = " Create a new hash table for use with four byte keys."]
    #[doc = ""]
    #[doc = " @param params"]
    #[doc = "   Parameters used in creation of hash table."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Pointer to hash table structure that is used in future hash table"]
    #[doc = "   operations, or NULL on error with rte_errno set appropriately."]
    #[doc = "   Possible rte_errno error values include:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - EINVAL - invalid parameter value passed to function"]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_fbk_hash_create(params: *const rte_fbk_hash_params) -> *mut rte_fbk_hash_table;
}
extern "C" {
    #[doc = " Free all memory used by a hash table."]
    #[doc = " Has no effect on hash tables allocated in memory zones"]
    #[doc = ""]
    #[doc = " @param ht"]
    #[doc = "   Hash table to deallocate."]
    pub fn rte_fbk_hash_free(ht: *mut rte_fbk_hash_table);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_fib6 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_rib6 {
    _unused: [u8; 0],
}
#[repr(u32)]
#[doc = " Type of FIB struct"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_fib6_type {
    #[doc = "< RIB6 tree based FIB"]
    RTE_FIB6_DUMMY = 0,
    #[doc = "< TRIE based fib"]
    RTE_FIB6_TRIE = 1,
}
#[doc = " Modify FIB function"]
pub type rte_fib6_modify_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        fib: *mut rte_fib6,
        ip: *const u8,
        depth: u8,
        next_hop: u64,
        op: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " FIB bulk lookup function"]
pub type rte_fib6_lookup_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        fib: *mut ::std::os::raw::c_void,
        ips: *mut [u8; 16usize],
        next_hops: *mut u64,
        n: ::std::os::raw::c_uint,
    ),
>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_fib6_op {
    RTE_FIB6_ADD = 0,
    RTE_FIB6_DEL = 1,
}
#[repr(u32)]
#[doc = " Size of nexthop (1 << nh_sz) bits for TRIE based FIB"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_fib_trie_nh_sz {
    RTE_FIB6_TRIE_2B = 1,
    RTE_FIB6_TRIE_4B = 2,
    RTE_FIB6_TRIE_8B = 3,
}
#[repr(u32)]
#[doc = " Type of lookup function implementation"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_fib6_lookup_type {
    RTE_FIB6_LOOKUP_DEFAULT = 0,
    #[doc = "< Scalar lookup function implementation"]
    RTE_FIB6_LOOKUP_TRIE_SCALAR = 1,
    #[doc = "< Vector implementation using AVX512"]
    RTE_FIB6_LOOKUP_TRIE_VECTOR_AVX512 = 2,
}
#[doc = " FIB configuration structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_fib6_conf {
    #[doc = "< Type of FIB struct"]
    pub type_: rte_fib6_type,
    #[doc = " Default value returned on lookup if there is no route"]
    pub default_nh: u64,
    pub max_routes: ::std::os::raw::c_int,
    #[doc = " Size of the node extension in the internal RIB struct"]
    pub rib_ext_sz: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: rte_fib6_conf__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_fib6_conf__bindgen_ty_1 {
    pub trie: rte_fib6_conf__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_fib6_conf__bindgen_ty_1__bindgen_ty_1 {
    pub nh_sz: rte_fib_trie_nh_sz,
    pub num_tbl8: u32,
}
extern "C" {
    #[doc = " Create FIB"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "  FIB name"]
    #[doc = " @param socket_id"]
    #[doc = "  NUMA socket ID for FIB table memory allocation"]
    #[doc = " @param conf"]
    #[doc = "  Structure containing the configuration"]
    #[doc = " @return"]
    #[doc = "  Handle to FIB object on success"]
    #[doc = "  NULL otherwise with rte_errno set to an appropriate values."]
    pub fn rte_fib6_create(
        name: *const ::std::os::raw::c_char,
        socket_id: ::std::os::raw::c_int,
        conf: *mut rte_fib6_conf,
    ) -> *mut rte_fib6;
}
extern "C" {
    #[doc = " Find an existing FIB object and return a pointer to it."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "  Name of the fib object as passed to rte_fib6_create()"]
    #[doc = " @return"]
    #[doc = "  Pointer to fib object or NULL if object not found with rte_errno"]
    #[doc = "  set appropriately. Possible rte_errno values include:"]
    #[doc = "   - ENOENT - required entry not available to return."]
    pub fn rte_fib6_find_existing(name: *const ::std::os::raw::c_char) -> *mut rte_fib6;
}
extern "C" {
    #[doc = " Free an FIB object."]
    #[doc = ""]
    #[doc = " @param fib"]
    #[doc = "   FIB object handle"]
    #[doc = " @return"]
    #[doc = "   None"]
    pub fn rte_fib6_free(fib: *mut rte_fib6);
}
extern "C" {
    #[doc = " Add a route to the FIB."]
    #[doc = ""]
    #[doc = " @param fib"]
    #[doc = "   FIB object handle"]
    #[doc = " @param ip"]
    #[doc = "   IPv6 prefix address to be added to the FIB"]
    #[doc = " @param depth"]
    #[doc = "   Prefix length"]
    #[doc = " @param next_hop"]
    #[doc = "   Next hop to be added to the FIB"]
    #[doc = " @return"]
    #[doc = "   0 on success, negative value otherwise"]
    pub fn rte_fib6_add(
        fib: *mut rte_fib6,
        ip: *const u8,
        depth: u8,
        next_hop: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete a rule from the FIB."]
    #[doc = ""]
    #[doc = " @param fib"]
    #[doc = "   FIB object handle"]
    #[doc = " @param ip"]
    #[doc = "   IPv6 prefix address to be deleted from the FIB"]
    #[doc = " @param depth"]
    #[doc = "   Prefix length"]
    #[doc = " @return"]
    #[doc = "   0 on success, negative value otherwise"]
    pub fn rte_fib6_delete(fib: *mut rte_fib6, ip: *const u8, depth: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Lookup multiple IP addresses in the FIB."]
    #[doc = ""]
    #[doc = " @param fib"]
    #[doc = "   FIB object handle"]
    #[doc = " @param ips"]
    #[doc = "   Array of IPv6s to be looked up in the FIB"]
    #[doc = " @param next_hops"]
    #[doc = "   Next hop of the most specific rule found for IP."]
    #[doc = "   This is an array of eight byte values."]
    #[doc = "   If the lookup for the given IP failed, then corresponding element would"]
    #[doc = "   contain default nexthop value configured for a FIB."]
    #[doc = " @param n"]
    #[doc = "   Number of elements in ips (and next_hops) array to lookup."]
    #[doc = "  @return"]
    #[doc = "   -EINVAL for incorrect arguments, otherwise 0"]
    pub fn rte_fib6_lookup_bulk(
        fib: *mut rte_fib6,
        ips: *mut [u8; 16usize],
        next_hops: *mut u64,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get pointer to the dataplane specific struct"]
    #[doc = ""]
    #[doc = " @param fib"]
    #[doc = "   FIB6 object handle"]
    #[doc = " @return"]
    #[doc = "   Pointer on the dataplane struct on success"]
    #[doc = "   NULL otherwise"]
    pub fn rte_fib6_get_dp(fib: *mut rte_fib6) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get pointer to the RIB6"]
    #[doc = ""]
    #[doc = " @param fib"]
    #[doc = "   FIB object handle"]
    #[doc = " @return"]
    #[doc = "   Pointer on the RIB6 on success"]
    #[doc = "   NULL otherwise"]
    pub fn rte_fib6_get_rib(fib: *mut rte_fib6) -> *mut rte_rib6;
}
extern "C" {
    #[doc = " Set lookup function based on type"]
    #[doc = ""]
    #[doc = " @param fib"]
    #[doc = "   FIB object handle"]
    #[doc = " @param type"]
    #[doc = "   type of lookup function"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success"]
    #[doc = "   -EINVAL on failure"]
    pub fn rte_fib6_select_lookup(
        fib: *mut rte_fib6,
        type_: rte_fib6_lookup_type,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_fib {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_rib {
    _unused: [u8; 0],
}
#[repr(u32)]
#[doc = " Type of FIB struct"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_fib_type {
    #[doc = "< RIB tree based FIB"]
    RTE_FIB_DUMMY = 0,
    #[doc = "< DIR24_8 based FIB"]
    RTE_FIB_DIR24_8 = 1,
}
#[doc = " Modify FIB function"]
pub type rte_fib_modify_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        fib: *mut rte_fib,
        ip: u32,
        depth: u8,
        next_hop: u64,
        op: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " FIB bulk lookup function"]
pub type rte_fib_lookup_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        fib: *mut ::std::os::raw::c_void,
        ips: *const u32,
        next_hops: *mut u64,
        n: ::std::os::raw::c_uint,
    ),
>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_fib_op {
    RTE_FIB_ADD = 0,
    RTE_FIB_DEL = 1,
}
#[repr(u32)]
#[doc = " Size of nexthop (1 << nh_sz) bits for DIR24_8 based FIB"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_fib_dir24_8_nh_sz {
    RTE_FIB_DIR24_8_1B = 0,
    RTE_FIB_DIR24_8_2B = 1,
    RTE_FIB_DIR24_8_4B = 2,
    RTE_FIB_DIR24_8_8B = 3,
}
#[repr(u32)]
#[doc = " Type of lookup function implementation"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_fib_lookup_type {
    RTE_FIB_LOOKUP_DEFAULT = 0,
    RTE_FIB_LOOKUP_DIR24_8_SCALAR_MACRO = 1,
    RTE_FIB_LOOKUP_DIR24_8_SCALAR_INLINE = 2,
    RTE_FIB_LOOKUP_DIR24_8_SCALAR_UNI = 3,
    RTE_FIB_LOOKUP_DIR24_8_VECTOR_AVX512 = 4,
}
#[doc = " FIB configuration structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_fib_conf {
    #[doc = "< Type of FIB struct"]
    pub type_: rte_fib_type,
    #[doc = " Default value returned on lookup if there is no route"]
    pub default_nh: u64,
    pub max_routes: ::std::os::raw::c_int,
    #[doc = " Size of the node extension in the internal RIB struct"]
    pub rib_ext_sz: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: rte_fib_conf__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_fib_conf__bindgen_ty_1 {
    pub dir24_8: rte_fib_conf__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_fib_conf__bindgen_ty_1__bindgen_ty_1 {
    pub nh_sz: rte_fib_dir24_8_nh_sz,
    pub num_tbl8: u32,
}
extern "C" {
    #[doc = " Create FIB"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "  FIB name"]
    #[doc = " @param socket_id"]
    #[doc = "  NUMA socket ID for FIB table memory allocation"]
    #[doc = " @param conf"]
    #[doc = "  Structure containing the configuration"]
    #[doc = " @return"]
    #[doc = "  Handle to the FIB object on success"]
    #[doc = "  NULL otherwise with rte_errno set to an appropriate values."]
    pub fn rte_fib_create(
        name: *const ::std::os::raw::c_char,
        socket_id: ::std::os::raw::c_int,
        conf: *mut rte_fib_conf,
    ) -> *mut rte_fib;
}
extern "C" {
    #[doc = " Find an existing FIB object and return a pointer to it."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "  Name of the fib object as passed to rte_fib_create()"]
    #[doc = " @return"]
    #[doc = "  Pointer to fib object or NULL if object not found with rte_errno"]
    #[doc = "  set appropriately. Possible rte_errno values include:"]
    #[doc = "   - ENOENT - required entry not available to return."]
    pub fn rte_fib_find_existing(name: *const ::std::os::raw::c_char) -> *mut rte_fib;
}
extern "C" {
    #[doc = " Free an FIB object."]
    #[doc = ""]
    #[doc = " @param fib"]
    #[doc = "   FIB object handle"]
    #[doc = " @return"]
    #[doc = "   None"]
    pub fn rte_fib_free(fib: *mut rte_fib);
}
extern "C" {
    #[doc = " Add a route to the FIB."]
    #[doc = ""]
    #[doc = " @param fib"]
    #[doc = "   FIB object handle"]
    #[doc = " @param ip"]
    #[doc = "   IPv4 prefix address to be added to the FIB"]
    #[doc = " @param depth"]
    #[doc = "   Prefix length"]
    #[doc = " @param next_hop"]
    #[doc = "   Next hop to be added to the FIB"]
    #[doc = " @return"]
    #[doc = "   0 on success, negative value otherwise"]
    pub fn rte_fib_add(
        fib: *mut rte_fib,
        ip: u32,
        depth: u8,
        next_hop: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete a rule from the FIB."]
    #[doc = ""]
    #[doc = " @param fib"]
    #[doc = "   FIB object handle"]
    #[doc = " @param ip"]
    #[doc = "   IPv4 prefix address to be deleted from the FIB"]
    #[doc = " @param depth"]
    #[doc = "   Prefix length"]
    #[doc = " @return"]
    #[doc = "   0 on success, negative value otherwise"]
    pub fn rte_fib_delete(fib: *mut rte_fib, ip: u32, depth: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Lookup multiple IP addresses in the FIB."]
    #[doc = ""]
    #[doc = " @param fib"]
    #[doc = "   FIB object handle"]
    #[doc = " @param ips"]
    #[doc = "   Array of IPs to be looked up in the FIB"]
    #[doc = " @param next_hops"]
    #[doc = "   Next hop of the most specific rule found for IP."]
    #[doc = "   This is an array of eight byte values."]
    #[doc = "   If the lookup for the given IP failed, then corresponding element would"]
    #[doc = "   contain default nexthop value configured for a FIB."]
    #[doc = " @param n"]
    #[doc = "   Number of elements in ips (and next_hops) array to lookup."]
    #[doc = "  @return"]
    #[doc = "   -EINVAL for incorrect arguments, otherwise 0"]
    pub fn rte_fib_lookup_bulk(
        fib: *mut rte_fib,
        ips: *mut u32,
        next_hops: *mut u64,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get pointer to the dataplane specific struct"]
    #[doc = ""]
    #[doc = " @param fib"]
    #[doc = "   FIB object handle"]
    #[doc = " @return"]
    #[doc = "   Pointer on the dataplane struct on success"]
    #[doc = "   NULL otherwise"]
    pub fn rte_fib_get_dp(fib: *mut rte_fib) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get pointer to the RIB"]
    #[doc = ""]
    #[doc = " @param fib"]
    #[doc = "   FIB object handle"]
    #[doc = " @return"]
    #[doc = "   Pointer on the RIB on success"]
    #[doc = "   NULL otherwise"]
    pub fn rte_fib_get_rib(fib: *mut rte_fib) -> *mut rte_rib;
}
extern "C" {
    #[doc = " Set lookup function based on type"]
    #[doc = ""]
    #[doc = " @param fib"]
    #[doc = "   FIB object handle"]
    #[doc = " @param type"]
    #[doc = "   type of lookup function"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success"]
    #[doc = "   -EINVAL on failure"]
    pub fn rte_fib_select_lookup(
        fib: *mut rte_fib,
        type_: rte_fib_lookup_type,
    ) -> ::std::os::raw::c_int;
}
pub type rte_graph_off_t = u32;
pub type rte_node_t = u32;
pub type rte_edge_t = u16;
pub type rte_graph_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_graph_cluster_stats {
    _unused: [u8; 0],
}
#[doc = " Node process function."]
#[doc = ""]
#[doc = " The function invoked when the worker thread walks on nodes using"]
#[doc = " rte_graph_walk()."]
#[doc = ""]
#[doc = " @param graph"]
#[doc = "   Pointer to the graph object."]
#[doc = " @param node"]
#[doc = "   Pointer to the node object."]
#[doc = " @param objs"]
#[doc = "   Pointer to an array of objects to be processed."]
#[doc = " @param nb_objs"]
#[doc = "   Number of objects in the array."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Number of objects processed."]
#[doc = ""]
#[doc = " @see rte_graph_walk()"]
#[doc = ""]
pub type rte_node_process_t = ::std::option::Option<
    unsafe extern "C" fn(
        graph: *mut rte_graph,
        node: *mut rte_node,
        objs: *mut *mut ::std::os::raw::c_void,
        nb_objs: u16,
    ) -> u16,
>;
#[doc = " Node initialization function."]
#[doc = ""]
#[doc = " The function invoked when the user creates the graph using rte_graph_create()"]
#[doc = ""]
#[doc = " @param graph"]
#[doc = "   Pointer to the graph object."]
#[doc = " @param node"]
#[doc = "   Pointer to the node object."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   - 0: Success."]
#[doc = "   -<0: Failure."]
#[doc = ""]
#[doc = " @see rte_graph_create()"]
pub type rte_node_init_t = ::std::option::Option<
    unsafe extern "C" fn(graph: *const rte_graph, node: *mut rte_node) -> ::std::os::raw::c_int,
>;
#[doc = " Node finalization function."]
#[doc = ""]
#[doc = " The function invoked when the user destroys the graph using"]
#[doc = " rte_graph_destroy()."]
#[doc = ""]
#[doc = " @param graph"]
#[doc = "   Pointer to the graph object."]
#[doc = " @param node"]
#[doc = "   Pointer to the node object."]
#[doc = ""]
#[doc = " @see rte_graph_destroy()"]
pub type rte_node_fini_t =
    ::std::option::Option<unsafe extern "C" fn(graph: *const rte_graph, node: *mut rte_node)>;
#[doc = " Graph cluster stats callback."]
#[doc = ""]
#[doc = " @param is_first"]
#[doc = "   Flag to denote that stats are of the first node."]
#[doc = " @param is_last"]
#[doc = "   Flag to denote that stats are of the last node."]
#[doc = " @param cookie"]
#[doc = "   Cookie supplied during stats creation."]
#[doc = " @param stats"]
#[doc = "   Node cluster stats data."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   - 0: Success."]
#[doc = "   -<0: Failure."]
pub type rte_graph_cluster_stats_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        is_first: bool,
        is_last: bool,
        cookie: *mut ::std::os::raw::c_void,
        stats: *const rte_graph_cluster_node_stats,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Structure to hold configuration parameters for creating the graph."]
#[doc = ""]
#[doc = " @see rte_graph_create()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_graph_param {
    #[doc = "< Socket id where memory is allocated."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< Number of node patterns."]
    pub nb_node_patterns: u16,
    pub node_patterns: *mut *const ::std::os::raw::c_char,
}
#[doc = " Structure to hold configuration parameters for graph cluster stats create."]
#[doc = ""]
#[doc = " @see rte_graph_cluster_stats_create()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_graph_cluster_stats_param {
    pub socket_id: ::std::os::raw::c_int,
    pub fn_: rte_graph_cluster_stats_cb_t,
    pub __bindgen_anon_1: rte_graph_cluster_stats_param__bindgen_ty_1,
    #[doc = "< Number of graph patterns."]
    pub nb_graph_patterns: u16,
    pub graph_patterns: *mut *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_graph_cluster_stats_param__bindgen_ty_1 {
    pub cookie: *mut ::std::os::raw::c_void,
    #[doc = "< File pointer to dump the stats when fn == NULL."]
    pub f: *mut FILE,
}
#[doc = " Node cluster stats data structure."]
#[doc = ""]
#[doc = " @see struct rte_graph_cluster_stats_param::fn"]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_graph_cluster_node_stats {
    #[doc = "< Current timestamp."]
    pub ts: u64,
    #[doc = "< Current number of calls made."]
    pub calls: u64,
    #[doc = "< Current number of objs processed."]
    pub objs: u64,
    #[doc = "< Current number of cycles."]
    pub cycles: u64,
    #[doc = "< Previous call timestamp."]
    pub prev_ts: u64,
    #[doc = "< Previous number of calls."]
    pub prev_calls: u64,
    #[doc = "< Previous number of processed objs."]
    pub prev_objs: u64,
    #[doc = "< Previous number of cycles."]
    pub prev_cycles: u64,
    #[doc = "< Realloc count."]
    pub realloc_count: u64,
    #[doc = "< Node identifier of stats."]
    pub id: rte_node_t,
    #[doc = "< Cycles per seconds."]
    pub hz: u64,
    #[doc = "< Name of the node."]
    pub name: [::std::os::raw::c_char; 64usize],
}
extern "C" {
    #[doc = " Create Graph."]
    #[doc = ""]
    #[doc = " Create memory reel, detect loops and find isolated nodes."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Unique name for this graph."]
    #[doc = " @param prm"]
    #[doc = "   Graph parameter, includes node names and count to be included"]
    #[doc = "   in this graph."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Unique graph id on success, RTE_GRAPH_ID_INVALID otherwise."]
    pub fn rte_graph_create(
        name: *const ::std::os::raw::c_char,
        prm: *mut rte_graph_param,
    ) -> rte_graph_t;
}
extern "C" {
    #[doc = " Destroy Graph."]
    #[doc = ""]
    #[doc = " Free Graph memory reel."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "   id of the graph to destroy."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, error otherwise."]
    pub fn rte_graph_destroy(id: rte_graph_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get graph id from graph name."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Name of the graph to get id."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Graph id on success, RTE_GRAPH_ID_INVALID otherwise."]
    pub fn rte_graph_from_name(name: *const ::std::os::raw::c_char) -> rte_graph_t;
}
extern "C" {
    #[doc = " Get graph name from graph id."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "   id of the graph to get name."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Graph name on success, NULL otherwise."]
    pub fn rte_graph_id_to_name(id: rte_graph_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Export the graph as graph viz dot file"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Name of the graph to export."]
    #[doc = " @param f"]
    #[doc = "   File pointer to export the graph."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, error otherwise."]
    pub fn rte_graph_export(
        name: *const ::std::os::raw::c_char,
        f: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get graph object from its name."]
    #[doc = ""]
    #[doc = " Typical usage of this API to get graph objects in the worker thread and"]
    #[doc = " followed calling rte_graph_walk() in a loop."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Name of the graph."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Graph pointer on success, NULL otherwise."]
    #[doc = ""]
    #[doc = " @see rte_graph_walk()"]
    pub fn rte_graph_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_graph;
}
extern "C" {
    #[doc = " Get maximum number of graph available."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Maximum graph count."]
    pub fn rte_graph_max_count() -> rte_graph_t;
}
extern "C" {
    #[doc = " Dump the graph information to file."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   File pointer to dump graph info."]
    #[doc = " @param id"]
    #[doc = "   Graph id to get graph info."]
    pub fn rte_graph_dump(f: *mut FILE, id: rte_graph_t);
}
extern "C" {
    #[doc = " Dump all graphs information to file"]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   File pointer to dump graph info."]
    pub fn rte_graph_list_dump(f: *mut FILE);
}
extern "C" {
    #[doc = " Dump graph information along with node info to file"]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   File pointer to dump graph info."]
    #[doc = " @param graph"]
    #[doc = "   Graph pointer to get graph info."]
    #[doc = " @param all"]
    #[doc = "   true to dump nodes in the graph."]
    pub fn rte_graph_obj_dump(f: *mut FILE, graph: *mut rte_graph, all: bool);
}
extern "C" {
    #[doc = " Get node object with in graph from id."]
    #[doc = ""]
    #[doc = " @param graph_id"]
    #[doc = "   Graph id to get node pointer from."]
    #[doc = " @param node_id"]
    #[doc = "   Node id to get node pointer."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Node pointer on success, NULL otherwise."]
    pub fn rte_graph_node_get(graph_id: rte_graph_t, node_id: rte_node_t) -> *mut rte_node;
}
extern "C" {
    #[doc = " Get node pointer with in graph from name."]
    #[doc = ""]
    #[doc = " @param graph"]
    #[doc = "   Graph name to get node pointer from."]
    #[doc = " @param name"]
    #[doc = "   Node name to get the node pointer."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Node pointer on success, NULL otherwise."]
    pub fn rte_graph_node_get_by_name(
        graph: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> *mut rte_node;
}
extern "C" {
    #[doc = " Create graph stats cluster to aggregate runtime node stats."]
    #[doc = ""]
    #[doc = " @param prm"]
    #[doc = "   Parameters including file pointer to dump stats,"]
    #[doc = "   Graph pattern to create cluster and callback function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Valid pointer on success, NULL otherwise."]
    pub fn rte_graph_cluster_stats_create(
        prm: *const rte_graph_cluster_stats_param,
    ) -> *mut rte_graph_cluster_stats;
}
extern "C" {
    #[doc = " Destroy cluster stats."]
    #[doc = ""]
    #[doc = " @param stat"]
    #[doc = "    Valid cluster pointer to destroy."]
    pub fn rte_graph_cluster_stats_destroy(stat: *mut rte_graph_cluster_stats);
}
extern "C" {
    #[doc = " Get stats to application."]
    #[doc = ""]
    #[doc = " @param[out] stat"]
    #[doc = "   Cluster status."]
    #[doc = " @param skip_cb"]
    #[doc = "   true to skip callback function invocation."]
    pub fn rte_graph_cluster_stats_get(stat: *mut rte_graph_cluster_stats, skip_cb: bool);
}
extern "C" {
    #[doc = " Reset cluster stats to zero."]
    #[doc = ""]
    #[doc = " @param stat"]
    #[doc = "   Valid cluster stats pointer."]
    pub fn rte_graph_cluster_stats_reset(stat: *mut rte_graph_cluster_stats);
}
#[doc = " Structure defines the node registration parameters."]
#[doc = ""]
#[doc = " @see __rte_node_register(), RTE_NODE_REGISTER()"]
#[repr(C)]
#[derive(Debug)]
pub struct rte_node_register {
    #[doc = "< Name of the node."]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< Node configuration flag."]
    pub flags: u64,
    #[doc = "< Node process function."]
    pub process: rte_node_process_t,
    #[doc = "< Node init function."]
    pub init: rte_node_init_t,
    #[doc = "< Node fini function."]
    pub fini: rte_node_fini_t,
    #[doc = "< Node Identifier."]
    pub id: rte_node_t,
    #[doc = "< Identifier of parent node."]
    pub parent_id: rte_node_t,
    #[doc = "< Number of edges from this node."]
    pub nb_edges: rte_edge_t,
    #[doc = "< Names of next nodes."]
    pub next_nodes: __IncompleteArrayField<*const ::std::os::raw::c_char>,
}
extern "C" {
    #[doc = " Register new packet processing node. Nodes can be registered"]
    #[doc = " dynamically via this call or statically via the RTE_NODE_REGISTER"]
    #[doc = " macro."]
    #[doc = ""]
    #[doc = " @param node"]
    #[doc = "   Valid node pointer with name, process function and next_nodes."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Valid node id on success, RTE_NODE_ID_INVALID otherwise."]
    #[doc = ""]
    #[doc = " @see RTE_NODE_REGISTER()"]
    pub fn __rte_node_register(node: *const rte_node_register) -> rte_node_t;
}
extern "C" {
    #[doc = " Clone a node from static node(node created from RTE_NODE_REGISTER)."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "   Static node id to clone from."]
    #[doc = " @param name"]
    #[doc = "   Name of the new node. The library prepends the parent node name to the"]
    #[doc = " user-specified name. The final node name will be,"]
    #[doc = " \"parent node name\" + \"-\" + name."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Valid node id on success, RTE_NODE_ID_INVALID otherwise."]
    pub fn rte_node_clone(id: rte_node_t, name: *const ::std::os::raw::c_char) -> rte_node_t;
}
extern "C" {
    #[doc = " Get node id from node name."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Valid node name. In the case of the cloned node, the name will be"]
    #[doc = " \"parent node name\" + \"-\" + name."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Valid node id on success, RTE_NODE_ID_INVALID otherwise."]
    pub fn rte_node_from_name(name: *const ::std::os::raw::c_char) -> rte_node_t;
}
extern "C" {
    #[doc = " Get node name from node id."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "   Valid node id."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Valid node name on success, NULL otherwise."]
    pub fn rte_node_id_to_name(id: rte_node_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the number of edges(next-nodes) for a node from node id."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "   Valid node id."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Valid edge count on success, RTE_EDGE_ID_INVALID otherwise."]
    pub fn rte_node_edge_count(id: rte_node_t) -> rte_edge_t;
}
extern "C" {
    #[doc = " Update the edges for a node from node id."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "   Valid node id."]
    #[doc = " @param from"]
    #[doc = "   Index to update the edges from. RTE_EDGE_ID_INVALID is valid,"]
    #[doc = " in that case, it will be added to the end of the list."]
    #[doc = " @param next_nodes"]
    #[doc = "   Name of the edges to update."]
    #[doc = " @param nb_edges"]
    #[doc = "   Number of edges to update."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Valid edge count on success, 0 otherwise."]
    pub fn rte_node_edge_update(
        id: rte_node_t,
        from: rte_edge_t,
        next_nodes: *mut *const ::std::os::raw::c_char,
        nb_edges: u16,
    ) -> rte_edge_t;
}
extern "C" {
    #[doc = " Shrink the edges to a given size."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "   Valid node id."]
    #[doc = " @param size"]
    #[doc = "   New size to shrink the edges."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   New size on success, RTE_EDGE_ID_INVALID otherwise."]
    pub fn rte_node_edge_shrink(id: rte_node_t, size: rte_edge_t) -> rte_edge_t;
}
extern "C" {
    #[doc = " Get the edge names from a given node."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "   Valid node id."]
    #[doc = " @param[out] next_nodes"]
    #[doc = "   Buffer to copy the edge names. The NULL value is allowed in that case,"]
    #[doc = " the function returns the size of the array that needs to be allocated."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   When next_nodes == NULL, it returns the size of the array else"]
    #[doc = "  number of item copied."]
    pub fn rte_node_edge_get(
        id: rte_node_t,
        next_nodes: *mut *mut ::std::os::raw::c_char,
    ) -> rte_node_t;
}
extern "C" {
    #[doc = " Get maximum nodes available."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Maximum nodes count."]
    pub fn rte_node_max_count() -> rte_node_t;
}
extern "C" {
    #[doc = " Dump node info to file."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   File pointer to dump the node info."]
    #[doc = " @param id"]
    #[doc = "   Node id to get the info."]
    pub fn rte_node_dump(f: *mut FILE, id: rte_node_t);
}
extern "C" {
    #[doc = " Dump all node info to file."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   File pointer to dump the node info."]
    pub fn rte_node_list_dump(f: *mut FILE);
}
#[doc = " @internal"]
#[doc = ""]
#[doc = " Data structure to hold graph data."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_graph {
    #[doc = "< Tail of circular buffer."]
    pub tail: u32,
    #[doc = "< Head of circular buffer."]
    pub head: u32,
    #[doc = "< Circular buffer wrap around mask."]
    pub cir_mask: u32,
    #[doc = "< Number of nodes in the graph."]
    pub nb_nodes: rte_node_t,
    #[doc = "< Pointer to circular buffer."]
    pub cir_start: *mut rte_graph_off_t,
    #[doc = "< Offset at which node memory starts."]
    pub nodes_start: rte_graph_off_t,
    #[doc = "< Graph identifier."]
    pub id: rte_graph_t,
    #[doc = "< Socket ID where memory is allocated."]
    pub socket: ::std::os::raw::c_int,
    #[doc = "< Name of the graph."]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< Fence."]
    pub fence: u64,
}
#[doc = " @internal"]
#[doc = ""]
#[doc = " Data structure to hold node data."]
#[repr(C)]
#[repr(align(64))]
pub struct rte_node {
    #[doc = "< Fence."]
    pub fence: u64,
    #[doc = "< Index to next node."]
    pub next: rte_graph_off_t,
    #[doc = "< Node identifier."]
    pub id: rte_node_t,
    #[doc = "< Parent Node identifier."]
    pub parent_id: rte_node_t,
    #[doc = "< Number of edges from this node."]
    pub nb_edges: rte_edge_t,
    #[doc = "< Number of times realloced."]
    pub realloc_count: u32,
    #[doc = "< Parent node name."]
    pub parent: [::std::os::raw::c_char; 64usize],
    #[doc = "< Name of the node."]
    pub name: [::std::os::raw::c_char; 64usize],
    pub __bindgen_padding_0: [u8; 36usize],
    #[doc = "< Node Context."]
    pub ctx: [u8; 16usize],
    #[doc = "< Total number of objects available."]
    pub size: u16,
    #[doc = "< Number of objects used."]
    pub idx: u16,
    #[doc = "< Offset of node in the graph reel."]
    pub off: rte_graph_off_t,
    #[doc = "< Cycles spent in this node."]
    pub total_cycles: u64,
    #[doc = "< Calls done to this node."]
    pub total_calls: u64,
    #[doc = "< Objects processed by this node."]
    pub total_objs: u64,
    pub __bindgen_anon_1: rte_node__bindgen_ty_1,
    pub __bindgen_anon_2: rte_node__bindgen_ty_2,
    #[doc = "< Next nodes."]
    pub nodes: __IncompleteArrayField<*mut rte_node>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_node__bindgen_ty_1 {
    #[doc = "< Array of object pointers."]
    pub objs: *mut *mut ::std::os::raw::c_void,
    pub objs_u64: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_node__bindgen_ty_2 {
    #[doc = "< Process function."]
    pub process: rte_node_process_t,
    pub process_u64: u64,
}
extern "C" {
    #[doc = " @internal"]
    #[doc = ""]
    #[doc = " Allocate a stream of objects."]
    #[doc = ""]
    #[doc = " If stream already exists then re-allocate it to a larger size."]
    #[doc = ""]
    #[doc = " @param graph"]
    #[doc = "   Pointer to the graph object."]
    #[doc = " @param node"]
    #[doc = "   Pointer to the node object."]
    pub fn __rte_node_stream_alloc(graph: *mut rte_graph, node: *mut rte_node);
}
extern "C" {
    #[doc = " @internal"]
    #[doc = ""]
    #[doc = " Allocate a stream with requested number of objects."]
    #[doc = ""]
    #[doc = " If stream already exists then re-allocate it to a larger size."]
    #[doc = ""]
    #[doc = " @param graph"]
    #[doc = "   Pointer to the graph object."]
    #[doc = " @param node"]
    #[doc = "   Pointer to the node object."]
    #[doc = " @param req_size"]
    #[doc = "   Number of objects to be allocated."]
    pub fn __rte_node_stream_alloc_size(graph: *mut rte_graph, node: *mut rte_node, req_size: u16);
}
extern "C" {
    pub static mut rte_rcu_log_type: ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_rcu_qsbr_cnt {
    pub cnt: u64,
    pub lock_cnt: u32,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug)]
pub struct rte_rcu_qsbr {
    pub token: u64,
    pub acked_token: u64,
    pub __bindgen_padding_0: [u32; 12usize],
    pub num_elems: u32,
    pub num_threads: u32,
    pub max_threads: u32,
    pub __bindgen_padding_1: [u64; 6usize],
    pub qsbr_cnt: __IncompleteArrayField<rte_rcu_qsbr_cnt>,
}
#[doc = " Call back function called to free the resources."]
#[doc = ""]
#[doc = " @param p"]
#[doc = "   Pointer provided while creating the defer queue"]
#[doc = " @param e"]
#[doc = "   Pointer to the resource data stored on the defer queue"]
#[doc = " @param n"]
#[doc = "   Number of resources to free. Currently, this is set to 1."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   None"]
pub type rte_rcu_qsbr_free_resource_t = ::std::option::Option<
    unsafe extern "C" fn(
        p: *mut ::std::os::raw::c_void,
        e: *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ),
>;
#[doc = " Parameters used when creating the defer queue."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_rcu_qsbr_dq_parameters {
    pub name: *const ::std::os::raw::c_char,
    pub flags: u32,
    pub size: u32,
    pub esize: u32,
    pub trigger_reclaim_limit: u32,
    pub max_reclaim_size: u32,
    pub free_fn: rte_rcu_qsbr_free_resource_t,
    pub p: *mut ::std::os::raw::c_void,
    pub v: *mut rte_rcu_qsbr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_rcu_qsbr_dq {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Return the size of the memory occupied by a Quiescent State variable."]
    #[doc = ""]
    #[doc = " @param max_threads"]
    #[doc = "   Maximum number of threads reporting quiescent state on this variable."]
    #[doc = " @return"]
    #[doc = "   On success - size of memory in bytes required for this QS variable."]
    #[doc = "   On error - 1 with error code set in rte_errno."]
    #[doc = "   Possible rte_errno codes are:"]
    #[doc = "   - EINVAL - max_threads is 0"]
    pub fn rte_rcu_qsbr_get_memsize(max_threads: u32) -> size_t;
}
extern "C" {
    #[doc = " Initialize a Quiescent State (QS) variable."]
    #[doc = ""]
    #[doc = " @param v"]
    #[doc = "   QS variable"]
    #[doc = " @param max_threads"]
    #[doc = "   Maximum number of threads reporting quiescent state on this variable."]
    #[doc = "   This should be the same value as passed to rte_rcu_qsbr_get_memsize."]
    #[doc = " @return"]
    #[doc = "   On success - 0"]
    #[doc = "   On error - 1 with error code set in rte_errno."]
    #[doc = "   Possible rte_errno codes are:"]
    #[doc = "   - EINVAL - max_threads is 0 or 'v' is NULL."]
    #[doc = ""]
    pub fn rte_rcu_qsbr_init(v: *mut rte_rcu_qsbr, max_threads: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a reader thread to report its quiescent state"]
    #[doc = " on a QS variable."]
    #[doc = ""]
    #[doc = " This is implemented as a lock-free function. It is multi-thread"]
    #[doc = " safe."]
    #[doc = " Any reader thread that wants to report its quiescent state must"]
    #[doc = " call this API. This can be called during initialization or as part"]
    #[doc = " of the packet processing loop."]
    #[doc = ""]
    #[doc = " Note that rte_rcu_qsbr_thread_online must be called before the"]
    #[doc = " thread updates its quiescent state using rte_rcu_qsbr_quiescent."]
    #[doc = ""]
    #[doc = " @param v"]
    #[doc = "   QS variable"]
    #[doc = " @param thread_id"]
    #[doc = "   Reader thread with this thread ID will report its quiescent state on"]
    #[doc = "   the QS variable. thread_id is a value between 0 and (max_threads - 1)."]
    #[doc = "   'max_threads' is the parameter passed in 'rte_rcu_qsbr_init' API."]
    pub fn rte_rcu_qsbr_thread_register(
        v: *mut rte_rcu_qsbr,
        thread_id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a reader thread, from the list of threads reporting their"]
    #[doc = " quiescent state on a QS variable."]
    #[doc = ""]
    #[doc = " This is implemented as a lock-free function. It is multi-thread safe."]
    #[doc = " This API can be called from the reader threads during shutdown."]
    #[doc = " Ongoing quiescent state queries will stop waiting for the status from this"]
    #[doc = " unregistered reader thread."]
    #[doc = ""]
    #[doc = " @param v"]
    #[doc = "   QS variable"]
    #[doc = " @param thread_id"]
    #[doc = "   Reader thread with this thread ID will stop reporting its quiescent"]
    #[doc = "   state on the QS variable."]
    pub fn rte_rcu_qsbr_thread_unregister(
        v: *mut rte_rcu_qsbr,
        thread_id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait till the reader threads have entered quiescent state."]
    #[doc = ""]
    #[doc = " This is implemented as a lock-free function. It is multi-thread safe."]
    #[doc = " This API can be thought of as a wrapper around rte_rcu_qsbr_start and"]
    #[doc = " rte_rcu_qsbr_check APIs."]
    #[doc = ""]
    #[doc = " If this API is called from multiple threads, only one of"]
    #[doc = " those threads can be reporting the quiescent state status on a"]
    #[doc = " given QS variable."]
    #[doc = ""]
    #[doc = " @param v"]
    #[doc = "   QS variable"]
    #[doc = " @param thread_id"]
    #[doc = "   Thread ID of the caller if it is registered to report quiescent state"]
    #[doc = "   on this QS variable (i.e. the calling thread is also part of the"]
    #[doc = "   readside critical section). If not, pass RTE_QSBR_THRID_INVALID."]
    pub fn rte_rcu_qsbr_synchronize(v: *mut rte_rcu_qsbr, thread_id: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Dump the details of a single QS variables to a file."]
    #[doc = ""]
    #[doc = " It is NOT multi-thread safe."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    #[doc = " @param v"]
    #[doc = "   QS variable"]
    #[doc = " @return"]
    #[doc = "   On success - 0"]
    #[doc = "   On error - 1 with error code set in rte_errno."]
    #[doc = "   Possible rte_errno codes are:"]
    #[doc = "   - EINVAL - NULL parameters are passed"]
    pub fn rte_rcu_qsbr_dump(f: *mut FILE, v: *mut rte_rcu_qsbr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Create a queue used to store the data structure elements that can"]
    #[doc = " be freed later. This queue is referred to as 'defer queue'."]
    #[doc = ""]
    #[doc = " @param params"]
    #[doc = "   Parameters to create a defer queue."]
    #[doc = " @return"]
    #[doc = "   On success - Valid pointer to defer queue"]
    #[doc = "   On error - NULL"]
    #[doc = "   Possible rte_errno codes are:"]
    #[doc = "   - EINVAL - NULL parameters are passed"]
    #[doc = "   - ENOMEM - Not enough memory"]
    pub fn rte_rcu_qsbr_dq_create(
        params: *const rte_rcu_qsbr_dq_parameters,
    ) -> *mut rte_rcu_qsbr_dq;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Enqueue one resource to the defer queue and start the grace period."]
    #[doc = " The resource will be freed later after at least one grace period"]
    #[doc = " is over."]
    #[doc = ""]
    #[doc = " If the defer queue is full, it will attempt to reclaim resources."]
    #[doc = " It will also reclaim resources at regular intervals to avoid"]
    #[doc = " the defer queue from growing too big."]
    #[doc = ""]
    #[doc = " Multi-thread safety is provided as the defer queue configuration."]
    #[doc = " When multi-thread safety is requested, it is possible that the"]
    #[doc = " resources are not stored in their order of deletion. This results"]
    #[doc = " in resources being held in the defer queue longer than they should."]
    #[doc = ""]
    #[doc = " @param dq"]
    #[doc = "   Defer queue to allocate an entry from."]
    #[doc = " @param e"]
    #[doc = "   Pointer to resource data to copy to the defer queue. The size of"]
    #[doc = "   the data to copy is equal to the element size provided when the"]
    #[doc = "   defer queue was created."]
    #[doc = " @return"]
    #[doc = "   On success - 0"]
    #[doc = "   On error - 1 with rte_errno set to"]
    #[doc = "   - EINVAL - NULL parameters are passed"]
    #[doc = "   - ENOSPC - Defer queue is full. This condition can not happen"]
    #[doc = "\t\tif the defer queue size is equal (or larger) than the"]
    #[doc = "\t\tnumber of elements in the data structure."]
    pub fn rte_rcu_qsbr_dq_enqueue(
        dq: *mut rte_rcu_qsbr_dq,
        e: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Free resources from the defer queue."]
    #[doc = ""]
    #[doc = " This API is multi-thread safe."]
    #[doc = ""]
    #[doc = " @param dq"]
    #[doc = "   Defer queue to free an entry from."]
    #[doc = " @param n"]
    #[doc = "   Maximum number of resources to free."]
    #[doc = " @param freed"]
    #[doc = "   Number of resources that were freed."]
    #[doc = " @param pending"]
    #[doc = "   Number of resources pending on the defer queue. This number might not"]
    #[doc = "   be accurate if multi-thread safety is configured."]
    #[doc = " @param available"]
    #[doc = "   Number of resources that can be added to the defer queue."]
    #[doc = "   This number might not be accurate if multi-thread safety is configured."]
    #[doc = " @return"]
    #[doc = "   On successful reclamation of at least 1 resource - 0"]
    #[doc = "   On error - 1 with rte_errno set to"]
    #[doc = "   - EINVAL - NULL parameters are passed"]
    pub fn rte_rcu_qsbr_dq_reclaim(
        dq: *mut rte_rcu_qsbr_dq,
        n: ::std::os::raw::c_uint,
        freed: *mut ::std::os::raw::c_uint,
        pending: *mut ::std::os::raw::c_uint,
        available: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Delete a defer queue."]
    #[doc = ""]
    #[doc = " It tries to reclaim all the resources on the defer queue."]
    #[doc = " If any of the resources have not completed the grace period"]
    #[doc = " the reclamation stops and returns immediately. The rest of"]
    #[doc = " the resources are not reclaimed and the defer queue is not"]
    #[doc = " freed."]
    #[doc = ""]
    #[doc = " @param dq"]
    #[doc = "   Defer queue to delete."]
    #[doc = " @return"]
    #[doc = "   On success - 0"]
    #[doc = "   On error - 1"]
    #[doc = "   Possible rte_errno codes are:"]
    #[doc = "   - EAGAIN - Some of the resources have not completed at least 1 grace"]
    #[doc = "\t\tperiod, try again."]
    pub fn rte_rcu_qsbr_dq_delete(dq: *mut rte_rcu_qsbr_dq) -> ::std::os::raw::c_int;
}
#[doc = " The type of hash value of a key."]
#[doc = " It should be a value of at least 32bit with fully random pattern."]
pub type hash_sig_t = u32;
#[doc = " Type of function that can be used for calculating the hash value."]
pub type rte_hash_function = ::std::option::Option<
    unsafe extern "C" fn(key: *const ::std::os::raw::c_void, key_len: u32, init_val: u32) -> u32,
>;
#[doc = " Type of function used to compare the hash key."]
pub type rte_hash_cmp_eq_t = ::std::option::Option<
    unsafe extern "C" fn(
        key1: *const ::std::os::raw::c_void,
        key2: *const ::std::os::raw::c_void,
        key_len: size_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Type of function used to free data stored in the key."]
#[doc = " Required when using internal RCU to allow application to free key-data once"]
#[doc = " the key is returned to the ring of free key-slots."]
pub type rte_hash_free_key_data = ::std::option::Option<
    unsafe extern "C" fn(p: *mut ::std::os::raw::c_void, key_data: *mut ::std::os::raw::c_void),
>;
#[doc = " Parameters used when creating the hash table."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_hash_parameters {
    #[doc = "< Name of the hash."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Total hash table entries."]
    pub entries: u32,
    #[doc = "< Unused field. Should be set to 0"]
    pub reserved: u32,
    #[doc = "< Length of hash key."]
    pub key_len: u32,
    #[doc = "< Primary Hash function used to calculate hash."]
    pub hash_func: rte_hash_function,
    #[doc = "< Init value used by hash_func."]
    pub hash_func_init_val: u32,
    #[doc = "< NUMA Socket ID for memory."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< Indicate if additional parameters are present."]
    pub extra_flag: u8,
}
#[repr(u32)]
#[doc = " RCU reclamation modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_hash_qsbr_mode {
    #[doc = " Create defer queue for reclaim."]
    RTE_HASH_QSBR_MODE_DQ = 0,
    #[doc = " Use blocking mode reclaim. No defer queue created."]
    RTE_HASH_QSBR_MODE_SYNC = 1,
}
#[doc = " HASH RCU QSBR configuration structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_hash_rcu_config {
    #[doc = "< RCU QSBR variable."]
    pub v: *mut rte_rcu_qsbr,
    pub mode: rte_hash_qsbr_mode,
    pub dq_size: u32,
    #[doc = "< Threshold to trigger auto reclaim."]
    pub trigger_reclaim_limit: u32,
    pub max_reclaim_size: u32,
    pub key_data_ptr: *mut ::std::os::raw::c_void,
    pub free_key_data_func: rte_hash_free_key_data,
}
#[doc = " @internal A hash table structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_hash {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a new hash table."]
    #[doc = ""]
    #[doc = " @param params"]
    #[doc = "   Parameters used to create and initialise the hash table."]
    #[doc = " @return"]
    #[doc = "   Pointer to hash table structure that is used in future hash table"]
    #[doc = "   operations, or NULL on error, with error code set in rte_errno."]
    #[doc = "   Possible rte_errno errors include:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - ENOENT - missing entry"]
    #[doc = "    - EINVAL - invalid parameter passed to function"]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_hash_create(params: *const rte_hash_parameters) -> *mut rte_hash;
}
extern "C" {
    #[doc = " Set a new hash compare function other than the default one."]
    #[doc = ""]
    #[doc = " @note Function pointer does not work with multi-process, so do not use it"]
    #[doc = " in multi-process mode."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   Hash table for which the function is to be changed"]
    #[doc = " @param func"]
    #[doc = "   New compare function"]
    pub fn rte_hash_set_cmp_func(h: *mut rte_hash, func: rte_hash_cmp_eq_t);
}
extern "C" {
    #[doc = " Find an existing hash table object and return a pointer to it."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Name of the hash table as passed to rte_hash_create()"]
    #[doc = " @return"]
    #[doc = "   Pointer to hash table or NULL if object not found"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - ENOENT - value not available for return"]
    pub fn rte_hash_find_existing(name: *const ::std::os::raw::c_char) -> *mut rte_hash;
}
extern "C" {
    #[doc = " De-allocate all memory used by hash table."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   Hash table to free, if NULL, the function does nothing."]
    #[doc = ""]
    pub fn rte_hash_free(h: *mut rte_hash);
}
extern "C" {
    #[doc = " Reset all hash structure, by zeroing all entries."]
    #[doc = " When RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF is enabled,"]
    #[doc = " it is application's responsibility to make sure that"]
    #[doc = " none of the readers are referencing the hash table"]
    #[doc = " while calling this API."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   Hash table to reset"]
    pub fn rte_hash_reset(h: *mut rte_hash);
}
extern "C" {
    #[doc = " Return the number of keys in the hash table"]
    #[doc = " @param h"]
    #[doc = "  Hash table to query from"]
    #[doc = " @return"]
    #[doc = "   - -EINVAL if parameters are invalid"]
    #[doc = "   - A value indicating how many keys were inserted in the table."]
    pub fn rte_hash_count(h: *const rte_hash) -> i32;
}
extern "C" {
    #[doc = " Return the maximum key value ID that could possibly be returned by"]
    #[doc = " rte_hash_add_key function."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "  Hash table to query from"]
    #[doc = " @return"]
    #[doc = "   - -EINVAL if parameters are invalid"]
    #[doc = "   - A value indicating the max key ID of key slots present in the table."]
    pub fn rte_hash_max_key_id(h: *const rte_hash) -> i32;
}
extern "C" {
    #[doc = " Add a key-value pair to an existing hash table."]
    #[doc = " This operation is not multi-thread safe"]
    #[doc = " and should only be called from one thread by default."]
    #[doc = " Thread safety can be enabled by setting flag during"]
    #[doc = " table creation."]
    #[doc = " If the key exists already in the table, this API updates its value"]
    #[doc = " with 'data' passed in this API. It is the responsibility of"]
    #[doc = " the application to manage any memory associated with the old value."]
    #[doc = " The readers might still be using the old value even after this API"]
    #[doc = " has returned."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   Hash table to add the key to."]
    #[doc = " @param key"]
    #[doc = "   Key to add to the hash table."]
    #[doc = " @param data"]
    #[doc = "   Data to add to the hash table."]
    #[doc = " @return"]
    #[doc = "   - 0 if added successfully"]
    #[doc = "   - -EINVAL if the parameters are invalid."]
    #[doc = "   - -ENOSPC if there is no space in the hash for this key."]
    pub fn rte_hash_add_key_data(
        h: *const rte_hash,
        key: *const ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a key-value pair with a pre-computed hash value"]
    #[doc = " to an existing hash table."]
    #[doc = " This operation is not multi-thread safe"]
    #[doc = " and should only be called from one thread by default."]
    #[doc = " Thread safety can be enabled by setting flag during"]
    #[doc = " table creation."]
    #[doc = " If the key exists already in the table, this API updates its value"]
    #[doc = " with 'data' passed in this API. It is the responsibility of"]
    #[doc = " the application to manage any memory associated with the old value."]
    #[doc = " The readers might still be using the old value even after this API"]
    #[doc = " has returned."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   Hash table to add the key to."]
    #[doc = " @param key"]
    #[doc = "   Key to add to the hash table."]
    #[doc = " @param sig"]
    #[doc = "   Precomputed hash value for 'key'"]
    #[doc = " @param data"]
    #[doc = "   Data to add to the hash table."]
    #[doc = " @return"]
    #[doc = "   - 0 if added successfully"]
    #[doc = "   - -EINVAL if the parameters are invalid."]
    #[doc = "   - -ENOSPC if there is no space in the hash for this key."]
    pub fn rte_hash_add_key_with_hash_data(
        h: *const rte_hash,
        key: *const ::std::os::raw::c_void,
        sig: hash_sig_t,
        data: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    #[doc = " Add a key to an existing hash table. This operation is not multi-thread safe"]
    #[doc = " and should only be called from one thread by default."]
    #[doc = " Thread safety can be enabled by setting flag during"]
    #[doc = " table creation."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   Hash table to add the key to."]
    #[doc = " @param key"]
    #[doc = "   Key to add to the hash table."]
    #[doc = " @return"]
    #[doc = "   - -EINVAL if the parameters are invalid."]
    #[doc = "   - -ENOSPC if there is no space in the hash for this key."]
    #[doc = "   - A positive value that can be used by the caller as an offset into an"]
    #[doc = "     array of user data. This value is unique for this key. This"]
    #[doc = "     unique key id may be larger than the user specified entry count"]
    #[doc = "     when RTE_HASH_EXTRA_FLAGS_MULTI_WRITER_ADD flag is set."]
    pub fn rte_hash_add_key(h: *const rte_hash, key: *const ::std::os::raw::c_void) -> i32;
}
extern "C" {
    #[doc = " Add a key to an existing hash table."]
    #[doc = " This operation is not multi-thread safe"]
    #[doc = " and should only be called from one thread by default."]
    #[doc = " Thread safety can be enabled by setting flag during"]
    #[doc = " table creation."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   Hash table to add the key to."]
    #[doc = " @param key"]
    #[doc = "   Key to add to the hash table."]
    #[doc = " @param sig"]
    #[doc = "   Precomputed hash value for 'key'."]
    #[doc = " @return"]
    #[doc = "   - -EINVAL if the parameters are invalid."]
    #[doc = "   - -ENOSPC if there is no space in the hash for this key."]
    #[doc = "   - A positive value that can be used by the caller as an offset into an"]
    #[doc = "     array of user data. This value is unique for this key. This"]
    #[doc = "     unique key ID may be larger than the user specified entry count"]
    #[doc = "     when RTE_HASH_EXTRA_FLAGS_MULTI_WRITER_ADD flag is set."]
    pub fn rte_hash_add_key_with_hash(
        h: *const rte_hash,
        key: *const ::std::os::raw::c_void,
        sig: hash_sig_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Remove a key from an existing hash table."]
    #[doc = " This operation is not multi-thread safe"]
    #[doc = " and should only be called from one thread by default."]
    #[doc = " Thread safety can be enabled by setting flag during"]
    #[doc = " table creation."]
    #[doc = " If RTE_HASH_EXTRA_FLAGS_NO_FREE_ON_DEL or"]
    #[doc = " RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF is enabled and"]
    #[doc = " internal RCU is NOT enabled,"]
    #[doc = " the key index returned by rte_hash_add_key_xxx APIs will not be"]
    #[doc = " freed by this API. rte_hash_free_key_with_position API must be called"]
    #[doc = " additionally to free the index associated with the key."]
    #[doc = " rte_hash_free_key_with_position API should be called after all"]
    #[doc = " the readers have stopped referencing the entry corresponding to"]
    #[doc = " this key. RCU mechanisms could be used to determine such a state."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   Hash table to remove the key from."]
    #[doc = " @param key"]
    #[doc = "   Key to remove from the hash table."]
    #[doc = " @return"]
    #[doc = "   - -EINVAL if the parameters are invalid."]
    #[doc = "   - -ENOENT if the key is not found."]
    #[doc = "   - A positive value that can be used by the caller as an offset into an"]
    #[doc = "     array of user data. This value is unique for this key, and is the same"]
    #[doc = "     value that was returned when the key was added."]
    pub fn rte_hash_del_key(h: *const rte_hash, key: *const ::std::os::raw::c_void) -> i32;
}
extern "C" {
    #[doc = " Remove a key from an existing hash table."]
    #[doc = " This operation is not multi-thread safe"]
    #[doc = " and should only be called from one thread by default."]
    #[doc = " Thread safety can be enabled by setting flag during"]
    #[doc = " table creation."]
    #[doc = " If RTE_HASH_EXTRA_FLAGS_NO_FREE_ON_DEL or"]
    #[doc = " RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF is enabled and"]
    #[doc = " internal RCU is NOT enabled,"]
    #[doc = " the key index returned by rte_hash_add_key_xxx APIs will not be"]
    #[doc = " freed by this API. rte_hash_free_key_with_position API must be called"]
    #[doc = " additionally to free the index associated with the key."]
    #[doc = " rte_hash_free_key_with_position API should be called after all"]
    #[doc = " the readers have stopped referencing the entry corresponding to"]
    #[doc = " this key. RCU mechanisms could be used to determine such a state."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   Hash table to remove the key from."]
    #[doc = " @param key"]
    #[doc = "   Key to remove from the hash table."]
    #[doc = " @param sig"]
    #[doc = "   Precomputed hash value for 'key'."]
    #[doc = " @return"]
    #[doc = "   - -EINVAL if the parameters are invalid."]
    #[doc = "   - -ENOENT if the key is not found."]
    #[doc = "   - A positive value that can be used by the caller as an offset into an"]
    #[doc = "     array of user data. This value is unique for this key, and is the same"]
    #[doc = "     value that was returned when the key was added."]
    pub fn rte_hash_del_key_with_hash(
        h: *const rte_hash,
        key: *const ::std::os::raw::c_void,
        sig: hash_sig_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Find a key in the hash table given the position."]
    #[doc = " This operation is multi-thread safe with regarding to other lookup threads."]
    #[doc = " Read-write concurrency can be enabled by setting flag during"]
    #[doc = " table creation."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   Hash table to get the key from."]
    #[doc = " @param position"]
    #[doc = "   Position returned when the key was inserted."]
    #[doc = " @param key"]
    #[doc = "   Output containing a pointer to the key"]
    #[doc = " @return"]
    #[doc = "   - 0 if retrieved successfully"]
    #[doc = "   - -EINVAL if the parameters are invalid."]
    #[doc = "   - -ENOENT if no valid key is found in the given position."]
    pub fn rte_hash_get_key_with_position(
        h: *const rte_hash,
        position: i32,
        key: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free a hash key in the hash table given the position"]
    #[doc = " of the key. This operation is not multi-thread safe and should"]
    #[doc = " only be called from one thread by default. Thread safety"]
    #[doc = " can be enabled by setting flag during table creation."]
    #[doc = " If RTE_HASH_EXTRA_FLAGS_NO_FREE_ON_DEL or"]
    #[doc = " RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF is enabled and"]
    #[doc = " internal RCU is NOT enabled,"]
    #[doc = " the key index returned by rte_hash_del_key_xxx APIs must be freed"]
    #[doc = " using this API. This API should be called after all the readers"]
    #[doc = " have stopped referencing the entry corresponding to this key."]
    #[doc = " RCU mechanisms could be used to determine such a state."]
    #[doc = " This API does not validate if the key is already freed."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   Hash table to free the key from."]
    #[doc = " @param position"]
    #[doc = "   Position returned when the key was deleted."]
    #[doc = " @return"]
    #[doc = "   - 0 if freed successfully"]
    #[doc = "   - -EINVAL if the parameters are invalid."]
    pub fn rte_hash_free_key_with_position(
        h: *const rte_hash,
        position: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find a key-value pair in the hash table."]
    #[doc = " This operation is multi-thread safe with regarding to other lookup threads."]
    #[doc = " Read-write concurrency can be enabled by setting flag during"]
    #[doc = " table creation."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   Hash table to look in."]
    #[doc = " @param key"]
    #[doc = "   Key to find."]
    #[doc = " @param data"]
    #[doc = "   Output with pointer to data returned from the hash table."]
    #[doc = " @return"]
    #[doc = "   - A positive value that can be used by the caller as an offset into an"]
    #[doc = "     array of user data. This value is unique for this key, and is the same"]
    #[doc = "     value that was returned when the key was added."]
    #[doc = "   - -EINVAL if the parameters are invalid."]
    #[doc = "   - -ENOENT if the key is not found."]
    pub fn rte_hash_lookup_data(
        h: *const rte_hash,
        key: *const ::std::os::raw::c_void,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find a key-value pair with a pre-computed hash value"]
    #[doc = " to an existing hash table."]
    #[doc = " This operation is multi-thread safe with regarding to other lookup threads."]
    #[doc = " Read-write concurrency can be enabled by setting flag during"]
    #[doc = " table creation."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   Hash table to look in."]
    #[doc = " @param key"]
    #[doc = "   Key to find."]
    #[doc = " @param sig"]
    #[doc = "   Precomputed hash value for 'key'"]
    #[doc = " @param data"]
    #[doc = "   Output with pointer to data returned from the hash table."]
    #[doc = " @return"]
    #[doc = "   - A positive value that can be used by the caller as an offset into an"]
    #[doc = "     array of user data. This value is unique for this key, and is the same"]
    #[doc = "     value that was returned when the key was added."]
    #[doc = "   - -EINVAL if the parameters are invalid."]
    #[doc = "   - -ENOENT if the key is not found."]
    pub fn rte_hash_lookup_with_hash_data(
        h: *const rte_hash,
        key: *const ::std::os::raw::c_void,
        sig: hash_sig_t,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find a key in the hash table."]
    #[doc = " This operation is multi-thread safe with regarding to other lookup threads."]
    #[doc = " Read-write concurrency can be enabled by setting flag during"]
    #[doc = " table creation."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   Hash table to look in."]
    #[doc = " @param key"]
    #[doc = "   Key to find."]
    #[doc = " @return"]
    #[doc = "   - -EINVAL if the parameters are invalid."]
    #[doc = "   - -ENOENT if the key is not found."]
    #[doc = "   - A positive value that can be used by the caller as an offset into an"]
    #[doc = "     array of user data. This value is unique for this key, and is the same"]
    #[doc = "     value that was returned when the key was added."]
    pub fn rte_hash_lookup(h: *const rte_hash, key: *const ::std::os::raw::c_void) -> i32;
}
extern "C" {
    #[doc = " Find a key in the hash table."]
    #[doc = " This operation is multi-thread safe with regarding to other lookup threads."]
    #[doc = " Read-write concurrency can be enabled by setting flag during"]
    #[doc = " table creation."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   Hash table to look in."]
    #[doc = " @param key"]
    #[doc = "   Key to find."]
    #[doc = " @param sig"]
    #[doc = "   Precomputed hash value for 'key'."]
    #[doc = " @return"]
    #[doc = "   - -EINVAL if the parameters are invalid."]
    #[doc = "   - -ENOENT if the key is not found."]
    #[doc = "   - A positive value that can be used by the caller as an offset into an"]
    #[doc = "     array of user data. This value is unique for this key, and is the same"]
    #[doc = "     value that was returned when the key was added."]
    pub fn rte_hash_lookup_with_hash(
        h: *const rte_hash,
        key: *const ::std::os::raw::c_void,
        sig: hash_sig_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Calc a hash value by key."]
    #[doc = " This operation is not multi-process safe."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   Hash table to look in."]
    #[doc = " @param key"]
    #[doc = "   Key to find."]
    #[doc = " @return"]
    #[doc = "   - hash value"]
    pub fn rte_hash_hash(h: *const rte_hash, key: *const ::std::os::raw::c_void) -> hash_sig_t;
}
extern "C" {
    #[doc = " Find multiple keys in the hash table."]
    #[doc = " This operation is multi-thread safe with regarding to other lookup threads."]
    #[doc = " Read-write concurrency can be enabled by setting flag during"]
    #[doc = " table creation."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   Hash table to look in."]
    #[doc = " @param keys"]
    #[doc = "   A pointer to a list of keys to look for."]
    #[doc = " @param num_keys"]
    #[doc = "   How many keys are in the keys list (less than RTE_HASH_LOOKUP_BULK_MAX)."]
    #[doc = " @param hit_mask"]
    #[doc = "   Output containing a bitmask with all successful lookups."]
    #[doc = " @param data"]
    #[doc = "   Output containing array of data returned from all the successful lookups."]
    #[doc = " @return"]
    #[doc = "   -EINVAL if there's an error, otherwise number of successful lookups."]
    pub fn rte_hash_lookup_bulk_data(
        h: *const rte_hash,
        keys: *mut *const ::std::os::raw::c_void,
        num_keys: u32,
        hit_mask: *mut u64,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find multiple keys in the hash table with precomputed hash value array."]
    #[doc = " This operation is multi-thread safe with regarding to other lookup threads."]
    #[doc = " Read-write concurrency can be enabled by setting flag during"]
    #[doc = " table creation."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   Hash table to look in."]
    #[doc = " @param keys"]
    #[doc = "   A pointer to a list of keys to look for."]
    #[doc = " @param sig"]
    #[doc = "   A pointer to a list of precomputed hash values for keys."]
    #[doc = " @param num_keys"]
    #[doc = "   How many keys are in the keys list (less than RTE_HASH_LOOKUP_BULK_MAX)."]
    #[doc = " @param positions"]
    #[doc = "   Output containing a list of values, corresponding to the list of keys that"]
    #[doc = "   can be used by the caller as an offset into an array of user data. These"]
    #[doc = "   values are unique for each key, and are the same values that were returned"]
    #[doc = "   when each key was added. If a key in the list was not found, then -ENOENT"]
    #[doc = "   will be the value."]
    #[doc = " @return"]
    #[doc = "   -EINVAL if there's an error, otherwise 0."]
    pub fn rte_hash_lookup_with_hash_bulk(
        h: *const rte_hash,
        keys: *mut *const ::std::os::raw::c_void,
        sig: *mut hash_sig_t,
        num_keys: u32,
        positions: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find multiple keys in the hash table with precomputed hash value array."]
    #[doc = " This operation is multi-thread safe with regarding to other lookup threads."]
    #[doc = " Read-write concurrency can be enabled by setting flag during"]
    #[doc = " table creation."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   Hash table to look in."]
    #[doc = " @param keys"]
    #[doc = "   A pointer to a list of keys to look for."]
    #[doc = " @param sig"]
    #[doc = "   A pointer to a list of precomputed hash values for keys."]
    #[doc = " @param num_keys"]
    #[doc = "   How many keys are in the keys list (less than RTE_HASH_LOOKUP_BULK_MAX)."]
    #[doc = " @param hit_mask"]
    #[doc = "   Output containing a bitmask with all successful lookups."]
    #[doc = " @param data"]
    #[doc = "   Output containing array of data returned from all the successful lookups."]
    #[doc = " @return"]
    #[doc = "   -EINVAL if there's an error, otherwise number of successful lookups."]
    pub fn rte_hash_lookup_with_hash_bulk_data(
        h: *const rte_hash,
        keys: *mut *const ::std::os::raw::c_void,
        sig: *mut hash_sig_t,
        num_keys: u32,
        hit_mask: *mut u64,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find multiple keys in the hash table."]
    #[doc = " This operation is multi-thread safe with regarding to other lookup threads."]
    #[doc = " Read-write concurrency can be enabled by setting flag during"]
    #[doc = " table creation."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   Hash table to look in."]
    #[doc = " @param keys"]
    #[doc = "   A pointer to a list of keys to look for."]
    #[doc = " @param num_keys"]
    #[doc = "   How many keys are in the keys list (less than RTE_HASH_LOOKUP_BULK_MAX)."]
    #[doc = " @param positions"]
    #[doc = "   Output containing a list of values, corresponding to the list of keys that"]
    #[doc = "   can be used by the caller as an offset into an array of user data. These"]
    #[doc = "   values are unique for each key, and are the same values that were returned"]
    #[doc = "   when each key was added. If a key in the list was not found, then -ENOENT"]
    #[doc = "   will be the value."]
    #[doc = " @return"]
    #[doc = "   -EINVAL if there's an error, otherwise 0."]
    pub fn rte_hash_lookup_bulk(
        h: *const rte_hash,
        keys: *mut *const ::std::os::raw::c_void,
        num_keys: u32,
        positions: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iterate through the hash table, returning key-value pairs."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   Hash table to iterate"]
    #[doc = " @param key"]
    #[doc = "   Output containing the key where current iterator"]
    #[doc = "   was pointing at"]
    #[doc = " @param data"]
    #[doc = "   Output containing the data associated with key."]
    #[doc = "   Returns NULL if data was not stored."]
    #[doc = " @param next"]
    #[doc = "   Pointer to iterator. Should be 0 to start iterating the hash table."]
    #[doc = "   Iterator is incremented after each call of this function."]
    #[doc = " @return"]
    #[doc = "   Position where key was stored, if successful."]
    #[doc = "   - -EINVAL if the parameters are invalid."]
    #[doc = "   - -ENOENT if end of the hash table."]
    pub fn rte_hash_iterate(
        h: *const rte_hash,
        key: *mut *const ::std::os::raw::c_void,
        data: *mut *mut ::std::os::raw::c_void,
        next: *mut u32,
    ) -> i32;
}
extern "C" {
    #[doc = " Associate RCU QSBR variable with a Hash object."]
    #[doc = " This API should be called to enable the integrated RCU QSBR support and"]
    #[doc = " should be called immediately after creating the Hash object."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "   the hash object to add RCU QSBR"]
    #[doc = " @param cfg"]
    #[doc = "   RCU QSBR configuration"]
    #[doc = " @return"]
    #[doc = "   On success - 0"]
    #[doc = "   On error - 1 with error code set in rte_errno."]
    #[doc = "   Possible rte_errno codes are:"]
    #[doc = "   - EINVAL - invalid pointer"]
    #[doc = "   - EEXIST - already added QSBR"]
    #[doc = "   - ENOMEM - memory allocation failure"]
    pub fn rte_hash_rcu_qsbr_add(
        h: *mut rte_hash,
        cfg: *mut rte_hash_rcu_config,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump out memory in a special hex dump format."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "\t\tA pointer to a file for output"]
    #[doc = " @param title"]
    #[doc = "\t\tIf not NULL this string is printed as a header to the output."]
    #[doc = " @param buf"]
    #[doc = "\t\tThis is the buffer address to print out."]
    #[doc = " @param len"]
    #[doc = "\t\tThe number of bytes to dump out"]
    #[doc = " @return"]
    #[doc = "\t\tNone."]
    pub fn rte_hexdump(
        f: *mut FILE,
        title: *const ::std::os::raw::c_char,
        buf: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Dump out memory in a hex format with colons between bytes."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "\t\tA pointer to a file for output"]
    #[doc = " @param title"]
    #[doc = "\t\tIf not NULL this string is printed as a header to the output."]
    #[doc = " @param buf"]
    #[doc = "\t\tThis is the buffer address to print out."]
    #[doc = " @param len"]
    #[doc = "\t\tThe number of bytes to dump out"]
    #[doc = " @return"]
    #[doc = "\t\tNone."]
    pub fn rte_memdump(
        f: *mut FILE,
        title: *const ::std::os::raw::c_char,
        buf: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_uint,
    );
}
#[repr(u32)]
#[doc = " @file"]
#[doc = " Hypervisor awareness."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_hypervisor {
    RTE_HYPERVISOR_NONE = 0,
    RTE_HYPERVISOR_KVM = 1,
    RTE_HYPERVISOR_HYPERV = 2,
    RTE_HYPERVISOR_VMWARE = 3,
    RTE_HYPERVISOR_UNKNOWN = 4,
}
extern "C" {
    #[doc = " Get the id of hypervisor it is running on."]
    pub fn rte_hypervisor_get() -> rte_hypervisor;
}
extern "C" {
    #[doc = " Get the name of a given hypervisor id."]
    pub fn rte_hypervisor_get_name(id: rte_hypervisor) -> *const ::std::os::raw::c_char;
}
#[doc = " mbuf death row (packets to be freed)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ip_frag_death_row {
    #[doc = "< number of mbufs currently on death row"]
    pub cnt: u32,
    pub row: [*mut rte_mbuf; 288usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ip_frag_tbl {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a new IP fragmentation table."]
    #[doc = ""]
    #[doc = " @param bucket_num"]
    #[doc = "   Number of buckets in the hash table."]
    #[doc = " @param bucket_entries"]
    #[doc = "   Number of entries per bucket (e.g. hash associativity)."]
    #[doc = "   Should be power of two."]
    #[doc = " @param max_entries"]
    #[doc = "   Maximum number of entries that could be stored in the table."]
    #[doc = "   The value should be less or equal then bucket_num * bucket_entries."]
    #[doc = " @param max_cycles"]
    #[doc = "   Maximum TTL in cycles for each fragmented packet."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in the case of"]
    #[doc = "   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA constraints."]
    #[doc = " @return"]
    #[doc = "   The pointer to the new allocated fragmentation table, on success. NULL on error."]
    pub fn rte_ip_frag_table_create(
        bucket_num: u32,
        bucket_entries: u32,
        max_entries: u32,
        max_cycles: u64,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_ip_frag_tbl;
}
extern "C" {
    #[doc = " Free allocated IP fragmentation table."]
    #[doc = ""]
    #[doc = " @param tbl"]
    #[doc = "   Fragmentation table to free."]
    pub fn rte_ip_frag_table_destroy(tbl: *mut rte_ip_frag_tbl);
}
extern "C" {
    #[doc = " This function implements the fragmentation of IPv6 packets."]
    #[doc = ""]
    #[doc = " @param pkt_in"]
    #[doc = "   The input packet."]
    #[doc = " @param pkts_out"]
    #[doc = "   Array storing the output fragments."]
    #[doc = " @param nb_pkts_out"]
    #[doc = "   Number of fragments."]
    #[doc = " @param mtu_size"]
    #[doc = "   Size in bytes of the Maximum Transfer Unit (MTU) for the outgoing IPv6"]
    #[doc = "   datagrams. This value includes the size of the IPv6 header."]
    #[doc = " @param pool_direct"]
    #[doc = "   MBUF pool used for allocating direct buffers for the output fragments."]
    #[doc = " @param pool_indirect"]
    #[doc = "   MBUF pool used for allocating indirect buffers for the output fragments."]
    #[doc = " @return"]
    #[doc = "   Upon successful completion - number of output fragments placed"]
    #[doc = "   in the pkts_out array."]
    #[doc = "   Otherwise - (-1) * errno."]
    pub fn rte_ipv6_fragment_packet(
        pkt_in: *mut rte_mbuf,
        pkts_out: *mut *mut rte_mbuf,
        nb_pkts_out: u16,
        mtu_size: u16,
        pool_direct: *mut rte_mempool,
        pool_indirect: *mut rte_mempool,
    ) -> i32;
}
extern "C" {
    #[doc = " This function implements reassembly of fragmented IPv6 packets."]
    #[doc = " Incoming mbuf should have its l2_len/l3_len fields setup correctly."]
    #[doc = ""]
    #[doc = " @param tbl"]
    #[doc = "   Table where to lookup/add the fragmented packet."]
    #[doc = " @param dr"]
    #[doc = "   Death row to free buffers to"]
    #[doc = " @param mb"]
    #[doc = "   Incoming mbuf with IPv6 fragment."]
    #[doc = " @param tms"]
    #[doc = "   Fragment arrival timestamp."]
    #[doc = " @param ip_hdr"]
    #[doc = "   Pointer to the IPv6 header."]
    #[doc = " @param frag_hdr"]
    #[doc = "   Pointer to the IPv6 fragment extension header."]
    #[doc = " @return"]
    #[doc = "   Pointer to mbuf for reassembled packet, or NULL if:"]
    #[doc = "   - an error occurred."]
    #[doc = "   - not all fragments of the packet are collected yet."]
    pub fn rte_ipv6_frag_reassemble_packet(
        tbl: *mut rte_ip_frag_tbl,
        dr: *mut rte_ip_frag_death_row,
        mb: *mut rte_mbuf,
        tms: u64,
        ip_hdr: *mut rte_ipv6_hdr,
        frag_hdr: *mut rte_ipv6_fragment_ext,
    ) -> *mut rte_mbuf;
}
extern "C" {
    #[doc = " IPv4 fragmentation."]
    #[doc = ""]
    #[doc = " This function implements the fragmentation of IPv4 packets."]
    #[doc = ""]
    #[doc = " @param pkt_in"]
    #[doc = "   The input packet."]
    #[doc = " @param pkts_out"]
    #[doc = "   Array storing the output fragments."]
    #[doc = " @param nb_pkts_out"]
    #[doc = "   Number of fragments."]
    #[doc = " @param mtu_size"]
    #[doc = "   Size in bytes of the Maximum Transfer Unit (MTU) for the outgoing IPv4"]
    #[doc = "   datagrams. This value includes the size of the IPv4 header."]
    #[doc = " @param pool_direct"]
    #[doc = "   MBUF pool used for allocating direct buffers for the output fragments."]
    #[doc = " @param pool_indirect"]
    #[doc = "   MBUF pool used for allocating indirect buffers for the output fragments."]
    #[doc = " @return"]
    #[doc = "   Upon successful completion - number of output fragments placed"]
    #[doc = "   in the pkts_out array."]
    #[doc = "   Otherwise - (-1) * errno."]
    pub fn rte_ipv4_fragment_packet(
        pkt_in: *mut rte_mbuf,
        pkts_out: *mut *mut rte_mbuf,
        nb_pkts_out: u16,
        mtu_size: u16,
        pool_direct: *mut rte_mempool,
        pool_indirect: *mut rte_mempool,
    ) -> i32;
}
extern "C" {
    #[doc = " This function implements reassembly of fragmented IPv4 packets."]
    #[doc = " Incoming mbufs should have its l2_len/l3_len fields setup correctly."]
    #[doc = ""]
    #[doc = " @param tbl"]
    #[doc = "   Table where to lookup/add the fragmented packet."]
    #[doc = " @param dr"]
    #[doc = "   Death row to free buffers to"]
    #[doc = " @param mb"]
    #[doc = "   Incoming mbuf with IPv4 fragment."]
    #[doc = " @param tms"]
    #[doc = "   Fragment arrival timestamp."]
    #[doc = " @param ip_hdr"]
    #[doc = "   Pointer to the IPV4 header inside the fragment."]
    #[doc = " @return"]
    #[doc = "   Pointer to mbuf for reassembled packet, or NULL if:"]
    #[doc = "   - an error occurred."]
    #[doc = "   - not all fragments of the packet are collected yet."]
    pub fn rte_ipv4_frag_reassemble_packet(
        tbl: *mut rte_ip_frag_tbl,
        dr: *mut rte_ip_frag_death_row,
        mb: *mut rte_mbuf,
        tms: u64,
        ip_hdr: *const rte_ipv4_hdr,
    ) -> *mut rte_mbuf;
}
extern "C" {
    #[doc = " Free mbufs on a given death row."]
    #[doc = ""]
    #[doc = " @param dr"]
    #[doc = "   Death row to free mbufs in."]
    #[doc = " @param prefetch"]
    #[doc = "   How many buffers to prefetch before freeing."]
    pub fn rte_ip_frag_free_death_row(dr: *mut rte_ip_frag_death_row, prefetch: u32);
}
extern "C" {
    #[doc = " Dump fragmentation table statistics to file."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   File to dump statistics to"]
    #[doc = " @param tbl"]
    #[doc = "   Fragmentation table to dump statistics from"]
    pub fn rte_ip_frag_table_statistics_dump(f: *mut FILE, tbl: *const rte_ip_frag_tbl);
}
extern "C" {
    #[doc = " Delete expired fragments"]
    #[doc = ""]
    #[doc = " @param tbl"]
    #[doc = "   Table to delete expired fragments from"]
    #[doc = " @param dr"]
    #[doc = "   Death row to free buffers to"]
    #[doc = " @param tms"]
    #[doc = "   Current timestamp"]
    pub fn rte_ip_frag_table_del_expired_entries(
        tbl: *mut rte_ip_frag_tbl,
        dr: *mut rte_ip_frag_death_row,
        tms: u64,
    );
}
#[doc = " This function should calculate new period and set it using"]
#[doc = " rte_jobstats_set_period() function. Time spent in this function will be"]
#[doc = " added to job's runtime."]
#[doc = ""]
#[doc = " @param job"]
#[doc = "  The job data structure handler."]
#[doc = " @param job_result"]
#[doc = "  Result of calling job callback."]
pub type rte_job_update_period_cb_t =
    ::std::option::Option<unsafe extern "C" fn(job: *mut rte_jobstats, job_result: i64)>;
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_jobstats {
    pub period: u64,
    pub min_period: u64,
    pub max_period: u64,
    pub target: i64,
    pub update_period_cb: rte_job_update_period_cb_t,
    pub exec_time: u64,
    pub min_exec_time: u64,
    pub max_exec_time: u64,
    pub exec_cnt: u64,
    pub name: [::std::os::raw::c_char; 32usize],
    pub context: *mut rte_jobstats_context,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_jobstats_context {
    #[doc = " Variable holding time at different points:"]
    #[doc = " -# loop start time if loop was started but no job executed yet."]
    #[doc = " -# job start time if job is currently executing."]
    #[doc = " -# job finish time if job finished its execution."]
    #[doc = " -# loop finish time if loop finished its execution."]
    pub state_time: u64,
    pub loop_executed_jobs: u64,
    pub exec_time: u64,
    pub min_exec_time: u64,
    pub max_exec_time: u64,
    #[doc = " Sum of time that is not the execute time (ex: from job finish to next"]
    #[doc = " job start)."]
    #[doc = ""]
    #[doc = " This time might be considered as overhead of library + job scheduling."]
    pub management_time: u64,
    pub min_management_time: u64,
    pub max_management_time: u64,
    pub start_time: u64,
    pub job_exec_cnt: u64,
    pub loop_cnt: u64,
}
extern "C" {
    #[doc = " Initialize given context object with default values."]
    #[doc = ""]
    #[doc = " @param ctx"]
    #[doc = "  Job stats context object to initialize."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  0 on success"]
    #[doc = "  -EINVAL if *ctx* is NULL"]
    pub fn rte_jobstats_context_init(ctx: *mut rte_jobstats_context) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Mark that new set of jobs start executing."]
    #[doc = ""]
    #[doc = " @param ctx"]
    #[doc = "  Job stats context object."]
    pub fn rte_jobstats_context_start(ctx: *mut rte_jobstats_context);
}
extern "C" {
    #[doc = " Mark that there is no more jobs ready to execute in this turn. Calculate"]
    #[doc = " stats for this loop turn."]
    #[doc = ""]
    #[doc = " @param ctx"]
    #[doc = "  Job stats context."]
    pub fn rte_jobstats_context_finish(ctx: *mut rte_jobstats_context);
}
extern "C" {
    #[doc = " Function resets job context statistics."]
    #[doc = ""]
    #[doc = " @param ctx"]
    #[doc = "  Job stats context which statistics will be reset."]
    pub fn rte_jobstats_context_reset(ctx: *mut rte_jobstats_context);
}
extern "C" {
    #[doc = " Initialize given job stats object."]
    #[doc = ""]
    #[doc = " @param job"]
    #[doc = "  Job object."]
    #[doc = " @param name"]
    #[doc = "  Optional job name."]
    #[doc = " @param min_period"]
    #[doc = "  Minimum period that this job can accept."]
    #[doc = " @param max_period"]
    #[doc = "  Maximum period that this job can accept."]
    #[doc = " @param initial_period"]
    #[doc = "  Initial period. It will be checked against *min_period* and *max_period*."]
    #[doc = " @param target"]
    #[doc = "  Target value that this job try to achieve."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  0 on success"]
    #[doc = "  -EINVAL if *job* is NULL"]
    pub fn rte_jobstats_init(
        job: *mut rte_jobstats,
        name: *const ::std::os::raw::c_char,
        min_period: u64,
        max_period: u64,
        initial_period: u64,
        target: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set job desired target value. Difference between target and job value"]
    #[doc = " value must be used to properly adjust job execute period value."]
    #[doc = ""]
    #[doc = " @param job"]
    #[doc = "  The job object."]
    #[doc = " @param target"]
    #[doc = "  New target."]
    pub fn rte_jobstats_set_target(job: *mut rte_jobstats, target: i64);
}
extern "C" {
    #[doc = " Mark that *job* is starting of its execution in context of *ctx* object."]
    #[doc = ""]
    #[doc = " @param ctx"]
    #[doc = "  Job stats context."]
    #[doc = " @param job"]
    #[doc = "  Job object."]
    #[doc = " @return"]
    #[doc = "  0 on success"]
    #[doc = "  -EINVAL if *ctx* or *job* is NULL or *job* is executing in another context"]
    #[doc = "  context already,"]
    pub fn rte_jobstats_start(
        ctx: *mut rte_jobstats_context,
        job: *mut rte_jobstats,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Mark that *job* finished its execution, but time of this work will be skipped"]
    #[doc = " and added to management time."]
    #[doc = ""]
    #[doc = " @param job"]
    #[doc = "  Job object."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  0 on success"]
    #[doc = "  -EINVAL if job is NULL or job was not started (it have no context)."]
    pub fn rte_jobstats_abort(job: *mut rte_jobstats) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Mark that *job* finished its execution. Context in which it was executing"]
    #[doc = " will receive stat update. After this function call *job* object is ready to"]
    #[doc = " be executed in other context."]
    #[doc = ""]
    #[doc = " @param job"]
    #[doc = "  Job object."]
    #[doc = " @param job_value"]
    #[doc = "  Job value. Job should pass in this parameter a value that it try to optimize"]
    #[doc = "  for example the number of packets it processed."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  0 if job's period was not updated (job target equals *job_value*)"]
    #[doc = "  1 if job's period was updated"]
    #[doc = "  -EINVAL if job is NULL or job was not started (it have no context)."]
    pub fn rte_jobstats_finish(job: *mut rte_jobstats, job_value: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set execute period of given job."]
    #[doc = ""]
    #[doc = " @param job"]
    #[doc = "  The job object."]
    #[doc = " @param period"]
    #[doc = "  New period value."]
    #[doc = " @param saturate"]
    #[doc = "  If zero, skip period saturation to min, max range."]
    pub fn rte_jobstats_set_period(job: *mut rte_jobstats, period: u64, saturate: u8);
}
extern "C" {
    #[doc = " Set minimum execute period of given job. Current period will be checked"]
    #[doc = " against new minimum value."]
    #[doc = ""]
    #[doc = " @param job"]
    #[doc = "  The job object."]
    #[doc = " @param period"]
    #[doc = "  New minimum period value."]
    pub fn rte_jobstats_set_min(job: *mut rte_jobstats, period: u64);
}
extern "C" {
    #[doc = " Set maximum execute period of given job. Current period will be checked"]
    #[doc = " against new maximum value."]
    #[doc = ""]
    #[doc = " @param job"]
    #[doc = "  The job object."]
    #[doc = " @param period"]
    #[doc = "  New maximum period value."]
    pub fn rte_jobstats_set_max(job: *mut rte_jobstats, period: u64);
}
extern "C" {
    #[doc = " Set update period callback that is invoked after job finish."]
    #[doc = ""]
    #[doc = " If application wants to do more sophisticated calculations than default"]
    #[doc = " it can provide this handler."]
    #[doc = ""]
    #[doc = " @param job"]
    #[doc = "  Job object."]
    #[doc = " @param update_period_cb"]
    #[doc = "  Callback to set. If NULL restore default update function."]
    pub fn rte_jobstats_set_update_period_function(
        job: *mut rte_jobstats,
        update_period_cb: rte_job_update_period_cb_t,
    );
}
extern "C" {
    #[doc = " Function resets job statistics."]
    #[doc = ""]
    #[doc = " @param job"]
    #[doc = "  Job which statistics will be reset."]
    pub fn rte_jobstats_reset(job: *mut rte_jobstats);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_keepalive_state {
    RTE_KA_STATE_UNUSED = 0,
    RTE_KA_STATE_ALIVE = 1,
    RTE_KA_STATE_MISSING = 4,
    RTE_KA_STATE_DEAD = 2,
    RTE_KA_STATE_GONE = 3,
    RTE_KA_STATE_DOZING = 5,
    RTE_KA_STATE_SLEEP = 6,
}
#[doc = " Keepalive failure callback."]
#[doc = ""]
#[doc = "  Receives a data pointer passed to rte_keepalive_create() and the id of the"]
#[doc = "  failed core."]
#[doc = "  @param data Data pointer passed to rte_keepalive_create()"]
#[doc = "  @param id_core ID of the core that has failed"]
pub type rte_keepalive_failure_callback_t = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, id_core: ::std::os::raw::c_int),
>;
#[doc = " Keepalive relay callback."]
#[doc = ""]
#[doc = "  Receives a data pointer passed to rte_keepalive_register_relay_callback(),"]
#[doc = "  the id of the core for which state is to be forwarded, and details of the"]
#[doc = "  current core state."]
#[doc = "  @param data Data pointer passed to rte_keepalive_register_relay_callback()"]
#[doc = "  @param id_core ID of the core for which state is being reported"]
#[doc = "  @param core_state The current state of the core"]
#[doc = "  @param last_seen Timestamp of when core was last seen alive"]
pub type rte_keepalive_relay_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        id_core: ::std::os::raw::c_int,
        core_state: rte_keepalive_state,
        last_seen: u64,
    ),
>;
#[doc = " Keepalive state structure."]
#[doc = " @internal"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_keepalive {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Initialise keepalive sub-system."]
    #[doc = " @param callback"]
    #[doc = "   Function called upon detection of a dead core."]
    #[doc = " @param data"]
    #[doc = "   Data pointer to be passed to function callback."]
    #[doc = " @return"]
    #[doc = "   Keepalive structure success, NULL on failure."]
    pub fn rte_keepalive_create(
        callback: rte_keepalive_failure_callback_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut rte_keepalive;
}
extern "C" {
    #[doc = " Checks & handles keepalive state of monitored cores."]
    #[doc = " @param *ptr_timer Triggering timer (unused)"]
    #[doc = " @param *ptr_data  Data pointer (keepalive structure)"]
    pub fn rte_keepalive_dispatch_pings(
        ptr_timer: *mut ::std::os::raw::c_void,
        ptr_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Registers a core for keepalive checks."]
    #[doc = " @param *keepcfg"]
    #[doc = "   Keepalive structure pointer"]
    #[doc = " @param id_core"]
    #[doc = "   ID number of core to register."]
    pub fn rte_keepalive_register_core(keepcfg: *mut rte_keepalive, id_core: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Per-core keepalive check."]
    #[doc = " @param *keepcfg"]
    #[doc = "   Keepalive structure pointer"]
    #[doc = ""]
    #[doc = " This function needs to be called from within the main process loop of"]
    #[doc = " the LCore to be checked."]
    pub fn rte_keepalive_mark_alive(keepcfg: *mut rte_keepalive);
}
extern "C" {
    #[doc = " Per-core sleep-time indication."]
    #[doc = " @param *keepcfg"]
    #[doc = "   Keepalive structure pointer"]
    #[doc = ""]
    #[doc = " If CPU idling is enabled, this function needs to be called from within"]
    #[doc = " the main process loop of the LCore going to sleep, in order to avoid"]
    #[doc = " the LCore being mis-detected as dead."]
    pub fn rte_keepalive_mark_sleep(keepcfg: *mut rte_keepalive);
}
extern "C" {
    #[doc = " Registers a 'live core' callback."]
    #[doc = ""]
    #[doc = " The complement of the 'dead core' callback. This is called when a"]
    #[doc = " core is known to be alive, and is intended for cases when an app"]
    #[doc = " needs to know 'liveness' beyond just knowing when a core has died."]
    #[doc = ""]
    #[doc = " @param *keepcfg"]
    #[doc = "   Keepalive structure pointer"]
    #[doc = " @param callback"]
    #[doc = "   Function called upon detection of a dead core."]
    #[doc = " @param data"]
    #[doc = "   Data pointer to be passed to function callback."]
    pub fn rte_keepalive_register_relay_callback(
        keepcfg: *mut rte_keepalive,
        callback: rte_keepalive_relay_callback_t,
        data: *mut ::std::os::raw::c_void,
    );
}
#[doc = " A structure describing an ID for a PCI driver. Each driver provides a"]
#[doc = " table of these IDs for each device that it supports."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pci_id {
    #[doc = "< Class ID or RTE_CLASS_ANY_ID."]
    pub class_id: u32,
    #[doc = "< Vendor ID or RTE_PCI_ANY_ID."]
    pub vendor_id: u16,
    #[doc = "< Device ID or RTE_PCI_ANY_ID."]
    pub device_id: u16,
    #[doc = "< Subsystem vendor ID or RTE_PCI_ANY_ID."]
    pub subsystem_vendor_id: u16,
    #[doc = "< Subsystem device ID or RTE_PCI_ANY_ID."]
    pub subsystem_device_id: u16,
}
#[doc = " A structure describing the location of a PCI device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pci_addr {
    #[doc = "< Device domain"]
    pub domain: u32,
    #[doc = "< Device bus"]
    pub bus: u8,
    #[doc = "< Device ID"]
    pub devid: u8,
    #[doc = "< Device function."]
    pub function: u8,
}
extern "C" {
    #[doc = " Utility function to write a pci device name, this device name can later be"]
    #[doc = " used to retrieve the corresponding rte_pci_addr using eal_parse_pci_*"]
    #[doc = " BDF helpers."]
    #[doc = ""]
    #[doc = " @param addr"]
    #[doc = "\tThe PCI Bus-Device-Function address"]
    #[doc = " @param output"]
    #[doc = "\tThe output buffer string"]
    #[doc = " @param size"]
    #[doc = "\tThe output buffer size"]
    pub fn rte_pci_device_name(
        addr: *const rte_pci_addr,
        output: *mut ::std::os::raw::c_char,
        size: size_t,
    );
}
extern "C" {
    #[doc = " Utility function to compare two PCI device addresses."]
    #[doc = ""]
    #[doc = " @param addr"]
    #[doc = "\tThe PCI Bus-Device-Function address to compare"]
    #[doc = " @param addr2"]
    #[doc = "\tThe PCI Bus-Device-Function address to compare"]
    #[doc = " @return"]
    #[doc = "\t0 on equal PCI address."]
    #[doc = "\tPositive on addr is greater than addr2."]
    #[doc = "\tNegative on addr is less than addr2, or error."]
    pub fn rte_pci_addr_cmp(
        addr: *const rte_pci_addr,
        addr2: *const rte_pci_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Utility function to parse a string into a PCI location."]
    #[doc = ""]
    #[doc = " @param str"]
    #[doc = "\tThe string to parse"]
    #[doc = " @param addr"]
    #[doc = "\tThe reference to the structure where the location"]
    #[doc = "\tis stored."]
    #[doc = " @return"]
    #[doc = "\t0 on success"]
    #[doc = "\t<0 otherwise"]
    pub fn rte_pci_addr_parse(
        str_: *const ::std::os::raw::c_char,
        addr: *mut rte_pci_addr,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_kni_req_id {
    RTE_KNI_REQ_UNKNOWN = 0,
    RTE_KNI_REQ_CHANGE_MTU = 1,
    RTE_KNI_REQ_CFG_NETWORK_IF = 2,
    RTE_KNI_REQ_CHANGE_MAC_ADDR = 3,
    RTE_KNI_REQ_CHANGE_PROMISC = 4,
    RTE_KNI_REQ_CHANGE_ALLMULTI = 5,
    RTE_KNI_REQ_MAX = 6,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_kni_request {
    #[doc = "< Request id"]
    pub req_id: u32,
    pub __bindgen_anon_1: rte_kni_request__bindgen_ty_1,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Result for processing request"]
    pub result: i32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_kni_request__bindgen_ty_1 {
    #[doc = "< New MTU"]
    pub new_mtu: u32,
    #[doc = "< 1: interface up, 0: interface down"]
    pub if_up: u8,
    #[doc = "< MAC address for interface"]
    pub mac_addr: [u8; 6usize],
    #[doc = "< 1: promisc mode enable, 0: disable"]
    pub promiscusity: u8,
    #[doc = "< 1: all-multicast mode enable, 0: disable"]
    pub allmulti: u8,
}
impl rte_kni_request {
    #[inline]
    pub fn async_(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_async(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(async_: i32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let async_: u32 = unsafe { ::std::mem::transmute(async_) };
            async_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rte_kni_fifo {
    #[doc = "< Next position to be written"]
    pub write: ::std::os::raw::c_uint,
    #[doc = "< Next position to be read"]
    pub read: ::std::os::raw::c_uint,
    #[doc = "< Circular buffer length"]
    pub len: ::std::os::raw::c_uint,
    #[doc = "< Pointer size - for 32/64 bit OS"]
    pub elem_size: ::std::os::raw::c_uint,
    #[doc = "< The buffer contains mbuf pointers"]
    pub buffer: __IncompleteArrayField<*mut ::std::os::raw::c_void>,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_kni_mbuf {
    pub buf_addr: *mut ::std::os::raw::c_void,
    pub buf_iova: u64,
    #[doc = "< Start address of data in segment buffer."]
    pub data_off: u16,
    pub pad1: [::std::os::raw::c_char; 2usize],
    #[doc = "< Number of segments."]
    pub nb_segs: u16,
    pub pad4: [::std::os::raw::c_char; 2usize],
    #[doc = "< Offload features."]
    pub ol_flags: u64,
    pub pad2: [::std::os::raw::c_char; 4usize],
    #[doc = "< Total pkt len: sum of all segment data_len."]
    pub pkt_len: u32,
    #[doc = "< Amount of data in segment buffer."]
    pub data_len: u16,
    pub pad3: [::std::os::raw::c_char; 14usize],
    pub pool: *mut ::std::os::raw::c_void,
    #[doc = "< Physical address of next mbuf in kernel."]
    pub next: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_kni_device_info {
    #[doc = "< Network device name for KNI"]
    pub name: [::std::os::raw::c_char; 16usize],
    pub tx_phys: phys_addr_t,
    pub rx_phys: phys_addr_t,
    pub alloc_phys: phys_addr_t,
    pub free_phys: phys_addr_t,
    pub req_phys: phys_addr_t,
    pub resp_phys: phys_addr_t,
    pub sync_phys: phys_addr_t,
    pub sync_va: *mut ::std::os::raw::c_void,
    pub mbuf_va: *mut ::std::os::raw::c_void,
    pub mbuf_phys: phys_addr_t,
    #[doc = "< Group ID"]
    pub group_id: u16,
    #[doc = "< core ID to bind for kernel thread"]
    pub core_id: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub mbuf_size: ::std::os::raw::c_uint,
    pub mtu: ::std::os::raw::c_uint,
    pub min_mtu: ::std::os::raw::c_uint,
    pub max_mtu: ::std::os::raw::c_uint,
    pub mac_addr: [u8; 6usize],
    pub iova_mode: u8,
}
impl rte_kni_device_info {
    #[inline]
    pub fn force_bind(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_bind(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(force_bind: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_bind: u8 = unsafe { ::std::mem::transmute(force_bind) };
            force_bind as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_kni {
    _unused: [u8; 0],
}
#[doc = " Structure which has the function pointers for KNI interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_kni_ops {
    pub port_id: u16,
    pub change_mtu: ::std::option::Option<
        unsafe extern "C" fn(
            port_id: u16,
            new_mtu: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub config_network_if: ::std::option::Option<
        unsafe extern "C" fn(port_id: u16, if_up: u8) -> ::std::os::raw::c_int,
    >,
    pub config_mac_address: ::std::option::Option<
        unsafe extern "C" fn(port_id: u16, mac_addr: *mut u8) -> ::std::os::raw::c_int,
    >,
    pub config_promiscusity: ::std::option::Option<
        unsafe extern "C" fn(port_id: u16, to_on: u8) -> ::std::os::raw::c_int,
    >,
    pub config_allmulticast: ::std::option::Option<
        unsafe extern "C" fn(port_id: u16, to_on: u8) -> ::std::os::raw::c_int,
    >,
}
#[doc = " Structure for configuring KNI device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_kni_conf {
    pub name: [::std::os::raw::c_char; 16usize],
    pub core_id: u32,
    pub group_id: u16,
    pub mbuf_size: ::std::os::raw::c_uint,
    pub addr: rte_pci_addr,
    pub id: rte_pci_id,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub mac_addr: [u8; 6usize],
    pub mtu: u16,
    pub min_mtu: u16,
    pub max_mtu: u16,
}
impl rte_kni_conf {
    #[inline]
    pub fn force_bind(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_bind(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(force_bind: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_bind: u8 = unsafe { ::std::mem::transmute(force_bind) };
            force_bind as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Initialize and preallocate KNI subsystem"]
    #[doc = ""]
    #[doc = " This function is to be executed on the main lcore only, after EAL"]
    #[doc = " initialization and before any KNI interface is attempted to be"]
    #[doc = " allocated"]
    #[doc = ""]
    #[doc = " @param max_kni_ifaces"]
    #[doc = "  The maximum number of KNI interfaces that can coexist concurrently"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 indicates success."]
    #[doc = "  - negative value indicates failure."]
    pub fn rte_kni_init(max_kni_ifaces: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate KNI interface according to the port id, mbuf size, mbuf pool,"]
    #[doc = " configurations and callbacks for kernel requests.The KNI interface created"]
    #[doc = " in the kernel space is the net interface the traditional Linux application"]
    #[doc = " talking to."]
    #[doc = ""]
    #[doc = " The rte_kni_alloc shall not be called before rte_kni_init() has been"]
    #[doc = " called. rte_kni_alloc is thread safe."]
    #[doc = ""]
    #[doc = " The mempool should have capacity of more than \"2 x KNI_FIFO_COUNT_MAX\""]
    #[doc = " elements for each KNI interface allocated."]
    #[doc = ""]
    #[doc = " @param pktmbuf_pool"]
    #[doc = "  The mempool for allocating mbufs for packets."]
    #[doc = " @param conf"]
    #[doc = "  The pointer to the configurations of the KNI device."]
    #[doc = " @param ops"]
    #[doc = "  The pointer to the callbacks for the KNI kernel requests."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - The pointer to the context of a KNI interface."]
    #[doc = "  - NULL indicate error."]
    pub fn rte_kni_alloc(
        pktmbuf_pool: *mut rte_mempool,
        conf: *const rte_kni_conf,
        ops: *mut rte_kni_ops,
    ) -> *mut rte_kni;
}
extern "C" {
    #[doc = " Release KNI interface according to the context. It will also release the"]
    #[doc = " paired KNI interface in kernel space. All processing on the specific KNI"]
    #[doc = " context need to be stopped before calling this interface."]
    #[doc = ""]
    #[doc = " rte_kni_release is thread safe."]
    #[doc = ""]
    #[doc = " @param kni"]
    #[doc = "  The pointer to the context of an existent KNI interface."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 indicates success."]
    #[doc = "  - negative value indicates failure."]
    pub fn rte_kni_release(kni: *mut rte_kni) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It is used to handle the request mbufs sent from kernel space."]
    #[doc = " Then analyzes it and calls the specific actions for the specific requests."]
    #[doc = " Finally constructs the response mbuf and puts it back to the resp_q."]
    #[doc = ""]
    #[doc = " @param kni"]
    #[doc = "  The pointer to the context of an existent KNI interface."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0"]
    #[doc = "  - negative value indicates failure."]
    pub fn rte_kni_handle_request(kni: *mut rte_kni) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve a burst of packets from a KNI interface. The retrieved packets are"]
    #[doc = " stored in rte_mbuf structures whose pointers are supplied in the array of"]
    #[doc = " mbufs, and the maximum number is indicated by num. It handles allocating"]
    #[doc = " the mbufs for KNI interface alloc queue."]
    #[doc = ""]
    #[doc = " @param kni"]
    #[doc = "  The KNI interface context."]
    #[doc = " @param mbufs"]
    #[doc = "  The array to store the pointers of mbufs."]
    #[doc = " @param num"]
    #[doc = "  The maximum number per burst."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  The actual number of packets retrieved."]
    pub fn rte_kni_rx_burst(
        kni: *mut rte_kni,
        mbufs: *mut *mut rte_mbuf,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Send a burst of packets to a KNI interface. The packets to be sent out are"]
    #[doc = " stored in rte_mbuf structures whose pointers are supplied in the array of"]
    #[doc = " mbufs, and the maximum number is indicated by num. It handles the freeing of"]
    #[doc = " the mbufs in the free queue of KNI interface."]
    #[doc = ""]
    #[doc = " @param kni"]
    #[doc = "  The KNI interface context."]
    #[doc = " @param mbufs"]
    #[doc = "  The array to store the pointers of mbufs."]
    #[doc = " @param num"]
    #[doc = "  The maximum number per burst."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  The actual number of packets sent."]
    pub fn rte_kni_tx_burst(
        kni: *mut rte_kni,
        mbufs: *mut *mut rte_mbuf,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the KNI context of its name."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "  pointer to the KNI device name."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  On success: Pointer to KNI interface."]
    #[doc = "  On failure: NULL."]
    pub fn rte_kni_get(name: *const ::std::os::raw::c_char) -> *mut rte_kni;
}
extern "C" {
    #[doc = " Get the name given to a KNI device"]
    #[doc = ""]
    #[doc = " @param kni"]
    #[doc = "   The KNI instance to query"]
    #[doc = " @return"]
    #[doc = "   The pointer to the KNI name"]
    pub fn rte_kni_get_name(kni: *const rte_kni) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Register KNI request handling for a specified port,and it can"]
    #[doc = " be called by primary process or secondary process."]
    #[doc = ""]
    #[doc = " @param kni"]
    #[doc = "  pointer to struct rte_kni."]
    #[doc = " @param ops"]
    #[doc = "  pointer to struct rte_kni_ops."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  On success: 0"]
    #[doc = "  On failure: -1"]
    pub fn rte_kni_register_handlers(
        kni: *mut rte_kni,
        ops: *mut rte_kni_ops,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Unregister KNI request handling for a specified port."]
    #[doc = ""]
    #[doc = "  @param kni"]
    #[doc = "   pointer to struct rte_kni."]
    #[doc = ""]
    #[doc = "  @return"]
    #[doc = "   On success: 0"]
    #[doc = "   On failure: -1"]
    pub fn rte_kni_unregister_handlers(kni: *mut rte_kni) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Update link carrier state for KNI port."]
    #[doc = ""]
    #[doc = " Update the linkup/linkdown state of a KNI interface in the kernel."]
    #[doc = ""]
    #[doc = " @param kni"]
    #[doc = "  pointer to struct rte_kni."]
    #[doc = " @param linkup"]
    #[doc = "  New link state:"]
    #[doc = "  0 for linkdown."]
    #[doc = "  > 0 for linkup."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  On failure: -1"]
    #[doc = "  Previous link state == linkdown: 0"]
    #[doc = "  Previous link state == linkup: 1"]
    pub fn rte_kni_update_link(
        kni: *mut rte_kni,
        linkup: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Close KNI device."]
    pub fn rte_kni_close();
}
#[doc = " Type of callback function used by rte_kvargs_process()"]
pub type arg_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A key/value association"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_kvargs_pair {
    #[doc = "< the name (key) of the association"]
    pub key: *mut ::std::os::raw::c_char,
    #[doc = "< the value associated to that key"]
    pub value: *mut ::std::os::raw::c_char,
}
#[doc = " Store a list of key/value associations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_kvargs {
    #[doc = "< copy of the argument string"]
    pub str_: *mut ::std::os::raw::c_char,
    #[doc = "< number of entries in the list"]
    pub count: ::std::os::raw::c_uint,
    #[doc = "< list of key/values"]
    pub pairs: [rte_kvargs_pair; 32usize],
}
extern "C" {
    #[doc = " Allocate a rte_kvargs and store key/value associations from a string"]
    #[doc = ""]
    #[doc = " The function allocates and fills a rte_kvargs structure from a given"]
    #[doc = " string whose format is key1=value1,key2=value2,..."]
    #[doc = ""]
    #[doc = " The structure can be freed with rte_kvargs_free()."]
    #[doc = ""]
    #[doc = " @param args"]
    #[doc = "   The input string containing the key/value associations"]
    #[doc = " @param valid_keys"]
    #[doc = "   A list of valid keys (table of const char *, the last must be NULL)."]
    #[doc = "   This argument is ignored if NULL"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - A pointer to an allocated rte_kvargs structure on success"]
    #[doc = "   - NULL on error"]
    pub fn rte_kvargs_parse(
        args: *const ::std::os::raw::c_char,
        valid_keys: *const *const ::std::os::raw::c_char,
    ) -> *mut rte_kvargs;
}
extern "C" {
    #[doc = " Allocate a rte_kvargs and store key/value associations from a string."]
    #[doc = " This version will consider any byte from valid_ends as a possible"]
    #[doc = " terminating character, and will not parse beyond any of their occurrence."]
    #[doc = ""]
    #[doc = " The function allocates and fills an rte_kvargs structure from a given"]
    #[doc = " string whose format is key1=value1,key2=value2,..."]
    #[doc = ""]
    #[doc = " The structure can be freed with rte_kvargs_free()."]
    #[doc = ""]
    #[doc = " @param args"]
    #[doc = "   The input string containing the key/value associations"]
    #[doc = ""]
    #[doc = " @param valid_keys"]
    #[doc = "   A list of valid keys (table of const char *, the last must be NULL)."]
    #[doc = "   This argument is ignored if NULL"]
    #[doc = ""]
    #[doc = " @param valid_ends"]
    #[doc = "   Acceptable terminating characters."]
    #[doc = "   If NULL, the behavior is the same as ``rte_kvargs_parse``."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - A pointer to an allocated rte_kvargs structure on success"]
    #[doc = "   - NULL on error"]
    pub fn rte_kvargs_parse_delim(
        args: *const ::std::os::raw::c_char,
        valid_keys: *const *const ::std::os::raw::c_char,
        valid_ends: *const ::std::os::raw::c_char,
    ) -> *mut rte_kvargs;
}
extern "C" {
    #[doc = " Free a rte_kvargs structure"]
    #[doc = ""]
    #[doc = " Free a rte_kvargs structure previously allocated with"]
    #[doc = " rte_kvargs_parse()."]
    #[doc = ""]
    #[doc = " @param kvlist"]
    #[doc = "   The rte_kvargs structure. No error if NULL."]
    pub fn rte_kvargs_free(kvlist: *mut rte_kvargs);
}
extern "C" {
    #[doc = " Get the value associated with a given key."]
    #[doc = ""]
    #[doc = " If multiple keys match, the value of the first one is returned."]
    #[doc = ""]
    #[doc = " The memory returned is allocated as part of the rte_kvargs structure,"]
    #[doc = " it must never be modified."]
    #[doc = ""]
    #[doc = " @param kvlist"]
    #[doc = "   A list of rte_kvargs pair of 'key=value'."]
    #[doc = " @param key"]
    #[doc = "   The matching key."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   NULL if no key matches the input,"]
    #[doc = "   a value associated with a matching key otherwise."]
    pub fn rte_kvargs_get(
        kvlist: *const rte_kvargs,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Get the value associated with a given key and value."]
    #[doc = ""]
    #[doc = " Find the first entry in the kvlist whose key and value match the"]
    #[doc = " ones passed as argument."]
    #[doc = ""]
    #[doc = " The memory returned is allocated as part of the rte_kvargs structure,"]
    #[doc = " it must never be modified."]
    #[doc = ""]
    #[doc = " @param kvlist"]
    #[doc = "   A list of rte_kvargs pair of 'key=value'."]
    #[doc = " @param key"]
    #[doc = "   The matching key. If NULL, any key will match."]
    #[doc = " @param value"]
    #[doc = "   The matching value. If NULL, any value will match."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   NULL if no key matches the input,"]
    #[doc = "   a value associated with a matching key otherwise."]
    pub fn rte_kvargs_get_with_value(
        kvlist: *const rte_kvargs,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Call a handler function for each key/value matching the key"]
    #[doc = ""]
    #[doc = " For each key/value association that matches the given key, calls the"]
    #[doc = " handler function with the for a given arg_name passing the value on the"]
    #[doc = " dictionary for that key and a given extra argument."]
    #[doc = ""]
    #[doc = " @param kvlist"]
    #[doc = "   The rte_kvargs structure. No error if NULL."]
    #[doc = " @param key_match"]
    #[doc = "   The key on which the handler should be called, or NULL to process handler"]
    #[doc = "   on all associations"]
    #[doc = " @param handler"]
    #[doc = "   The function to call for each matching key"]
    #[doc = " @param opaque_arg"]
    #[doc = "   A pointer passed unchanged to the handler"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - Negative on error"]
    pub fn rte_kvargs_process(
        kvlist: *const rte_kvargs,
        key_match: *const ::std::os::raw::c_char,
        handler: arg_handler_t,
        opaque_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Count the number of associations matching the given key"]
    #[doc = ""]
    #[doc = " @param kvlist"]
    #[doc = "   The rte_kvargs structure"]
    #[doc = " @param key_match"]
    #[doc = "   The key that should match, or NULL to count all associations"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The number of entries"]
    pub fn rte_kvargs_count(
        kvlist: *const rte_kvargs,
        key_match: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut metrics_initialized: ::std::os::raw::c_int;
}
#[doc = " A name-key lookup for metrics."]
#[doc = ""]
#[doc = " An array of this structure is returned by rte_metrics_get_names()."]
#[doc = " The struct rte_metric_value references these names via their array index."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_metric_name {
    #[doc = " String describing metric"]
    pub name: [::std::os::raw::c_char; 64usize],
}
#[doc = " Metric value structure."]
#[doc = ""]
#[doc = " This structure is used by rte_metrics_get_values() to return metrics,"]
#[doc = " which are statistics that are not generated by PMDs. It maps a name key,"]
#[doc = " which corresponds to an index in the array returned by"]
#[doc = " rte_metrics_get_names()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_metric_value {
    #[doc = " Numeric identifier of metric."]
    pub key: u16,
    #[doc = " Value for metric"]
    pub value: u64,
}
extern "C" {
    #[doc = " Initializes metric module. This function must be called from"]
    #[doc = " a primary process before metrics are used."]
    #[doc = ""]
    #[doc = " @param socket_id"]
    #[doc = "   Socket to use for shared memory allocation."]
    pub fn rte_metrics_init(socket_id: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Deinitialize metric module. This function must be called from"]
    #[doc = " a primary process after all the metrics usage is over, to"]
    #[doc = "  release the shared memory."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  -EINVAL - invalid parameter."]
    #[doc = "  -EIO: Error, unable to access metrics shared memory"]
    #[doc = "    (rte_metrics_init() not called)"]
    #[doc = "  0 - success"]
    pub fn rte_metrics_deinit() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a metric, making it available as a reporting parameter."]
    #[doc = ""]
    #[doc = " Registering a metric is the way producers declare a parameter"]
    #[doc = " that they wish to be reported. Once registered, the associated"]
    #[doc = " numeric key can be obtained via rte_metrics_get_names(), which"]
    #[doc = " is required for updating said metric's value."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Metric name. If this exceeds RTE_METRICS_MAX_NAME_LEN (including"]
    #[doc = "   the NULL terminator), it is truncated."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - Zero or positive: Success (index key of new metric)"]
    #[doc = "  - -EIO: Error, unable to access metrics shared memory"]
    #[doc = "    (rte_metrics_init() not called)"]
    #[doc = "  - -EINVAL: Error, invalid parameters"]
    #[doc = "  - -ENOMEM: Error, maximum metrics reached"]
    pub fn rte_metrics_reg_name(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a set of metrics."]
    #[doc = ""]
    #[doc = " This is a bulk version of rte_metrics_reg_names() and aside from"]
    #[doc = " handling multiple keys at once is functionally identical."]
    #[doc = ""]
    #[doc = " @param names"]
    #[doc = "   List of metric names"]
    #[doc = ""]
    #[doc = " @param cnt_names"]
    #[doc = "   Number of metrics in set"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - Zero or positive: Success (index key of start of set)"]
    #[doc = "  - -EIO: Error, unable to access metrics shared memory"]
    #[doc = "    (rte_metrics_init() not called)"]
    #[doc = "  - -EINVAL: Error, invalid parameters"]
    #[doc = "  - -ENOMEM: Error, maximum metrics reached"]
    pub fn rte_metrics_reg_names(
        names: *const *const ::std::os::raw::c_char,
        cnt_names: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get metric name-key lookup table."]
    #[doc = ""]
    #[doc = " @param names"]
    #[doc = "   A struct rte_metric_name array of at least *capacity* in size to"]
    #[doc = "   receive key names. If this is NULL, function returns the required"]
    #[doc = "   number of elements for this array."]
    #[doc = ""]
    #[doc = " @param capacity"]
    #[doc = "   Size (number of elements) of struct rte_metric_name array."]
    #[doc = "   Disregarded if names is NULL."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - Positive value above capacity: error, *names* is too small."]
    #[doc = "     Return value is required size."]
    #[doc = "   - Positive value equal or less than capacity: Success. Return"]
    #[doc = "     value is number of elements filled in."]
    #[doc = "   - Negative value: error."]
    pub fn rte_metrics_get_names(
        names: *mut rte_metric_name,
        capacity: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get metric value table."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port id to query"]
    #[doc = ""]
    #[doc = " @param values"]
    #[doc = "   A struct rte_metric_value array of at least *capacity* in size to"]
    #[doc = "   receive metric ids and values. If this is NULL, function returns"]
    #[doc = "   the required number of elements for this array."]
    #[doc = ""]
    #[doc = " @param capacity"]
    #[doc = "   Size (number of elements) of struct rte_metric_value array."]
    #[doc = "   Disregarded if names is NULL."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - Positive value above capacity: error, *values* is too small."]
    #[doc = "     Return value is required size."]
    #[doc = "   - Positive value equal or less than capacity: Success. Return"]
    #[doc = "     value is number of elements filled in."]
    #[doc = "   - Negative value: error."]
    pub fn rte_metrics_get_values(
        port_id: ::std::os::raw::c_int,
        values: *mut rte_metric_value,
        capacity: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Updates a metric"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port to update metrics for"]
    #[doc = " @param key"]
    #[doc = "   Id of metric to update"]
    #[doc = " @param value"]
    #[doc = "   New value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - -EIO if unable to access shared metrics memory"]
    #[doc = "   - Zero on success"]
    pub fn rte_metrics_update_value(
        port_id: ::std::os::raw::c_int,
        key: u16,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Updates a metric set. Note that it is an error to try to"]
    #[doc = " update across a set boundary."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port to update metrics for"]
    #[doc = " @param key"]
    #[doc = "   Base id of metrics set to update"]
    #[doc = " @param values"]
    #[doc = "   Set of new values"]
    #[doc = " @param count"]
    #[doc = "   Number of new values"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - -ERANGE if count exceeds metric set size"]
    #[doc = "   - -EIO if unable to access shared metrics memory"]
    #[doc = "   - Zero on success"]
    pub fn rte_metrics_update_values(
        port_id: ::std::os::raw::c_int,
        key: u16,
        values: *const u64,
        count: u32,
    ) -> ::std::os::raw::c_int;
}
#[doc = "  Note: This function pointer is for future flow based latency stats"]
#[doc = "  implementation."]
#[doc = ""]
#[doc = " Function type used for identifying flow types of a Rx packet."]
#[doc = ""]
#[doc = " The callback function is called on Rx for each packet."]
#[doc = " This function is used for flow based latency calculations."]
#[doc = ""]
#[doc = " @param pkt"]
#[doc = "   Packet that has to be identified with its flow types."]
#[doc = " @param user_param"]
#[doc = "   The arbitrary user parameter passed in by the application when"]
#[doc = "   the callback was originally configured."]
#[doc = " @return"]
#[doc = "   The flow_mask, representing the multiple flow types of a packet."]
pub type rte_latency_stats_flow_type_fn = ::std::option::Option<
    unsafe extern "C" fn(pkt: *mut rte_mbuf, user_param: *mut ::std::os::raw::c_void) -> u16,
>;
extern "C" {
    #[doc = "  Registers Rx/Tx callbacks for each active port, queue."]
    #[doc = ""]
    #[doc = " @param samp_intvl"]
    #[doc = "  Sampling time period in nano seconds, at which packet"]
    #[doc = "  should be marked with time stamp."]
    #[doc = " @param user_cb"]
    #[doc = "  Note: This param is for future flow based latency stats"]
    #[doc = "  implementation."]
    #[doc = "  User callback to be called to get flow types of a packet."]
    #[doc = "  Used for flow based latency calculation."]
    #[doc = "  If the value is NULL, global stats will be calculated,"]
    #[doc = "  else flow based latency stats will be calculated."]
    #[doc = "  For now just pass on the NULL value to this param."]
    #[doc = "  @return"]
    #[doc = "   -1     : On error"]
    #[doc = "   -ENOMEM: On error"]
    #[doc = "    0     : On success"]
    pub fn rte_latencystats_init(
        samp_intvl: u64,
        user_cb: rte_latency_stats_flow_type_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calculates the latency and jitter values internally, exposing the updated"]
    #[doc = " values via *rte_latencystats_get* or the rte_metrics API."]
    #[doc = " @return:"]
    #[doc = "  0      : on Success"]
    #[doc = "  < 0    : Error in updating values."]
    pub fn rte_latencystats_update() -> i32;
}
extern "C" {
    #[doc = "  Removes registered Rx/Tx callbacks for each active port, queue."]
    #[doc = ""]
    #[doc = "  @return"]
    #[doc = "   -1: On error"]
    #[doc = "    0: On success"]
    pub fn rte_latencystats_uninit() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve names of latency statistics"]
    #[doc = ""]
    #[doc = " @param names"]
    #[doc = "  Block of memory to insert names into. Must be at least size in capacity."]
    #[doc = "  If set to NULL, function returns required capacity."]
    #[doc = " @param size"]
    #[doc = "  Capacity of latency stats names (number of names)."]
    #[doc = " @return"]
    #[doc = "   - positive value lower or equal to size: success. The return value"]
    #[doc = "     is the number of entries filled in the stats table."]
    #[doc = "   - positive value higher than size: error, the given statistics table"]
    #[doc = "     is too small. The return value corresponds to the size that should"]
    #[doc = "     be given to succeed. The entries in the table are not valid and"]
    #[doc = "     shall not be used by the caller."]
    pub fn rte_latencystats_get_names(
        names: *mut rte_metric_name,
        size: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve latency statistics."]
    #[doc = ""]
    #[doc = " @param values"]
    #[doc = "   A pointer to a table of structure of type *rte_metric_value*"]
    #[doc = "   to be filled with latency statistics ids and values."]
    #[doc = "   This parameter can be set to NULL if size is 0."]
    #[doc = " @param size"]
    #[doc = "   The size of the stats table, which should be large enough to store"]
    #[doc = "   all the latency stats."]
    #[doc = " @return"]
    #[doc = "   - positive value lower or equal to size: success. The return value"]
    #[doc = "     is the number of entries filled in the stats table."]
    #[doc = "   - positive value higher than size: error, the given statistics table"]
    #[doc = "     is too small. The return value corresponds to the size that should"]
    #[doc = "     be given to succeed. The entries in the table are not valid and"]
    #[doc = "     shall not be used by the caller."]
    #[doc = "   -ENOMEM: On failure."]
    pub fn rte_latencystats_get(values: *mut rte_metric_value, size: u16) -> ::std::os::raw::c_int;
}
#[doc = " LPM structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_lpm6 {
    _unused: [u8; 0],
}
#[doc = " LPM configuration structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_lpm6_config {
    #[doc = "< Max number of rules."]
    pub max_rules: u32,
    #[doc = "< Number of tbl8s to allocate."]
    pub number_tbl8s: u32,
    #[doc = "< This field is currently unused."]
    pub flags: ::std::os::raw::c_int,
}
extern "C" {
    #[doc = " Create an LPM object."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   LPM object name"]
    #[doc = " @param socket_id"]
    #[doc = "   NUMA socket ID for LPM table memory allocation"]
    #[doc = " @param config"]
    #[doc = "   Structure containing the configuration"]
    #[doc = " @return"]
    #[doc = "   Handle to LPM object on success, NULL otherwise with rte_errno set"]
    #[doc = "   to an appropriate values. Possible rte_errno values include:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - EINVAL - invalid parameter passed to function"]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_lpm6_create(
        name: *const ::std::os::raw::c_char,
        socket_id: ::std::os::raw::c_int,
        config: *const rte_lpm6_config,
    ) -> *mut rte_lpm6;
}
extern "C" {
    #[doc = " Find an existing LPM object and return a pointer to it."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Name of the lpm object as passed to rte_lpm6_create()"]
    #[doc = " @return"]
    #[doc = "   Pointer to lpm object or NULL if object not found with rte_errno"]
    #[doc = "   set appropriately. Possible rte_errno values include:"]
    #[doc = "    - ENOENT - required entry not available to return."]
    pub fn rte_lpm6_find_existing(name: *const ::std::os::raw::c_char) -> *mut rte_lpm6;
}
extern "C" {
    #[doc = " Free an LPM object."]
    #[doc = ""]
    #[doc = " @param lpm"]
    #[doc = "   LPM object handle"]
    #[doc = " @return"]
    #[doc = "   None"]
    pub fn rte_lpm6_free(lpm: *mut rte_lpm6);
}
extern "C" {
    #[doc = " Add a rule to the LPM table."]
    #[doc = ""]
    #[doc = " @param lpm"]
    #[doc = "   LPM object handle"]
    #[doc = " @param ip"]
    #[doc = "   IP of the rule to be added to the LPM table"]
    #[doc = " @param depth"]
    #[doc = "   Depth of the rule to be added to the LPM table"]
    #[doc = " @param next_hop"]
    #[doc = "   Next hop of the rule to be added to the LPM table"]
    #[doc = " @return"]
    #[doc = "   0 on success, negative value otherwise"]
    pub fn rte_lpm6_add(
        lpm: *mut rte_lpm6,
        ip: *const u8,
        depth: u8,
        next_hop: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if a rule is present in the LPM table,"]
    #[doc = " and provide its next hop if it is."]
    #[doc = ""]
    #[doc = " @param lpm"]
    #[doc = "   LPM object handle"]
    #[doc = " @param ip"]
    #[doc = "   IP of the rule to be searched"]
    #[doc = " @param depth"]
    #[doc = "   Depth of the rule to searched"]
    #[doc = " @param next_hop"]
    #[doc = "   Next hop of the rule (valid only if it is found)"]
    #[doc = " @return"]
    #[doc = "   1 if the rule exists, 0 if it does not, a negative value on failure"]
    pub fn rte_lpm6_is_rule_present(
        lpm: *mut rte_lpm6,
        ip: *const u8,
        depth: u8,
        next_hop: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete a rule from the LPM table."]
    #[doc = ""]
    #[doc = " @param lpm"]
    #[doc = "   LPM object handle"]
    #[doc = " @param ip"]
    #[doc = "   IP of the rule to be deleted from the LPM table"]
    #[doc = " @param depth"]
    #[doc = "   Depth of the rule to be deleted from the LPM table"]
    #[doc = " @return"]
    #[doc = "   0 on success, negative value otherwise"]
    pub fn rte_lpm6_delete(lpm: *mut rte_lpm6, ip: *const u8, depth: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete a rule from the LPM table."]
    #[doc = ""]
    #[doc = " @param lpm"]
    #[doc = "   LPM object handle"]
    #[doc = " @param ips"]
    #[doc = "   Array of IPs to be deleted from the LPM table"]
    #[doc = " @param depths"]
    #[doc = "   Array of depths of the rules to be deleted from the LPM table"]
    #[doc = " @param n"]
    #[doc = "   Number of rules to be deleted from the LPM table"]
    #[doc = " @return"]
    #[doc = "   0 on success, negative value otherwise."]
    pub fn rte_lpm6_delete_bulk_func(
        lpm: *mut rte_lpm6,
        ips: *mut [u8; 16usize],
        depths: *mut u8,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete all rules from the LPM table."]
    #[doc = ""]
    #[doc = " @param lpm"]
    #[doc = "   LPM object handle"]
    pub fn rte_lpm6_delete_all(lpm: *mut rte_lpm6);
}
extern "C" {
    #[doc = " Lookup an IP into the LPM table."]
    #[doc = ""]
    #[doc = " @param lpm"]
    #[doc = "   LPM object handle"]
    #[doc = " @param ip"]
    #[doc = "   IP to be looked up in the LPM table"]
    #[doc = " @param next_hop"]
    #[doc = "   Next hop of the most specific rule found for IP (valid on lookup hit only)"]
    #[doc = " @return"]
    #[doc = "   -EINVAL for incorrect arguments, -ENOENT on lookup miss, 0 on lookup hit"]
    pub fn rte_lpm6_lookup(
        lpm: *const rte_lpm6,
        ip: *const u8,
        next_hop: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Lookup multiple IP addresses in an LPM table."]
    #[doc = ""]
    #[doc = " @param lpm"]
    #[doc = "   LPM object handle"]
    #[doc = " @param ips"]
    #[doc = "   Array of IPs to be looked up in the LPM table"]
    #[doc = " @param next_hops"]
    #[doc = "   Next hop of the most specific rule found for IP (valid on lookup hit only)."]
    #[doc = "   This is an array of two byte values. The next hop will be stored on"]
    #[doc = "   each position on success; otherwise the position will be set to -1."]
    #[doc = " @param n"]
    #[doc = "   Number of elements in ips (and next_hops) array to lookup."]
    #[doc = "  @return"]
    #[doc = "   -EINVAL for incorrect arguments, otherwise 0"]
    pub fn rte_lpm6_lookup_bulk_func(
        lpm: *const rte_lpm6,
        ips: *mut [u8; 16usize],
        next_hops: *mut i32,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " RCU reclamation modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_lpm_qsbr_mode {
    #[doc = " Create defer queue for reclaim."]
    RTE_LPM_QSBR_MODE_DQ = 0,
    #[doc = " Use blocking mode reclaim. No defer queue created."]
    RTE_LPM_QSBR_MODE_SYNC = 1,
}
#[doc = " @internal Tbl24 entry structure."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_lpm_tbl_entry {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rte_lpm_tbl_entry {
    #[inline]
    pub fn next_hop(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_next_hop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn valid_group(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid_group(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn depth(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_depth(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        next_hop: u32,
        valid: u32,
        valid_group: u32,
        depth: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let next_hop: u32 = unsafe { ::std::mem::transmute(next_hop) };
            next_hop as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let valid: u32 = unsafe { ::std::mem::transmute(valid) };
            valid as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let valid_group: u32 = unsafe { ::std::mem::transmute(valid_group) };
            valid_group as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let depth: u32 = unsafe { ::std::mem::transmute(depth) };
            depth as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " LPM configuration structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_lpm_config {
    #[doc = "< Max number of rules."]
    pub max_rules: u32,
    #[doc = "< Number of tbl8s to allocate."]
    pub number_tbl8s: u32,
    #[doc = "< This field is currently unused."]
    pub flags: ::std::os::raw::c_int,
}
#[doc = " @internal LPM structure."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_lpm {
    pub tbl24: [rte_lpm_tbl_entry; 16777216usize],
    #[doc = "< LPM tbl8 table."]
    pub tbl8: *mut rte_lpm_tbl_entry,
}
#[doc = " LPM RCU QSBR configuration structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_lpm_rcu_config {
    pub v: *mut rte_rcu_qsbr,
    pub mode: rte_lpm_qsbr_mode,
    pub dq_size: u32,
    pub reclaim_thd: u32,
    pub reclaim_max: u32,
}
extern "C" {
    #[doc = " Create an LPM object."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   LPM object name"]
    #[doc = " @param socket_id"]
    #[doc = "   NUMA socket ID for LPM table memory allocation"]
    #[doc = " @param config"]
    #[doc = "   Structure containing the configuration"]
    #[doc = " @return"]
    #[doc = "   Handle to LPM object on success, NULL otherwise with rte_errno set"]
    #[doc = "   to an appropriate values. Possible rte_errno values include:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - EINVAL - invalid parameter passed to function"]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_lpm_create(
        name: *const ::std::os::raw::c_char,
        socket_id: ::std::os::raw::c_int,
        config: *const rte_lpm_config,
    ) -> *mut rte_lpm;
}
extern "C" {
    #[doc = " Find an existing LPM object and return a pointer to it."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Name of the lpm object as passed to rte_lpm_create()"]
    #[doc = " @return"]
    #[doc = "   Pointer to lpm object or NULL if object not found with rte_errno"]
    #[doc = "   set appropriately. Possible rte_errno values include:"]
    #[doc = "    - ENOENT - required entry not available to return."]
    pub fn rte_lpm_find_existing(name: *const ::std::os::raw::c_char) -> *mut rte_lpm;
}
extern "C" {
    #[doc = " Free an LPM object."]
    #[doc = ""]
    #[doc = " @param lpm"]
    #[doc = "   LPM object handle"]
    #[doc = " @return"]
    #[doc = "   None"]
    pub fn rte_lpm_free(lpm: *mut rte_lpm);
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Associate RCU QSBR variable with an LPM object."]
    #[doc = ""]
    #[doc = " @param lpm"]
    #[doc = "   the lpm object to add RCU QSBR"]
    #[doc = " @param cfg"]
    #[doc = "   RCU QSBR configuration"]
    #[doc = " @return"]
    #[doc = "   On success - 0"]
    #[doc = "   On error - 1 with error code set in rte_errno."]
    #[doc = "   Possible rte_errno codes are:"]
    #[doc = "   - EINVAL - invalid pointer"]
    #[doc = "   - EEXIST - already added QSBR"]
    #[doc = "   - ENOMEM - memory allocation failure"]
    pub fn rte_lpm_rcu_qsbr_add(
        lpm: *mut rte_lpm,
        cfg: *mut rte_lpm_rcu_config,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a rule to the LPM table."]
    #[doc = ""]
    #[doc = " @param lpm"]
    #[doc = "   LPM object handle"]
    #[doc = " @param ip"]
    #[doc = "   IP of the rule to be added to the LPM table"]
    #[doc = " @param depth"]
    #[doc = "   Depth of the rule to be added to the LPM table"]
    #[doc = " @param next_hop"]
    #[doc = "   Next hop of the rule to be added to the LPM table"]
    #[doc = " @return"]
    #[doc = "   0 on success, negative value otherwise"]
    pub fn rte_lpm_add(
        lpm: *mut rte_lpm,
        ip: u32,
        depth: u8,
        next_hop: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if a rule is present in the LPM table,"]
    #[doc = " and provide its next hop if it is."]
    #[doc = ""]
    #[doc = " @param lpm"]
    #[doc = "   LPM object handle"]
    #[doc = " @param ip"]
    #[doc = "   IP of the rule to be searched"]
    #[doc = " @param depth"]
    #[doc = "   Depth of the rule to searched"]
    #[doc = " @param next_hop"]
    #[doc = "   Next hop of the rule (valid only if it is found)"]
    #[doc = " @return"]
    #[doc = "   1 if the rule exists, 0 if it does not, a negative value on failure"]
    pub fn rte_lpm_is_rule_present(
        lpm: *mut rte_lpm,
        ip: u32,
        depth: u8,
        next_hop: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete a rule from the LPM table."]
    #[doc = ""]
    #[doc = " @param lpm"]
    #[doc = "   LPM object handle"]
    #[doc = " @param ip"]
    #[doc = "   IP of the rule to be deleted from the LPM table"]
    #[doc = " @param depth"]
    #[doc = "   Depth of the rule to be deleted from the LPM table"]
    #[doc = " @return"]
    #[doc = "   0 on success, negative value otherwise"]
    pub fn rte_lpm_delete(lpm: *mut rte_lpm, ip: u32, depth: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete all rules from the LPM table."]
    #[doc = ""]
    #[doc = " @param lpm"]
    #[doc = "   LPM object handle"]
    pub fn rte_lpm_delete_all(lpm: *mut rte_lpm);
}
#[doc = " The set ID type that stored internally in hash table based set summary."]
pub type member_set_t = u16;
extern "C" {
    pub static mut librte_member_logtype: ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
#[doc = ""]
#[doc = " Define different set summary types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_member_setsum_type {
    #[doc = "< Hash table based set summary."]
    RTE_MEMBER_TYPE_HT = 0,
    #[doc = "< Vector of bloom filters."]
    RTE_MEMBER_TYPE_VBF = 1,
    RTE_MEMBER_NUM_TYPE = 2,
}
#[repr(u32)]
#[doc = " @internal compare function for different arch."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_member_sig_compare_function {
    RTE_MEMBER_COMPARE_SCALAR = 0,
    RTE_MEMBER_COMPARE_AVX2 = 1,
    RTE_MEMBER_COMPARE_NUM = 2,
}
#[doc = " @internal setsummary structure."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_member_setsum {
    pub type_: rte_member_setsum_type,
    pub key_len: u32,
    pub prim_hash_seed: u32,
    pub sec_hash_seed: u32,
    pub bucket_cnt: u32,
    pub bucket_mask: u32,
    pub sig_cmp_fn: rte_member_sig_compare_function,
    pub cache: u8,
    pub num_set: u32,
    pub bits: u32,
    pub bit_mask: u32,
    pub num_hashes: u32,
    pub mul_shift: u32,
    pub div_shift: u32,
    pub table: *mut ::std::os::raw::c_void,
    pub socket_id: u32,
    pub name: [::std::os::raw::c_char; 32usize],
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
#[doc = ""]
#[doc = " Parameter struct used to create set summary"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_member_parameters {
    #[doc = "< Name of the hash."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " User to specify the type of the setsummary from one of"]
    #[doc = " rte_member_setsum_type."]
    #[doc = ""]
    #[doc = " HT based setsummary is implemented like a hash table. User should use"]
    #[doc = " this type when there are many sets."]
    #[doc = ""]
    #[doc = " vBF setsummary is a vector of bloom filters. It is used when number"]
    #[doc = " of sets is not big (less than 32 for current implementation)."]
    pub type_: rte_member_setsum_type,
    #[doc = " is_cache is only used for HT based setsummary."]
    #[doc = ""]
    #[doc = " If it is HT based setsummary, user to specify the subtype or mode"]
    #[doc = " of the setsummary. It could be cache, or non-cache mode."]
    #[doc = " Set is_cache to be 1 if to use as cache mode."]
    #[doc = ""]
    #[doc = " For cache mode, keys can be evicted out of the HT setsummary. Keys"]
    #[doc = " with the same signature and map to the same bucket"]
    #[doc = " will overwrite each other in the setsummary table."]
    #[doc = " This mode is useful for the case that the set-summary only"]
    #[doc = " needs to keep record of the recently inserted keys. Both"]
    #[doc = " false-negative and false-positive could happen."]
    #[doc = ""]
    #[doc = " For non-cache mode, keys cannot be evicted out of the cache. So for"]
    #[doc = " this mode the setsummary will become full eventually. Keys with the"]
    #[doc = " same signature but map to the same bucket will still occupy multiple"]
    #[doc = " entries. This mode does not give false-negative result."]
    pub is_cache: u8,
    #[doc = " For HT setsummary, num_keys equals to the number of entries of the"]
    #[doc = " table. When the number of keys inserted in the HT setsummary"]
    #[doc = " approaches this number, eviction could happen. For cache mode,"]
    #[doc = " keys could be evicted out of the table. For non-cache mode, keys will"]
    #[doc = " be evicted to other buckets like cuckoo hash. The table will also"]
    #[doc = " likely to become full before the number of inserted keys equal to the"]
    #[doc = " total number of entries."]
    #[doc = ""]
    #[doc = " For vBF, num_keys equal to the expected number of keys that will"]
    #[doc = " be inserted into the vBF. The implementation assumes the keys are"]
    #[doc = " evenly distributed to each BF in vBF. This is used to calculate the"]
    #[doc = " number of bits we need for each BF. User does not specify the size of"]
    #[doc = " each BF directly because the optimal size depends on the num_keys"]
    #[doc = " and false positive rate."]
    pub num_keys: u32,
    #[doc = " The length of key is used for hash calculation. Since key is not"]
    #[doc = " stored in set-summary, large key does not require more memory space."]
    pub key_len: u32,
    #[doc = " num_set is only used for vBF, but not used for HT setsummary."]
    #[doc = ""]
    #[doc = " num_set is equal to the number of BFs in vBF. For current"]
    #[doc = " implementation, it only supports 1,2,4,8,16,32 BFs in one vBF set"]
    #[doc = " summary. If other number of sets are needed, for example 5, the user"]
    #[doc = " should allocate the minimum available value that larger than 5,"]
    #[doc = " which is 8."]
    pub num_set: u32,
    #[doc = " false_positive_rate is only used for vBF, but not used for HT"]
    #[doc = " setsummary."]
    #[doc = ""]
    #[doc = " For vBF, false_positive_rate is the user-defined false positive rate"]
    #[doc = " given expected number of inserted keys (num_keys). It is used to"]
    #[doc = " calculate the total number of bits for each BF, and the number of"]
    #[doc = " hash values used during lookup and insertion. For details please"]
    #[doc = " refer to vBF implementation and membership library documentation."]
    #[doc = ""]
    #[doc = " For HT, This parameter is not directly set by users."]
    #[doc = " HT setsummary's false positive rate is in the order of:"]
    #[doc = " false_pos = (1/bucket_count)*(1/2^16), since we use 16-bit signature."]
    #[doc = " This is because two keys needs to map to same bucket and same"]
    #[doc = " signature to have a collision (false positive). bucket_count is equal"]
    #[doc = " to number of entries (num_keys) divided by entry count per bucket"]
    #[doc = " (RTE_MEMBER_BUCKET_ENTRIES). Thus, the false_positive_rate is not"]
    #[doc = " directly set by users for HT mode."]
    pub false_positive_rate: f32,
    #[doc = " We use two seeds to calculate two independent hashes for each key."]
    #[doc = ""]
    #[doc = " For HT type, one hash is used as signature, and the other is used"]
    #[doc = " for bucket location."]
    #[doc = " For vBF type, these two hashes and their combinations are used as"]
    #[doc = " hash locations to index the bit array."]
    pub prim_hash_seed: u32,
    #[doc = " The secondary seed should be a different value from the primary seed."]
    pub sec_hash_seed: u32,
    #[doc = "< NUMA Socket ID for memory."]
    pub socket_id: ::std::os::raw::c_int,
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Find an existing set-summary and return a pointer to it."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Name of the set-summary."]
    #[doc = " @return"]
    #[doc = "   Pointer to the set-summary or NULL if object not found"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - ENOENT - value not available for return"]
    pub fn rte_member_find_existing(name: *const ::std::os::raw::c_char) -> *mut rte_member_setsum;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Create set-summary (SS)."]
    #[doc = ""]
    #[doc = " @param params"]
    #[doc = "   Parameters to initialize the setsummary."]
    #[doc = " @return"]
    #[doc = "   Return the pointer to the setsummary."]
    #[doc = "   Return value is NULL if the creation failed."]
    pub fn rte_member_create(params: *const rte_member_parameters) -> *mut rte_member_setsum;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Lookup key in set-summary (SS)."]
    #[doc = " Single key lookup and return as soon as the first match found"]
    #[doc = ""]
    #[doc = " @param setsum"]
    #[doc = "   Pointer of a setsummary."]
    #[doc = " @param key"]
    #[doc = "   Pointer of the key to be looked up."]
    #[doc = " @param set_id"]
    #[doc = "   Output the set id matches the key."]
    #[doc = " @return"]
    #[doc = "   Return 1 for found a match and 0 for not found a match."]
    pub fn rte_member_lookup(
        setsum: *const rte_member_setsum,
        key: *const ::std::os::raw::c_void,
        set_id: *mut member_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Lookup bulk of keys in set-summary (SS)."]
    #[doc = " Each key lookup returns as soon as the first match found"]
    #[doc = ""]
    #[doc = " @param setsum"]
    #[doc = "   Pointer of a setsummary."]
    #[doc = " @param keys"]
    #[doc = "   Pointer of the bulk of keys to be looked up."]
    #[doc = " @param num_keys"]
    #[doc = "   Number of keys that will be lookup."]
    #[doc = " @param set_ids"]
    #[doc = "   Output set ids for all the keys to this array."]
    #[doc = "   User should preallocate array that can contain all results, which size is"]
    #[doc = "   the num_keys."]
    #[doc = " @return"]
    #[doc = "   The number of keys that found a match."]
    pub fn rte_member_lookup_bulk(
        setsum: *const rte_member_setsum,
        keys: *mut *const ::std::os::raw::c_void,
        num_keys: u32,
        set_ids: *mut member_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Lookup a key in set-summary (SS) for multiple matches."]
    #[doc = " The key lookup will find all matched entries (multiple match)."]
    #[doc = " Note that for cache mode of HT, each key can have at most one match. This is"]
    #[doc = " because keys with same signature that maps to same bucket will overwrite"]
    #[doc = " each other. So multi-match lookup should be used for vBF and non-cache HT."]
    #[doc = ""]
    #[doc = " @param setsum"]
    #[doc = "   Pointer of a set-summary."]
    #[doc = " @param key"]
    #[doc = "   Pointer of the key that to be looked up."]
    #[doc = " @param max_match_per_key"]
    #[doc = "   User specified maximum number of matches for each key. The function returns"]
    #[doc = "   as soon as this number of matches found for the key."]
    #[doc = " @param set_id"]
    #[doc = "   Output set ids for all the matches of the key. User needs to preallocate"]
    #[doc = "   the array that can contain max_match_per_key number of results."]
    #[doc = " @return"]
    #[doc = "   The number of matches that found for the key."]
    #[doc = "   For cache mode HT set-summary, the number should be at most 1."]
    pub fn rte_member_lookup_multi(
        setsum: *const rte_member_setsum,
        key: *const ::std::os::raw::c_void,
        max_match_per_key: u32,
        set_id: *mut member_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Lookup a bulk of keys in set-summary (SS) for multiple matches each key."]
    #[doc = " Each key lookup will find all matched entries (multiple match)."]
    #[doc = " Note that for cache mode HT, each key can have at most one match. So"]
    #[doc = " multi-match function is mainly used for vBF and non-cache mode HT."]
    #[doc = ""]
    #[doc = " @param setsum"]
    #[doc = "   Pointer of a setsummary."]
    #[doc = " @param keys"]
    #[doc = "   Pointer of the keys to be looked up."]
    #[doc = " @param num_keys"]
    #[doc = "   The number of keys that will be lookup."]
    #[doc = " @param max_match_per_key"]
    #[doc = "   The possible maximum number of matches for each key."]
    #[doc = " @param match_count"]
    #[doc = "   Output the number of matches for each key in an array."]
    #[doc = " @param set_ids"]
    #[doc = "   Return set ids for all the matches of all keys. Users pass in a"]
    #[doc = "   preallocated 2D array with first dimension as key index and second"]
    #[doc = "   dimension as match index. For example set_ids[bulk_size][max_match_per_key]"]
    #[doc = " @return"]
    #[doc = "   The number of keys that found one or more matches in the set-summary."]
    pub fn rte_member_lookup_multi_bulk(
        setsum: *const rte_member_setsum,
        keys: *mut *const ::std::os::raw::c_void,
        num_keys: u32,
        max_match_per_key: u32,
        match_count: *mut u32,
        set_ids: *mut member_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Insert key into set-summary (SS)."]
    #[doc = ""]
    #[doc = " @param setsum"]
    #[doc = "   Pointer of a set-summary."]
    #[doc = " @param key"]
    #[doc = "   Pointer of the key to be added."]
    #[doc = " @param set_id"]
    #[doc = "   The set id associated with the key that needs to be added. Different mode"]
    #[doc = "   supports different set_id ranges. 0 cannot be used as set_id since"]
    #[doc = "   RTE_MEMBER_NO_MATCH by default is set as 0."]
    #[doc = "   For HT mode, the set_id has range as [1, 0x7FFF], MSB is reserved."]
    #[doc = "   For vBF mode the set id is limited by the num_set parameter when create"]
    #[doc = "   the set-summary."]
    #[doc = " @return"]
    #[doc = "   HT (cache mode) and vBF should never fail unless the set_id is not in the"]
    #[doc = "   valid range. In such case -EINVAL is returned."]
    #[doc = "   For HT (non-cache mode) it could fail with -ENOSPC error code when table is"]
    #[doc = "   full."]
    #[doc = "   For success it returns different values for different modes to provide"]
    #[doc = "   extra information for users."]
    #[doc = "   Return 0 for HT (cache mode) if the add does not cause"]
    #[doc = "   eviction, return 1 otherwise. Return 0 for non-cache mode if success,"]
    #[doc = "   -ENOSPC for full, and 1 if cuckoo eviction happens."]
    #[doc = "   Always returns 0 for vBF mode."]
    pub fn rte_member_add(
        setsum: *const rte_member_setsum,
        key: *const ::std::os::raw::c_void,
        set_id: member_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " De-allocate memory used by set-summary."]
    #[doc = ""]
    #[doc = " @param setsum"]
    #[doc = "   Pointer to the set summary."]
    pub fn rte_member_free(setsum: *mut rte_member_setsum);
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Reset the set-summary tables. E.g. reset bits to be 0 in BF,"]
    #[doc = " reset set_id in each entry to be RTE_MEMBER_NO_MATCH in HT based SS."]
    #[doc = ""]
    #[doc = " @param setsum"]
    #[doc = "   Pointer to the set-summary."]
    pub fn rte_member_reset(setsum: *const rte_member_setsum);
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Delete items from the set-summary. Note that vBF does not support deletion"]
    #[doc = " in current implementation. For vBF, error code of -EINVAL will be returned."]
    #[doc = ""]
    #[doc = " @param setsum"]
    #[doc = "   Pointer to the set-summary."]
    #[doc = " @param key"]
    #[doc = "   Pointer of the key to be deleted."]
    #[doc = " @param set_id"]
    #[doc = "   For HT mode, we need both key and its corresponding set_id to"]
    #[doc = "   properly delete the key. Without set_id, we may delete other keys with the"]
    #[doc = "   same signature."]
    #[doc = " @return"]
    #[doc = "   If no entry found to delete, an error code of -ENOENT could be returned."]
    pub fn rte_member_delete(
        setsum: *const rte_member_setsum,
        key: *const ::std::os::raw::c_void,
        set_id: member_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __rte_mempool_trace_create: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_create_empty: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_free: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_populate_iova: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_populate_virt: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_populate_default: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_populate_anon: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_cache_create: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_cache_free: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_get_page_size: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_ops_populate: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_ops_alloc: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_ops_free: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_set_ops_byname: rte_trace_point_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_telemetry_stats_type {
    PORT_STATS = 0,
    GLOBAL_STATS = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct telemetry_encode_param {
    pub type_: rte_telemetry_stats_type,
    pub pp: telemetry_encode_param_port_param,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct telemetry_encode_param_port_param {
    pub num_metric_ids: ::std::os::raw::c_int,
    pub metric_ids: [u32; 256usize],
    pub num_port_ids: ::std::os::raw::c_int,
    pub port_ids: [u32; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct telemetry_metrics_data {
    pub reg_index: [::std::os::raw::c_int; 32usize],
    pub metrics_register_done: ::std::os::raw::c_int,
}
extern "C" {
    pub fn rte_metrics_tel_reg_all_ethdev(
        metrics_register_done: *mut ::std::os::raw::c_int,
        reg_index_list: *mut ::std::os::raw::c_int,
    ) -> i32;
}
extern "C" {
    pub fn rte_metrics_tel_encode_json_format(
        ep: *mut telemetry_encode_param,
        json_buffer: *mut *mut ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    pub fn rte_metrics_tel_get_global_stats(ep: *mut telemetry_encode_param) -> i32;
}
extern "C" {
    pub fn rte_metrics_tel_get_port_stats_ids(ep: *mut telemetry_encode_param) -> i32;
}
extern "C" {
    pub fn rte_metrics_tel_get_ports_stats_json(
        ep: *mut telemetry_encode_param,
        reg_index: *mut ::std::os::raw::c_int,
        json_buffer: *mut *mut ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    pub fn rte_metrics_tel_extract_data(
        ep: *mut telemetry_encode_param,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> i32;
}
#[doc = " MPLS header."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mpls_hdr {
    #[doc = "< Label(msb)."]
    pub tag_msb: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Time to live."]
    pub ttl: u8,
}
impl rte_mpls_hdr {
    #[inline]
    pub fn bs(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bs(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tc(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_tc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn tag_lsb(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tag_lsb(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(bs: u8, tc: u8, tag_lsb: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bs: u8 = unsafe { ::std::mem::transmute(bs) };
            bs as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let tc: u8 = unsafe { ::std::mem::transmute(tc) };
            tc as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let tag_lsb: u8 = unsafe { ::std::mem::transmute(tag_lsb) };
            tag_lsb as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @internal"]
#[doc = " Structure used to hold information about the callbacks to be called for a"]
#[doc = " queue on Rx and Tx."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rxtx_callback {
    pub next: *mut rte_eth_rxtx_callback,
    pub fn_: rte_eth_rxtx_callback__bindgen_ty_1,
    pub param: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_rxtx_callback__bindgen_ty_1 {
    pub rx: rte_rx_callback_fn,
    pub tx: rte_tx_callback_fn,
}
#[doc = " @internal"]
#[doc = " The generic data structure associated with each Ethernet device."]
#[doc = ""]
#[doc = " Pointers to burst-oriented packet receive and transmit functions are"]
#[doc = " located at the beginning of the structure, along with the pointer to"]
#[doc = " where all the data elements for the particular device are stored in shared"]
#[doc = " memory. This split allows the function pointer and driver data to be per-"]
#[doc = " process, while the actual configuration data for the device is shared."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev {
    #[doc = "< Pointer to PMD receive function"]
    pub rx_pkt_burst: eth_rx_burst_t,
    #[doc = "< Pointer to PMD transmit function"]
    pub tx_pkt_burst: eth_tx_burst_t,
    #[doc = " Pointer to PMD transmit prepare function"]
    pub tx_pkt_prepare: eth_tx_prep_t,
    #[doc = " Get the number of used Rx descriptors"]
    pub rx_queue_count: eth_rx_queue_count_t,
    #[doc = " Check the status of a Rx descriptor"]
    pub rx_descriptor_status: eth_rx_descriptor_status_t,
    #[doc = " Check the status of a Tx descriptor"]
    pub tx_descriptor_status: eth_tx_descriptor_status_t,
    #[doc = " Device data that is shared between primary and secondary processes"]
    pub data: *mut rte_eth_dev_data,
    #[doc = "< Pointer to per-process device data"]
    pub process_private: *mut ::std::os::raw::c_void,
    #[doc = "< Functions exported by PMD"]
    pub dev_ops: *const eth_dev_ops,
    #[doc = "< Backing device"]
    pub device: *mut rte_device,
    #[doc = "< Device interrupt handle"]
    pub intr_handle: *mut rte_intr_handle,
    #[doc = " User application callbacks for NIC interrupts"]
    pub link_intr_cbs: rte_eth_dev_cb_list,
    #[doc = " User-supplied functions called from rx_burst to post-process"]
    #[doc = " received packets before passing them to the user"]
    pub post_rx_burst_cbs: [*mut rte_eth_rxtx_callback; 1024usize],
    #[doc = " User-supplied functions called from tx_burst to pre-process"]
    #[doc = " received packets before passing them to the driver for transmission"]
    pub pre_tx_burst_cbs: [*mut rte_eth_rxtx_callback; 1024usize],
    #[doc = "< Flag indicating the port state"]
    pub state: rte_eth_dev_state,
    #[doc = "< Context for security ops"]
    pub security_ctx: *mut ::std::os::raw::c_void,
}
#[doc = " @internal"]
#[doc = " The data part, with no function pointers, associated with each Ethernet"]
#[doc = " device. This structure is safe to place in shared memory to be common"]
#[doc = " among different processes in a multi-process configuration."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_data {
    #[doc = "< Unique identifier name"]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< Array of pointers to Rx queues"]
    pub rx_queues: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Array of pointers to Tx queues"]
    pub tx_queues: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Number of Rx queues"]
    pub nb_rx_queues: u16,
    #[doc = "< Number of Tx queues"]
    pub nb_tx_queues: u16,
    #[doc = "< SRIOV data"]
    pub sriov: rte_eth_dev_sriov,
    #[doc = " PMD-specific private data. @see rte_eth_dev_release_port()"]
    pub dev_private: *mut ::std::os::raw::c_void,
    #[doc = "< Link-level information & status"]
    pub dev_link: rte_eth_link,
    #[doc = "< Configuration applied to device"]
    pub dev_conf: rte_eth_conf,
    #[doc = "< Maximum Transmission Unit"]
    pub mtu: u16,
    #[doc = " Common Rx buffer size handled by all queues"]
    pub min_rx_buf_size: u32,
    #[doc = "< Rx ring mbuf allocation failures"]
    pub rx_mbuf_alloc_failed: u64,
    #[doc = " Device Ethernet link address. @see rte_eth_dev_release_port()"]
    pub mac_addrs: *mut rte_ether_addr,
    #[doc = " Bitmap associating MAC addresses to pools"]
    pub mac_pool_sel: [u64; 128usize],
    #[doc = " Device Ethernet MAC addresses of hash filtering."]
    #[doc = " @see rte_eth_dev_release_port()"]
    pub hash_mac_addrs: *mut rte_ether_addr,
    #[doc = "< Device [external] port identifier"]
    pub port_id: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " Queues state: HAIRPIN(2) / STARTED(1) / STOPPED(0)"]
    pub rx_queue_state: [u8; 1024usize],
    #[doc = " Queues state: HAIRPIN(2) / STARTED(1) / STOPPED(0)"]
    pub tx_queue_state: [u8; 1024usize],
    #[doc = "< Capabilities"]
    pub dev_flags: u32,
    #[doc = "< NUMA node connection"]
    pub numa_node: ::std::os::raw::c_int,
    #[doc = " VLAN filter configuration"]
    pub vlan_filter_conf: rte_vlan_filter_conf,
    #[doc = "< The port owner"]
    pub owner: rte_eth_dev_owner,
    #[doc = " Switch-specific identifier."]
    #[doc = " Valid if RTE_ETH_DEV_REPRESENTOR in dev_flags."]
    pub representor_id: u16,
    #[doc = " Port ID of the backing device."]
    #[doc = " This device will be used to query representor info and calculate"]
    #[doc = " representor IDs. Valid if RTE_ETH_DEV_REPRESENTOR in dev_flags."]
    pub backer_port_id: u16,
    #[doc = "< rte_flow ops mutex"]
    pub flow_ops_mutex: pthread_mutex_t,
}
impl rte_eth_dev_data {
    #[inline]
    pub fn promiscuous(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_promiscuous(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scattered_rx(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scattered_rx(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn all_multicast(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_all_multicast(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dev_started(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dev_started(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lro(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lro(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dev_configured(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dev_configured(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flow_configured(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flow_configured(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        promiscuous: u8,
        scattered_rx: u8,
        all_multicast: u8,
        dev_started: u8,
        lro: u8,
        dev_configured: u8,
        flow_configured: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let promiscuous: u8 = unsafe { ::std::mem::transmute(promiscuous) };
            promiscuous as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let scattered_rx: u8 = unsafe { ::std::mem::transmute(scattered_rx) };
            scattered_rx as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let all_multicast: u8 = unsafe { ::std::mem::transmute(all_multicast) };
            all_multicast as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dev_started: u8 = unsafe { ::std::mem::transmute(dev_started) };
            dev_started as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let lro: u8 = unsafe { ::std::mem::transmute(lro) };
            lro as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dev_configured: u8 = unsafe { ::std::mem::transmute(dev_configured) };
            dev_configured as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let flow_configured: u8 = unsafe { ::std::mem::transmute(flow_configured) };
            flow_configured as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " The pool of *rte_eth_dev* structures. The size of the pool"]
    #[doc = " is configured at compile-time in the <rte_ethdev.c> file."]
    pub static mut rte_eth_devices: [rte_eth_dev; 0usize];
}
#[doc = " @internal Declaration of the hairpin peer queue information structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_hairpin_peer_info {
    _unused: [u8; 0],
}
#[doc = " @internal Ethernet device configuration."]
pub type eth_dev_configure_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to start a configured Ethernet device."]
pub type eth_dev_start_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to stop a configured Ethernet device."]
pub type eth_dev_stop_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to link up a configured Ethernet device."]
pub type eth_dev_set_link_up_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to link down a configured Ethernet device."]
pub type eth_dev_set_link_down_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to close a configured Ethernet device."]
pub type eth_dev_close_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to reset a configured Ethernet device."]
pub type eth_dev_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to detect an Ethernet device removal."]
pub type eth_is_removed_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal"]
#[doc = " Function used to enable the Rx promiscuous mode of an Ethernet device."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   ethdev handle of port."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Negative errno value on error, 0 on success."]
#[doc = ""]
#[doc = " @retval 0"]
#[doc = "   Success, promiscuous mode is enabled."]
#[doc = " @retval -ENOTSUP"]
#[doc = "   Promiscuous mode is not supported."]
#[doc = " @retval -ENODEV"]
#[doc = "   Device is gone."]
#[doc = " @retval -E_RTE_SECONDARY"]
#[doc = "   Function was called from a secondary process instance and not supported."]
#[doc = " @retval -ETIMEDOUT"]
#[doc = "   Attempt to enable promiscuous mode failed because of timeout."]
#[doc = " @retval -EAGAIN"]
#[doc = "   Failed to enable promiscuous mode."]
pub type eth_promiscuous_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal"]
#[doc = " Function used to disable the Rx promiscuous mode of an Ethernet device."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   ethdev handle of port."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Negative errno value on error, 0 on success."]
#[doc = ""]
#[doc = " @retval 0"]
#[doc = "   Success, promiscuous mode is disabled."]
#[doc = " @retval -ENOTSUP"]
#[doc = "   Promiscuous mode disabling is not supported."]
#[doc = " @retval -ENODEV"]
#[doc = "   Device is gone."]
#[doc = " @retval -E_RTE_SECONDARY"]
#[doc = "   Function was called from a secondary process instance and not supported."]
#[doc = " @retval -ETIMEDOUT"]
#[doc = "   Attempt to disable promiscuous mode failed because of timeout."]
#[doc = " @retval -EAGAIN"]
#[doc = "   Failed to disable promiscuous mode."]
pub type eth_promiscuous_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal"]
#[doc = " Enable the receipt of all multicast packets by an Ethernet device."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   ethdev handle of port."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Negative errno value on error, 0 on success."]
#[doc = ""]
#[doc = " @retval 0"]
#[doc = "   Success, all-multicast mode is enabled."]
#[doc = " @retval -ENOTSUP"]
#[doc = "   All-multicast mode is not supported."]
#[doc = " @retval -ENODEV"]
#[doc = "   Device is gone."]
#[doc = " @retval -E_RTE_SECONDARY"]
#[doc = "   Function was called from a secondary process instance and not supported."]
#[doc = " @retval -ETIMEDOUT"]
#[doc = "   Attempt to enable all-multicast mode failed because of timeout."]
#[doc = " @retval -EAGAIN"]
#[doc = "   Failed to enable all-multicast mode."]
pub type eth_allmulticast_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal"]
#[doc = " Disable the receipt of all multicast packets by an Ethernet device."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   ethdev handle of port."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Negative errno value on error, 0 on success."]
#[doc = ""]
#[doc = " @retval 0"]
#[doc = "   Success, all-multicast mode is disabled."]
#[doc = " @retval -ENOTSUP"]
#[doc = "   All-multicast mode disabling is not supported."]
#[doc = " @retval -ENODEV"]
#[doc = "   Device is gone."]
#[doc = " @retval -E_RTE_SECONDARY"]
#[doc = "   Function was called from a secondary process instance and not supported."]
#[doc = " @retval -ETIMEDOUT"]
#[doc = "   Attempt to disable all-multicast mode failed because of timeout."]
#[doc = " @retval -EAGAIN"]
#[doc = "   Failed to disable all-multicast mode."]
pub type eth_allmulticast_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal"]
#[doc = " Get link speed, duplex mode and state (up/down) of an Ethernet device."]
pub type eth_link_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        wait_to_complete: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get global I/O statistics of an Ethernet device."]
pub type eth_stats_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        igb_stats: *mut rte_eth_stats,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Reset global I/O statistics of an Ethernet device to 0."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   ethdev handle of port."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Negative errno value on error, 0 on success."]
#[doc = ""]
#[doc = " @retval 0"]
#[doc = "   Success, statistics has been reset."]
#[doc = " @retval -ENOTSUP"]
#[doc = "   Resetting statistics is not supported."]
#[doc = " @retval -EINVAL"]
#[doc = "   Resetting statistics is not valid."]
#[doc = " @retval -ENOMEM"]
#[doc = "   Not enough memory to get the stats."]
pub type eth_stats_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Get extended stats of an Ethernet device."]
pub type eth_xstats_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        stats: *mut rte_eth_xstat,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Get extended stats of an Ethernet device."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   ethdev handle of port."]
#[doc = " @param ids"]
#[doc = "   IDs array to retrieve specific statistics. Must not be NULL."]
#[doc = " @param values"]
#[doc = "   A pointer to a table to be filled with device statistics values."]
#[doc = "   Must not be NULL."]
#[doc = " @param n"]
#[doc = "   Element count in @p ids and @p values."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   - A number of filled in stats."]
#[doc = "   - A negative value on error."]
pub type eth_xstats_get_by_id_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ids: *const u64,
        values: *mut u64,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Reset extended stats of an Ethernet device."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   ethdev handle of port."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Negative errno value on error, 0 on success."]
#[doc = ""]
#[doc = " @retval 0"]
#[doc = "   Success, statistics has been reset."]
#[doc = " @retval -ENOTSUP"]
#[doc = "   Resetting statistics is not supported."]
#[doc = " @retval -EINVAL"]
#[doc = "   Resetting statistics is not valid."]
#[doc = " @retval -ENOMEM"]
#[doc = "   Not enough memory to get the stats."]
pub type eth_xstats_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Get names of extended stats of an Ethernet device."]
pub type eth_xstats_get_names_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Get names of extended stats of an Ethernet device."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   ethdev handle of port."]
#[doc = " @param ids"]
#[doc = "   IDs array to retrieve specific statistics. Must not be NULL."]
#[doc = " @param xstats_names"]
#[doc = "   An rte_eth_xstat_name array of at least @p size elements to be filled."]
#[doc = "   Must not be NULL."]
#[doc = " @param size"]
#[doc = "   Element count in @p ids and @p xstats_names."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   - A number of filled in stats."]
#[doc = "   - A negative value on error."]
pub type eth_xstats_get_names_by_id_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ids: *const u64,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Set a queue statistics mapping for a Tx/Rx queue of an Ethernet device."]
pub type eth_queue_stats_mapping_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        queue_id: u16,
        stat_idx: u8,
        is_rx: u8,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get specific information of an Ethernet device."]
pub type eth_dev_infos_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        dev_info: *mut rte_eth_dev_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get supported ptypes of an Ethernet device."]
pub type eth_dev_supported_ptypes_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> *const u32>;
#[doc = " @internal"]
#[doc = " Inform Ethernet device about reduced range of packet types to handle."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   The Ethernet device identifier."]
#[doc = " @param ptype_mask"]
#[doc = "   The ptype family that application is interested in should be bitwise OR of"]
#[doc = "   RTE_PTYPE_*_MASK or 0."]
#[doc = " @return"]
#[doc = "   - (0) if Success."]
pub type eth_dev_ptypes_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, ptype_mask: u32) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Start Rx and Tx of a queue of an Ethernet device."]
pub type eth_queue_start_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, queue_id: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Stop Rx and Tx of a queue of an Ethernet device."]
pub type eth_queue_stop_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, queue_id: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set up a receive queue of an Ethernet device."]
pub type eth_rx_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        rx_conf: *const rte_eth_rxconf,
        mb_pool: *mut rte_mempool,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Setup a transmit queue of an Ethernet device."]
pub type eth_tx_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        tx_conf: *const rte_eth_txconf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Enable interrupt of a receive queue of an Ethernet device."]
pub type eth_rx_enable_intr_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Disable interrupt of a receive queue of an Ethernet device."]
pub type eth_rx_disable_intr_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Release memory resources allocated by given Rx/Tx queue."]
pub type eth_queue_release_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, queue_id: u16)>;
#[doc = " @internal Get firmware information of an Ethernet device."]
pub type eth_fw_version_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        fw_version: *mut ::std::os::raw::c_char,
        fw_size: size_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Force mbufs to be from Tx ring."]
pub type eth_tx_done_cleanup_t = ::std::option::Option<
    unsafe extern "C" fn(txq: *mut ::std::os::raw::c_void, free_cnt: u32) -> ::std::os::raw::c_int,
>;
pub type eth_rxq_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16, qinfo: *mut rte_eth_rxq_info),
>;
pub type eth_txq_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, tx_queue_id: u16, qinfo: *mut rte_eth_txq_info),
>;
pub type eth_burst_mode_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        queue_id: u16,
        mode: *mut rte_eth_burst_mode,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set MTU."]
pub type mtu_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, mtu: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Filtering of a VLAN Tag Identifier by an Ethernet device."]
pub type vlan_filter_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        vlan_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set the outer/inner VLAN-TPID by an Ethernet device."]
pub type vlan_tpid_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        type_: rte_vlan_type,
        tpid: u16,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set VLAN offload function by an Ethernet device."]
pub type vlan_offload_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set port based Tx VLAN insertion by an Ethernet device."]
pub type vlan_pvid_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        vlan_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal VLAN stripping enable/disable by an queue of Ethernet device."]
pub type vlan_strip_queue_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16, on: ::std::os::raw::c_int),
>;
#[doc = " @internal Get current flow control parameter on an Ethernet device."]
pub type flow_ctrl_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Setup flow control parameter on an Ethernet device."]
pub type flow_ctrl_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Setup priority flow control parameter on an Ethernet device."]
pub type priority_flow_ctrl_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        pfc_conf: *mut rte_eth_pfc_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get info for queue based PFC on an Ethernet device."]
pub type priority_flow_ctrl_queue_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        pfc_queue_info: *mut rte_eth_pfc_queue_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Configure queue based PFC parameter on an Ethernet device."]
pub type priority_flow_ctrl_queue_config_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        pfc_queue_conf: *mut rte_eth_pfc_queue_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Update RSS redirection table on an Ethernet device."]
pub type reta_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Query RSS redirection table on an Ethernet device."]
pub type reta_query_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Update RSS hash configuration of an Ethernet device."]
pub type rss_hash_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get current RSS hash configuration of an Ethernet device."]
pub type rss_hash_conf_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Turn on SW controllable LED on an Ethernet device."]
pub type eth_dev_led_on_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Turn off SW controllable LED on an Ethernet device."]
pub type eth_dev_led_off_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Remove MAC address from receive address register."]
pub type eth_mac_addr_remove_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, index: u32)>;
#[doc = " @internal Set a MAC address into Receive Address Register."]
pub type eth_mac_addr_add_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mac_addr: *mut rte_ether_addr,
        index: u32,
        vmdq: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set a MAC address into Receive Address Register."]
pub type eth_mac_addr_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mac_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set a Unicast Hash bitmap."]
pub type eth_uc_hash_table_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mac_addr: *mut rte_ether_addr,
        on: u8,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set all Unicast Hash bitmap."]
pub type eth_uc_all_hash_table_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, on: u8) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set queue Tx rate."]
pub type eth_set_queue_rate_limit_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        queue_idx: u16,
        tx_rate: u16,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Add tunneling UDP port."]
pub type eth_udp_tunnel_port_add_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Delete tunneling UDP port."]
pub type eth_udp_tunnel_port_del_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal set the list of multicast addresses on an Ethernet device."]
pub type eth_set_mc_addr_list_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mc_addr_set: *mut rte_ether_addr,
        nb_mc_addr: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function used to enable IEEE1588/802.1AS timestamping."]
pub type eth_timesync_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to disable IEEE1588/802.1AS timestamping."]
pub type eth_timesync_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to read an Rx IEEE1588/802.1AS timestamp."]
pub type eth_timesync_read_rx_timestamp_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        timestamp: *mut timespec,
        flags: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function used to read a Tx IEEE1588/802.1AS timestamp."]
pub type eth_timesync_read_tx_timestamp_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, timestamp: *mut timespec) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function used to adjust the device clock."]
pub type eth_timesync_adjust_time = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, arg1: i64) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function used to get time from the device clock."]
pub type eth_timesync_read_time = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, timestamp: *mut timespec) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function used to get time from the device clock."]
pub type eth_timesync_write_time = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        timestamp: *const timespec,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function used to get the current value of the device clock."]
pub type eth_read_clock = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, timestamp: *mut u64) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Retrieve registers."]
pub type eth_get_reg_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_reg_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Retrieve EEPROM size."]
pub type eth_get_eeprom_length_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Retrieve EEPROM data."]
pub type eth_get_eeprom_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Program EEPROM data."]
pub type eth_set_eeprom_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Retrieve type and size of plugin module EEPROM."]
pub type eth_get_module_info_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        modinfo: *mut rte_eth_dev_module_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Retrieve plugin module EEPROM data."]
pub type eth_get_module_eeprom_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_ops {
    _unused: [u8; 0],
}
#[doc = " @internal"]
#[doc = " Get flow operations."]
#[doc = ""]
#[doc = " If the flow API is not supported for the specified device,"]
#[doc = " the driver can return NULL."]
pub type eth_flow_ops_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ops: *mut *const rte_flow_ops,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get Traffic Management (TM) operations on an Ethernet device."]
pub type eth_tm_ops_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ops: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get Traffic Metering and Policing (MTR) operations."]
pub type eth_mtr_ops_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ops: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get DCB information on an Ethernet device."]
pub type eth_get_dcb_info = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        dcb_info: *mut rte_eth_dcb_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Test if a port supports specific mempool ops."]
pub type eth_pool_ops_supported_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        pool: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Get the hairpin capabilities."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   ethdev handle of port."]
#[doc = " @param cap"]
#[doc = "   returns the hairpin capabilities from the device."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Negative errno value on error, 0 on success."]
#[doc = ""]
#[doc = " @retval 0"]
#[doc = "   Success, hairpin is supported."]
#[doc = " @retval -ENOTSUP"]
#[doc = "   Hairpin is not supported."]
pub type eth_hairpin_cap_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        cap: *mut rte_eth_hairpin_cap,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Setup Rx hairpin queue."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   ethdev handle of port."]
#[doc = " @param rx_queue_id"]
#[doc = "   the selected Rx queue index."]
#[doc = " @param nb_rx_desc"]
#[doc = "   the requested number of descriptors for this queue. 0 - use PMD default."]
#[doc = " @param conf"]
#[doc = "   the Rx hairpin configuration structure."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Negative errno value on error, 0 on success."]
#[doc = ""]
#[doc = " @retval 0"]
#[doc = "   Success, hairpin is supported."]
#[doc = " @retval -ENOTSUP"]
#[doc = "   Hairpin is not supported."]
#[doc = " @retval -EINVAL"]
#[doc = "   One of the parameters is invalid."]
#[doc = " @retval -ENOMEM"]
#[doc = "   Unable to allocate resources."]
pub type eth_rx_hairpin_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        conf: *const rte_eth_hairpin_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Setup Tx hairpin queue."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   ethdev handle of port."]
#[doc = " @param tx_queue_id"]
#[doc = "   the selected Tx queue index."]
#[doc = " @param nb_tx_desc"]
#[doc = "   the requested number of descriptors for this queue. 0 - use PMD default."]
#[doc = " @param conf"]
#[doc = "   the Tx hairpin configuration structure."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Negative errno value on error, 0 on success."]
#[doc = ""]
#[doc = " @retval 0"]
#[doc = "   Success, hairpin is supported."]
#[doc = " @retval -ENOTSUP"]
#[doc = "   Hairpin is not supported."]
#[doc = " @retval -EINVAL"]
#[doc = "   One of the parameters is invalid."]
#[doc = " @retval -ENOMEM"]
#[doc = "   Unable to allocate resources."]
pub type eth_tx_hairpin_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        hairpin_conf: *const rte_eth_hairpin_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Get Forward Error Correction(FEC) capability."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   ethdev handle of port."]
#[doc = " @param speed_fec_capa"]
#[doc = "   speed_fec_capa is out only with per-speed capabilities."]
#[doc = " @param num"]
#[doc = "   a number of elements in an speed_fec_capa array."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Negative errno value on error, positive value on success."]
#[doc = ""]
#[doc = " @retval positive value"]
#[doc = "   A non-negative value lower or equal to num: success. The return value"]
#[doc = "   is the number of entries filled in the fec capa array."]
#[doc = "   A non-negative value higher than num: error, the given fec capa array"]
#[doc = "   is too small. The return value corresponds to the num that should"]
#[doc = "   be given to succeed. The entries in the fec capa array are not valid"]
#[doc = "   and shall not be used by the caller."]
#[doc = " @retval -ENOTSUP"]
#[doc = "   Operation is not supported."]
#[doc = " @retval -EIO"]
#[doc = "   Device is removed."]
#[doc = " @retval -EINVAL"]
#[doc = "   *num* or *speed_fec_capa* invalid."]
pub type eth_fec_get_capability_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        speed_fec_capa: *mut rte_eth_fec_capa,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Get Forward Error Correction(FEC) mode."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   ethdev handle of port."]
#[doc = " @param fec_capa"]
#[doc = "   a bitmask of enabled FEC modes. If AUTO bit is set, other"]
#[doc = "   bits specify FEC modes which may be negotiated. If AUTO"]
#[doc = "   bit is clear, specify FEC modes to be used (only one valid"]
#[doc = "   mode per speed may be set)."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Negative errno value on error, 0 on success."]
#[doc = ""]
#[doc = " @retval 0"]
#[doc = "   Success, get FEC success."]
#[doc = " @retval -ENOTSUP"]
#[doc = "   Operation is not supported."]
#[doc = " @retval -EIO"]
#[doc = "   Device is removed."]
pub type eth_fec_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, fec_capa: *mut u32) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Set Forward Error Correction(FEC) mode."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   ethdev handle of port."]
#[doc = " @param fec_capa"]
#[doc = "   bitmask of allowed FEC modes. It must be only one"]
#[doc = "   if AUTO is disabled. If AUTO is enabled, other"]
#[doc = "   bits specify FEC modes which may be negotiated."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Negative errno value on error, 0 on success."]
#[doc = ""]
#[doc = " @retval 0"]
#[doc = "   Success, set FEC success."]
#[doc = " @retval -ENOTSUP"]
#[doc = "   Operation is not supported."]
#[doc = " @retval -EINVAL"]
#[doc = "   Unsupported FEC mode requested."]
#[doc = " @retval -EIO"]
#[doc = "   Device is removed."]
pub type eth_fec_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, fec_capa: u32) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Get all hairpin Tx/Rx peer ports of the current device, if any."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   ethdev handle of port."]
#[doc = " @param peer_ports"]
#[doc = "   array to save the ports list."]
#[doc = " @param len"]
#[doc = "   array length."]
#[doc = " @param direction"]
#[doc = "   value to decide the current to peer direction"]
#[doc = "   positive - used as Tx to get all peer Rx ports."]
#[doc = "   zero - used as Rx to get all peer Tx ports."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Negative errno value on error, 0 or positive on success."]
#[doc = ""]
#[doc = " @retval 0"]
#[doc = "   Success, no peer ports."]
#[doc = " @retval >0"]
#[doc = "   Actual number of the peer ports."]
#[doc = " @retval -ENOTSUP"]
#[doc = "   Get peer ports API is not supported."]
#[doc = " @retval -EINVAL"]
#[doc = "   One of the parameters is invalid."]
pub type hairpin_get_peer_ports_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        peer_ports: *mut u16,
        len: size_t,
        direction: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Bind all hairpin Tx queues of one port to the Rx queues of the peer port."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   ethdev handle of port."]
#[doc = " @param rx_port"]
#[doc = "   the peer Rx port."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Negative errno value on error, 0 on success."]
#[doc = ""]
#[doc = " @retval 0"]
#[doc = "   Success, bind successfully."]
#[doc = " @retval -ENOTSUP"]
#[doc = "   Bind API is not supported."]
#[doc = " @retval -EINVAL"]
#[doc = "   One of the parameters is invalid."]
#[doc = " @retval -EBUSY"]
#[doc = "   Device is not started."]
pub type eth_hairpin_bind_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_port: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Unbind all hairpin Tx queues of one port from the Rx queues of the peer port."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   ethdev handle of port."]
#[doc = " @param rx_port"]
#[doc = "   the peer Rx port."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Negative errno value on error, 0 on success."]
#[doc = ""]
#[doc = " @retval 0"]
#[doc = "   Success, unbind successfully."]
#[doc = " @retval -ENOTSUP"]
#[doc = "   Bind API is not supported."]
#[doc = " @retval -EINVAL"]
#[doc = "   One of the parameters is invalid."]
#[doc = " @retval -EBUSY"]
#[doc = "   Device is already stopped."]
pub type eth_hairpin_unbind_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_port: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Update and fetch peer queue information."]
pub type eth_hairpin_queue_peer_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        peer_queue: u16,
        current_info: *mut rte_hairpin_peer_info,
        peer_info: *mut rte_hairpin_peer_info,
        direction: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Bind peer queue to the current queue with fetched information."]
pub type eth_hairpin_queue_peer_bind_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        cur_queue: u16,
        peer_info: *mut rte_hairpin_peer_info,
        direction: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Unbind peer queue from the current queue."]
pub type eth_hairpin_queue_peer_unbind_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        cur_queue: u16,
        direction: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Get address of memory location whose contents will change whenever there is"]
#[doc = " new data to be received on an Rx queue."]
#[doc = ""]
#[doc = " @param rxq"]
#[doc = "   Ethdev queue pointer."]
#[doc = " @param pmc"]
#[doc = "   The pointer to power-optimized monitoring condition structure."]
#[doc = " @return"]
#[doc = "   Negative errno value on error, 0 on success."]
#[doc = ""]
#[doc = " @retval 0"]
#[doc = "   Success"]
#[doc = " @retval -EINVAL"]
#[doc = "   Invalid parameters"]
pub type eth_get_monitor_addr_t = ::std::option::Option<
    unsafe extern "C" fn(
        rxq: *mut ::std::os::raw::c_void,
        pmc: *mut rte_power_monitor_cond,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Get representor info to be able to calculate the unique representor ID."]
#[doc = ""]
#[doc = " Caller should pass NULL as pointer of info to get number of entries,"]
#[doc = " allocate info buffer according to returned entry number, then call"]
#[doc = " again with buffer to get real info."]
#[doc = ""]
#[doc = " To calculate the representor ID, caller should iterate each entry,"]
#[doc = " match controller index, pf index, vf or sf start index and range,"]
#[doc = " then calculate representor ID from offset to vf/sf start index."]
#[doc = " @see rte_eth_representor_id_get."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Ethdev handle of port."]
#[doc = " @param [out] info"]
#[doc = "   Pointer to memory to save device representor info."]
#[doc = " @return"]
#[doc = "   Negative errno value on error, number of info entries otherwise."]
pub type eth_representor_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_eth_representor_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Negotiate the NIC's ability to deliver specific kinds of metadata to the PMD."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Port (ethdev) handle"]
#[doc = ""]
#[doc = " @param[inout] features"]
#[doc = "   Feature selection buffer"]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Negative errno value on error, zero otherwise"]
pub type eth_rx_metadata_negotiate_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, features: *mut u64) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Get IP reassembly offload capability of a PMD."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Port (ethdev) handle"]
#[doc = ""]
#[doc = " @param[out] conf"]
#[doc = "   IP reassembly capability supported by the PMD"]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Negative errno value on error, zero otherwise"]
pub type eth_ip_reassembly_capability_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        capa: *mut rte_eth_ip_reassembly_params,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Get IP reassembly offload configuration parameters set in PMD."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Port (ethdev) handle"]
#[doc = ""]
#[doc = " @param[out] conf"]
#[doc = "   Configuration parameters for IP reassembly."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Negative errno value on error, zero otherwise"]
pub type eth_ip_reassembly_conf_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        conf: *mut rte_eth_ip_reassembly_params,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Set configuration parameters for enabling IP reassembly offload in hardware."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Port (ethdev) handle"]
#[doc = ""]
#[doc = " @param[in] conf"]
#[doc = "   Configuration parameters for IP reassembly."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Negative errno value on error, zero otherwise"]
pub type eth_ip_reassembly_conf_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        conf: *const rte_eth_ip_reassembly_params,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal"]
#[doc = " Dump private info from device to a file."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Port (ethdev) handle."]
#[doc = " @param file"]
#[doc = "   A pointer to a file for output."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Negative value on error, 0 on success."]
#[doc = ""]
#[doc = " @retval 0"]
#[doc = "   Success"]
#[doc = " @retval -EINVAL"]
#[doc = "   Invalid file"]
pub type eth_dev_priv_dump_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, file: *mut FILE) -> ::std::os::raw::c_int,
>;
#[doc = " @internal A structure containing the functions exported by an Ethernet driver."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eth_dev_ops {
    #[doc = "< Configure device"]
    pub dev_configure: eth_dev_configure_t,
    #[doc = "< Start device"]
    pub dev_start: eth_dev_start_t,
    #[doc = "< Stop device"]
    pub dev_stop: eth_dev_stop_t,
    #[doc = "< Device link up"]
    pub dev_set_link_up: eth_dev_set_link_up_t,
    #[doc = "< Device link down"]
    pub dev_set_link_down: eth_dev_set_link_down_t,
    #[doc = "< Close device"]
    pub dev_close: eth_dev_close_t,
    #[doc = "< Reset device"]
    pub dev_reset: eth_dev_reset_t,
    #[doc = "< Get device link state"]
    pub link_update: eth_link_update_t,
    #[doc = " Check if the device was physically removed"]
    pub is_removed: eth_is_removed_t,
    #[doc = "< Promiscuous ON"]
    pub promiscuous_enable: eth_promiscuous_enable_t,
    #[doc = "< Promiscuous OFF"]
    pub promiscuous_disable: eth_promiscuous_disable_t,
    #[doc = "< Rx multicast ON"]
    pub allmulticast_enable: eth_allmulticast_enable_t,
    #[doc = "< Rx multicast OFF"]
    pub allmulticast_disable: eth_allmulticast_disable_t,
    #[doc = "< Remove MAC address"]
    pub mac_addr_remove: eth_mac_addr_remove_t,
    #[doc = "< Add a MAC address"]
    pub mac_addr_add: eth_mac_addr_add_t,
    #[doc = "< Set a MAC address"]
    pub mac_addr_set: eth_mac_addr_set_t,
    #[doc = " Set list of multicast addresses"]
    pub set_mc_addr_list: eth_set_mc_addr_list_t,
    #[doc = "< Set MTU"]
    pub mtu_set: mtu_set_t,
    #[doc = " Get generic device statistics"]
    pub stats_get: eth_stats_get_t,
    #[doc = " Reset generic device statistics"]
    pub stats_reset: eth_stats_reset_t,
    #[doc = " Get extended device statistics"]
    pub xstats_get: eth_xstats_get_t,
    #[doc = " Reset extended device statistics"]
    pub xstats_reset: eth_xstats_reset_t,
    #[doc = " Get names of extended statistics"]
    pub xstats_get_names: eth_xstats_get_names_t,
    #[doc = " Configure per queue stat counter mapping"]
    pub queue_stats_mapping_set: eth_queue_stats_mapping_set_t,
    #[doc = "< Get device info"]
    pub dev_infos_get: eth_dev_infos_get_t,
    #[doc = " Retrieve Rx queue information"]
    pub rxq_info_get: eth_rxq_info_get_t,
    #[doc = " Retrieve Tx queue information"]
    pub txq_info_get: eth_txq_info_get_t,
    #[doc = "< Get Rx burst mode"]
    pub rx_burst_mode_get: eth_burst_mode_get_t,
    #[doc = "< Get Tx burst mode"]
    pub tx_burst_mode_get: eth_burst_mode_get_t,
    #[doc = "< Get firmware version"]
    pub fw_version_get: eth_fw_version_get_t,
    #[doc = " Get packet types supported and identified by device"]
    pub dev_supported_ptypes_get: eth_dev_supported_ptypes_get_t,
    #[doc = " Inform Ethernet device about reduced range of packet types to"]
    #[doc = " handle"]
    pub dev_ptypes_set: eth_dev_ptypes_set_t,
    #[doc = " Filter VLAN Setup"]
    pub vlan_filter_set: vlan_filter_set_t,
    #[doc = " Outer/Inner VLAN TPID Setup"]
    pub vlan_tpid_set: vlan_tpid_set_t,
    #[doc = " VLAN Stripping on queue"]
    pub vlan_strip_queue_set: vlan_strip_queue_set_t,
    #[doc = " Set VLAN Offload"]
    pub vlan_offload_set: vlan_offload_set_t,
    #[doc = " Set port based Tx VLAN insertion"]
    pub vlan_pvid_set: vlan_pvid_set_t,
    #[doc = "< Start Rx for a queue"]
    pub rx_queue_start: eth_queue_start_t,
    #[doc = "< Stop Rx for a queue"]
    pub rx_queue_stop: eth_queue_stop_t,
    #[doc = "< Start Tx for a queue"]
    pub tx_queue_start: eth_queue_start_t,
    #[doc = "< Stop Tx for a queue"]
    pub tx_queue_stop: eth_queue_stop_t,
    #[doc = "< Set up device Rx queue"]
    pub rx_queue_setup: eth_rx_queue_setup_t,
    #[doc = "< Release Rx queue"]
    pub rx_queue_release: eth_queue_release_t,
    #[doc = " Enable Rx queue interrupt"]
    pub rx_queue_intr_enable: eth_rx_enable_intr_t,
    #[doc = " Disable Rx queue interrupt"]
    pub rx_queue_intr_disable: eth_rx_disable_intr_t,
    #[doc = "< Set up device Tx queue"]
    pub tx_queue_setup: eth_tx_queue_setup_t,
    #[doc = "< Release Tx queue"]
    pub tx_queue_release: eth_queue_release_t,
    #[doc = "< Free Tx ring mbufs"]
    pub tx_done_cleanup: eth_tx_done_cleanup_t,
    #[doc = "< Turn on LED"]
    pub dev_led_on: eth_dev_led_on_t,
    #[doc = "< Turn off LED"]
    pub dev_led_off: eth_dev_led_off_t,
    #[doc = "< Get flow control"]
    pub flow_ctrl_get: flow_ctrl_get_t,
    #[doc = "< Setup flow control"]
    pub flow_ctrl_set: flow_ctrl_set_t,
    #[doc = " Setup priority flow control"]
    pub priority_flow_ctrl_set: priority_flow_ctrl_set_t,
    #[doc = " Priority flow control queue info get"]
    pub priority_flow_ctrl_queue_info_get: priority_flow_ctrl_queue_info_get_t,
    #[doc = " Priority flow control queue configure"]
    pub priority_flow_ctrl_queue_config: priority_flow_ctrl_queue_config_t,
    #[doc = " Set Unicast Table Array"]
    pub uc_hash_table_set: eth_uc_hash_table_set_t,
    #[doc = " Set Unicast hash bitmap"]
    pub uc_all_hash_table_set: eth_uc_all_hash_table_set_t,
    #[doc = " Add UDP tunnel port"]
    pub udp_tunnel_port_add: eth_udp_tunnel_port_add_t,
    #[doc = " Delete UDP tunnel port"]
    pub udp_tunnel_port_del: eth_udp_tunnel_port_del_t,
    #[doc = " Set queue rate limit"]
    pub set_queue_rate_limit: eth_set_queue_rate_limit_t,
    #[doc = " Configure RSS hash protocols and hashing key"]
    pub rss_hash_update: rss_hash_update_t,
    #[doc = " Get current RSS hash configuration"]
    pub rss_hash_conf_get: rss_hash_conf_get_t,
    #[doc = " Update redirection table"]
    pub reta_update: reta_update_t,
    #[doc = " Query redirection table"]
    pub reta_query: reta_query_t,
    #[doc = "< Get registers"]
    pub get_reg: eth_get_reg_t,
    #[doc = "< Get EEPROM length"]
    pub get_eeprom_length: eth_get_eeprom_length_t,
    #[doc = "< Get EEPROM data"]
    pub get_eeprom: eth_get_eeprom_t,
    #[doc = "< Set EEPROM"]
    pub set_eeprom: eth_set_eeprom_t,
    #[doc = " Get plugin module EEPROM attribute"]
    pub get_module_info: eth_get_module_info_t,
    #[doc = " Get plugin module EEPROM data"]
    pub get_module_eeprom: eth_get_module_eeprom_t,
    #[doc = "< Get flow operations"]
    pub flow_ops_get: eth_flow_ops_get_t,
    #[doc = "< Get DCB information"]
    pub get_dcb_info: eth_get_dcb_info,
    #[doc = " Turn IEEE1588/802.1AS timestamping on"]
    pub timesync_enable: eth_timesync_enable_t,
    #[doc = " Turn IEEE1588/802.1AS timestamping off"]
    pub timesync_disable: eth_timesync_disable_t,
    #[doc = " Read the IEEE1588/802.1AS Rx timestamp"]
    pub timesync_read_rx_timestamp: eth_timesync_read_rx_timestamp_t,
    #[doc = " Read the IEEE1588/802.1AS Tx timestamp"]
    pub timesync_read_tx_timestamp: eth_timesync_read_tx_timestamp_t,
    #[doc = " Adjust the device clock"]
    pub timesync_adjust_time: eth_timesync_adjust_time,
    #[doc = " Get the device clock time"]
    pub timesync_read_time: eth_timesync_read_time,
    #[doc = " Set the device clock time"]
    pub timesync_write_time: eth_timesync_write_time,
    pub read_clock: eth_read_clock,
    #[doc = " Get extended device statistic values by ID"]
    pub xstats_get_by_id: eth_xstats_get_by_id_t,
    #[doc = " Get name of extended device statistics by ID"]
    pub xstats_get_names_by_id: eth_xstats_get_names_by_id_t,
    #[doc = " Get Traffic Management (TM) operations"]
    pub tm_ops_get: eth_tm_ops_get_t,
    #[doc = " Get Traffic Metering and Policing (MTR) operations"]
    pub mtr_ops_get: eth_mtr_ops_get_t,
    #[doc = " Test if a port supports specific mempool ops"]
    pub pool_ops_supported: eth_pool_ops_supported_t,
    #[doc = " Returns the hairpin capabilities"]
    pub hairpin_cap_get: eth_hairpin_cap_get_t,
    #[doc = " Set up device Rx hairpin queue"]
    pub rx_hairpin_queue_setup: eth_rx_hairpin_queue_setup_t,
    #[doc = " Set up device Tx hairpin queue"]
    pub tx_hairpin_queue_setup: eth_tx_hairpin_queue_setup_t,
    #[doc = " Get Forward Error Correction(FEC) capability"]
    pub fec_get_capability: eth_fec_get_capability_t,
    #[doc = " Get Forward Error Correction(FEC) mode"]
    pub fec_get: eth_fec_get_t,
    #[doc = " Set Forward Error Correction(FEC) mode"]
    pub fec_set: eth_fec_set_t,
    #[doc = " Get hairpin peer ports list"]
    pub hairpin_get_peer_ports: hairpin_get_peer_ports_t,
    #[doc = " Bind all hairpin Tx queues of device to the peer port Rx queues"]
    pub hairpin_bind: eth_hairpin_bind_t,
    #[doc = " Unbind all hairpin Tx queues from the peer port Rx queues"]
    pub hairpin_unbind: eth_hairpin_unbind_t,
    #[doc = " Pass the current queue info and get the peer queue info"]
    pub hairpin_queue_peer_update: eth_hairpin_queue_peer_update_t,
    #[doc = " Set up the connection between the pair of hairpin queues"]
    pub hairpin_queue_peer_bind: eth_hairpin_queue_peer_bind_t,
    #[doc = " Disconnect the hairpin queues of a pair from each other"]
    pub hairpin_queue_peer_unbind: eth_hairpin_queue_peer_unbind_t,
    #[doc = " Get power monitoring condition for Rx queue"]
    pub get_monitor_addr: eth_get_monitor_addr_t,
    #[doc = " Get representor info"]
    pub representor_info_get: eth_representor_info_get_t,
    #[doc = " Negotiate the NIC's ability to deliver specific"]
    #[doc = " kinds of metadata to the PMD"]
    pub rx_metadata_negotiate: eth_rx_metadata_negotiate_t,
    #[doc = " Get IP reassembly capability"]
    pub ip_reassembly_capability_get: eth_ip_reassembly_capability_get_t,
    #[doc = " Get IP reassembly configuration"]
    pub ip_reassembly_conf_get: eth_ip_reassembly_conf_get_t,
    #[doc = " Set IP reassembly configuration"]
    pub ip_reassembly_conf_set: eth_ip_reassembly_conf_set_t,
    #[doc = " Dump private info from device"]
    pub eth_dev_priv_dump: eth_dev_priv_dump_t,
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Check if the selected Rx queue is hairpin queue."]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "  Pointer to the selected device."]
    #[doc = " @param queue_id"]
    #[doc = "  The selected queue."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (1) if the queue is hairpin queue, 0 otherwise."]
    pub fn rte_eth_dev_is_rx_hairpin_queue(
        dev: *mut rte_eth_dev,
        queue_id: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Check if the selected Tx queue is hairpin queue."]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "  Pointer to the selected device."]
    #[doc = " @param queue_id"]
    #[doc = "  The selected queue."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (1) if the queue is hairpin queue, 0 otherwise."]
    pub fn rte_eth_dev_is_tx_hairpin_queue(
        dev: *mut rte_eth_dev,
        queue_id: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Returns a ethdev slot specified by the unique identifier name."]
    #[doc = ""]
    #[doc = " @param\tname"]
    #[doc = "  The pointer to the Unique identifier name for each Ethernet device"]
    #[doc = " @return"]
    #[doc = "   - The pointer to the ethdev slot, on success. NULL on error"]
    pub fn rte_eth_dev_allocated(name: *const ::std::os::raw::c_char) -> *mut rte_eth_dev;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Allocates a new ethdev slot for an Ethernet device and returns the pointer"]
    #[doc = " to that slot for the driver to use."]
    #[doc = ""]
    #[doc = " @param\tname\tUnique identifier name for each Ethernet device"]
    #[doc = " @return"]
    #[doc = "   - Slot in the rte_dev_devices array for a new device;"]
    pub fn rte_eth_dev_allocate(name: *const ::std::os::raw::c_char) -> *mut rte_eth_dev;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Attach to the ethdev already initialized by the primary"]
    #[doc = " process."]
    #[doc = ""]
    #[doc = " @param       name    Ethernet device's name."]
    #[doc = " @return"]
    #[doc = "   - Success: Slot in the rte_dev_devices array for attached"]
    #[doc = "        device."]
    #[doc = "   - Error: Null pointer."]
    pub fn rte_eth_dev_attach_secondary(name: *const ::std::os::raw::c_char) -> *mut rte_eth_dev;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Notify RTE_ETH_EVENT_DESTROY and release the specified ethdev port."]
    #[doc = ""]
    #[doc = " The following PMD-managed data fields will be freed:"]
    #[doc = "   - dev_private"]
    #[doc = "   - mac_addrs"]
    #[doc = "   - hash_mac_addrs"]
    #[doc = " If one of these fields should not be freed,"]
    #[doc = " it must be reset to NULL by the PMD, typically in dev_close method."]
    #[doc = ""]
    #[doc = " @param eth_dev"]
    #[doc = " Device to be detached."]
    #[doc = " @return"]
    #[doc = "   - 0 on success, negative on error"]
    pub fn rte_eth_dev_release_port(eth_dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Release device queues and clear its configuration to force the user"]
    #[doc = " application to reconfigure it. It is for internal use only."]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "  Pointer to struct rte_eth_dev."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  void"]
    pub fn rte_eth_dev_internal_reset(dev: *mut rte_eth_dev);
}
extern "C" {
    #[doc = " @internal Executes all the user application registered callbacks for"]
    #[doc = " the specific device. It is for DPDK internal user only. User"]
    #[doc = " application should not call it directly."]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "  Pointer to struct rte_eth_dev."]
    #[doc = " @param event"]
    #[doc = "  Eth device interrupt event type."]
    #[doc = " @param ret_param"]
    #[doc = "  To pass data back to user application."]
    #[doc = "  This allows the user application to decide if a particular function"]
    #[doc = "  is permitted or not."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  int"]
    pub fn rte_eth_dev_callback_process(
        dev: *mut rte_eth_dev,
        event: rte_eth_event_type,
        ret_param: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " This is the last step of device probing."]
    #[doc = " It must be called after a port is allocated and initialized successfully."]
    #[doc = ""]
    #[doc = " The notification RTE_ETH_EVENT_NEW is sent to other entities"]
    #[doc = " (libraries and applications)."]
    #[doc = " The state is set as RTE_ETH_DEV_ATTACHED."]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "  New ethdev port."]
    pub fn rte_eth_dev_probing_finish(dev: *mut rte_eth_dev);
}
extern "C" {
    #[doc = " Create memzone for HW rings."]
    #[doc = " malloc can't be used as the physical address is needed."]
    #[doc = " If the memzone is already created, then this function returns a ptr"]
    #[doc = " to the old one."]
    #[doc = ""]
    #[doc = " @param eth_dev"]
    #[doc = "   The *eth_dev* pointer is the address of the *rte_eth_dev* structure"]
    #[doc = " @param name"]
    #[doc = "   The name of the memory zone"]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the queue to add to name"]
    #[doc = " @param size"]
    #[doc = "   The sizeof of the memory area"]
    #[doc = " @param align"]
    #[doc = "   Alignment for resulting memzone. Must be a power of 2."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in case of NUMA."]
    pub fn rte_eth_dma_zone_reserve(
        eth_dev: *const rte_eth_dev,
        name: *const ::std::os::raw::c_char,
        queue_id: u16,
        size: size_t,
        align: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
    ) -> *const rte_memzone;
}
extern "C" {
    #[doc = " Free previously allocated memzone for HW rings."]
    #[doc = ""]
    #[doc = " @param eth_dev"]
    #[doc = "   The *eth_dev* pointer is the address of the *rte_eth_dev* structure"]
    #[doc = " @param name"]
    #[doc = "   The name of the memory zone"]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the queue to add to name"]
    #[doc = " @return"]
    #[doc = "   Negative errno value on error, 0 on success."]
    pub fn rte_eth_dma_zone_free(
        eth_dev: *const rte_eth_dev,
        name: *const ::std::os::raw::c_char,
        queue_id: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Dummy DPDK callback for Rx/Tx packet burst."]
    #[doc = ""]
    #[doc = " @param queue"]
    #[doc = "  Pointer to Rx/Tx queue"]
    #[doc = " @param pkts"]
    #[doc = "  Packet array"]
    #[doc = " @param nb_pkts"]
    #[doc = "  Number of packets in packet array"]
    pub fn rte_eth_pkt_burst_dummy(
        queue: *mut ::std::os::raw::c_void,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " Allocate an unique switch domain identifier."]
    #[doc = ""]
    #[doc = " A pool of switch domain identifiers which can be allocated on request. This"]
    #[doc = " will enabled devices which support the concept of switch domains to request"]
    #[doc = " a switch domain ID which is guaranteed to be unique from other devices"]
    #[doc = " running in the same process."]
    #[doc = ""]
    #[doc = " @param domain_id"]
    #[doc = "  switch domain identifier parameter to pass back to application"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Negative errno value on error, 0 on success."]
    pub fn rte_eth_switch_domain_alloc(domain_id: *mut u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free switch domain."]
    #[doc = ""]
    #[doc = " Return a switch domain identifier to the pool of free identifiers after it is"]
    #[doc = " no longer in use by device."]
    #[doc = ""]
    #[doc = " @param domain_id"]
    #[doc = "  switch domain identifier to free"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Negative errno value on error, 0 on success."]
    pub fn rte_eth_switch_domain_free(domain_id: u16) -> ::std::os::raw::c_int;
}
#[doc = " Generic Ethernet device arguments"]
#[doc = ""]
#[doc = " One type of representor each structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_devargs {
    pub mh_controllers: [u16; 4usize],
    #[doc = " controller/s number in case of multi-host"]
    pub nb_mh_controllers: u16,
    #[doc = " number of controllers in multi-host controllers field"]
    pub ports: [u16; 32usize],
    #[doc = " port/s number to enable on a multi-port single function"]
    pub nb_ports: u16,
    #[doc = " number of ports in ports field"]
    pub representor_ports: [u16; 32usize],
    #[doc = " representor port/s identifier to enable on device"]
    pub nb_representor_ports: u16,
    #[doc = " number of ports in representor port field"]
    pub type_: rte_eth_representor_type,
}
extern "C" {
    #[doc = " PMD helper function to get representor ID from location detail."]
    #[doc = ""]
    #[doc = " Get representor ID from controller, pf and (sf or vf)."]
    #[doc = " The mapping is retrieved from rte_eth_representor_info_get()."]
    #[doc = ""]
    #[doc = " For backward compatibility, if no representor info, direct"]
    #[doc = " map legacy VF (no controller and pf)."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "  Port ID of the backing device."]
    #[doc = " @param type"]
    #[doc = "  Representor type."]
    #[doc = " @param controller"]
    #[doc = "  Controller ID, -1 if unspecified."]
    #[doc = " @param pf"]
    #[doc = "  PF port ID, -1 if unspecified."]
    #[doc = " @param representor_port"]
    #[doc = "  VF or SF representor port number, -1 if unspecified."]
    #[doc = " @param repr_id"]
    #[doc = "  Pointer to output representor ID."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  Negative errno value on error, 0 on success."]
    pub fn rte_eth_representor_id_get(
        port_id: u16,
        type_: rte_eth_representor_type,
        controller: ::std::os::raw::c_int,
        pf: ::std::os::raw::c_int,
        representor_port: ::std::os::raw::c_int,
        repr_id: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " PMD helper function to parse ethdev arguments"]
    #[doc = ""]
    #[doc = " @param devargs"]
    #[doc = "  device arguments"]
    #[doc = " @param eth_devargs"]
    #[doc = "  parsed ethdev specific arguments."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Negative errno value on error, 0 on success."]
    pub fn rte_eth_devargs_parse(
        devargs: *const ::std::os::raw::c_char,
        eth_devargs: *mut rte_eth_devargs,
    ) -> ::std::os::raw::c_int;
}
pub type ethdev_init_t = ::std::option::Option<
    unsafe extern "C" fn(
        ethdev: *mut rte_eth_dev,
        init_params: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type ethdev_bus_specific_init = ::std::option::Option<
    unsafe extern "C" fn(
        ethdev: *mut rte_eth_dev,
        bus_specific_init_params: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " PMD helper function for the creation of a new ethdev ports."]
    #[doc = ""]
    #[doc = " @param device"]
    #[doc = "  rte_device handle."]
    #[doc = " @param name"]
    #[doc = "  port name."]
    #[doc = " @param priv_data_size"]
    #[doc = "  size of private data required for port."]
    #[doc = " @param bus_specific_init"]
    #[doc = "  port bus specific initialisation callback function"]
    #[doc = " @param bus_init_params"]
    #[doc = "  port bus specific initialisation parameters"]
    #[doc = " @param ethdev_init"]
    #[doc = "  device specific port initialization callback function"]
    #[doc = " @param init_params"]
    #[doc = "  port initialisation parameters"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Negative errno value on error, 0 on success."]
    pub fn rte_eth_dev_create(
        device: *mut rte_device,
        name: *const ::std::os::raw::c_char,
        priv_data_size: size_t,
        bus_specific_init: ethdev_bus_specific_init,
        bus_init_params: *mut ::std::os::raw::c_void,
        ethdev_init: ethdev_init_t,
        init_params: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub type ethdev_uninit_t =
    ::std::option::Option<unsafe extern "C" fn(ethdev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
extern "C" {
    #[doc = " PMD helper function for cleaning up the resources of a ethdev port on it's"]
    #[doc = " destruction."]
    #[doc = ""]
    #[doc = " @param ethdev"]
    #[doc = "   ethdev handle of port."]
    #[doc = " @param ethdev_uninit"]
    #[doc = "   device specific port un-initialise callback function"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Negative errno value on error, 0 on success."]
    pub fn rte_eth_dev_destroy(
        ethdev: *mut rte_eth_dev,
        ethdev_uninit: ethdev_uninit_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Pass the current hairpin queue HW and/or SW information to the peer queue"]
    #[doc = " and fetch back the information of the peer queue."]
    #[doc = ""]
    #[doc = " @param peer_port"]
    #[doc = "  Peer port identifier of the Ethernet device."]
    #[doc = " @param peer_queue"]
    #[doc = "  Peer queue index of the port."]
    #[doc = " @param cur_info"]
    #[doc = "  Pointer to the current information structure."]
    #[doc = " @param peer_info"]
    #[doc = "  Pointer to the peer information, output."]
    #[doc = " @param direction"]
    #[doc = "  Direction to pass the information."]
    #[doc = "  positive - pass Tx queue information and get peer Rx queue information"]
    #[doc = "  zero - pass Rx queue information and get peer Tx queue information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  Negative errno value on error, 0 on success."]
    pub fn rte_eth_hairpin_queue_peer_update(
        peer_port: u16,
        peer_queue: u16,
        cur_info: *mut rte_hairpin_peer_info,
        peer_info: *mut rte_hairpin_peer_info,
        direction: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Configure current hairpin queue with the peer information fetched to create"]
    #[doc = " the connection (bind) with peer queue in the specified direction."]
    #[doc = " This function might need to be called twice to fully create the connections."]
    #[doc = ""]
    #[doc = " @param cur_port"]
    #[doc = "  Current port identifier of the Ethernet device."]
    #[doc = " @param cur_queue"]
    #[doc = "  Current queue index of the port."]
    #[doc = " @param peer_info"]
    #[doc = "  Pointer to the peer information, input."]
    #[doc = " @param direction"]
    #[doc = "  Direction to create the connection."]
    #[doc = "  positive - bind current Tx queue to peer Rx queue"]
    #[doc = "  zero - bind current Rx queue to peer Tx queue"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  Negative errno value on error, 0 on success."]
    pub fn rte_eth_hairpin_queue_peer_bind(
        cur_port: u16,
        cur_queue: u16,
        peer_info: *mut rte_hairpin_peer_info,
        direction: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Get rte_eth_dev from device name. The device name should be specified"]
    #[doc = " as below:"]
    #[doc = " - PCIe address (Domain:Bus:Device.Function), for example 0000:2:00.0"]
    #[doc = " - SoC device name, for example fsl-gmac0"]
    #[doc = " - vdev dpdk name, for example net_[pcap0|null0|tap0]"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   PCI address or name of the device"]
    #[doc = " @return"]
    #[doc = "   - rte_eth_dev if successful"]
    #[doc = "   - NULL on failure"]
    pub fn rte_eth_dev_get_by_name(name: *const ::std::os::raw::c_char) -> *mut rte_eth_dev;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Reset the current queue state and configuration to disconnect (unbind) it"]
    #[doc = " from the peer queue."]
    #[doc = " This function might need to be called twice to disconnect each other."]
    #[doc = ""]
    #[doc = " @param cur_port"]
    #[doc = "  Current port identifier of the Ethernet device."]
    #[doc = " @param cur_queue"]
    #[doc = "  Current queue index of the port."]
    #[doc = " @param direction"]
    #[doc = "  Direction to destroy the connection."]
    #[doc = "  positive - unbind current Tx queue from peer Rx queue"]
    #[doc = "  zero - unbind current Rx queue from peer Tx queue"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  Negative errno value on error, 0 on success."]
    pub fn rte_eth_hairpin_queue_peer_unbind(
        cur_port: u16,
        cur_queue: u16,
        direction: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Register mbuf dynamic field and flag for IP reassembly incomplete case."]
    pub fn rte_eth_ip_reassembly_dynfield_register(
        field_offset: *mut ::std::os::raw::c_int,
        flag: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_filter_type {
    RTE_ETH_FILTER_NONE = 0,
    RTE_ETH_FILTER_ETHERTYPE = 1,
    RTE_ETH_FILTER_FLEXIBLE = 2,
    RTE_ETH_FILTER_SYN = 3,
    RTE_ETH_FILTER_NTUPLE = 4,
    RTE_ETH_FILTER_TUNNEL = 5,
    RTE_ETH_FILTER_FDIR = 6,
    RTE_ETH_FILTER_HASH = 7,
    RTE_ETH_FILTER_L2_TUNNEL = 8,
}
#[doc = " A structure used to define the ethertype filter entry"]
#[doc = " to support RTE_ETH_FILTER_ETHERTYPE data representation."]
#[repr(C)]
pub struct rte_eth_ethertype_filter {
    #[doc = "< Mac address to match"]
    pub mac_addr: rte_ether_addr,
    #[doc = "< Ether type to match"]
    pub ether_type: u16,
    #[doc = "< Flags from RTE_ETHTYPE_FLAGS_*"]
    pub flags: u16,
    #[doc = "< Queue assigned to when match"]
    pub queue: u16,
}
#[doc = " A structure used to define the TCP syn filter entry"]
#[doc = " to support RTE_ETH_FILTER_SYN data representation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_syn_filter {
    #[doc = " 1 - higher priority than other filters, 0 - lower priority"]
    pub hig_pri: u8,
    #[doc = "< Queue assigned to when match"]
    pub queue: u16,
}
#[repr(u32)]
#[doc = "  Select IPv4 or IPv6 for tunnel filters."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_tunnel_iptype {
    #[doc = "< IPv4"]
    RTE_TUNNEL_IPTYPE_IPV4 = 0,
    #[doc = "< IPv6"]
    RTE_TUNNEL_IPTYPE_IPV6 = 1,
}
#[doc = " Tunneling Packet filter configuration."]
#[repr(C)]
pub struct rte_eth_tunnel_filter_conf {
    #[doc = "< Outer MAC address to match"]
    pub outer_mac: rte_ether_addr,
    #[doc = "< Inner MAC address to match"]
    pub inner_mac: rte_ether_addr,
    #[doc = "< Inner VLAN to match"]
    pub inner_vlan: u16,
    #[doc = "< IP address type"]
    pub ip_type: rte_tunnel_iptype,
    pub ip_addr: rte_eth_tunnel_filter_conf__bindgen_ty_1,
    #[doc = " Flags from ETH_TUNNEL_FILTER_XX - see above"]
    pub filter_type: u16,
    #[doc = "< Tunnel Type"]
    pub tunnel_type: rte_eth_tunnel_type,
    #[doc = "< Tenant ID to match: VNI, GRE key..."]
    pub tenant_id: u32,
    #[doc = "< Queue assigned to if match"]
    pub queue_id: u16,
}
#[doc = " Outer destination IP address to match if ETH_TUNNEL_FILTER_OIP"]
#[doc = " is set in filter_type, or inner destination IP address to match"]
#[doc = " if ETH_TUNNEL_FILTER_IIP is set in filter_type."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_tunnel_filter_conf__bindgen_ty_1 {
    #[doc = "< IPv4 address in big endian"]
    pub ipv4_addr: u32,
    #[doc = "< IPv6 address in big endian"]
    pub ipv6_addr: [u32; 4usize],
}
#[repr(u32)]
#[doc = " Statistics counter type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_mtr_stats_type {
    #[doc = " Number of packets passed as green by the policer."]
    RTE_MTR_STATS_N_PKTS_GREEN = 1,
    #[doc = " Number of packets passed as yellow by the policer."]
    RTE_MTR_STATS_N_PKTS_YELLOW = 2,
    #[doc = " Number of packets passed as red by the policer."]
    RTE_MTR_STATS_N_PKTS_RED = 4,
    #[doc = " Number of packets dropped by the policer."]
    RTE_MTR_STATS_N_PKTS_DROPPED = 8,
    #[doc = " Number of bytes passed as green by the policer."]
    RTE_MTR_STATS_N_BYTES_GREEN = 16,
    #[doc = " Number of bytes passed as yellow by the policer."]
    RTE_MTR_STATS_N_BYTES_YELLOW = 32,
    #[doc = " Number of bytes passed as red by the policer."]
    RTE_MTR_STATS_N_BYTES_RED = 64,
    #[doc = " Number of bytes dropped by the policer."]
    RTE_MTR_STATS_N_BYTES_DROPPED = 128,
}
#[doc = " Statistics counters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mtr_stats {
    #[doc = " Number of packets passed by the policer (per color)."]
    pub n_pkts: [u64; 3usize],
    #[doc = " Number of bytes passed by the policer (per color)."]
    pub n_bytes: [u64; 3usize],
    #[doc = " Number of packets dropped by the policer."]
    pub n_pkts_dropped: u64,
    #[doc = " Number of bytes passed by the policer."]
    pub n_bytes_dropped: u64,
}
#[repr(u32)]
#[doc = " Traffic metering algorithms"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_mtr_algorithm {
    #[doc = " No traffic metering performed, the output color is the same as the"]
    #[doc = " input color for every input packet. The meter of the MTR object is"]
    #[doc = " working in pass-through mode, having same effect as meter disable."]
    #[doc = " @see rte_mtr_meter_disable()"]
    RTE_MTR_NONE = 0,
    #[doc = " Single Rate Three Color Marker (srTCM) - IETF RFC 2697."]
    RTE_MTR_SRTCM_RFC2697 = 1,
    #[doc = " Two Rate Three Color Marker (trTCM) - IETF RFC 2698."]
    RTE_MTR_TRTCM_RFC2698 = 2,
    #[doc = " Two Rate Three Color Marker (trTCM) - IETF RFC 4115."]
    RTE_MTR_TRTCM_RFC4115 = 3,
}
#[doc = " Meter profile"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mtr_meter_profile {
    #[doc = " Traffic metering algorithm."]
    pub alg: rte_mtr_algorithm,
    pub __bindgen_anon_1: rte_mtr_meter_profile__bindgen_ty_1,
    #[doc = " When zero, the byte mode is enabled for the current profile, so the"]
    #[doc = " *rate* and *size* fields are specified in bytes per second"]
    #[doc = " and bytes, respectively."]
    #[doc = " When non-zero, the packet mode is enabled for the current profile,"]
    #[doc = " so the *rate* and *size* fields are specified in packets per second"]
    #[doc = " and packets, respectively."]
    pub packet_mode: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mtr_meter_profile__bindgen_ty_1 {
    pub srtcm_rfc2697: rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_1,
    pub trtcm_rfc2698: rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_2,
    pub trtcm_rfc4115: rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_3,
}
#[doc = " Items only valid when *alg* is set to srTCM - RFC 2697."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Committed Information Rate (CIR)"]
    #[doc = " (bytes per second or packets per second)."]
    pub cir: u64,
    #[doc = " Committed Burst Size (CBS) (bytes or packets)."]
    pub cbs: u64,
    #[doc = " Excess Burst Size (EBS) (bytes or packets)."]
    pub ebs: u64,
}
#[doc = " Items only valid when *alg* is set to trTCM - RFC 2698."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " Committed Information Rate (CIR)"]
    #[doc = " (bytes per second or packets per second)."]
    pub cir: u64,
    #[doc = " Peak Information Rate (PIR)"]
    #[doc = " (bytes per second or packets per second)."]
    pub pir: u64,
    #[doc = " Committed Burst Size (CBS) (bytes or packets)."]
    pub cbs: u64,
    #[doc = " Peak Burst Size (PBS) (bytes or packets)."]
    pub pbs: u64,
}
#[doc = " Items only valid when *alg* is set to trTCM - RFC 4115."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " Committed Information Rate (CIR)"]
    #[doc = " (bytes per second or packets per second)."]
    pub cir: u64,
    #[doc = " Excess Information Rate (EIR)"]
    #[doc = " (bytes per second or packets per second)."]
    pub eir: u64,
    #[doc = " Committed Burst Size (CBS) (bytes or packets)."]
    pub cbs: u64,
    #[doc = " Excess Burst Size (EBS) (bytes or packets)."]
    pub ebs: u64,
}
#[doc = " Meter policy"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mtr_meter_policy_params {
    #[doc = " Policy action list per color."]
    #[doc = " actions[i] potentially represents a chain of rte_flow actions"]
    #[doc = " terminated by the END action, exactly as specified by the rte_flow"]
    #[doc = " API for the flow definition, and not just a single action."]
    pub actions: [*const rte_flow_action; 3usize],
}
#[doc = " Parameters for each traffic metering & policing object"]
#[doc = ""]
#[doc = " @see enum rte_mtr_stats_type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mtr_params {
    #[doc = " Meter profile ID. @see rte_mtr_meter_profile_add()"]
    pub meter_profile_id: u32,
    #[doc = " Meter input color in case of MTR object chaining. When non-zero: if"]
    #[doc = " a previous MTR object is enabled in the same flow, then the color"]
    #[doc = " determined by the latest MTR object in the same flow is used as the"]
    #[doc = " input color by the current MTR object, otherwise the current MTR"]
    #[doc = " object uses the *dscp_table* to determine the input color. When zero:"]
    #[doc = " the color determined by any previous MTR object in same flow is"]
    #[doc = " ignored by the current MTR object, which uses the *dscp_table* to"]
    #[doc = " determine the input color."]
    pub use_prev_mtr_color: ::std::os::raw::c_int,
    #[doc = " Meter input color. When non-NULL: it points to a pre-allocated and"]
    #[doc = " pre-populated table with exactly 64 elements providing the input"]
    #[doc = " color for each value of the IPv4/IPv6 Differentiated Services Code"]
    #[doc = " Point (DSCP) input packet field. When NULL: it is equivalent to"]
    #[doc = " setting this parameter to an all-green populated table (i.e. table"]
    #[doc = " with all the 64 elements set to green color). The color blind mode"]
    #[doc = " is configured by setting *use_prev_mtr_color* to 0 and *dscp_table*"]
    #[doc = " to either NULL or to an all-green populated table. When"]
    #[doc = " *use_prev_mtr_color* is non-zero value or when *dscp_table* contains"]
    #[doc = " at least one yellow or red color element, then the color aware mode"]
    #[doc = " is configured."]
    pub dscp_table: *mut rte_color,
    #[doc = " Non-zero to enable the meter, zero to disable the meter at the time"]
    #[doc = " of MTR object creation. Ignored when the meter profile indicated by"]
    #[doc = " *meter_profile_id* is set to NONE."]
    #[doc = " @see rte_mtr_meter_disable()"]
    pub meter_enable: ::std::os::raw::c_int,
    #[doc = " Set of stats counters to be enabled."]
    #[doc = " @see enum rte_mtr_stats_type"]
    pub stats_mask: u64,
    #[doc = " Meter policy ID. @see rte_mtr_meter_policy_add()"]
    pub meter_policy_id: u32,
}
#[doc = " MTR capabilities"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mtr_capabilities {
    #[doc = " Maximum number of MTR objects."]
    pub n_max: u32,
    #[doc = " Maximum number of MTR objects that can be shared by multiple flows."]
    #[doc = " The value of zero indicates that shared MTR objects are not"]
    #[doc = " supported. The maximum value is *n_max*."]
    pub n_shared_max: u32,
    #[doc = " When non-zero, this flag indicates that all the MTR objects that"]
    #[doc = " cannot be shared by multiple flows have identical capability set."]
    pub identical: ::std::os::raw::c_int,
    #[doc = " When non-zero, this flag indicates that all the MTR objects that"]
    #[doc = " can be shared by multiple flows have identical capability set."]
    pub shared_identical: ::std::os::raw::c_int,
    #[doc = " Maximum number of flows that can share the same MTR object. The"]
    #[doc = " value of zero is invalid. The value of 1 means that shared MTR"]
    #[doc = " objects not supported."]
    pub shared_n_flows_per_mtr_max: u32,
    #[doc = " Maximum number of MTR objects that can be part of the same flow. The"]
    #[doc = " value of zero is invalid. The value of 1 indicates that MTR object"]
    #[doc = " chaining is not supported. The maximum value is *n_max*."]
    pub chaining_n_mtrs_per_flow_max: u32,
    #[doc = " When non-zero, it indicates that the packet color identified by one"]
    #[doc = " MTR object can be used as the packet input color by any subsequent"]
    #[doc = " MTR object from the same flow. When zero, it indicates that the color"]
    #[doc = " determined by one MTR object is always ignored by any subsequent MTR"]
    #[doc = " object from the same flow. Only valid when MTR chaining is supported,"]
    #[doc = " i.e. *chaining_n_mtrs_per_flow_max* is greater than 1. When non-zero,"]
    #[doc = " it also means that the color aware mode is supported by at least one"]
    #[doc = " metering algorithm."]
    pub chaining_use_prev_mtr_color_supported: ::std::os::raw::c_int,
    #[doc = " When non-zero, it indicates that the packet color identified by one"]
    #[doc = " MTR object is always used as the packet input color by any subsequent"]
    #[doc = " MTR object that is part of the same flow. When zero, it indicates"]
    #[doc = " that whether the color determined by one MTR object is either ignored"]
    #[doc = " or used as the packet input color by any subsequent MTR object from"]
    #[doc = " the same flow is individually configurable for each MTR object. Only"]
    #[doc = " valid when *chaining_use_prev_mtr_color_supported* is non-zero."]
    pub chaining_use_prev_mtr_color_enforced: ::std::os::raw::c_int,
    #[doc = " Maximum number of MTR objects that can have their meter configured"]
    #[doc = " to run the srTCM RFC 2697 algorithm. The value of 0 indicates this"]
    #[doc = " metering algorithm is not supported. The maximum value is *n_max*."]
    pub meter_srtcm_rfc2697_n_max: u32,
    #[doc = " Maximum number of MTR objects that can have their meter configured"]
    #[doc = " to run the trTCM RFC 2698 algorithm. The value of 0 indicates this"]
    #[doc = " metering algorithm is not supported. The maximum value is *n_max*."]
    pub meter_trtcm_rfc2698_n_max: u32,
    #[doc = " Maximum number of MTR objects that can have their meter configured"]
    #[doc = " to run the trTCM RFC 4115 algorithm. The value of 0 indicates this"]
    #[doc = " metering algorithm is not supported. The maximum value is *n_max*."]
    pub meter_trtcm_rfc4115_n_max: u32,
    #[doc = " Maximum traffic rate that can be metered by a single MTR object. For"]
    #[doc = " srTCM RFC 2697, this is the maximum CIR rate. For trTCM RFC 2698,"]
    #[doc = " this is the maximum PIR rate. For trTCM RFC 4115, this is the maximum"]
    #[doc = " value for the sum of PIR and EIR rates."]
    pub meter_rate_max: u64,
    #[doc = " Maximum number of policy objects that can have."]
    #[doc = " The value of 0 is invalid. Policy must be supported for meter."]
    #[doc = " The maximum value is *n_max*."]
    pub meter_policy_n_max: u64,
    #[doc = " When non-zero, it indicates that color aware mode is supported for"]
    #[doc = " the srTCM RFC 2697 metering algorithm."]
    pub color_aware_srtcm_rfc2697_supported: ::std::os::raw::c_int,
    #[doc = " When non-zero, it indicates that color aware mode is supported for"]
    #[doc = " the trTCM RFC 2698 metering algorithm."]
    pub color_aware_trtcm_rfc2698_supported: ::std::os::raw::c_int,
    #[doc = " When non-zero, it indicates that color aware mode is supported for"]
    #[doc = " the trTCM RFC 4115 metering algorithm."]
    pub color_aware_trtcm_rfc4115_supported: ::std::os::raw::c_int,
    #[doc = " srTCM rfc2697 byte mode supported."]
    #[doc = " When non-zero, it indicates that byte mode is supported for"]
    #[doc = " the srTCM RFC 2697 metering algorithm."]
    pub srtcm_rfc2697_byte_mode_supported: ::std::os::raw::c_int,
    #[doc = " srTCM rfc2697 packet mode supported."]
    #[doc = " When non-zero, it indicates that packet mode is supported for"]
    #[doc = " the srTCM RFC 2697 metering algorithm."]
    pub srtcm_rfc2697_packet_mode_supported: ::std::os::raw::c_int,
    #[doc = " trTCM rfc2698 byte mode supported."]
    #[doc = " When non-zero, it indicates that byte mode is supported for"]
    #[doc = " the trTCM RFC 2698 metering algorithm."]
    pub trtcm_rfc2698_byte_mode_supported: ::std::os::raw::c_int,
    #[doc = " trTCM rfc2698 packet mode supported."]
    #[doc = " When non-zero, it indicates that packet mode is supported for"]
    #[doc = " the trTCM RFC 2698 metering algorithm."]
    pub trtcm_rfc2698_packet_mode_supported: ::std::os::raw::c_int,
    #[doc = " trTCM rfc4115 byte mode supported."]
    #[doc = " When non-zero, it indicates that byte mode is supported for"]
    #[doc = " the trTCM RFC 4115 metering algorithm."]
    pub trtcm_rfc4115_byte_mode_supported: ::std::os::raw::c_int,
    #[doc = " trTCM rfc4115 packet mode supported."]
    #[doc = " When non-zero, it indicates that packet mode is supported for"]
    #[doc = " the trTCM RFC 4115 metering algorithm."]
    pub trtcm_rfc4115_packet_mode_supported: ::std::os::raw::c_int,
    #[doc = " Set of supported statistics counter types."]
    #[doc = " @see enum rte_mtr_stats_type"]
    pub stats_mask: u64,
}
#[repr(u32)]
#[doc = " Verbose error types."]
#[doc = ""]
#[doc = " Most of them provide the type of the object referenced by struct"]
#[doc = " rte_mtr_error::cause."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_mtr_error_type {
    #[doc = "< No error."]
    RTE_MTR_ERROR_TYPE_NONE = 0,
    #[doc = "< Cause unspecified."]
    RTE_MTR_ERROR_TYPE_UNSPECIFIED = 1,
    RTE_MTR_ERROR_TYPE_METER_PROFILE_ID = 2,
    RTE_MTR_ERROR_TYPE_METER_PROFILE = 3,
    RTE_MTR_ERROR_TYPE_METER_PROFILE_PACKET_MODE = 4,
    RTE_MTR_ERROR_TYPE_MTR_ID = 5,
    RTE_MTR_ERROR_TYPE_MTR_PARAMS = 6,
    RTE_MTR_ERROR_TYPE_POLICER_ACTION_GREEN = 7,
    RTE_MTR_ERROR_TYPE_POLICER_ACTION_YELLOW = 8,
    RTE_MTR_ERROR_TYPE_POLICER_ACTION_RED = 9,
    RTE_MTR_ERROR_TYPE_STATS_MASK = 10,
    RTE_MTR_ERROR_TYPE_STATS = 11,
    RTE_MTR_ERROR_TYPE_SHARED = 12,
    RTE_MTR_ERROR_TYPE_METER_POLICY_ID = 13,
    RTE_MTR_ERROR_TYPE_METER_POLICY = 14,
}
#[doc = " Verbose error structure definition."]
#[doc = ""]
#[doc = " This object is normally allocated by applications and set by PMDs, the"]
#[doc = " message points to a constant string which does not need to be freed by"]
#[doc = " the application, however its pointer can be considered valid only as long"]
#[doc = " as its associated DPDK port remains configured. Closing the underlying"]
#[doc = " device or unloading the PMD invalidates it."]
#[doc = ""]
#[doc = " Both cause and message may be NULL regardless of the error type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mtr_error {
    #[doc = "< Cause field and error type."]
    pub type_: rte_mtr_error_type,
    #[doc = "< Object responsible for the error."]
    pub cause: *const ::std::os::raw::c_void,
    #[doc = "< Human-readable error message."]
    pub message: *const ::std::os::raw::c_char,
}
extern "C" {
    #[doc = " MTR capabilities get"]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[out] cap"]
    #[doc = "   MTR capabilities. Needs to be pre-allocated and valid."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    pub fn rte_mtr_capabilities_get(
        port_id: u16,
        cap: *mut rte_mtr_capabilities,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Meter profile add"]
    #[doc = ""]
    #[doc = " Create a new meter profile with ID set to *meter_profile_id*. The new profile"]
    #[doc = " is used to create one or several MTR objects."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] meter_profile_id"]
    #[doc = "   ID for the new meter profile. Needs to be unused by any of the existing"]
    #[doc = "   meter profiles added for the current port."]
    #[doc = " @param[in] profile"]
    #[doc = "   Meter profile parameters. Needs to be pre-allocated and valid."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    pub fn rte_mtr_meter_profile_add(
        port_id: u16,
        meter_profile_id: u32,
        profile: *mut rte_mtr_meter_profile,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Meter profile delete"]
    #[doc = ""]
    #[doc = " Delete an existing meter profile. This operation fails when there is"]
    #[doc = " currently at least one user (i.e. MTR object) of this profile."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] meter_profile_id"]
    #[doc = "   Meter profile ID. Needs to be the valid."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    pub fn rte_mtr_meter_profile_delete(
        port_id: u16,
        meter_profile_id: u32,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check whether a meter policy can be created on a given port."]
    #[doc = ""]
    #[doc = " The meter policy is validated for correctness and"]
    #[doc = " whether it could be accepted by the device given sufficient resources."]
    #[doc = " The policy is checked against the current capability information"]
    #[doc = " meter_policy_n_max configuration."]
    #[doc = " The policy may also optionally be validated against existing"]
    #[doc = " device policy resources."]
    #[doc = " This function has no effect on the target device."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] policy"]
    #[doc = "   Associated action list per color."]
    #[doc = "   list NULL is legal and means no special action."]
    #[doc = "   (list terminated by the END action)."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    pub fn rte_mtr_meter_policy_validate(
        port_id: u16,
        policy: *mut rte_mtr_meter_policy_params,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Meter policy add"]
    #[doc = ""]
    #[doc = " Create a new meter policy. The new policy"]
    #[doc = " is used to create single or multiple MTR objects."]
    #[doc = " The same policy can be used to create multiple MTR objects."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] policy_id"]
    #[doc = "   Policy identifier for the new meter policy."]
    #[doc = " @param[in] policy"]
    #[doc = "   Associated actions per color."]
    #[doc = "   list NULL is legal and means no special action."]
    #[doc = "   Non-NULL list must be terminated."]
    #[doc = "   (list terminated by the END action)."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    pub fn rte_mtr_meter_policy_add(
        port_id: u16,
        policy_id: u32,
        policy: *mut rte_mtr_meter_policy_params,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Meter policy delete"]
    #[doc = ""]
    #[doc = " Delete an existing meter policy. This operation fails when there is"]
    #[doc = " currently at least one user (i.e. MTR object) of this policy."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] policy_id"]
    #[doc = "   Policy identifier."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    pub fn rte_mtr_meter_policy_delete(
        port_id: u16,
        policy_id: u32,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " MTR object create"]
    #[doc = ""]
    #[doc = " Create a new MTR object for the current port. This object is run as part of"]
    #[doc = " associated flow action for traffic metering and policing."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] mtr_id"]
    #[doc = "   MTR object ID. Needs to be unused by any of the existing MTR objects."]
    #[doc = "   created for the current port."]
    #[doc = " @param[in] params"]
    #[doc = "   MTR object params. Needs to be pre-allocated and valid."]
    #[doc = " @param[in] shared"]
    #[doc = "   Non-zero when this MTR object can be shared by multiple flows, zero when"]
    #[doc = "   this MTR object can be used by a single flow."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see enum rte_flow_action_type::RTE_FLOW_ACTION_TYPE_METER"]
    pub fn rte_mtr_create(
        port_id: u16,
        mtr_id: u32,
        params: *mut rte_mtr_params,
        shared: ::std::os::raw::c_int,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " MTR object destroy"]
    #[doc = ""]
    #[doc = " Delete an existing MTR object. This operation fails when there is currently"]
    #[doc = " at least one user (i.e. flow) of this MTR object."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] mtr_id"]
    #[doc = "   MTR object ID. Needs to be valid."]
    #[doc = "   created for the current port."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    pub fn rte_mtr_destroy(
        port_id: u16,
        mtr_id: u32,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " MTR object meter disable"]
    #[doc = ""]
    #[doc = " Disable the meter of an existing MTR object. In disabled state, the meter of"]
    #[doc = " the current MTR object works in pass-through mode, meaning that for each"]
    #[doc = " input packet the meter output color is always the same as the input color. In"]
    #[doc = " particular, when the meter of the current MTR object is configured in color"]
    #[doc = " blind mode, the input color is always green, so the meter output color is"]
    #[doc = " also always green. Note that the policer and the statistics of the current"]
    #[doc = " MTR object are working as usual while the meter is disabled. No action is"]
    #[doc = " taken and this function returns successfully when the meter of the current"]
    #[doc = " MTR object is already disabled."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] mtr_id"]
    #[doc = "   MTR object ID."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    pub fn rte_mtr_meter_disable(
        port_id: u16,
        mtr_id: u32,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " MTR object meter enable"]
    #[doc = ""]
    #[doc = " Enable the meter of an existing MTR object. If the MTR object has its meter"]
    #[doc = " already enabled, then no action is taken and this function returns"]
    #[doc = " successfully."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] mtr_id"]
    #[doc = "   MTR object ID."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    pub fn rte_mtr_meter_enable(
        port_id: u16,
        mtr_id: u32,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " MTR object meter profile update"]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] mtr_id"]
    #[doc = "   MTR object ID. Needs to be valid."]
    #[doc = " @param[in] meter_profile_id"]
    #[doc = "   Meter profile ID for the current MTR object. Needs to be valid."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    pub fn rte_mtr_meter_profile_update(
        port_id: u16,
        mtr_id: u32,
        meter_profile_id: u32,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " MTR object meter policy update"]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] mtr_id"]
    #[doc = "   MTR object ID. Needs to be valid."]
    #[doc = " @param[in] meter_policy_id"]
    #[doc = "   Meter policy ID for the current MTR object. Needs to be valid."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    pub fn rte_mtr_meter_policy_update(
        port_id: u16,
        mtr_id: u32,
        meter_policy_id: u32,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " MTR object DSCP table update"]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] mtr_id"]
    #[doc = "   MTR object ID. Needs to be valid."]
    #[doc = " @param[in] dscp_table"]
    #[doc = "   When non-NULL: it points to a pre-allocated and pre-populated table with"]
    #[doc = "   exactly 64 elements providing the input color for each value of the"]
    #[doc = "   IPv4/IPv6 Differentiated Services Code Point (DSCP) input packet field."]
    #[doc = "   When NULL: it is equivalent to setting this parameter to an \"all-green\""]
    #[doc = "   populated table (i.e. table with all the 64 elements set to green color)."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    pub fn rte_mtr_meter_dscp_table_update(
        port_id: u16,
        mtr_id: u32,
        dscp_table: *mut rte_color,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " MTR object enabled statistics counters update"]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] mtr_id"]
    #[doc = "   MTR object ID. Needs to be valid."]
    #[doc = " @param[in] stats_mask"]
    #[doc = "   Mask of statistics counter types to be enabled for the current MTR object."]
    #[doc = "   Any statistics counter type not included in this set is to be disabled for"]
    #[doc = "   the current MTR object."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see enum rte_mtr_stats_type"]
    pub fn rte_mtr_stats_update(
        port_id: u16,
        mtr_id: u32,
        stats_mask: u64,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " MTR object statistics counters read"]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] mtr_id"]
    #[doc = "   MTR object ID. Needs to be valid."]
    #[doc = " @param[out] stats"]
    #[doc = "   When non-NULL, it contains the current value for the statistics counters"]
    #[doc = "   enabled for the current MTR object."]
    #[doc = " @param[out] stats_mask"]
    #[doc = "   When non-NULL, it contains the mask of statistics counter types that are"]
    #[doc = "   currently enabled for this MTR object, indicating which of the counters"]
    #[doc = "   retrieved with the *stats* structure are valid."]
    #[doc = " @param[in] clear"]
    #[doc = "   When this parameter has a non-zero value, the statistics counters are"]
    #[doc = "   cleared (i.e. set to zero) immediately after they have been read,"]
    #[doc = "   otherwise the statistics counters are left untouched."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see enum rte_mtr_stats_type"]
    pub fn rte_mtr_stats_read(
        port_id: u16,
        mtr_id: u32,
        stats: *mut rte_mtr_stats,
        stats_mask: *mut u64,
        clear: ::std::os::raw::c_int,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @internal MTR capabilities get."]
pub type rte_mtr_capabilities_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        cap: *mut rte_mtr_capabilities,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal MTR meter profile add."]
pub type rte_mtr_meter_profile_add_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        meter_profile_id: u32,
        profile: *mut rte_mtr_meter_profile,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal MTR meter profile delete."]
pub type rte_mtr_meter_profile_delete_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        meter_profile_id: u32,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal MTR meter policy validate."]
pub type rte_mtr_meter_policy_validate_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        policy: *mut rte_mtr_meter_policy_params,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal MTR meter policy add."]
pub type rte_mtr_meter_policy_add_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        policy_id: u32,
        policy: *mut rte_mtr_meter_policy_params,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal MTR meter policy delete."]
pub type rte_mtr_meter_policy_delete_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        policy_id: u32,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal MTR object create."]
pub type rte_mtr_create_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mtr_id: u32,
        params: *mut rte_mtr_params,
        shared: ::std::os::raw::c_int,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal MTR object destroy."]
pub type rte_mtr_destroy_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mtr_id: u32,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal MTR object meter enable."]
pub type rte_mtr_meter_enable_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mtr_id: u32,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal MTR object meter disable."]
pub type rte_mtr_meter_disable_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mtr_id: u32,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal MTR object meter profile update."]
pub type rte_mtr_meter_profile_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mtr_id: u32,
        meter_profile_id: u32,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal MTR object meter policy update."]
pub type rte_mtr_meter_policy_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mtr_id: u32,
        meter_policy_id: u32,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal MTR object meter DSCP table update."]
pub type rte_mtr_meter_dscp_table_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mtr_id: u32,
        dscp_table: *mut rte_color,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal MTR object enabled stats update."]
pub type rte_mtr_stats_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mtr_id: u32,
        stats_mask: u64,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal MTR object stats read."]
pub type rte_mtr_stats_read_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mtr_id: u32,
        stats: *mut rte_mtr_stats,
        stats_mask: *mut u64,
        clear: ::std::os::raw::c_int,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mtr_ops {
    #[doc = " MTR capabilities get"]
    pub capabilities_get: rte_mtr_capabilities_get_t,
    #[doc = " MTR meter profile add"]
    pub meter_profile_add: rte_mtr_meter_profile_add_t,
    #[doc = " MTR meter profile delete"]
    pub meter_profile_delete: rte_mtr_meter_profile_delete_t,
    #[doc = " MTR object create"]
    pub create: rte_mtr_create_t,
    #[doc = " MTR object destroy"]
    pub destroy: rte_mtr_destroy_t,
    #[doc = " MTR object meter enable"]
    pub meter_enable: rte_mtr_meter_enable_t,
    #[doc = " MTR object meter disable"]
    pub meter_disable: rte_mtr_meter_disable_t,
    #[doc = " MTR object meter profile update"]
    pub meter_profile_update: rte_mtr_meter_profile_update_t,
    #[doc = " MTR object meter DSCP table update"]
    pub meter_dscp_table_update: rte_mtr_meter_dscp_table_update_t,
    #[doc = " MTR object enabled stats update"]
    pub stats_update: rte_mtr_stats_update_t,
    #[doc = " MTR object stats read"]
    pub stats_read: rte_mtr_stats_read_t,
    #[doc = " MTR meter policy validate"]
    pub meter_policy_validate: rte_mtr_meter_policy_validate_t,
    #[doc = " MTR meter policy add"]
    pub meter_policy_add: rte_mtr_meter_policy_add_t,
    #[doc = " MTR meter policy delete"]
    pub meter_policy_delete: rte_mtr_meter_policy_delete_t,
    #[doc = " MTR object meter policy update"]
    pub meter_policy_update: rte_mtr_meter_policy_update_t,
}
extern "C" {
    #[doc = " Get generic traffic metering and policing operations structure from a port"]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The traffic metering and policing operations structure associated with"]
    #[doc = "   port_id on success, NULL otherwise."]
    pub fn rte_mtr_ops_get(port_id: u16, error: *mut rte_mtr_error) -> *const rte_mtr_ops;
}
#[doc = " Structure containing header lengths associated to a packet, filled"]
#[doc = " by rte_net_get_ptype()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_net_hdr_lens {
    pub l2_len: u8,
    pub inner_l2_len: u8,
    pub l3_len: u16,
    pub inner_l3_len: u16,
    pub tunnel_len: u16,
    pub l4_len: u8,
    pub inner_l4_len: u8,
}
extern "C" {
    #[doc = " Skip IPv6 header extensions."]
    #[doc = ""]
    #[doc = " This function skips all IPv6 extensions, returning size of"]
    #[doc = " complete header including options and final protocol value."]
    #[doc = ""]
    #[doc = " @param proto"]
    #[doc = "   Protocol field of IPv6 header."]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf to be parsed."]
    #[doc = " @param off"]
    #[doc = "   On input, must contain the offset to the first byte following"]
    #[doc = "   IPv6 header, on output, contains offset to the first byte"]
    #[doc = "   of next layer (after any IPv6 extension header)"]
    #[doc = " @param frag"]
    #[doc = "   Contains 1 in output if packet is an IPv6 fragment."]
    #[doc = " @return"]
    #[doc = "   Protocol that follows IPv6 header."]
    #[doc = "   -1 if an error occurs during mbuf parsing."]
    pub fn rte_net_skip_ip6_ext(
        proto: u16,
        m: *const rte_mbuf,
        off: *mut u32,
        frag: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse an Ethernet packet to get its packet type."]
    #[doc = ""]
    #[doc = " This function parses the network headers in mbuf data and return its"]
    #[doc = " packet type."]
    #[doc = ""]
    #[doc = " If it is provided by the user, it also fills a rte_net_hdr_lens"]
    #[doc = " structure that contains the lengths of the parsed network"]
    #[doc = " headers. Each length field is valid only if the associated packet"]
    #[doc = " type is set. For instance, hdr_lens->l2_len is valid only if"]
    #[doc = " (retval & RTE_PTYPE_L2_MASK) != RTE_PTYPE_UNKNOWN."]
    #[doc = ""]
    #[doc = " Supported packet types are:"]
    #[doc = "   L2: Ether, Vlan, QinQ"]
    #[doc = "   L3: IPv4, IPv6"]
    #[doc = "   L4: TCP, UDP, SCTP"]
    #[doc = "   Tunnels: IPv4, IPv6, Gre, Nvgre"]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf to be parsed."]
    #[doc = " @param hdr_lens"]
    #[doc = "   A pointer to a structure where the header lengths will be returned,"]
    #[doc = "   or NULL."]
    #[doc = " @param layers"]
    #[doc = "   List of layers to parse. The function will stop at the first"]
    #[doc = "   empty layer. Examples:"]
    #[doc = "   - To parse all known layers, use RTE_PTYPE_ALL_MASK."]
    #[doc = "   - To parse only L2 and L3, use RTE_PTYPE_L2_MASK | RTE_PTYPE_L3_MASK"]
    #[doc = " @return"]
    #[doc = "   The packet type of the packet."]
    pub fn rte_net_get_ptype(
        m: *const rte_mbuf,
        hdr_lens: *mut rte_net_hdr_lens,
        layers: u32,
    ) -> u32;
}
#[doc = " Port config for ethdev_rx and ethdev_tx node."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_node_ethdev_config {
    pub port_id: u16,
    pub num_rx_queues: u16,
    pub num_tx_queues: u16,
    pub mp: *mut *mut rte_mempool,
    pub mp_count: u16,
}
extern "C" {
    #[doc = " Initializes ethdev nodes."]
    #[doc = ""]
    #[doc = " @param cfg"]
    #[doc = "   Array of ethdev config that identifies which port's"]
    #[doc = "   ethdev_rx and ethdev_tx nodes need to be created"]
    #[doc = "   and queue association."]
    #[doc = " @param cnt"]
    #[doc = "   Size of cfg array."]
    #[doc = " @param nb_graphs"]
    #[doc = "   Number of graphs that will be used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on successful initialization, negative otherwise."]
    pub fn rte_node_eth_config(
        cfg: *mut rte_node_ethdev_config,
        cnt: u16,
        nb_graphs: u16,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " IP4 lookup next nodes."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_node_ip4_lookup_next {
    RTE_NODE_IP4_LOOKUP_NEXT_REWRITE = 0,
    RTE_NODE_IP4_LOOKUP_NEXT_PKT_DROP = 1,
    RTE_NODE_IP4_LOOKUP_NEXT_MAX = 2,
}
extern "C" {
    #[doc = " Add ipv4 route to lookup table."]
    #[doc = ""]
    #[doc = " @param ip"]
    #[doc = "   IP address of route to be added."]
    #[doc = " @param depth"]
    #[doc = "   Depth of the rule to be added."]
    #[doc = " @param next_hop"]
    #[doc = "   Next hop id of the rule result to be added."]
    #[doc = " @param next_node"]
    #[doc = "   Next node to redirect traffic to."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, negative otherwise."]
    pub fn rte_node_ip4_route_add(
        ip: u32,
        depth: u8,
        next_hop: u16,
        next_node: rte_node_ip4_lookup_next,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a next hop's rewrite data."]
    #[doc = ""]
    #[doc = " @param next_hop"]
    #[doc = "   Next hop id to add rewrite data to."]
    #[doc = " @param rewrite_data"]
    #[doc = "   Rewrite data."]
    #[doc = " @param rewrite_len"]
    #[doc = "   Length of rewrite data."]
    #[doc = " @param dst_port"]
    #[doc = "   Destination port to redirect traffic to."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, negative otherwise."]
    pub fn rte_node_ip4_rewrite_add(
        next_hop: u16,
        rewrite_data: *mut u8,
        rewrite_len: u8,
        dst_port: u16,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pcapng {
    _unused: [u8; 0],
}
pub type rte_pcapng_t = rte_pcapng;
extern "C" {
    #[doc = " Write data to existing open file"]
    #[doc = ""]
    #[doc = " @param fd"]
    #[doc = "   file descriptor"]
    #[doc = " @param osname"]
    #[doc = "   Optional description of the operating system."]
    #[doc = "   Examples: \"Debian 11\", \"Windows Server 22\""]
    #[doc = " @param hardware"]
    #[doc = "   Optional description of the hardware used to create this file."]
    #[doc = "   Examples: \"x86 Virtual Machine\""]
    #[doc = " @param appname"]
    #[doc = "   Optional: application name recorded in the pcapng file."]
    #[doc = "   Example: \"dpdk-dumpcap 1.0 (DPDK 20.11)\""]
    #[doc = " @param comment"]
    #[doc = "   Optional comment to add to file header."]
    #[doc = " @return"]
    #[doc = "   handle to library, or NULL in case of error (and rte_errno is set)."]
    pub fn rte_pcapng_fdopen(
        fd: ::std::os::raw::c_int,
        osname: *const ::std::os::raw::c_char,
        hardware: *const ::std::os::raw::c_char,
        appname: *const ::std::os::raw::c_char,
        comment: *const ::std::os::raw::c_char,
    ) -> *mut rte_pcapng_t;
}
extern "C" {
    #[doc = " Close capture file"]
    #[doc = ""]
    #[doc = " @param self"]
    #[doc = "  handle to library"]
    pub fn rte_pcapng_close(self_: *mut rte_pcapng_t);
}
#[repr(u32)]
#[doc = " Direction flag"]
#[doc = " These should match Enhanced Packet Block flag bits"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_pcapng_direction {
    RTE_PCAPNG_DIRECTION_UNKNOWN = 0,
    RTE_PCAPNG_DIRECTION_IN = 1,
    RTE_PCAPNG_DIRECTION_OUT = 2,
}
extern "C" {
    #[doc = " Format an mbuf for writing to file."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The Ethernet port on which packet was received"]
    #[doc = "   or is going to be transmitted."]
    #[doc = " @param queue"]
    #[doc = "   The queue on the Ethernet port where packet was received"]
    #[doc = "   or is going to be transmitted."]
    #[doc = " @param mp"]
    #[doc = "   The mempool from which the \"clone\" mbufs are allocated."]
    #[doc = " @param m"]
    #[doc = "   The mbuf to copy"]
    #[doc = " @param length"]
    #[doc = "   The upper limit on bytes to copy.  Passing UINT32_MAX"]
    #[doc = "   means all data (after offset)."]
    #[doc = " @param timestamp"]
    #[doc = "   The timestamp in TSC cycles."]
    #[doc = " @param direction"]
    #[doc = "   The direction of the packer: receive, transmit or unknown."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - The pointer to the new mbuf formatted for pcapng_write"]
    #[doc = "   - NULL if allocation fails."]
    #[doc = ""]
    pub fn rte_pcapng_copy(
        port_id: u16,
        queue: u32,
        m: *const rte_mbuf,
        mp: *mut rte_mempool,
        length: u32,
        timestamp: u64,
        direction: rte_pcapng_direction,
    ) -> *mut rte_mbuf;
}
extern "C" {
    #[doc = " Determine optimum mbuf data size."]
    #[doc = ""]
    #[doc = " @param length"]
    #[doc = "   The largest packet that will be copied."]
    #[doc = " @return"]
    #[doc = "   The minimum size of mbuf data to handle packet with length bytes."]
    #[doc = "   Accounting for required header and trailer fields"]
    pub fn rte_pcapng_mbuf_size(length: u32) -> u32;
}
extern "C" {
    #[doc = " Write packets to the capture file."]
    #[doc = ""]
    #[doc = " Packets to be captured are copied by rte_pcapng_copy()"]
    #[doc = " and then this function is called to write them to the file."]
    #[doc = ""]
    #[doc = " @warning"]
    #[doc = " Do not pass original mbufs from transmit or receive"]
    #[doc = " or file will be invalid pcapng format."]
    #[doc = ""]
    #[doc = " @param self"]
    #[doc = "  The handle to the packet capture file"]
    #[doc = " @param pkts"]
    #[doc = "  The address of an array of *nb_pkts* pointers to *rte_mbuf* structures"]
    #[doc = "  which contain the output packets"]
    #[doc = " @param nb_pkts"]
    #[doc = "  The number of packets to write to the file."]
    #[doc = " @return"]
    #[doc = "  The number of bytes written to file, -1 on failure to write file."]
    #[doc = "  The mbuf's in *pkts* are always freed."]
    pub fn rte_pcapng_write_packets(
        self_: *mut rte_pcapng_t,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " Write an Interface statistics block."]
    #[doc = " For statistics, use 0 if don't know or care to report it."]
    #[doc = " Should be called before closing capture to report results."]
    #[doc = ""]
    #[doc = " @param self"]
    #[doc = "  The handle to the packet capture file"]
    #[doc = " @param port"]
    #[doc = "  The Ethernet port to report stats on."]
    #[doc = " @param comment"]
    #[doc = "   Optional comment to add to statistics."]
    #[doc = " @param start_time"]
    #[doc = "  The time when packet capture was started in nanoseconds."]
    #[doc = "  Optional: can be zero if not known."]
    #[doc = " @param end_time"]
    #[doc = "  The time when packet capture was stopped in nanoseconds."]
    #[doc = "  Optional: can be zero if not finished;"]
    #[doc = " @param ifrecv"]
    #[doc = "  The number of packets received by capture."]
    #[doc = "  Optional: use UINT64_MAX if not known."]
    #[doc = " @param ifdrop"]
    #[doc = "  The number of packets missed by the capture process."]
    #[doc = "  Optional: use UINT64_MAX if not known."]
    #[doc = " @return"]
    #[doc = "  number of bytes written to file, -1 on failure to write file"]
    pub fn rte_pcapng_write_stats(
        self_: *mut rte_pcapng_t,
        port: u16,
        comment: *const ::std::os::raw::c_char,
        start_time: u64,
        end_time: u64,
        ifrecv: u64,
        ifdrop: u64,
    ) -> ssize_t;
}
pub const EBPF_REG_0: _bindgen_ty_25 = _bindgen_ty_25::EBPF_REG_0;
pub const EBPF_REG_1: _bindgen_ty_25 = _bindgen_ty_25::EBPF_REG_1;
pub const EBPF_REG_2: _bindgen_ty_25 = _bindgen_ty_25::EBPF_REG_2;
pub const EBPF_REG_3: _bindgen_ty_25 = _bindgen_ty_25::EBPF_REG_3;
pub const EBPF_REG_4: _bindgen_ty_25 = _bindgen_ty_25::EBPF_REG_4;
pub const EBPF_REG_5: _bindgen_ty_25 = _bindgen_ty_25::EBPF_REG_5;
pub const EBPF_REG_6: _bindgen_ty_25 = _bindgen_ty_25::EBPF_REG_6;
pub const EBPF_REG_7: _bindgen_ty_25 = _bindgen_ty_25::EBPF_REG_7;
pub const EBPF_REG_8: _bindgen_ty_25 = _bindgen_ty_25::EBPF_REG_8;
pub const EBPF_REG_9: _bindgen_ty_25 = _bindgen_ty_25::EBPF_REG_9;
pub const EBPF_REG_10: _bindgen_ty_25 = _bindgen_ty_25::EBPF_REG_10;
pub const EBPF_REG_NUM: _bindgen_ty_25 = _bindgen_ty_25::EBPF_REG_NUM;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_25 {
    EBPF_REG_0 = 0,
    EBPF_REG_1 = 1,
    EBPF_REG_2 = 2,
    EBPF_REG_3 = 3,
    EBPF_REG_4 = 4,
    EBPF_REG_5 = 5,
    EBPF_REG_6 = 6,
    EBPF_REG_7 = 7,
    EBPF_REG_8 = 8,
    EBPF_REG_9 = 9,
    EBPF_REG_10 = 10,
    EBPF_REG_NUM = 11,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ebpf_insn {
    pub code: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub off: i16,
    pub imm: i32,
}
impl ebpf_insn {
    #[inline]
    pub fn dst_reg(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_dst_reg(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn src_reg(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_src_reg(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(dst_reg: u8, src_reg: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let dst_reg: u8 = unsafe { ::std::mem::transmute(dst_reg) };
            dst_reg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let src_reg: u8 = unsafe { ::std::mem::transmute(src_reg) };
            src_reg as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(u32)]
#[doc = " Possible types for function/BPF program arguments."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_bpf_arg_type {
    #[doc = "< undefined"]
    RTE_BPF_ARG_UNDEF = 0,
    #[doc = "< scalar value"]
    RTE_BPF_ARG_RAW = 1,
    #[doc = "< pointer to data buffer"]
    RTE_BPF_ARG_PTR = 16,
    #[doc = "< pointer to rte_mbuf"]
    RTE_BPF_ARG_PTR_MBUF = 17,
    #[doc = "< reserved for internal use"]
    RTE_BPF_ARG_RESERVED = 18,
}
#[doc = " function argument information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bpf_arg {
    pub type_: rte_bpf_arg_type,
    #[doc = " for ptr type - max size of data buffer it points to"]
    #[doc = " for raw type - the size (in bytes) of the value"]
    pub size: size_t,
    pub buf_size: size_t,
}
#[repr(u32)]
#[doc = " Possible types for external symbols."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_bpf_xtype {
    #[doc = "< function"]
    RTE_BPF_XTYPE_FUNC = 0,
    #[doc = "< variable"]
    RTE_BPF_XTYPE_VAR = 1,
}
#[doc = " Definition for external symbols available in the BPF program."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_bpf_xsym {
    #[doc = "< name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< type"]
    pub type_: rte_bpf_xtype,
    pub __bindgen_anon_1: rte_bpf_xsym__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_bpf_xsym__bindgen_ty_1 {
    pub func: rte_bpf_xsym__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< external variable"]
    pub var: rte_bpf_xsym__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bpf_xsym__bindgen_ty_1__bindgen_ty_1 {
    pub val: ::std::option::Option<
        unsafe extern "C" fn(arg1: u64, arg2: u64, arg3: u64, arg4: u64, arg5: u64) -> u64,
    >,
    pub nb_args: u32,
    pub args: [rte_bpf_arg; 5usize],
    #[doc = "< function return value."]
    pub ret: rte_bpf_arg,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bpf_xsym__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< actual memory location"]
    pub val: *mut ::std::os::raw::c_void,
    #[doc = "< type, size, etc."]
    pub desc: rte_bpf_arg,
}
#[doc = " Input parameters for loading eBPF code."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bpf_prm {
    #[doc = "< array of eBPF instructions"]
    pub ins: *const ebpf_insn,
    #[doc = "< number of instructions in ins"]
    pub nb_ins: u32,
    pub xsym: *const rte_bpf_xsym,
    #[doc = "< number of elements in xsym"]
    pub nb_xsym: u32,
    #[doc = "< eBPF program input arg description"]
    pub prog_arg: rte_bpf_arg,
}
#[doc = " Information about compiled into native ISA eBPF code."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bpf_jit {
    #[doc = "< JIT-ed native code"]
    pub func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> u64>,
    #[doc = "< size of JIT-ed code"]
    pub sz: size_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bpf {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " De-allocate all memory used by this eBPF execution context."]
    #[doc = ""]
    #[doc = " @param bpf"]
    #[doc = "   BPF handle to destroy."]
    pub fn rte_bpf_destroy(bpf: *mut rte_bpf);
}
extern "C" {
    #[doc = " Create a new eBPF execution context and load given BPF code into it."]
    #[doc = ""]
    #[doc = " @param prm"]
    #[doc = "  Parameters used to create and initialise the BPF execution context."]
    #[doc = " @return"]
    #[doc = "   BPF handle that is used in future BPF operations,"]
    #[doc = "   or NULL on error, with error code set in rte_errno."]
    #[doc = "   Possible rte_errno errors include:"]
    #[doc = "   - EINVAL - invalid parameter passed to function"]
    #[doc = "   - ENOMEM - can't reserve enough memory"]
    pub fn rte_bpf_load(prm: *const rte_bpf_prm) -> *mut rte_bpf;
}
extern "C" {
    #[doc = " Create a new eBPF execution context and load BPF code from given ELF"]
    #[doc = " file into it."]
    #[doc = " Note that if the function will encounter EBPF_PSEUDO_CALL instruction"]
    #[doc = " that references external symbol, it will treat is as standard BPF_CALL"]
    #[doc = " to the external helper function."]
    #[doc = ""]
    #[doc = " @param prm"]
    #[doc = "  Parameters used to create and initialise the BPF execution context."]
    #[doc = " @param fname"]
    #[doc = "  Pathname for a ELF file."]
    #[doc = " @param sname"]
    #[doc = "  Name of the executable section within the file to load."]
    #[doc = " @return"]
    #[doc = "   BPF handle that is used in future BPF operations,"]
    #[doc = "   or NULL on error, with error code set in rte_errno."]
    #[doc = "   Possible rte_errno errors include:"]
    #[doc = "   - EINVAL - invalid parameter passed to function"]
    #[doc = "   - ENOMEM - can't reserve enough memory"]
    pub fn rte_bpf_elf_load(
        prm: *const rte_bpf_prm,
        fname: *const ::std::os::raw::c_char,
        sname: *const ::std::os::raw::c_char,
    ) -> *mut rte_bpf;
}
extern "C" {
    #[doc = " Execute given BPF bytecode."]
    #[doc = ""]
    #[doc = " @param bpf"]
    #[doc = "   handle for the BPF code to execute."]
    #[doc = " @param ctx"]
    #[doc = "   pointer to input context."]
    #[doc = " @return"]
    #[doc = "   BPF execution return value."]
    pub fn rte_bpf_exec(bpf: *const rte_bpf, ctx: *mut ::std::os::raw::c_void) -> u64;
}
extern "C" {
    #[doc = " Execute given BPF bytecode over a set of input contexts."]
    #[doc = ""]
    #[doc = " @param bpf"]
    #[doc = "   handle for the BPF code to execute."]
    #[doc = " @param ctx"]
    #[doc = "   array of pointers to the input contexts."]
    #[doc = " @param rc"]
    #[doc = "   array of return values (one per input)."]
    #[doc = " @param num"]
    #[doc = "   number of elements in ctx[] (and rc[])."]
    #[doc = " @return"]
    #[doc = "   number of successfully processed inputs."]
    pub fn rte_bpf_exec_burst(
        bpf: *const rte_bpf,
        ctx: *mut *mut ::std::os::raw::c_void,
        rc: *mut u64,
        num: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Provide information about natively compiled code for given BPF handle."]
    #[doc = ""]
    #[doc = " @param bpf"]
    #[doc = "   handle for the BPF code."]
    #[doc = " @param jit"]
    #[doc = "   pointer to the rte_bpf_jit structure to be filled with related data."]
    #[doc = " @return"]
    #[doc = "   - -EINVAL if the parameters are invalid."]
    #[doc = "   - Zero if operation completed successfully."]
    pub fn rte_bpf_get_jit(bpf: *const rte_bpf, jit: *mut rte_bpf_jit) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump epf instructions to a file."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    #[doc = " @param buf"]
    #[doc = "   A pointer to BPF instructions"]
    #[doc = " @param len"]
    #[doc = "   Number of BPF instructions to dump."]
    pub fn rte_bpf_dump(f: *mut FILE, buf: *const ebpf_insn, len: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_program {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Convert a Classic BPF program from libpcap into a DPDK BPF code."]
    #[doc = ""]
    #[doc = " @param prog"]
    #[doc = "  Classic BPF program from pcap_compile()."]
    #[doc = " @return"]
    #[doc = "   Pointer to BPF program (allocated with *rte_malloc*)"]
    #[doc = "   that is used in future BPF operations,"]
    #[doc = "   or NULL on error, with error code set in rte_errno."]
    #[doc = "   Possible rte_errno errors include:"]
    #[doc = "   - EINVAL - invalid parameter passed to function"]
    #[doc = "   - ENOMEM - can't reserve enough memory"]
    #[doc = "   - ENOTSUP - operation not supported"]
    pub fn rte_bpf_convert(prog: *const bpf_program) -> *mut rte_bpf_prm;
}
pub const RTE_PDUMP_FLAG_RX: _bindgen_ty_26 = _bindgen_ty_26::RTE_PDUMP_FLAG_RX;
pub const RTE_PDUMP_FLAG_TX: _bindgen_ty_26 = _bindgen_ty_26::RTE_PDUMP_FLAG_TX;
pub const RTE_PDUMP_FLAG_RXTX: _bindgen_ty_26 = _bindgen_ty_26::RTE_PDUMP_FLAG_RXTX;
pub const RTE_PDUMP_FLAG_PCAPNG: _bindgen_ty_26 = _bindgen_ty_26::RTE_PDUMP_FLAG_PCAPNG;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_26 {
    RTE_PDUMP_FLAG_RX = 1,
    RTE_PDUMP_FLAG_TX = 2,
    RTE_PDUMP_FLAG_RXTX = 3,
    RTE_PDUMP_FLAG_PCAPNG = 4,
}
extern "C" {
    #[doc = " Initialize packet capturing handling"]
    #[doc = ""]
    #[doc = " Register the IPC action for communication with target (primary) process."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    0 on success, -1 on error"]
    pub fn rte_pdump_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Un initialize packet capturing handling"]
    #[doc = ""]
    #[doc = " Unregister the IPC action for communication with target (primary) process."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    0 on success, -1 on error"]
    pub fn rte_pdump_uninit() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enables packet capturing on given port and queue."]
    #[doc = ""]
    #[doc = " @param port"]
    #[doc = "  port on which packet capturing should be enabled."]
    #[doc = " @param queue"]
    #[doc = "  queue of a given port on which packet capturing should be enabled."]
    #[doc = "  users should pass on value UINT16_MAX to enable packet capturing on all"]
    #[doc = "  queues of a given port."]
    #[doc = " @param flags"]
    #[doc = "  flags specifies RTE_PDUMP_FLAG_RX/RTE_PDUMP_FLAG_TX/RTE_PDUMP_FLAG_RXTX"]
    #[doc = "  on which packet capturing should be enabled for a given port and queue."]
    #[doc = " @param ring"]
    #[doc = "  ring on which captured packets will be enqueued for user."]
    #[doc = " @param mp"]
    #[doc = "  mempool on to which original packets will be mirrored or duplicated."]
    #[doc = " @param filter"]
    #[doc = "  Unused should be NULL."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    0 on success, -1 on error, rte_errno is set accordingly."]
    pub fn rte_pdump_enable(
        port: u16,
        queue: u16,
        flags: u32,
        ring: *mut rte_ring,
        mp: *mut rte_mempool,
        filter: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Enables packet capturing on given port and queue with filtering."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "  The Ethernet port on which packet capturing should be enabled."]
    #[doc = " @param queue"]
    #[doc = "  The queue on the Ethernet port which packet capturing"]
    #[doc = "  should be enabled. Pass UINT16_MAX to enable packet capturing on all"]
    #[doc = "  queues of a given port."]
    #[doc = " @param flags"]
    #[doc = "  Pdump library flags that specify direction and packet format."]
    #[doc = " @param snaplen"]
    #[doc = "  The upper limit on bytes to copy."]
    #[doc = "  Passing UINT32_MAX means capture all the possible data."]
    #[doc = " @param ring"]
    #[doc = "  The ring on which captured packets will be enqueued for user."]
    #[doc = " @param mp"]
    #[doc = "  The mempool on to which original packets will be mirrored or duplicated."]
    #[doc = " @param prm"]
    #[doc = "  Use BPF program to run to filter packes (can be NULL)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    0 on success, -1 on error, rte_errno is set accordingly."]
    pub fn rte_pdump_enable_bpf(
        port_id: u16,
        queue: u16,
        flags: u32,
        snaplen: u32,
        ring: *mut rte_ring,
        mp: *mut rte_mempool,
        prm: *const rte_bpf_prm,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disables packet capturing on given port and queue."]
    #[doc = ""]
    #[doc = " @param port"]
    #[doc = "  port on which packet capturing should be disabled."]
    #[doc = " @param queue"]
    #[doc = "  queue of a given port on which packet capturing should be disabled."]
    #[doc = "  users should pass on value UINT16_MAX to disable packet capturing on all"]
    #[doc = "  queues of a given port."]
    #[doc = " @param flags"]
    #[doc = "  flags specifies RTE_PDUMP_FLAG_RX/RTE_PDUMP_FLAG_TX/RTE_PDUMP_FLAG_RXTX"]
    #[doc = "  on which packet capturing should be enabled for a given port and queue."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    0 on success, -1 on error, rte_errno is set accordingly."]
    pub fn rte_pdump_disable(port: u16, queue: u16, flags: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enables packet capturing on given device id and queue."]
    #[doc = " device_id can be name or pci address of device."]
    #[doc = ""]
    #[doc = " @param device_id"]
    #[doc = "  device id on which packet capturing should be enabled."]
    #[doc = " @param queue"]
    #[doc = "  queue of a given device id on which packet capturing should be enabled."]
    #[doc = "  users should pass on value UINT16_MAX to enable packet capturing on all"]
    #[doc = "  queues of a given device id."]
    #[doc = " @param flags"]
    #[doc = "  flags specifies RTE_PDUMP_FLAG_RX/RTE_PDUMP_FLAG_TX/RTE_PDUMP_FLAG_RXTX"]
    #[doc = "  on which packet capturing should be enabled for a given port and queue."]
    #[doc = " @param ring"]
    #[doc = "  ring on which captured packets will be enqueued for user."]
    #[doc = " @param mp"]
    #[doc = "  mempool on to which original packets will be mirrored or duplicated."]
    #[doc = " @param filter"]
    #[doc = "  unused should be NULL"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    0 on success, -1 on error, rte_errno is set accordingly."]
    pub fn rte_pdump_enable_by_deviceid(
        device_id: *mut ::std::os::raw::c_char,
        queue: u16,
        flags: u32,
        ring: *mut rte_ring,
        mp: *mut rte_mempool,
        filter: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Enables packet capturing on given device id and queue with filtering."]
    #[doc = " device_id can be name or pci address of device."]
    #[doc = ""]
    #[doc = " @param device_id"]
    #[doc = "  device id on which packet capturing should be enabled."]
    #[doc = " @param queue"]
    #[doc = "  The queue on the Ethernet port which packet capturing"]
    #[doc = "  should be enabled. Pass UINT16_MAX to enable packet capturing on all"]
    #[doc = "  queues of a given port."]
    #[doc = " @param flags"]
    #[doc = "  Pdump library flags that specify direction and packet format."]
    #[doc = " @param snaplen"]
    #[doc = "  The upper limit on bytes to copy."]
    #[doc = "  Passing UINT32_MAX means capture all the possible data."]
    #[doc = " @param ring"]
    #[doc = "  The ring on which captured packets will be enqueued for user."]
    #[doc = " @param mp"]
    #[doc = "  The mempool on to which original packets will be mirrored or duplicated."]
    #[doc = " @param filter"]
    #[doc = "  Use BPF program to run to filter packes (can be NULL)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    0 on success, -1 on error, rte_errno is set accordingly."]
    pub fn rte_pdump_enable_bpf_by_deviceid(
        device_id: *const ::std::os::raw::c_char,
        queue: u16,
        flags: u32,
        snaplen: u32,
        ring: *mut rte_ring,
        mp: *mut rte_mempool,
        filter: *const rte_bpf_prm,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disables packet capturing on given device_id and queue."]
    #[doc = " device_id can be name or pci address of device."]
    #[doc = ""]
    #[doc = " @param device_id"]
    #[doc = "  pci address or name of the device on which packet capturing"]
    #[doc = "  should be disabled."]
    #[doc = " @param queue"]
    #[doc = "  queue of a given device on which packet capturing should be disabled."]
    #[doc = "  users should pass on value UINT16_MAX to disable packet capturing on all"]
    #[doc = "  queues of a given device id."]
    #[doc = " @param flags"]
    #[doc = "  flags specifies RTE_PDUMP_FLAG_RX/RTE_PDUMP_FLAG_TX/RTE_PDUMP_FLAG_RXTX"]
    #[doc = "  on which packet capturing should be enabled for a given port and queue."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    0 on success, -1 on error, rte_errno is set accordingly."]
    pub fn rte_pdump_disable_by_deviceid(
        device_id: *mut ::std::os::raw::c_char,
        queue: u16,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
#[doc = " A structure used to retrieve statistics from packet capture."]
#[doc = " The statistics are sum of both receive and transmit queues."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pdump_stats {
    #[doc = "< Number of packets accepted by filter."]
    pub accepted: u64,
    #[doc = "< Number of packets rejected by filter."]
    pub filtered: u64,
    #[doc = "< Number of mbuf allocation failures."]
    pub nombuf: u64,
    #[doc = "< Number of missed packets due to ring full."]
    pub ringfull: u64,
    #[doc = "< Reserved and pad to cache line"]
    pub reserved: [u64; 4usize],
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Retrieve the packet capture statistics for a queue."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param stats"]
    #[doc = "   A pointer to structure of type *rte_pdump_stats* to be filled in."]
    #[doc = " @return"]
    #[doc = "   Zero if successful. -1 on error and rte_errno is set."]
    pub fn rte_pdump_stats(port_id: u16, stats: *mut rte_pdump_stats) -> ::std::os::raw::c_int;
}
#[doc = " PIE configuration parameters passed by user"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pie_params {
    #[doc = "< Latency Target (milliseconds)"]
    pub qdelay_ref: u16,
    #[doc = "< Update interval for drop probability (milliseconds)"]
    pub dp_update_interval: u16,
    #[doc = "< Max Burst Allowance (milliseconds)"]
    pub max_burst: u16,
    #[doc = "< Tailq drop threshold (packet counts)"]
    pub tailq_th: u16,
}
#[doc = " PIE configuration parameters"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pie_config {
    #[doc = "< Latency Target (in CPU cycles.)"]
    pub qdelay_ref: u64,
    #[doc = "< Update interval for drop probability (in CPU cycles)"]
    pub dp_update_interval: u64,
    #[doc = "< Max Burst Allowance (in CPU cycles.)"]
    pub max_burst: u64,
    #[doc = "< Tailq drop threshold (packet counts)"]
    pub tailq_th: u16,
}
#[doc = " PIE run-time data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pie {
    #[doc = "< Flag for activating/deactivating pie"]
    pub active: u16,
    #[doc = "< Flag for activation of measurement cycle"]
    pub in_measurement: u16,
    #[doc = "< Number of bytes departed in current measurement cycle"]
    pub departed_bytes_count: u32,
    #[doc = "< Time to start to measurement cycle (in cpu cycles)"]
    pub start_measurement: u64,
    #[doc = "< Time of last measurement (in cpu cycles)"]
    pub last_measurement: u64,
    #[doc = "< Queue length (packets count)"]
    pub qlen: u64,
    #[doc = "< Queue length (bytes count)"]
    pub qlen_bytes: u64,
    #[doc = "< Time averaged dequeue rate (in cpu cycles)"]
    pub avg_dq_time: u64,
    #[doc = "< Current burst allowance (bytes)"]
    pub burst_allowance: u32,
    #[doc = "< Old queue delay (bytes)"]
    pub qdelay_old: u64,
    #[doc = "< Current packet drop probability"]
    pub drop_prob: f64,
    #[doc = "< Accumulated packet drop probability"]
    pub accu_prob: f64,
}
extern "C" {
    #[doc = " @brief Initialises run-time data"]
    #[doc = ""]
    #[doc = " @param pie [in,out] data pointer to PIE runtime data"]
    #[doc = ""]
    #[doc = " @return Operation status"]
    #[doc = " @retval 0 success"]
    #[doc = " @retval !0 error"]
    pub fn rte_pie_rt_data_init(pie: *mut rte_pie) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Configures a single PIE configuration parameter structure."]
    #[doc = ""]
    #[doc = " @param pie_cfg [in,out] config pointer to a PIE configuration parameter structure"]
    #[doc = " @param qdelay_ref [in]  latency target(milliseconds)"]
    #[doc = " @param dp_update_interval [in] update interval for drop probability (milliseconds)"]
    #[doc = " @param max_burst [in] maximum burst allowance (milliseconds)"]
    #[doc = " @param tailq_th [in] tail drop threshold for the queue (number of packets)"]
    #[doc = ""]
    #[doc = " @return Operation status"]
    #[doc = " @retval 0 success"]
    #[doc = " @retval !0 error"]
    pub fn rte_pie_config_init(
        pie_cfg: *mut rte_pie_config,
        qdelay_ref: u16,
        dp_update_interval: u16,
        max_burst: u16,
        tailq_th: u16,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Input port statistics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_in_stats {
    pub n_pkts_in: u64,
    pub n_pkts_drop: u64,
}
#[doc = " Input port create"]
#[doc = ""]
#[doc = " @param params"]
#[doc = "   Parameters for input port creation"]
#[doc = " @param socket_id"]
#[doc = "   CPU socket ID (e.g. for memory allocation purpose)"]
#[doc = " @return"]
#[doc = "   Handle to input port instance"]
pub type rte_port_in_op_create = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ::std::os::raw::c_void,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Input port free"]
#[doc = ""]
#[doc = " @param port"]
#[doc = "   Handle to input port instance"]
#[doc = " @return"]
#[doc = "   0 on success, error code otherwise"]
pub type rte_port_in_op_free = ::std::option::Option<
    unsafe extern "C" fn(port: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " Input port packet burst RX"]
#[doc = ""]
#[doc = " @param port"]
#[doc = "   Handle to input port instance"]
#[doc = " @param pkts"]
#[doc = "   Burst of input packets"]
#[doc = " @param n_pkts"]
#[doc = "   Number of packets in the input burst"]
#[doc = " @return"]
#[doc = "   0 on success, error code otherwise"]
pub type rte_port_in_op_rx = ::std::option::Option<
    unsafe extern "C" fn(
        port: *mut ::std::os::raw::c_void,
        pkts: *mut *mut rte_mbuf,
        n_pkts: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Input port stats get"]
#[doc = ""]
#[doc = " @param port"]
#[doc = "   Handle to output port instance"]
#[doc = " @param stats"]
#[doc = "   Handle to port_in stats struct to copy data"]
#[doc = " @param clear"]
#[doc = "   Flag indicating that stats should be cleared after read"]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Error code or 0 on success."]
pub type rte_port_in_op_stats_read = ::std::option::Option<
    unsafe extern "C" fn(
        port: *mut ::std::os::raw::c_void,
        stats: *mut rte_port_in_stats,
        clear: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Input port interface defining the input port operation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_in_ops {
    #[doc = "< Create"]
    pub f_create: rte_port_in_op_create,
    #[doc = "< Free"]
    pub f_free: rte_port_in_op_free,
    #[doc = "< Packet RX (packet burst)"]
    pub f_rx: rte_port_in_op_rx,
    #[doc = "< Stats"]
    pub f_stats: rte_port_in_op_stats_read,
}
#[doc = " Output port statistics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_out_stats {
    pub n_pkts_in: u64,
    pub n_pkts_drop: u64,
}
#[doc = " Output port create"]
#[doc = ""]
#[doc = " @param params"]
#[doc = "   Parameters for output port creation"]
#[doc = " @param socket_id"]
#[doc = "   CPU socket ID (e.g. for memory allocation purpose)"]
#[doc = " @return"]
#[doc = "   Handle to output port instance"]
pub type rte_port_out_op_create = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ::std::os::raw::c_void,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Output port free"]
#[doc = ""]
#[doc = " @param port"]
#[doc = "   Handle to output port instance"]
#[doc = " @return"]
#[doc = "   0 on success, error code otherwise"]
pub type rte_port_out_op_free = ::std::option::Option<
    unsafe extern "C" fn(port: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " Output port single packet TX"]
#[doc = ""]
#[doc = " @param port"]
#[doc = "   Handle to output port instance"]
#[doc = " @param pkt"]
#[doc = "   Input packet"]
#[doc = " @return"]
#[doc = "   0 on success, error code otherwise"]
pub type rte_port_out_op_tx = ::std::option::Option<
    unsafe extern "C" fn(
        port: *mut ::std::os::raw::c_void,
        pkt: *mut rte_mbuf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Output port packet burst TX"]
#[doc = ""]
#[doc = " @param port"]
#[doc = "   Handle to output port instance"]
#[doc = " @param pkts"]
#[doc = "   Burst of input packets specified as array of up to 64 pointers to struct"]
#[doc = "   rte_mbuf"]
#[doc = " @param pkts_mask"]
#[doc = "   64-bit bitmask specifying which packets in the input burst are valid. When"]
#[doc = "   pkts_mask bit n is set, then element n of pkts array is pointing to a"]
#[doc = "   valid packet. Otherwise, element n of pkts array will not be accessed."]
#[doc = " @return"]
#[doc = "   0 on success, error code otherwise"]
pub type rte_port_out_op_tx_bulk = ::std::option::Option<
    unsafe extern "C" fn(
        port: *mut ::std::os::raw::c_void,
        pkts: *mut *mut rte_mbuf,
        pkts_mask: u64,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Output port flush"]
#[doc = ""]
#[doc = " @param port"]
#[doc = "   Handle to output port instance"]
#[doc = " @return"]
#[doc = "   0 on success, error code otherwise"]
pub type rte_port_out_op_flush = ::std::option::Option<
    unsafe extern "C" fn(port: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " Output port stats read"]
#[doc = ""]
#[doc = " @param port"]
#[doc = "   Handle to output port instance"]
#[doc = " @param stats"]
#[doc = "   Handle to port_out stats struct to copy data"]
#[doc = " @param clear"]
#[doc = "   Flag indicating that stats should be cleared after read"]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Error code or 0 on success."]
pub type rte_port_out_op_stats_read = ::std::option::Option<
    unsafe extern "C" fn(
        port: *mut ::std::os::raw::c_void,
        stats: *mut rte_port_out_stats,
        clear: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Output port interface defining the output port operation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_out_ops {
    #[doc = "< Create"]
    pub f_create: rte_port_out_op_create,
    #[doc = "< Free"]
    pub f_free: rte_port_out_op_free,
    #[doc = "< Packet TX (single packet)"]
    pub f_tx: rte_port_out_op_tx,
    #[doc = "< Packet TX (packet burst)"]
    pub f_tx_bulk: rte_port_out_op_tx_bulk,
    #[doc = "< Flush"]
    pub f_flush: rte_port_out_op_flush,
    #[doc = "< Stats"]
    pub f_stats: rte_port_out_op_stats_read,
}
#[doc = " Lookup table statistics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_table_stats {
    pub n_pkts_in: u64,
    pub n_pkts_lookup_miss: u64,
}
#[doc = " Lookup table create"]
#[doc = ""]
#[doc = " @param params"]
#[doc = "   Parameters for lookup table creation. The underlying data structure is"]
#[doc = "   different for each lookup table type."]
#[doc = " @param socket_id"]
#[doc = "   CPU socket ID (e.g. for memory allocation purpose)"]
#[doc = " @param entry_size"]
#[doc = "   Data size of each lookup table entry (measured in bytes)"]
#[doc = " @return"]
#[doc = "   Handle to lookup table instance"]
pub type rte_table_op_create = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ::std::os::raw::c_void,
        socket_id: ::std::os::raw::c_int,
        entry_size: u32,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Lookup table free"]
#[doc = ""]
#[doc = " @param table"]
#[doc = "   Handle to lookup table instance"]
#[doc = " @return"]
#[doc = "   0 on success, error code otherwise"]
pub type rte_table_op_free = ::std::option::Option<
    unsafe extern "C" fn(table: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " Lookup table entry add"]
#[doc = ""]
#[doc = " @param table"]
#[doc = "   Handle to lookup table instance"]
#[doc = " @param key"]
#[doc = "   Lookup key"]
#[doc = " @param entry"]
#[doc = "   Data to be associated with the current key. This parameter has to point to"]
#[doc = "   a valid memory buffer where the first entry_size bytes (table create"]
#[doc = "   parameter) are populated with the data."]
#[doc = " @param key_found"]
#[doc = "   After successful invocation, *key_found is set to a value different than 0"]
#[doc = "   if the current key is already present in the table and to 0 if not. This"]
#[doc = "   pointer has to be set to a valid memory location before the table entry add"]
#[doc = "   function is called."]
#[doc = " @param entry_ptr"]
#[doc = "   After successful invocation, *entry_ptr stores the handle to the table"]
#[doc = "   entry containing the data associated with the current key. This handle can"]
#[doc = "   be used to perform further read-write accesses to this entry. This handle"]
#[doc = "   is valid until the key is deleted from the table or the same key is"]
#[doc = "   re-added to the table, typically to associate it with different data. This"]
#[doc = "   pointer has to be set to a valid memory location before the function is"]
#[doc = "   called."]
#[doc = " @return"]
#[doc = "   0 on success, error code otherwise"]
pub type rte_table_op_entry_add = ::std::option::Option<
    unsafe extern "C" fn(
        table: *mut ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_void,
        entry: *mut ::std::os::raw::c_void,
        key_found: *mut ::std::os::raw::c_int,
        entry_ptr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Lookup table entry delete"]
#[doc = ""]
#[doc = " @param table"]
#[doc = "   Handle to lookup table instance"]
#[doc = " @param key"]
#[doc = "   Lookup key"]
#[doc = " @param key_found"]
#[doc = "   After successful invocation, *key_found is set to a value different than 0"]
#[doc = "   if the current key was present in the table before the delete operation"]
#[doc = "   was performed and to 0 if not. This pointer has to be set to a valid"]
#[doc = "   memory location before the table entry delete function is called."]
#[doc = " @param entry"]
#[doc = "   After successful invocation, if the key is found in the table (*key found"]
#[doc = "   is different than 0 after function call is completed) and entry points to"]
#[doc = "   a valid buffer (entry is set to a value different than NULL before the"]
#[doc = "   function is called), then the first entry_size bytes (table create"]
#[doc = "   parameter) in *entry store a copy of table entry that contained the data"]
#[doc = "   associated with the current key before the key was deleted."]
#[doc = " @return"]
#[doc = "   0 on success, error code otherwise"]
pub type rte_table_op_entry_delete = ::std::option::Option<
    unsafe extern "C" fn(
        table: *mut ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_void,
        key_found: *mut ::std::os::raw::c_int,
        entry: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Lookup table entry add bulk"]
#[doc = ""]
#[doc = " @param table"]
#[doc = "   Handle to lookup table instance"]
#[doc = " @param keys"]
#[doc = "   Array containing lookup keys"]
#[doc = " @param entries"]
#[doc = "   Array containing data to be associated with each key. Every item in the"]
#[doc = "   array has to point to a valid memory buffer where the first entry_size"]
#[doc = "   bytes (table create parameter) are populated with the data."]
#[doc = " @param n_keys"]
#[doc = "   Number of keys to add"]
#[doc = " @param key_found"]
#[doc = "   After successful invocation, key_found for every item in the array is set"]
#[doc = "   to a value different than 0 if the current key is already present in the"]
#[doc = "   table and to 0 if not. This pointer has to be set to a valid memory"]
#[doc = "   location before the table entry add function is called."]
#[doc = " @param entries_ptr"]
#[doc = "   After successful invocation, array *entries_ptr stores the handle to the"]
#[doc = "   table entry containing the data associated with every key. This handle can"]
#[doc = "   be used to perform further read-write accesses to this entry. This handle"]
#[doc = "   is valid until the key is deleted from the table or the same key is"]
#[doc = "   re-added to the table, typically to associate it with different data. This"]
#[doc = "   pointer has to be set to a valid memory location before the function is"]
#[doc = "   called."]
#[doc = " @return"]
#[doc = "   0 on success, error code otherwise"]
pub type rte_table_op_entry_add_bulk = ::std::option::Option<
    unsafe extern "C" fn(
        table: *mut ::std::os::raw::c_void,
        keys: *mut *mut ::std::os::raw::c_void,
        entries: *mut *mut ::std::os::raw::c_void,
        n_keys: u32,
        key_found: *mut ::std::os::raw::c_int,
        entries_ptr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Lookup table entry delete bulk"]
#[doc = ""]
#[doc = " @param table"]
#[doc = "   Handle to lookup table instance"]
#[doc = " @param keys"]
#[doc = "   Array containing lookup keys"]
#[doc = " @param n_keys"]
#[doc = "   Number of keys to delete"]
#[doc = " @param key_found"]
#[doc = "   After successful invocation, key_found for every item in the array is set"]
#[doc = "   to a value different than 0if the current key was present in the table"]
#[doc = "   before the delete operation was performed and to 0 if not. This pointer"]
#[doc = "   has to be set to a valid memory location before the table entry delete"]
#[doc = "   function is called."]
#[doc = " @param entries"]
#[doc = "   If entries pointer is NULL, this pointer is ignored for every entry found."]
#[doc = "   Else, after successful invocation, if specific key is found in the table"]
#[doc = "   (key_found is different than 0 for this item after function call is"]
#[doc = "   completed) and item of entry array points to a valid buffer (entry is set"]
#[doc = "   to a value different than NULL before the function is called), then the"]
#[doc = "   first entry_size bytes (table create parameter) in *entry store a copy of"]
#[doc = "   table entry that contained the data associated with the current key before"]
#[doc = "   the key was deleted."]
#[doc = " @return"]
#[doc = "   0 on success, error code otherwise"]
pub type rte_table_op_entry_delete_bulk = ::std::option::Option<
    unsafe extern "C" fn(
        table: *mut ::std::os::raw::c_void,
        keys: *mut *mut ::std::os::raw::c_void,
        n_keys: u32,
        key_found: *mut ::std::os::raw::c_int,
        entries: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Lookup table lookup"]
#[doc = ""]
#[doc = " @param table"]
#[doc = "   Handle to lookup table instance"]
#[doc = " @param pkts"]
#[doc = "   Burst of input packets specified as array of up to 64 pointers to struct"]
#[doc = "   rte_mbuf"]
#[doc = " @param pkts_mask"]
#[doc = "   64-bit bitmask specifying which packets in the input burst are valid. When"]
#[doc = "   pkts_mask bit n is set, then element n of pkts array is pointing to a"]
#[doc = "   valid packet. Otherwise, element n of pkts array does not point to a valid"]
#[doc = "   packet, therefore it will not be accessed."]
#[doc = " @param lookup_hit_mask"]
#[doc = "   Once the table lookup operation is completed, this 64-bit bitmask"]
#[doc = "   specifies which of the valid packets in the input burst resulted in lookup"]
#[doc = "   hit. For each valid input packet (pkts_mask bit n is set), the following"]
#[doc = "   are true on lookup hit: lookup_hit_mask bit n is set, element n of entries"]
#[doc = "   array is valid and it points to the lookup table entry that was hit. For"]
#[doc = "   each valid input packet (pkts_mask bit n is set), the following are true"]
#[doc = "   on lookup miss: lookup_hit_mask bit n is not set and element n of entries"]
#[doc = "   array is not valid."]
#[doc = " @param entries"]
#[doc = "   Once the table lookup operation is completed, this array provides the"]
#[doc = "   lookup table entries that were hit, as described above. It is required"]
#[doc = "   that this array is always pre-allocated by the caller of this function"]
#[doc = "   with exactly 64 elements. The implementation is allowed to speculatively"]
#[doc = "   modify the elements of this array, so elements marked as invalid in"]
#[doc = "   lookup_hit_mask once the table lookup operation is completed might have"]
#[doc = "   been modified by this function."]
#[doc = " @return"]
#[doc = "   0 on success, error code otherwise"]
pub type rte_table_op_lookup = ::std::option::Option<
    unsafe extern "C" fn(
        table: *mut ::std::os::raw::c_void,
        pkts: *mut *mut rte_mbuf,
        pkts_mask: u64,
        lookup_hit_mask: *mut u64,
        entries: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Lookup table stats read"]
#[doc = ""]
#[doc = " @param table"]
#[doc = "   Handle to lookup table instance"]
#[doc = " @param stats"]
#[doc = "   Handle to table stats struct to copy data"]
#[doc = " @param clear"]
#[doc = "   Flag indicating that stats should be cleared after read"]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Error code or 0 on success."]
pub type rte_table_op_stats_read = ::std::option::Option<
    unsafe extern "C" fn(
        table: *mut ::std::os::raw::c_void,
        stats: *mut rte_table_stats,
        clear: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Lookup table interface defining the lookup table operation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_table_ops {
    #[doc = "< Create"]
    pub f_create: rte_table_op_create,
    #[doc = "< Free"]
    pub f_free: rte_table_op_free,
    #[doc = "< Entry add"]
    pub f_add: rte_table_op_entry_add,
    #[doc = "< Entry delete"]
    pub f_delete: rte_table_op_entry_delete,
    #[doc = "< Add entry bulk"]
    pub f_add_bulk: rte_table_op_entry_add_bulk,
    #[doc = "< Delete entry bulk"]
    pub f_delete_bulk: rte_table_op_entry_delete_bulk,
    #[doc = "< Lookup"]
    pub f_lookup: rte_table_op_lookup,
    #[doc = "< Stats"]
    pub f_stats: rte_table_op_stats_read,
}
#[doc = " Opaque data type for pipeline"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pipeline {
    _unused: [u8; 0],
}
#[doc = " Parameters for pipeline creation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pipeline_params {
    #[doc = " Pipeline name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " CPU socket ID where memory for the pipeline and its elements (ports"]
    #[doc = "and tables) should be allocated"]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = " Offset within packet meta-data to port_id to be used by action"]
    #[doc = "\"Send packet to output port read from packet meta-data\". Has to be"]
    #[doc = "4-byte aligned."]
    pub offset_port_id: u32,
}
#[doc = " Pipeline port in stats."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pipeline_port_in_stats {
    #[doc = " Port in stats."]
    pub stats: rte_port_in_stats,
    #[doc = " Number of packets dropped by action handler."]
    pub n_pkts_dropped_by_ah: u64,
}
#[doc = " Pipeline port out stats."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pipeline_port_out_stats {
    #[doc = " Port out stats."]
    pub stats: rte_port_out_stats,
    #[doc = " Number of packets dropped by action handler."]
    pub n_pkts_dropped_by_ah: u64,
}
#[doc = " Pipeline table stats."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pipeline_table_stats {
    #[doc = " Table stats."]
    pub stats: rte_table_stats,
    #[doc = " Number of packets dropped by lookup hit action handler."]
    pub n_pkts_dropped_by_lkp_hit_ah: u64,
    #[doc = " Number of packets dropped by lookup miss action handler."]
    pub n_pkts_dropped_by_lkp_miss_ah: u64,
    #[doc = " Number of packets dropped by pipeline in behalf of this"]
    #[doc = " table based on action specified in table entry."]
    pub n_pkts_dropped_lkp_hit: u64,
    #[doc = " Number of packets dropped by pipeline in behalf of this"]
    #[doc = "  table based on action specified in table entry."]
    pub n_pkts_dropped_lkp_miss: u64,
}
extern "C" {
    #[doc = " Pipeline create"]
    #[doc = ""]
    #[doc = " @param params"]
    #[doc = "   Parameters for pipeline creation"]
    #[doc = " @return"]
    #[doc = "   Handle to pipeline instance on success or NULL otherwise"]
    pub fn rte_pipeline_create(params: *mut rte_pipeline_params) -> *mut rte_pipeline;
}
extern "C" {
    #[doc = " Pipeline free"]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance"]
    #[doc = " @return"]
    #[doc = "   0 on success, error code otherwise"]
    pub fn rte_pipeline_free(p: *mut rte_pipeline) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pipeline consistency check"]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance"]
    #[doc = " @return"]
    #[doc = "   0 on success, error code otherwise"]
    pub fn rte_pipeline_check(p: *mut rte_pipeline) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pipeline run"]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance"]
    #[doc = " @return"]
    #[doc = "   Number of packets read and processed"]
    pub fn rte_pipeline_run(p: *mut rte_pipeline) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pipeline flush"]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance"]
    #[doc = " @return"]
    #[doc = "   0 on success, error code otherwise"]
    pub fn rte_pipeline_flush(p: *mut rte_pipeline) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " Reserved actions"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_pipeline_action {
    #[doc = " Drop the packet"]
    RTE_PIPELINE_ACTION_DROP = 0,
    #[doc = " Send packet to output port"]
    RTE_PIPELINE_ACTION_PORT = 1,
    #[doc = " Send packet to output port read from packet meta-data"]
    RTE_PIPELINE_ACTION_PORT_META = 2,
    #[doc = " Send packet to table"]
    RTE_PIPELINE_ACTION_TABLE = 3,
    #[doc = " Number of reserved actions"]
    RTE_PIPELINE_ACTIONS = 4,
}
#[doc = " Head format for the table entry of any pipeline table. For any given"]
#[doc = " pipeline table, all table entries should have the same size and format. For"]
#[doc = " any given pipeline table, the table entry has to start with a head of this"]
#[doc = " structure, which contains the reserved actions and their associated"]
#[doc = " meta-data, and then optionally continues with user actions and their"]
#[doc = " associated meta-data. As all the currently defined reserved actions are"]
#[doc = " mutually exclusive, only one reserved action can be set per table entry."]
#[repr(C)]
pub struct rte_pipeline_table_entry {
    #[doc = " Reserved action"]
    pub action: rte_pipeline_action,
    pub __bindgen_anon_1: rte_pipeline_table_entry__bindgen_ty_1,
    #[doc = " Start of table entry area for user defined actions and meta-data"]
    pub action_data: __IncompleteArrayField<u8>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_pipeline_table_entry__bindgen_ty_1 {
    #[doc = " Output port ID (meta-data for \"Send packet to output port\""]
    #[doc = "action)"]
    pub port_id: u32,
    #[doc = " Table ID (meta-data for \"Send packet to table\" action)"]
    pub table_id: u32,
}
#[doc = " Pipeline table action handler on lookup hit"]
#[doc = ""]
#[doc = " The action handler can decide to drop packets by resetting the associated"]
#[doc = " packet bit in the pkts_mask parameter. In this case, the action handler is"]
#[doc = " required not to free the packet buffer, which will be freed eventually by"]
#[doc = " the pipeline."]
#[doc = ""]
#[doc = " @param p"]
#[doc = "   Handle to pipeline instance"]
#[doc = " @param pkts"]
#[doc = "   Burst of input packets specified as array of up to 64 pointers to struct"]
#[doc = "   rte_mbuf"]
#[doc = " @param pkts_mask"]
#[doc = "   64-bit bitmask specifying which packets in the input burst are valid. When"]
#[doc = "   pkts_mask bit n is set, then element n of pkts array is pointing to a"]
#[doc = "   valid packet and element n of entries array is pointing to a valid table"]
#[doc = "   entry associated with the packet, with the association typically done by"]
#[doc = "   the table lookup operation. Otherwise, element n of pkts array and element"]
#[doc = "   n of entries array will not be accessed."]
#[doc = " @param entries"]
#[doc = "   Set of table entries specified as array of up to 64 pointers to struct"]
#[doc = "   rte_pipeline_table_entry"]
#[doc = " @param arg"]
#[doc = "   Opaque parameter registered by the user at the pipeline table creation"]
#[doc = "   time"]
#[doc = " @return"]
#[doc = "   0 on success, error code otherwise"]
pub type rte_pipeline_table_action_handler_hit = ::std::option::Option<
    unsafe extern "C" fn(
        p: *mut rte_pipeline,
        pkts: *mut *mut rte_mbuf,
        pkts_mask: u64,
        entries: *mut *mut rte_pipeline_table_entry,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Pipeline table action handler on lookup miss"]
#[doc = ""]
#[doc = " The action handler can decide to drop packets by resetting the associated"]
#[doc = " packet bit in the pkts_mask parameter. In this case, the action handler is"]
#[doc = " required not to free the packet buffer, which will be freed eventually by"]
#[doc = " the pipeline."]
#[doc = ""]
#[doc = " @param p"]
#[doc = "   Handle to pipeline instance"]
#[doc = " @param pkts"]
#[doc = "   Burst of input packets specified as array of up to 64 pointers to struct"]
#[doc = "   rte_mbuf"]
#[doc = " @param pkts_mask"]
#[doc = "   64-bit bitmask specifying which packets in the input burst are valid. When"]
#[doc = "   pkts_mask bit n is set, then element n of pkts array is pointing to a"]
#[doc = "   valid packet. Otherwise, element n of pkts array will not be accessed."]
#[doc = " @param entry"]
#[doc = "   Single table entry associated with all the valid packets from the input"]
#[doc = "   burst, specified as pointer to struct rte_pipeline_table_entry."]
#[doc = "   This entry is the pipeline table default entry that is associated by the"]
#[doc = "   table lookup operation with the input packets that have resulted in lookup"]
#[doc = "   miss."]
#[doc = " @param arg"]
#[doc = "   Opaque parameter registered by the user at the pipeline table creation"]
#[doc = "   time"]
#[doc = " @return"]
#[doc = "   0 on success, error code otherwise"]
pub type rte_pipeline_table_action_handler_miss = ::std::option::Option<
    unsafe extern "C" fn(
        p: *mut rte_pipeline,
        pkts: *mut *mut rte_mbuf,
        pkts_mask: u64,
        entry: *mut rte_pipeline_table_entry,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Parameters for pipeline table creation. Action handlers have to be either"]
#[doc = "both enabled or both disabled (they can be disabled by setting them to"]
#[doc = "NULL)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pipeline_table_params {
    #[doc = " Table operations (specific to each table type)"]
    pub ops: *mut rte_table_ops,
    #[doc = " Opaque param to be passed to the table create operation when"]
    #[doc = "invoked"]
    pub arg_create: *mut ::std::os::raw::c_void,
    #[doc = " Callback function to execute the user actions on input packets in"]
    #[doc = "case of lookup hit"]
    pub f_action_hit: rte_pipeline_table_action_handler_hit,
    #[doc = " Callback function to execute the user actions on input packets in"]
    #[doc = "case of lookup miss"]
    pub f_action_miss: rte_pipeline_table_action_handler_miss,
    #[doc = " Opaque parameter to be passed to lookup hit and/or lookup miss"]
    #[doc = "action handlers when invoked"]
    pub arg_ah: *mut ::std::os::raw::c_void,
    #[doc = " Memory size to be reserved per table entry for storing the user"]
    #[doc = "actions and their meta-data"]
    pub action_data_size: u32,
}
extern "C" {
    #[doc = " Pipeline table create"]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance"]
    #[doc = " @param params"]
    #[doc = "   Parameters for pipeline table creation"]
    #[doc = " @param table_id"]
    #[doc = "   Table ID. Valid only within the scope of table IDs of the current"]
    #[doc = "   pipeline. Only returned after a successful invocation."]
    #[doc = " @return"]
    #[doc = "   0 on success, error code otherwise"]
    pub fn rte_pipeline_table_create(
        p: *mut rte_pipeline,
        params: *mut rte_pipeline_table_params,
        table_id: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pipeline table default entry add"]
    #[doc = ""]
    #[doc = " The contents of the table default entry is updated with the provided actions"]
    #[doc = " and meta-data. When the default entry is not configured (by using this"]
    #[doc = " function), the built-in default entry has the action \"Drop\" and meta-data"]
    #[doc = " set to all-zeros."]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance"]
    #[doc = " @param table_id"]
    #[doc = "   Table ID (returned by previous invocation of pipeline table create)"]
    #[doc = " @param default_entry"]
    #[doc = "   New contents for the table default entry"]
    #[doc = " @param default_entry_ptr"]
    #[doc = "   On successful invocation, pointer to the default table entry which can be"]
    #[doc = "   used for further read-write accesses to this table entry. This pointer"]
    #[doc = "   is valid until the default entry is deleted or re-added."]
    #[doc = " @return"]
    #[doc = "   0 on success, error code otherwise"]
    pub fn rte_pipeline_table_default_entry_add(
        p: *mut rte_pipeline,
        table_id: u32,
        default_entry: *mut rte_pipeline_table_entry,
        default_entry_ptr: *mut *mut rte_pipeline_table_entry,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pipeline table default entry delete"]
    #[doc = ""]
    #[doc = " The new contents of the table default entry is set to reserved action \"Drop"]
    #[doc = " the packet\" with meta-data cleared (i.e. set to all-zeros)."]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance"]
    #[doc = " @param table_id"]
    #[doc = "   Table ID (returned by previous invocation of pipeline table create)"]
    #[doc = " @param entry"]
    #[doc = "   On successful invocation, when entry points to a valid buffer, the"]
    #[doc = "   previous contents of the table default entry (as it was just before the"]
    #[doc = "   delete operation) is copied to this buffer"]
    #[doc = " @return"]
    #[doc = "   0 on success, error code otherwise"]
    pub fn rte_pipeline_table_default_entry_delete(
        p: *mut rte_pipeline,
        table_id: u32,
        entry: *mut rte_pipeline_table_entry,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pipeline table entry add"]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance"]
    #[doc = " @param table_id"]
    #[doc = "   Table ID (returned by previous invocation of pipeline table create)"]
    #[doc = " @param key"]
    #[doc = "   Table entry key"]
    #[doc = " @param entry"]
    #[doc = "   New contents for the table entry identified by key"]
    #[doc = " @param key_found"]
    #[doc = "   On successful invocation, set to TRUE (value different than 0) if key was"]
    #[doc = "   already present in the table before the add operation and to FALSE (value"]
    #[doc = "   0) if not"]
    #[doc = " @param entry_ptr"]
    #[doc = "   On successful invocation, pointer to the table entry associated with key."]
    #[doc = "   This can be used for further read-write accesses to this table entry and"]
    #[doc = "   is valid until the key is deleted from the table or re-added (usually for"]
    #[doc = "   associating different actions and/or action meta-data to the current key)"]
    #[doc = " @return"]
    #[doc = "   0 on success, error code otherwise"]
    pub fn rte_pipeline_table_entry_add(
        p: *mut rte_pipeline,
        table_id: u32,
        key: *mut ::std::os::raw::c_void,
        entry: *mut rte_pipeline_table_entry,
        key_found: *mut ::std::os::raw::c_int,
        entry_ptr: *mut *mut rte_pipeline_table_entry,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pipeline table entry delete"]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance"]
    #[doc = " @param table_id"]
    #[doc = "   Table ID (returned by previous invocation of pipeline table create)"]
    #[doc = " @param key"]
    #[doc = "   Table entry key"]
    #[doc = " @param key_found"]
    #[doc = "   On successful invocation, set to TRUE (value different than 0) if key was"]
    #[doc = "   found in the table before the delete operation and to FALSE (value 0) if"]
    #[doc = "   not"]
    #[doc = " @param entry"]
    #[doc = "   On successful invocation, when key is found in the table and entry points"]
    #[doc = "   to a valid buffer, the table entry contents (as it was before the delete"]
    #[doc = "   was performed) is copied to this buffer"]
    #[doc = " @return"]
    #[doc = "   0 on success, error code otherwise"]
    pub fn rte_pipeline_table_entry_delete(
        p: *mut rte_pipeline,
        table_id: u32,
        key: *mut ::std::os::raw::c_void,
        key_found: *mut ::std::os::raw::c_int,
        entry: *mut rte_pipeline_table_entry,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pipeline table entry add bulk"]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance"]
    #[doc = " @param table_id"]
    #[doc = "   Table ID (returned by previous invocation of pipeline table create)"]
    #[doc = " @param keys"]
    #[doc = "   Array containing table entry keys"]
    #[doc = " @param entries"]
    #[doc = "   Array containing new contents for every table entry identified by key"]
    #[doc = " @param n_keys"]
    #[doc = "   Number of keys to add"]
    #[doc = " @param key_found"]
    #[doc = "   On successful invocation, key_found for every item in the array is set to"]
    #[doc = "   TRUE (value different than 0) if key was already present in the table"]
    #[doc = "   before the add operation and to FALSE (value 0) if not"]
    #[doc = " @param entries_ptr"]
    #[doc = "   On successful invocation, array *entries_ptr stores pointer to every table"]
    #[doc = "   entry associated with key. This can be used for further read-write accesses"]
    #[doc = "   to this table entry and is valid until the key is deleted from the table or"]
    #[doc = "   re-added (usually for associating different actions and/or action meta-data"]
    #[doc = "   to the current key)"]
    #[doc = " @return"]
    #[doc = "   0 on success, error code otherwise"]
    pub fn rte_pipeline_table_entry_add_bulk(
        p: *mut rte_pipeline,
        table_id: u32,
        keys: *mut *mut ::std::os::raw::c_void,
        entries: *mut *mut rte_pipeline_table_entry,
        n_keys: u32,
        key_found: *mut ::std::os::raw::c_int,
        entries_ptr: *mut *mut rte_pipeline_table_entry,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pipeline table entry delete bulk"]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance"]
    #[doc = " @param table_id"]
    #[doc = "   Table ID (returned by previous invocation of pipeline table create)"]
    #[doc = " @param keys"]
    #[doc = "   Array containing table entry keys"]
    #[doc = " @param n_keys"]
    #[doc = "   Number of keys to delete"]
    #[doc = " @param key_found"]
    #[doc = "   On successful invocation, key_found for every item in the array is set to"]
    #[doc = "   TRUE (value different than 0) if key was found in the table before the"]
    #[doc = "   delete operation and to FALSE (value 0) if not"]
    #[doc = " @param entries"]
    #[doc = "   If entries pointer is NULL, this pointer is ignored for every entry found."]
    #[doc = "   Else, after successful invocation, if specific key is found in the table"]
    #[doc = "   and entry points to a valid buffer, the table entry contents (as it was"]
    #[doc = "   before the delete was performed) is copied to this buffer."]
    #[doc = " @return"]
    #[doc = "   0 on success, error code otherwise"]
    pub fn rte_pipeline_table_entry_delete_bulk(
        p: *mut rte_pipeline,
        table_id: u32,
        keys: *mut *mut ::std::os::raw::c_void,
        n_keys: u32,
        key_found: *mut ::std::os::raw::c_int,
        entries: *mut *mut rte_pipeline_table_entry,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read pipeline table stats."]
    #[doc = ""]
    #[doc = " This function reads table statistics identified by *table_id* of given"]
    #[doc = " pipeline *p*."]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance."]
    #[doc = " @param table_id"]
    #[doc = "   Port ID what stats will be returned."]
    #[doc = " @param stats"]
    #[doc = "   Statistics buffer."]
    #[doc = " @param clear"]
    #[doc = "   If not 0 clear stats after reading."]
    #[doc = " @return"]
    #[doc = "   0 on success, error code otherwise"]
    pub fn rte_pipeline_table_stats_read(
        p: *mut rte_pipeline,
        table_id: u32,
        stats: *mut rte_pipeline_table_stats,
        clear: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Pipeline input port action handler"]
#[doc = ""]
#[doc = " The action handler can decide to drop packets by resetting the associated"]
#[doc = " packet bit in the pkts_mask parameter. In this case, the action handler is"]
#[doc = " required not to free the packet buffer, which will be freed eventually by"]
#[doc = " the pipeline."]
#[doc = ""]
#[doc = " @param p"]
#[doc = "   Handle to pipeline instance"]
#[doc = " @param pkts"]
#[doc = "   Burst of input packets specified as array of up to 64 pointers to struct"]
#[doc = "   rte_mbuf"]
#[doc = " @param n"]
#[doc = "   Number of packets in the input burst. This parameter specifies that"]
#[doc = "   elements 0 to (n-1) of pkts array are valid."]
#[doc = " @param arg"]
#[doc = "   Opaque parameter registered by the user at the pipeline table creation"]
#[doc = "   time"]
#[doc = " @return"]
#[doc = "   0 on success, error code otherwise"]
pub type rte_pipeline_port_in_action_handler = ::std::option::Option<
    unsafe extern "C" fn(
        p: *mut rte_pipeline,
        pkts: *mut *mut rte_mbuf,
        n: u32,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Parameters for pipeline input port creation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pipeline_port_in_params {
    #[doc = " Input port operations (specific to each table type)"]
    pub ops: *mut rte_port_in_ops,
    #[doc = " Opaque parameter to be passed to create operation when invoked"]
    pub arg_create: *mut ::std::os::raw::c_void,
    #[doc = " Callback function to execute the user actions on input packets."]
    #[doc = "Disabled if set to NULL."]
    pub f_action: rte_pipeline_port_in_action_handler,
    #[doc = " Opaque parameter to be passed to the action handler when invoked"]
    pub arg_ah: *mut ::std::os::raw::c_void,
    #[doc = " Recommended burst size for the RX operation(in number of pkts)"]
    pub burst_size: u32,
}
extern "C" {
    #[doc = " Pipeline input port create"]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance"]
    #[doc = " @param params"]
    #[doc = "   Parameters for pipeline input port creation"]
    #[doc = " @param port_id"]
    #[doc = "   Input port ID. Valid only within the scope of input port IDs of the"]
    #[doc = "   current pipeline. Only returned after a successful invocation."]
    #[doc = " @return"]
    #[doc = "   0 on success, error code otherwise"]
    pub fn rte_pipeline_port_in_create(
        p: *mut rte_pipeline,
        params: *mut rte_pipeline_port_in_params,
        port_id: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pipeline input port connect to table"]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance"]
    #[doc = " @param port_id"]
    #[doc = "   Port ID (returned by previous invocation of pipeline input port create)"]
    #[doc = " @param table_id"]
    #[doc = "   Table ID (returned by previous invocation of pipeline table create)"]
    #[doc = " @return"]
    #[doc = "   0 on success, error code otherwise"]
    pub fn rte_pipeline_port_in_connect_to_table(
        p: *mut rte_pipeline,
        port_id: u32,
        table_id: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pipeline input port enable"]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance"]
    #[doc = " @param port_id"]
    #[doc = "   Port ID (returned by previous invocation of pipeline input port create)"]
    #[doc = " @return"]
    #[doc = "   0 on success, error code otherwise"]
    pub fn rte_pipeline_port_in_enable(p: *mut rte_pipeline, port_id: u32)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pipeline input port disable"]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance"]
    #[doc = " @param port_id"]
    #[doc = "   Port ID (returned by previous invocation of pipeline input port create)"]
    #[doc = " @return"]
    #[doc = "   0 on success, error code otherwise"]
    pub fn rte_pipeline_port_in_disable(
        p: *mut rte_pipeline,
        port_id: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read pipeline port in stats."]
    #[doc = ""]
    #[doc = " This function reads port in statistics identified by *port_id* of given"]
    #[doc = " pipeline *p*."]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance."]
    #[doc = " @param port_id"]
    #[doc = "   Port ID what stats will be returned."]
    #[doc = " @param stats"]
    #[doc = "   Statistics buffer."]
    #[doc = " @param clear"]
    #[doc = "   If not 0 clear stats after reading."]
    #[doc = " @return"]
    #[doc = "   0 on success, error code otherwise"]
    pub fn rte_pipeline_port_in_stats_read(
        p: *mut rte_pipeline,
        port_id: u32,
        stats: *mut rte_pipeline_port_in_stats,
        clear: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Pipeline output port action handler"]
#[doc = ""]
#[doc = " The action handler can decide to drop packets by resetting the associated"]
#[doc = " packet bit in the pkts_mask parameter. In this case, the action handler is"]
#[doc = " required not to free the packet buffer, which will be freed eventually by"]
#[doc = " the pipeline."]
#[doc = ""]
#[doc = " @param p"]
#[doc = "   Handle to pipeline instance"]
#[doc = " @param pkts"]
#[doc = "   Burst of input packets specified as array of up to 64 pointers to struct"]
#[doc = "   rte_mbuf"]
#[doc = " @param pkts_mask"]
#[doc = "   64-bit bitmask specifying which packets in the input burst are valid. When"]
#[doc = "   pkts_mask bit n is set, then element n of pkts array is pointing to a"]
#[doc = "   valid packet. Otherwise, element n of pkts array will not be accessed."]
#[doc = " @param arg"]
#[doc = "   Opaque parameter registered by the user at the pipeline table creation"]
#[doc = "   time"]
#[doc = " @return"]
#[doc = "   0 on success, error code otherwise"]
pub type rte_pipeline_port_out_action_handler = ::std::option::Option<
    unsafe extern "C" fn(
        p: *mut rte_pipeline,
        pkts: *mut *mut rte_mbuf,
        pkts_mask: u64,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Parameters for pipeline output port creation. The action handlers have to"]
#[doc = "be either both enabled or both disabled (by setting them to NULL). When"]
#[doc = "enabled, the pipeline selects between them at different moments, based on the"]
#[doc = "number of packets that have to be sent to the same output port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pipeline_port_out_params {
    #[doc = " Output port operations (specific to each table type)"]
    pub ops: *mut rte_port_out_ops,
    #[doc = " Opaque parameter to be passed to create operation when invoked"]
    pub arg_create: *mut ::std::os::raw::c_void,
    #[doc = " Callback function executing the user actions on bust of input"]
    #[doc = "packets"]
    pub f_action: rte_pipeline_port_out_action_handler,
    #[doc = " Opaque parameter to be passed to the action handler when invoked"]
    pub arg_ah: *mut ::std::os::raw::c_void,
}
extern "C" {
    #[doc = " Pipeline output port create"]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance"]
    #[doc = " @param params"]
    #[doc = "   Parameters for pipeline output port creation"]
    #[doc = " @param port_id"]
    #[doc = "   Output port ID. Valid only within the scope of output port IDs of the"]
    #[doc = "   current pipeline. Only returned after a successful invocation."]
    #[doc = " @return"]
    #[doc = "   0 on success, error code otherwise"]
    pub fn rte_pipeline_port_out_create(
        p: *mut rte_pipeline,
        params: *mut rte_pipeline_port_out_params,
        port_id: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read pipeline port out stats."]
    #[doc = ""]
    #[doc = " This function reads port out statistics identified by *port_id* of given"]
    #[doc = " pipeline *p*."]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance."]
    #[doc = " @param port_id"]
    #[doc = "   Port ID what stats will be returned."]
    #[doc = " @param stats"]
    #[doc = "   Statistics buffer."]
    #[doc = " @param clear"]
    #[doc = "   If not 0 clear stats after reading."]
    #[doc = " @return"]
    #[doc = "   0 on success, error code otherwise"]
    pub fn rte_pipeline_port_out_stats_read(
        p: *mut rte_pipeline,
        port_id: u32,
        stats: *mut rte_pipeline_port_out_stats,
        clear: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Action handler packet insert to output port"]
    #[doc = ""]
    #[doc = " This function can be called by any input/output port or table action handler"]
    #[doc = " to send a packet out through one of the pipeline output ports. This packet is"]
    #[doc = " generated by the action handler, i.e. this packet is not part of the burst of"]
    #[doc = " packets read from one of the pipeline input ports and currently processed by"]
    #[doc = " the pipeline (this packet is not an element of the pkts array input parameter"]
    #[doc = " of the action handler)."]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance"]
    #[doc = " @param port_id"]
    #[doc = "   Output port ID (returned by previous invocation of pipeline output port"]
    #[doc = "   create) to send the packet specified by pkt"]
    #[doc = " @param pkt"]
    #[doc = "   New packet generated by the action handler"]
    #[doc = " @return"]
    #[doc = "   0 on success, error code otherwise"]
    pub fn rte_pipeline_port_out_packet_insert(
        p: *mut rte_pipeline,
        port_id: u32,
        pkt: *mut rte_mbuf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Action handler packet hijack"]
    #[doc = ""]
    #[doc = " This function can be called by any input/output port or table action handler"]
    #[doc = " to hijack selected packets from the burst of packets read from one of the"]
    #[doc = " pipeline input ports and currently processed by the pipeline. The hijacked"]
    #[doc = " packets are removed from any further pipeline processing, with the action"]
    #[doc = " handler now having the full ownership for these packets."]
    #[doc = ""]
    #[doc = " The action handler can further send the hijacked packets out through any"]
    #[doc = " pipeline output port by calling the rte_pipeline_ah_port_out_packet_insert()"]
    #[doc = " function. The action handler can also drop these packets by calling the"]
    #[doc = " rte_pktmbuf_free() function, although a better alternative is provided by"]
    #[doc = " the action handler using the rte_pipeline_ah_packet_drop() function."]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance"]
    #[doc = " @param pkts_mask"]
    #[doc = "   64-bit bitmask specifying which of the packets handed over for processing"]
    #[doc = "   to the action handler is to be hijacked by the action handler. When"]
    #[doc = "   pkts_mask bit n is set, then element n of the pkts array (input argument to"]
    #[doc = "   the action handler) is hijacked."]
    #[doc = " @return"]
    #[doc = "   0 on success, error code otherwise"]
    pub fn rte_pipeline_ah_packet_hijack(
        p: *mut rte_pipeline,
        pkts_mask: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Action handler packet drop"]
    #[doc = ""]
    #[doc = " This function is called by the pipeline action handlers (port in/out, table)"]
    #[doc = " to drop the packets selected using packet mask."]
    #[doc = ""]
    #[doc = " This function can be called by any input/output port or table action handler"]
    #[doc = " to drop selected packets from the burst of packets read from one of the"]
    #[doc = " pipeline input ports and currently processed by the pipeline. The dropped"]
    #[doc = " packets are removed from any further pipeline processing and the packet"]
    #[doc = " buffers are eventually freed to their buffer pool."]
    #[doc = ""]
    #[doc = " This function updates the drop statistics counters correctly, therefore the"]
    #[doc = " recommended approach for dropping packets by the action handlers is to call"]
    #[doc = " this function as opposed to the action handler hijacking the packets first"]
    #[doc = " and then dropping them invisibly to the pipeline (by using the"]
    #[doc = " rte_pktmbuf_free() function)."]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   Handle to pipeline instance"]
    #[doc = " @param pkts_mask"]
    #[doc = "   64-bit bitmask specifying which of the packets handed over for processing"]
    #[doc = "   to the action handler is to be dropped by the action handler. When"]
    #[doc = "   pkts_mask bit n is set, then element n of the pkts array (input argument to"]
    #[doc = "   the action handler) is dropped."]
    #[doc = " @return"]
    #[doc = "   0 on success, error code otherwise"]
    pub fn rte_pipeline_ah_packet_drop(
        p: *mut rte_pipeline,
        pkts_mask: u64,
    ) -> ::std::os::raw::c_int;
}
#[doc = " ethdev_reader port parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_ethdev_reader_params {
    #[doc = " NIC RX port ID"]
    pub port_id: u16,
    #[doc = " NIC RX queue ID"]
    pub queue_id: u16,
}
extern "C" {
    #[doc = " ethdev_reader port operations"]
    pub static mut rte_port_ethdev_reader_ops: rte_port_in_ops;
}
#[doc = " ethdev_writer port parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_ethdev_writer_params {
    #[doc = " NIC RX port ID"]
    pub port_id: u16,
    #[doc = " NIC RX queue ID"]
    pub queue_id: u16,
    #[doc = " Recommended burst size to NIC TX queue. The actual burst size can be"]
    #[doc = "bigger or smaller than this value."]
    pub tx_burst_sz: u32,
}
extern "C" {
    #[doc = " ethdev_writer port operations"]
    pub static mut rte_port_ethdev_writer_ops: rte_port_out_ops;
}
#[doc = " ethdev_writer_nodrop port parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_ethdev_writer_nodrop_params {
    #[doc = " NIC RX port ID"]
    pub port_id: u16,
    #[doc = " NIC RX queue ID"]
    pub queue_id: u16,
    #[doc = " Recommended burst size to NIC TX queue. The actual burst size can be"]
    #[doc = "bigger or smaller than this value."]
    pub tx_burst_sz: u32,
    #[doc = " Maximum number of retries, 0 for no limit"]
    pub n_retries: u32,
}
extern "C" {
    #[doc = " ethdev_writer_nodrop port operations"]
    pub static mut rte_port_ethdev_writer_nodrop_ops: rte_port_out_ops;
}
#[doc = " Eventdev_reader port parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_eventdev_reader_params {
    #[doc = " Eventdev Device ID"]
    pub eventdev_id: u8,
    #[doc = " Eventdev Port ID"]
    pub port_id: u8,
}
extern "C" {
    #[doc = " Eventdev_reader port operations."]
    pub static mut rte_port_eventdev_reader_ops: rte_port_in_ops;
}
#[doc = " Eventdev_writer port parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_eventdev_writer_params {
    #[doc = " Eventdev Device ID."]
    pub eventdev_id: u8,
    #[doc = " Eventdev Port ID."]
    pub port_id: u8,
    #[doc = " Eventdev Queue ID."]
    pub queue_id: u8,
    #[doc = " Burst size to eventdev interface."]
    pub enq_burst_sz: u32,
    #[doc = " Scheduler synchronization type (RTE_SCHED_TYPE_*)"]
    pub sched_type: u8,
    #[doc = " The type of eventdev enqueue operation - new/forward/release"]
    pub evt_op: u8,
}
extern "C" {
    #[doc = " Eventdev_writer port operations."]
    pub static mut rte_port_eventdev_writer_ops: rte_port_out_ops;
}
#[doc = " Event_writer_nodrop port parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_eventdev_writer_nodrop_params {
    #[doc = " Eventdev Device ID."]
    pub eventdev_id: u8,
    #[doc = " Eventdev Port ID."]
    pub port_id: u16,
    #[doc = " Eventdev Queue ID."]
    pub queue_id: u16,
    #[doc = " Burst size to eventdev interface."]
    pub enq_burst_sz: u32,
    #[doc = " Scheduler synchronization type (RTE_SCHED_TYPE_*)"]
    pub sched_type: u8,
    #[doc = " The type of eventdev enqueue operation - new/forward/release"]
    pub evt_op: u8,
    #[doc = " Maximum number of retries, 0 for no limit."]
    pub n_retries: u32,
}
extern "C" {
    #[doc = " Eventdev_writer_nodrop port operations."]
    pub static mut rte_port_eventdev_writer_nodrop_ops: rte_port_out_ops;
}
#[doc = " fd_reader port parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_fd_reader_params {
    #[doc = " File descriptor"]
    pub fd: ::std::os::raw::c_int,
    #[doc = " Maximum Transfer Unit (MTU)"]
    pub mtu: u32,
    #[doc = " Pre-initialized buffer pool"]
    pub mempool: *mut rte_mempool,
}
extern "C" {
    #[doc = " fd_reader port operations"]
    pub static mut rte_port_fd_reader_ops: rte_port_in_ops;
}
#[doc = " fd_writer port parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_fd_writer_params {
    #[doc = " File descriptor"]
    pub fd: ::std::os::raw::c_int,
    pub tx_burst_sz: u32,
}
extern "C" {
    #[doc = " fd_writer port operations"]
    pub static mut rte_port_fd_writer_ops: rte_port_out_ops;
}
#[doc = " fd_writer_nodrop port parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_fd_writer_nodrop_params {
    #[doc = " File descriptor"]
    pub fd: ::std::os::raw::c_int,
    pub tx_burst_sz: u32,
    #[doc = " Maximum number of retries, 0 for no limit"]
    pub n_retries: u32,
}
extern "C" {
    #[doc = " fd_writer_nodrop port operations"]
    pub static mut rte_port_fd_writer_nodrop_ops: rte_port_out_ops;
}
#[doc = " ring_reader_ipv4_frag port parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_ring_reader_frag_params {
    #[doc = " Underlying single consumer ring that has to be pre-initialized."]
    pub ring: *mut rte_ring,
    #[doc = " Maximum Transfer Unit (MTU). Maximum IP packet size (in bytes)."]
    pub mtu: u32,
    #[doc = " Size of application dependent meta-data stored per each input packet"]
    #[doc = "that has to be copied to each of the fragments originating from the"]
    #[doc = "same input IP datagram."]
    pub metadata_size: u32,
    #[doc = " Pre-initialized buffer pool used for allocating direct buffers for"]
    #[doc = "the output fragments."]
    pub pool_direct: *mut rte_mempool,
    #[doc = " Pre-initialized buffer pool used for allocating indirect buffers for"]
    #[doc = "the output fragments."]
    pub pool_indirect: *mut rte_mempool,
}
extern "C" {
    #[doc = " ring_reader_ipv4_frag port operations"]
    pub static mut rte_port_ring_reader_ipv4_frag_ops: rte_port_in_ops;
}
extern "C" {
    #[doc = " ring_reader_ipv6_frag port operations"]
    pub static mut rte_port_ring_reader_ipv6_frag_ops: rte_port_in_ops;
}
#[doc = " Hash function"]
pub type rte_table_hash_op_hash = ::std::option::Option<
    unsafe extern "C" fn(
        key: *mut ::std::os::raw::c_void,
        key_mask: *mut ::std::os::raw::c_void,
        key_size: u32,
        seed: u64,
    ) -> u64,
>;
#[doc = " Hash table parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_table_hash_params {
    #[doc = " Name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Key size (number of bytes)"]
    pub key_size: u32,
    #[doc = " Byte offset within packet meta-data where the key is located"]
    pub key_offset: u32,
    #[doc = " Key mask"]
    pub key_mask: *mut u8,
    #[doc = " Number of keys"]
    pub n_keys: u32,
    #[doc = " Number of buckets"]
    pub n_buckets: u32,
    #[doc = " Hash function"]
    pub f_hash: rte_table_hash_op_hash,
    #[doc = " Seed value for the hash function"]
    pub seed: u64,
}
extern "C" {
    #[doc = " Extendable bucket hash table operations"]
    pub static mut rte_table_hash_ext_ops: rte_table_ops;
}
extern "C" {
    pub static mut rte_table_hash_key8_ext_ops: rte_table_ops;
}
extern "C" {
    pub static mut rte_table_hash_key16_ext_ops: rte_table_ops;
}
extern "C" {
    pub static mut rte_table_hash_key32_ext_ops: rte_table_ops;
}
extern "C" {
    #[doc = " LRU hash table operations"]
    pub static mut rte_table_hash_lru_ops: rte_table_ops;
}
extern "C" {
    pub static mut rte_table_hash_key8_lru_ops: rte_table_ops;
}
extern "C" {
    pub static mut rte_table_hash_key16_lru_ops: rte_table_ops;
}
extern "C" {
    pub static mut rte_table_hash_key32_lru_ops: rte_table_ops;
}
#[repr(u32)]
#[doc = " Input port actions."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_port_in_action_type {
    #[doc = " Filter selected input packets."]
    RTE_PORT_IN_ACTION_FLTR = 0,
    #[doc = "  Load balance."]
    RTE_PORT_IN_ACTION_LB = 1,
}
#[doc = " Filter action configuration (per action profile)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_in_action_fltr_config {
    #[doc = " Key offset within the input packet buffer. Offset 0 points to the"]
    #[doc = " first byte of the MBUF structure."]
    pub key_offset: u32,
    #[doc = " Key mask."]
    pub key_mask: [u8; 16usize],
    #[doc = " Key value."]
    pub key: [u8; 16usize],
    #[doc = " When non-zero, all the input packets that match the *key* (with the"]
    #[doc = " *key_mask* applied) are sent to the pipeline output port *port_id*."]
    #[doc = " When zero, all the input packets that do NOT match the *key* (with"]
    #[doc = " *key_mask* applied) are sent to the pipeline output port *port_id*."]
    pub filter_on_match: ::std::os::raw::c_int,
    #[doc = " Pipeline output port ID to send the filtered input packets to."]
    #[doc = " Can be updated later."]
    #[doc = ""]
    #[doc = " @see struct rte_port_in_action_fltr_params"]
    pub port_id: u32,
}
#[doc = " Filter action parameters (per action)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_in_action_fltr_params {
    #[doc = " Pipeline output port ID to send the filtered input packets to."]
    pub port_id: u32,
}
#[doc = " Load balance action configuration (per action profile)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_in_action_lb_config {
    #[doc = " Key size (number of bytes)."]
    pub key_size: u32,
    #[doc = " Key offset within the input packet buffer. Offset 0 points to the"]
    #[doc = " first byte of the MBUF structure."]
    pub key_offset: u32,
    #[doc = " Key mask(*key_size* bytes are valid)."]
    pub key_mask: [u8; 64usize],
    #[doc = " Hash function."]
    pub f_hash: rte_table_hash_op_hash,
    #[doc = " Seed value for *f_hash*."]
    pub seed: u64,
    #[doc = " Table defining the weight of each pipeline output port. The weights"]
    #[doc = " are set in 1/RTE_PORT_IN_ACTION_LB_TABLE_SIZE increments. To assign a"]
    #[doc = " weight of N/RTE_PORT_IN_ACTION_LB_TABLE_SIZE to a given output port"]
    #[doc = " (0 <= N <= RTE_PORT_IN_ACTION_LB_TABLE_SIZE), the output port needs"]
    #[doc = " to show up exactly N times in this table. Can be updated later."]
    #[doc = ""]
    #[doc = " @see struct rte_port_in_action_lb_params"]
    pub port_id: [u32; 16usize],
}
#[doc = " Load balance action parameters (per action)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_in_action_lb_params {
    #[doc = " Table defining the weight of each pipeline output port. The weights"]
    #[doc = " are set in 1/RTE_PORT_IN_ACTION_LB_TABLE_SIZE increments. To assign a"]
    #[doc = " weight of N/RTE_PORT_IN_ACTION_LB_TABLE_SIZE to a given output port"]
    #[doc = " (0 <= N <= RTE_PORT_IN_ACTION_LB_TABLE_SIZE), the output port needs"]
    #[doc = " to show up exactly N times in this table."]
    pub port_id: [u32; 16usize],
}
#[doc = " Input port action profile."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_in_action_profile {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Input port action profile create."]
    #[doc = ""]
    #[doc = " @param[in] socket_id"]
    #[doc = "   CPU socket ID for the internal data structures memory allocation."]
    #[doc = " @return"]
    #[doc = "   Input port action profile handle on success, NULL otherwise."]
    pub fn rte_port_in_action_profile_create(socket_id: u32) -> *mut rte_port_in_action_profile;
}
extern "C" {
    #[doc = " Input port action profile free."]
    #[doc = ""]
    #[doc = " @param[in] profile"]
    #[doc = "   Input port action profile handle (needs to be valid)."]
    #[doc = " @return"]
    #[doc = "   Zero on success, non-zero error code otherwise."]
    pub fn rte_port_in_action_profile_free(
        profile: *mut rte_port_in_action_profile,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Input port action profile action register."]
    #[doc = ""]
    #[doc = " @param[in] profile"]
    #[doc = "   Input port action profile handle (needs to be valid and not in frozen"]
    #[doc = "   state)."]
    #[doc = " @param[in] type"]
    #[doc = "   Specific input port action to be registered for *profile*."]
    #[doc = " @param[in] action_config"]
    #[doc = "   Configuration for the *type* action."]
    #[doc = "   If struct rte_port_in_action_*type*_config is defined, it needs to point to"]
    #[doc = "   a valid instance of this structure, otherwise it needs to be set to NULL."]
    #[doc = " @return"]
    #[doc = "   Zero on success, non-zero error code otherwise."]
    pub fn rte_port_in_action_profile_action_register(
        profile: *mut rte_port_in_action_profile,
        type_: rte_port_in_action_type,
        action_config: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Input port action profile freeze."]
    #[doc = ""]
    #[doc = " Once this function is called successfully, the given profile enters the"]
    #[doc = " frozen state with the following immediate effects: no more actions can be"]
    #[doc = " registered for this profile, so the profile can be instantiated to create"]
    #[doc = " input port action objects."]
    #[doc = ""]
    #[doc = " @param[in] profile"]
    #[doc = "   Input port profile action handle (needs to be valid and not in frozen"]
    #[doc = "   state)."]
    #[doc = " @return"]
    #[doc = "   Zero on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see rte_port_in_action_create()"]
    pub fn rte_port_in_action_profile_freeze(
        profile: *mut rte_port_in_action_profile,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Input port action."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_in_action {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Input port action create."]
    #[doc = ""]
    #[doc = " Instantiates the given input port action profile to create an input port"]
    #[doc = " action object."]
    #[doc = ""]
    #[doc = " @param[in] profile"]
    #[doc = "   Input port profile action handle (needs to be valid and in frozen state)."]
    #[doc = " @param[in] socket_id"]
    #[doc = "   CPU socket ID where the internal data structures required by the new input"]
    #[doc = "   port action object should be allocated."]
    #[doc = " @return"]
    #[doc = "   Handle to input port action object on success, NULL on error."]
    pub fn rte_port_in_action_create(
        profile: *mut rte_port_in_action_profile,
        socket_id: u32,
    ) -> *mut rte_port_in_action;
}
extern "C" {
    #[doc = " Input port action free."]
    #[doc = ""]
    #[doc = " @param[in] action"]
    #[doc = "   Handle to input port action object (needs to be valid)."]
    #[doc = " @return"]
    #[doc = "   Zero on success, non-zero error code otherwise."]
    pub fn rte_port_in_action_free(action: *mut rte_port_in_action) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Input port params get."]
    #[doc = ""]
    #[doc = " @param[in] action"]
    #[doc = "   Handle to input port action object (needs to be valid)."]
    #[doc = " @param[inout] params"]
    #[doc = "   Pipeline input port parameters (needs to be pre-allocated)."]
    #[doc = " @return"]
    #[doc = "   Zero on success, non-zero error code otherwise."]
    pub fn rte_port_in_action_params_get(
        action: *mut rte_port_in_action,
        params: *mut rte_pipeline_port_in_params,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Input port action apply."]
    #[doc = ""]
    #[doc = " @param[in] action"]
    #[doc = "   Handle to input port action object (needs to be valid)."]
    #[doc = " @param[in] type"]
    #[doc = "   Specific input port action previously registered for the input port action"]
    #[doc = "   profile of the *action* object."]
    #[doc = " @param[in] action_params"]
    #[doc = "   Parameters for the *type* action."]
    #[doc = "   If struct rte_port_in_action_*type*_params is defined, it needs to point to"]
    #[doc = "   a valid instance of this structure, otherwise it needs to be set to NULL."]
    #[doc = " @return"]
    #[doc = "   Zero on success, non-zero error code otherwise."]
    pub fn rte_port_in_action_apply(
        action: *mut rte_port_in_action,
        type_: rte_port_in_action_type,
        action_params: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " kni_reader port parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_kni_reader_params {
    #[doc = " KNI interface reference"]
    pub kni: *mut rte_kni,
}
extern "C" {
    #[doc = " kni_reader port operations"]
    pub static mut rte_port_kni_reader_ops: rte_port_in_ops;
}
#[doc = " kni_writer port parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_kni_writer_params {
    #[doc = " KNI interface reference"]
    pub kni: *mut rte_kni,
    #[doc = " Burst size to KNI interface."]
    pub tx_burst_sz: u32,
}
extern "C" {
    #[doc = " kni_writer port operations"]
    pub static mut rte_port_kni_writer_ops: rte_port_out_ops;
}
#[doc = " kni_writer_nodrop port parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_kni_writer_nodrop_params {
    #[doc = " KNI interface reference"]
    pub kni: *mut rte_kni,
    #[doc = " Burst size to KNI interface."]
    pub tx_burst_sz: u32,
    #[doc = " Maximum number of retries, 0 for no limit"]
    pub n_retries: u32,
}
extern "C" {
    #[doc = " kni_writer_nodrop port operations"]
    pub static mut rte_port_kni_writer_nodrop_ops: rte_port_out_ops;
}
#[doc = " ring_writer_ipv4_ras port parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_ring_writer_ras_params {
    #[doc = " Underlying single consumer ring that has to be pre-initialized."]
    pub ring: *mut rte_ring,
    #[doc = " Recommended burst size to ring. The actual burst size can be bigger"]
    #[doc = "or smaller than this value."]
    pub tx_burst_sz: u32,
}
extern "C" {
    #[doc = " ring_writer_ipv4_ras port operations"]
    pub static mut rte_port_ring_writer_ipv4_ras_ops: rte_port_out_ops;
}
extern "C" {
    #[doc = " ring_writer_ipv6_ras port operations"]
    pub static mut rte_port_ring_writer_ipv6_ras_ops: rte_port_out_ops;
}
#[doc = " ring_reader port parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_ring_reader_params {
    #[doc = " Underlying consumer ring that has to be pre-initialized"]
    pub ring: *mut rte_ring,
}
extern "C" {
    #[doc = " ring_reader port operations"]
    pub static mut rte_port_ring_reader_ops: rte_port_in_ops;
}
#[doc = " ring_writer port parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_ring_writer_params {
    #[doc = " Underlying producer ring that has to be pre-initialized"]
    pub ring: *mut rte_ring,
    #[doc = " Recommended burst size to ring. The actual burst size can be"]
    #[doc = "bigger or smaller than this value."]
    pub tx_burst_sz: u32,
}
extern "C" {
    #[doc = " ring_writer port operations"]
    pub static mut rte_port_ring_writer_ops: rte_port_out_ops;
}
#[doc = " ring_writer_nodrop port parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_ring_writer_nodrop_params {
    #[doc = " Underlying producer ring that has to be pre-initialized"]
    pub ring: *mut rte_ring,
    #[doc = " Recommended burst size to ring. The actual burst size can be"]
    #[doc = "bigger or smaller than this value."]
    pub tx_burst_sz: u32,
    #[doc = " Maximum number of retries, 0 for no limit"]
    pub n_retries: u32,
}
extern "C" {
    #[doc = " ring_writer_nodrop port operations"]
    pub static mut rte_port_ring_writer_nodrop_ops: rte_port_out_ops;
}
extern "C" {
    #[doc = " ring_multi_reader port operations"]
    pub static mut rte_port_ring_multi_reader_ops: rte_port_in_ops;
}
extern "C" {
    #[doc = " ring_multi_writer port operations"]
    pub static mut rte_port_ring_multi_writer_ops: rte_port_out_ops;
}
extern "C" {
    #[doc = " ring_multi_writer_nodrop port operations"]
    pub static mut rte_port_ring_multi_writer_nodrop_ops: rte_port_out_ops;
}
extern "C" {
    #[doc = " Externs"]
    #[doc = ""]
    pub static mut rte_red_rand_val: u32;
}
extern "C" {
    pub static mut rte_red_rand_seed: u32;
}
extern "C" {
    pub static mut rte_red_log2_1_minus_Wq: [u16; 12usize];
}
extern "C" {
    pub static mut rte_red_pow2_frac_inv: [u16; 16usize];
}
#[doc = " RED configuration parameters passed by user"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_red_params {
    #[doc = "< Minimum threshold for queue (max_th)"]
    pub min_th: u16,
    #[doc = "< Maximum threshold for queue (max_th)"]
    pub max_th: u16,
    #[doc = "< Inverse of packet marking probability maximum value (maxp = 1 / maxp_inv)"]
    pub maxp_inv: u16,
    #[doc = "< Negated log2 of queue weight (wq = 1 / (2 ^ wq_log2))"]
    pub wq_log2: u16,
}
#[doc = " RED configuration parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_red_config {
    #[doc = "< min_th scaled in fixed-point format"]
    pub min_th: u32,
    #[doc = "< max_th scaled in fixed-point format"]
    pub max_th: u32,
    #[doc = "< Precomputed constant value used for pa calculation (scaled in fixed-point format)"]
    pub pa_const: u32,
    #[doc = "< maxp_inv"]
    pub maxp_inv: u8,
    #[doc = "< wq_log2"]
    pub wq_log2: u8,
}
#[doc = " RED run-time data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_red {
    #[doc = "< Average queue size (avg), scaled in fixed-point format"]
    pub avg: u32,
    #[doc = "< Number of packets since last marked packet (count)"]
    pub count: u32,
    #[doc = "< Start of the queue idle time (q_time)"]
    pub q_time: u64,
}
extern "C" {
    #[doc = " @brief Initialises run-time data"]
    #[doc = ""]
    #[doc = " @param red [in,out] data pointer to RED runtime data"]
    #[doc = ""]
    #[doc = " @return Operation status"]
    #[doc = " @retval 0 success"]
    #[doc = " @retval !0 error"]
    pub fn rte_red_rt_data_init(red: *mut rte_red) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Configures a single RED configuration parameter structure."]
    #[doc = ""]
    #[doc = " @param red_cfg [in,out] config pointer to a RED configuration parameter structure"]
    #[doc = " @param wq_log2 [in]  log2 of the filter weight, valid range is:"]
    #[doc = "             RTE_RED_WQ_LOG2_MIN <= wq_log2 <= RTE_RED_WQ_LOG2_MAX"]
    #[doc = " @param min_th [in] queue minimum threshold in number of packets"]
    #[doc = " @param max_th [in] queue maximum threshold in number of packets"]
    #[doc = " @param maxp_inv [in] inverse maximum mark probability"]
    #[doc = ""]
    #[doc = " @return Operation status"]
    #[doc = " @retval 0 success"]
    #[doc = " @retval !0 error"]
    pub fn rte_red_config_init(
        red_cfg: *mut rte_red_config,
        wq_log2: u16,
        min_th: u16,
        max_th: u16,
        maxp_inv: u16,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " Congestion Management (CMAN) mode"]
#[doc = ""]
#[doc = " This is used for controlling the admission of packets into a packet queue or"]
#[doc = " group of packet queues on congestion."]
#[doc = ""]
#[doc = " The *Random Early Detection (RED)* algorithm works by proactively dropping"]
#[doc = " more and more input packets as the queue occupancy builds up. When the queue"]
#[doc = " is full or almost full, RED effectively works as *tail drop*. The *Weighted"]
#[doc = " RED* algorithm uses a separate set of RED thresholds for each packet color."]
#[doc = ""]
#[doc = " Similar to RED, Proportional Integral Controller Enhanced (PIE) randomly"]
#[doc = " drops a packet at the onset of the congestion and tries to control the"]
#[doc = " latency around the target value. The congestion detection, however, is based"]
#[doc = " on the queueing latency instead of the queue length like RED. For more"]
#[doc = " information, refer RFC8033."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_sched_cman_mode {
    #[doc = "< Random Early Detection (RED)"]
    RTE_SCHED_CMAN_RED = 0,
    #[doc = "< Proportional Integral Controller Enhanced (PIE)"]
    RTE_SCHED_CMAN_PIE = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_sched_pipe_params {
    #[doc = " Token bucket rate (measured in bytes per second)"]
    pub tb_rate: u64,
    #[doc = " Token bucket size (measured in credits)"]
    pub tb_size: u64,
    #[doc = " Traffic class rates (measured in bytes per second)"]
    pub tc_rate: [u64; 13usize],
    #[doc = " Enforcement period (measured in milliseconds)"]
    pub tc_period: u64,
    #[doc = " Best-effort traffic class oversubscription weight"]
    pub tc_ov_weight: u8,
    #[doc = " WRR weights of best-effort traffic class queues"]
    pub wrr_weights: [u8; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_sched_cman_params {
    #[doc = " Congestion Management mode"]
    pub cman_mode: rte_sched_cman_mode,
    pub __bindgen_anon_1: rte_sched_cman_params__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_sched_cman_params__bindgen_ty_1 {
    #[doc = " RED parameters"]
    pub red_params: [[rte_red_params; 3usize]; 13usize],
    #[doc = " PIE parameters"]
    pub pie_params: [rte_pie_params; 13usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_sched_subport_params {
    #[doc = " Number of subport pipes."]
    #[doc = " The subport can enable/allocate fewer pipes than the maximum"]
    #[doc = " number set through struct port_params::n_max_pipes_per_subport,"]
    #[doc = " as needed, to avoid memory allocation for the queues of the"]
    #[doc = " pipes that are not really needed."]
    pub n_pipes_per_subport_enabled: u32,
    #[doc = " Packet queue size for each traffic class."]
    #[doc = " All the pipes within the same subport share the similar"]
    #[doc = " configuration for the queues."]
    pub qsize: [u16; 13usize],
    #[doc = " Pipe profile table."]
    #[doc = " Every pipe is configured using one of the profiles from this table."]
    pub pipe_profiles: *mut rte_sched_pipe_params,
    #[doc = " Profiles in the pipe profile table"]
    pub n_pipe_profiles: u32,
    #[doc = " Max allowed profiles in the pipe profile table"]
    pub n_max_pipe_profiles: u32,
    #[doc = " Congestion Management parameters"]
    #[doc = " If NULL the congestion management is disabled for the subport,"]
    #[doc = " otherwise proper parameters need to be provided."]
    pub cman_params: *mut rte_sched_cman_params,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_sched_subport_profile_params {
    #[doc = " Token bucket rate (measured in bytes per second)"]
    pub tb_rate: u64,
    #[doc = " Token bucket size (measured in credits)"]
    pub tb_size: u64,
    #[doc = " Traffic class rates (measured in bytes per second)"]
    pub tc_rate: [u64; 13usize],
    #[doc = " Enforcement period for rates (measured in milliseconds)"]
    pub tc_period: u64,
}
#[doc = " Subport statistics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_sched_subport_stats {
    #[doc = " Number of packets successfully written"]
    pub n_pkts_tc: [u64; 13usize],
    #[doc = " Number of packets dropped"]
    pub n_pkts_tc_dropped: [u64; 13usize],
    #[doc = " Number of bytes successfully written for each traffic class"]
    pub n_bytes_tc: [u64; 13usize],
    #[doc = " Number of bytes dropped for each traffic class"]
    pub n_bytes_tc_dropped: [u64; 13usize],
    #[doc = " Number of packets dropped by congestion management scheme"]
    pub n_pkts_cman_dropped: [u64; 13usize],
}
#[doc = " Queue statistics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_sched_queue_stats {
    #[doc = " Packets successfully written"]
    pub n_pkts: u64,
    #[doc = " Packets dropped"]
    pub n_pkts_dropped: u64,
    #[doc = " Packets dropped by congestion management scheme"]
    pub n_pkts_cman_dropped: u64,
    #[doc = " Bytes successfully written"]
    pub n_bytes: u64,
    #[doc = " Bytes dropped"]
    pub n_bytes_dropped: u64,
}
#[doc = " Port configuration parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_sched_port_params {
    #[doc = " Name of the port to be associated"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " CPU socket ID"]
    pub socket: ::std::os::raw::c_int,
    #[doc = " Output port rate (measured in bytes per second)"]
    pub rate: u64,
    #[doc = " Maximum Ethernet frame size (measured in bytes)."]
    #[doc = " Should not include the framing overhead."]
    pub mtu: u32,
    #[doc = " Framing overhead per packet (measured in bytes)"]
    pub frame_overhead: u32,
    #[doc = " Number of subports"]
    pub n_subports_per_port: u32,
    #[doc = " subport profile table."]
    #[doc = " Every pipe is configured using one of the profiles from this table."]
    pub subport_profiles: *mut rte_sched_subport_profile_params,
    #[doc = " Profiles in the pipe profile table"]
    pub n_subport_profiles: u32,
    #[doc = " Max allowed profiles in the pipe profile table"]
    pub n_max_subport_profiles: u32,
    #[doc = " Maximum number of subport pipes."]
    #[doc = " This parameter is used to reserve a fixed number of bits"]
    #[doc = " in struct rte_mbuf::sched.queue_id for the pipe_id for all"]
    #[doc = " the subports of the same port."]
    pub n_pipes_per_subport: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_sched_port {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Hierarchical scheduler port configuration"]
    #[doc = ""]
    #[doc = " @param params"]
    #[doc = "   Port scheduler configuration parameter structure"]
    #[doc = " @return"]
    #[doc = "   Handle to port scheduler instance upon success or NULL otherwise."]
    pub fn rte_sched_port_config(params: *mut rte_sched_port_params) -> *mut rte_sched_port;
}
extern "C" {
    #[doc = " Hierarchical scheduler port free"]
    #[doc = ""]
    #[doc = " @param port"]
    #[doc = "   Handle to port scheduler instance"]
    pub fn rte_sched_port_free(port: *mut rte_sched_port);
}
extern "C" {
    #[doc = " Hierarchical scheduler pipe profile add"]
    #[doc = ""]
    #[doc = " @param port"]
    #[doc = "   Handle to port scheduler instance"]
    #[doc = " @param subport_id"]
    #[doc = "   Subport ID"]
    #[doc = " @param params"]
    #[doc = "   Pipe profile parameters"]
    #[doc = " @param pipe_profile_id"]
    #[doc = "   Set to valid profile id when profile is added successfully."]
    #[doc = " @return"]
    #[doc = "   0 upon success, error code otherwise"]
    pub fn rte_sched_subport_pipe_profile_add(
        port: *mut rte_sched_port,
        subport_id: u32,
        params: *mut rte_sched_pipe_params,
        pipe_profile_id: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Hierarchical scheduler subport bandwidth profile add"]
    #[doc = " Note that this function is safe to use in runtime for adding new"]
    #[doc = " subport bandwidth profile as it doesn't have any impact on hierarchical"]
    #[doc = " structure of the scheduler."]
    #[doc = " @param port"]
    #[doc = "   Handle to port scheduler instance"]
    #[doc = " @param profile"]
    #[doc = "   Subport bandwidth profile"]
    #[doc = " @param subport_profile_id"]
    #[doc = "   Subport profile id"]
    #[doc = " @return"]
    #[doc = "   0 upon success, error code otherwise"]
    pub fn rte_sched_port_subport_profile_add(
        port: *mut rte_sched_port,
        profile: *mut rte_sched_subport_profile_params,
        subport_profile_id: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Hierarchical scheduler subport configuration"]
    #[doc = " Note that this function is safe to use at runtime"]
    #[doc = " to configure subport bandwidth profile."]
    #[doc = " @param port"]
    #[doc = "   Handle to port scheduler instance"]
    #[doc = " @param subport_id"]
    #[doc = "   Subport ID"]
    #[doc = " @param params"]
    #[doc = "   Subport configuration parameters. Must be non-NULL"]
    #[doc = "   for first invocation (i.e initialization) for a given"]
    #[doc = "   subport. Ignored (recommended value is NULL) for all"]
    #[doc = "   subsequent invocation on the same subport."]
    #[doc = " @param subport_profile_id"]
    #[doc = "   ID of subport bandwidth profile"]
    #[doc = " @return"]
    #[doc = "   0 upon success, error code otherwise"]
    pub fn rte_sched_subport_config(
        port: *mut rte_sched_port,
        subport_id: u32,
        params: *mut rte_sched_subport_params,
        subport_profile_id: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Hierarchical scheduler pipe configuration"]
    #[doc = ""]
    #[doc = " @param port"]
    #[doc = "   Handle to port scheduler instance"]
    #[doc = " @param subport_id"]
    #[doc = "   Subport ID"]
    #[doc = " @param pipe_id"]
    #[doc = "   Pipe ID within subport"]
    #[doc = " @param pipe_profile"]
    #[doc = "   ID of subport-level pre-configured pipe profile"]
    #[doc = " @return"]
    #[doc = "   0 upon success, error code otherwise"]
    pub fn rte_sched_pipe_config(
        port: *mut rte_sched_port,
        subport_id: u32,
        pipe_id: u32,
        pipe_profile: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Hierarchical scheduler memory footprint size per port"]
    #[doc = ""]
    #[doc = " @param port_params"]
    #[doc = "   Port scheduler configuration parameter structure"]
    #[doc = " @param subport_params"]
    #[doc = "   Array of subport parameter structures"]
    #[doc = " @return"]
    #[doc = "   Memory footprint size in bytes upon success, 0 otherwise"]
    pub fn rte_sched_port_get_memory_footprint(
        port_params: *mut rte_sched_port_params,
        subport_params: *mut *mut rte_sched_subport_params,
    ) -> u32;
}
extern "C" {
    #[doc = " Hierarchical scheduler subport statistics read"]
    #[doc = ""]
    #[doc = " @param port"]
    #[doc = "   Handle to port scheduler instance"]
    #[doc = " @param subport_id"]
    #[doc = "   Subport ID"]
    #[doc = " @param stats"]
    #[doc = "   Pointer to pre-allocated subport statistics structure where the statistics"]
    #[doc = "   counters should be stored"]
    #[doc = " @param tc_ov"]
    #[doc = "   Pointer to pre-allocated RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE-entry array"]
    #[doc = "   where the oversubscription status for each of the subport traffic classes"]
    #[doc = "   should be stored."]
    #[doc = " @return"]
    #[doc = "   0 upon success, error code otherwise"]
    pub fn rte_sched_subport_read_stats(
        port: *mut rte_sched_port,
        subport_id: u32,
        stats: *mut rte_sched_subport_stats,
        tc_ov: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Hierarchical scheduler queue statistics read"]
    #[doc = ""]
    #[doc = " @param port"]
    #[doc = "   Handle to port scheduler instance"]
    #[doc = " @param queue_id"]
    #[doc = "   Queue ID within port scheduler"]
    #[doc = " @param stats"]
    #[doc = "   Pointer to pre-allocated subport statistics structure where the statistics"]
    #[doc = "   counters should be stored"]
    #[doc = " @param qlen"]
    #[doc = "   Pointer to pre-allocated variable where the current queue length"]
    #[doc = "   should be stored."]
    #[doc = " @return"]
    #[doc = "   0 upon success, error code otherwise"]
    pub fn rte_sched_queue_read_stats(
        port: *mut rte_sched_port,
        queue_id: u32,
        stats: *mut rte_sched_queue_stats,
        qlen: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Scheduler hierarchy path write to packet descriptor. Typically"]
    #[doc = " called by the packet classification stage."]
    #[doc = ""]
    #[doc = " @param port"]
    #[doc = "   Handle to port scheduler instance"]
    #[doc = " @param pkt"]
    #[doc = "   Packet descriptor handle"]
    #[doc = " @param subport"]
    #[doc = "   Subport ID"]
    #[doc = " @param pipe"]
    #[doc = "   Pipe ID within subport"]
    #[doc = " @param traffic_class"]
    #[doc = "   Traffic class ID within pipe (0 .. RTE_SCHED_TRAFFIC_CLASS_BE)"]
    #[doc = " @param queue"]
    #[doc = "   Queue ID within pipe traffic class, 0 for high priority TCs, and"]
    #[doc = "   0 .. (RTE_SCHED_BE_QUEUES_PER_PIPE - 1) for best-effort TC"]
    #[doc = " @param color"]
    #[doc = "   Packet color set"]
    pub fn rte_sched_port_pkt_write(
        port: *mut rte_sched_port,
        pkt: *mut rte_mbuf,
        subport: u32,
        pipe: u32,
        traffic_class: u32,
        queue: u32,
        color: rte_color,
    );
}
extern "C" {
    #[doc = " Scheduler hierarchy path read from packet descriptor (struct"]
    #[doc = " rte_mbuf). Typically called as part of the hierarchical scheduler"]
    #[doc = " enqueue operation. The subport, pipe, traffic class and queue"]
    #[doc = " parameters need to be pre-allocated by the caller."]
    #[doc = ""]
    #[doc = " @param port"]
    #[doc = "   Handle to port scheduler instance"]
    #[doc = " @param pkt"]
    #[doc = "   Packet descriptor handle"]
    #[doc = " @param subport"]
    #[doc = "   Subport ID"]
    #[doc = " @param pipe"]
    #[doc = "   Pipe ID within subport"]
    #[doc = " @param traffic_class"]
    #[doc = "   Traffic class ID within pipe (0 .. RTE_SCHED_TRAFFIC_CLASS_BE)"]
    #[doc = " @param queue"]
    #[doc = "   Queue ID within pipe traffic class, 0 for high priority TCs, and"]
    #[doc = "   0 .. (RTE_SCHED_BE_QUEUES_PER_PIPE - 1) for best-effort TC"]
    pub fn rte_sched_port_pkt_read_tree_path(
        port: *mut rte_sched_port,
        pkt: *const rte_mbuf,
        subport: *mut u32,
        pipe: *mut u32,
        traffic_class: *mut u32,
        queue: *mut u32,
    );
}
extern "C" {
    pub fn rte_sched_port_pkt_read_color(pkt: *const rte_mbuf) -> rte_color;
}
extern "C" {
    #[doc = " Hierarchical scheduler port enqueue. Writes up to n_pkts to port"]
    #[doc = " scheduler and returns the number of packets actually written. For"]
    #[doc = " each packet, the port scheduler queue to write the packet to is"]
    #[doc = " identified by reading the hierarchy path from the packet"]
    #[doc = " descriptor; if the queue is full or congested and the packet is not"]
    #[doc = " written to the queue, then the packet is automatically dropped"]
    #[doc = " without any action required from the caller."]
    #[doc = ""]
    #[doc = " @param port"]
    #[doc = "   Handle to port scheduler instance"]
    #[doc = " @param pkts"]
    #[doc = "   Array storing the packet descriptor handles"]
    #[doc = " @param n_pkts"]
    #[doc = "   Number of packets to enqueue from the pkts array into the port scheduler"]
    #[doc = " @return"]
    #[doc = "   Number of packets successfully enqueued"]
    pub fn rte_sched_port_enqueue(
        port: *mut rte_sched_port,
        pkts: *mut *mut rte_mbuf,
        n_pkts: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Hierarchical scheduler port dequeue. Reads up to n_pkts from the"]
    #[doc = " port scheduler and stores them in the pkts array and returns the"]
    #[doc = " number of packets actually read.  The pkts array needs to be"]
    #[doc = " pre-allocated by the caller with at least n_pkts entries."]
    #[doc = ""]
    #[doc = " @param port"]
    #[doc = "   Handle to port scheduler instance"]
    #[doc = " @param pkts"]
    #[doc = "   Pre-allocated packet descriptor array where the packets dequeued"]
    #[doc = "   from the port"]
    #[doc = "   scheduler should be stored"]
    #[doc = " @param n_pkts"]
    #[doc = "   Number of packets to dequeue from the port scheduler"]
    #[doc = " @return"]
    #[doc = "   Number of packets successfully dequeued and placed in the pkts array"]
    pub fn rte_sched_port_dequeue(
        port: *mut rte_sched_port,
        pkts: *mut *mut rte_mbuf,
        n_pkts: u32,
    ) -> ::std::os::raw::c_int;
}
#[doc = " sched_reader port parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_sched_reader_params {
    #[doc = " Underlying pre-initialized rte_sched_port"]
    pub sched: *mut rte_sched_port,
}
extern "C" {
    #[doc = " sched_reader port operations"]
    pub static mut rte_port_sched_reader_ops: rte_port_in_ops;
}
#[doc = " sched_writer port parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_sched_writer_params {
    #[doc = " Underlying pre-initialized rte_sched_port"]
    pub sched: *mut rte_sched_port,
    #[doc = " Recommended burst size. The actual burst size can be bigger or"]
    #[doc = "smaller than this value."]
    pub tx_burst_sz: u32,
}
extern "C" {
    #[doc = " sched_writer port operations"]
    pub static mut rte_port_sched_writer_ops: rte_port_out_ops;
}
#[doc = " source port parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_source_params {
    #[doc = " Pre-initialized buffer pool"]
    pub mempool: *mut rte_mempool,
    #[doc = " The full path of the pcap file to read packets from"]
    pub file_name: *const ::std::os::raw::c_char,
    #[doc = " The number of bytes to be read from each packet in the"]
    #[doc = "  pcap file. If this value is 0, the whole packet is read;"]
    #[doc = "  if it is bigger than packet size, the generated packets"]
    #[doc = "  will contain the whole packet"]
    pub n_bytes_per_pkt: u32,
}
extern "C" {
    #[doc = " source port operations"]
    pub static mut rte_port_source_ops: rte_port_in_ops;
}
#[doc = " sink port parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_port_sink_params {
    #[doc = " The full path of the pcap file to write the packets to"]
    pub file_name: *const ::std::os::raw::c_char,
    #[doc = " The maximum number of packets write to the pcap file."]
    #[doc = "  If this value is 0, the \"infinite\" write will be carried"]
    #[doc = "  out."]
    pub max_n_pkts: u32,
}
extern "C" {
    #[doc = " sink port operations"]
    pub static mut rte_port_sink_ops: rte_port_out_ops;
}
pub type rte_rawdev_obj_t = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = " Get the total number of raw devices that have been successfully"]
    #[doc = " initialised."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The total number of usable raw devices."]
    pub fn rte_rawdev_count() -> u8;
}
extern "C" {
    #[doc = " Get the device identifier for the named raw device."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Raw device name to select the raw device identifier."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Returns raw device identifier on success."]
    #[doc = "   - <0: Failure to find named raw device."]
    pub fn rte_rawdev_get_dev_id(name: *const ::std::os::raw::c_char) -> u16;
}
extern "C" {
    #[doc = " Return the NUMA socket to which a device is connected."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @return"]
    #[doc = "   The NUMA socket id to which the device is connected or"]
    #[doc = "   a default of zero if the socket could not be determined."]
    #[doc = "   -(-EINVAL)  dev_id value is out of range."]
    pub fn rte_rawdev_socket_id(dev_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the contextual information of a raw device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @param[out] dev_info"]
    #[doc = "   A pointer to a structure of type *rte_rawdev_info* to be filled with the"]
    #[doc = "   contextual information of the device. The dev_info->dev_private field"]
    #[doc = "   should point to an appropriate buffer space for holding the device-"]
    #[doc = "   specific info for that hardware."]
    #[doc = "   If the dev_private field is set to NULL, then the device-specific info"]
    #[doc = "   function will not be called and only basic information about the device"]
    #[doc = "   will be returned. This can be used to safely query the type of a rawdev"]
    #[doc = "   instance without needing to know the size of the private data to return."]
    #[doc = ""]
    #[doc = " @param dev_private_size"]
    #[doc = "   The length of the memory space pointed to by dev_private in dev_info."]
    #[doc = "   This should be set to the size of the expected private structure to be"]
    #[doc = "   returned, and may be checked by drivers to ensure the expected struct"]
    #[doc = "   type is provided."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success, driver updates the contextual information of the raw device"]
    #[doc = "   - <0: Error code returned by the driver info get function."]
    #[doc = ""]
    pub fn rte_rawdev_info_get(
        dev_id: u16,
        dev_info: *mut rte_rawdev_info,
        dev_private_size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configure a raw device."]
    #[doc = ""]
    #[doc = " This function must be invoked first before any other function in the"]
    #[doc = " API. This function can also be re-invoked when a device is in the"]
    #[doc = " stopped state."]
    #[doc = ""]
    #[doc = " The caller may use rte_rawdev_info_get() to get the capability of each"]
    #[doc = " resources available for this raw device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device to configure."]
    #[doc = " @param dev_conf"]
    #[doc = "   The raw device configuration structure encapsulated into rte_rawdev_info"]
    #[doc = "   object."]
    #[doc = "   It is assumed that the opaque object has enough information which the"]
    #[doc = "   driver/implementation can use to configure the device. It is also assumed"]
    #[doc = "   that once the configuration is done, a `queue_id` type field can be used"]
    #[doc = "   to refer to some arbitrary internal representation of a queue."]
    #[doc = " @param dev_private_size"]
    #[doc = "   The length of the memory space pointed to by dev_private in dev_info."]
    #[doc = "   This should be set to the size of the expected private structure to be"]
    #[doc = "   used by the driver, and may be checked by drivers to ensure the expected"]
    #[doc = "   struct type is provided."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success, device configured."]
    #[doc = "   - <0: Error code returned by the driver configuration function."]
    pub fn rte_rawdev_configure(
        dev_id: u16,
        dev_conf: *mut rte_rawdev_info,
        dev_private_size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the current configuration information of a raw queue designated"]
    #[doc = " by its *queue_id* from the raw driver for a raw device."]
    #[doc = ""]
    #[doc = " This function intended to be used in conjunction with rte_raw_queue_setup()"]
    #[doc = " where caller needs to set up the queue by overriding few default values."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the raw queue to get the configuration information."]
    #[doc = "   The value must be in the range [0, nb_raw_queues - 1]"]
    #[doc = "   previously supplied to rte_rawdev_configure()."]
    #[doc = " @param[out] queue_conf"]
    #[doc = "   The pointer to the default raw queue configuration data."]
    #[doc = " @param queue_conf_size"]
    #[doc = "   The size of the structure pointed to by queue_conf"]
    #[doc = " @return"]
    #[doc = "   - 0: Success, driver updates the default raw queue configuration data."]
    #[doc = "   - <0: Error code returned by the driver info get function."]
    #[doc = ""]
    #[doc = " @see rte_raw_queue_setup()"]
    #[doc = ""]
    pub fn rte_rawdev_queue_conf_get(
        dev_id: u16,
        queue_id: u16,
        queue_conf: rte_rawdev_obj_t,
        queue_conf_size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate and set up a raw queue for a raw device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the raw queue to setup. The value must be in the range"]
    #[doc = "   [0, nb_raw_queues - 1] previously supplied to rte_rawdev_configure()."]
    #[doc = " @param queue_conf"]
    #[doc = "   The pointer to the configuration data to be used for the raw queue."]
    #[doc = "   NULL value is allowed, in which case default configuration\tused."]
    #[doc = " @param queue_conf_size"]
    #[doc = "   The size of the structure pointed to by queue_conf"]
    #[doc = ""]
    #[doc = " @see rte_rawdev_queue_conf_get()"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success, raw queue correctly set up."]
    #[doc = "   - <0: raw queue configuration failed"]
    pub fn rte_rawdev_queue_setup(
        dev_id: u16,
        queue_id: u16,
        queue_conf: rte_rawdev_obj_t,
        queue_conf_size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release and deallocate a raw queue from a raw device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the raw queue to release. The value must be in the range"]
    #[doc = "   [0, nb_raw_queues - 1] previously supplied to rte_rawdev_configure()."]
    #[doc = ""]
    #[doc = " @see rte_rawdev_queue_conf_get()"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success, raw queue released."]
    #[doc = "   - <0: raw queue configuration failed"]
    pub fn rte_rawdev_queue_release(dev_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the number of raw queues on a specific raw device"]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Raw device identifier."]
    #[doc = " @return"]
    #[doc = "   - The number of configured raw queues"]
    pub fn rte_rawdev_queue_count(dev_id: u16) -> u16;
}
extern "C" {
    #[doc = " Start a raw device."]
    #[doc = ""]
    #[doc = " The device start step is the last one and consists of setting the raw"]
    #[doc = " queues to start accepting the raws and schedules to raw ports."]
    #[doc = ""]
    #[doc = " On success, all basic functions exported by the API (raw enqueue,"]
    #[doc = " raw dequeue and so on) can be invoked."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Raw device identifier"]
    #[doc = " @return"]
    #[doc = "   - 0: Success, device started."]
    #[doc = "   < 0: Failure"]
    pub fn rte_rawdev_start(dev_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop a raw device. The device can be restarted with a call to"]
    #[doc = " rte_rawdev_start()"]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Raw device identifier."]
    pub fn rte_rawdev_stop(dev_id: u16);
}
extern "C" {
    #[doc = " Close a raw device. The device cannot be restarted after this call."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Raw device identifier"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 on successfully closing device"]
    #[doc = "  - <0 on failure to close device"]
    #[doc = "  - (-EAGAIN) if device is busy"]
    pub fn rte_rawdev_close(dev_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset a raw device."]
    #[doc = " This is different from cycle of rte_rawdev_start->rte_rawdev_stop in the"]
    #[doc = " sense similar to hard or soft reset."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Raw device identifiers"]
    #[doc = " @return"]
    #[doc = "   0 for successful reset,"]
    #[doc = "  !0 for failure in resetting"]
    pub fn rte_rawdev_reset(dev_id: u16) -> ::std::os::raw::c_int;
}
#[doc = " @internal"]
#[doc = " The data structure associated with each raw device."]
#[doc = " It is a placeholder for PMD specific data, encapsulating only information"]
#[doc = " related to framework."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_rawdev {
    pub socket_id: ::std::os::raw::c_int,
    pub dev_id: u16,
    pub dev_ops: *const rte_rawdev_ops,
    pub device: *mut rte_device,
    pub driver_name: *const ::std::os::raw::c_char,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub dev_private: rte_rawdev_obj_t,
    pub name: [::std::os::raw::c_char; 64usize],
}
impl rte_rawdev {
    #[inline]
    pub fn attached(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_attached(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn started(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_started(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(attached: u8, started: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let attached: u8 = unsafe { ::std::mem::transmute(attached) };
            attached as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let started: u8 = unsafe { ::std::mem::transmute(started) };
            started as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @internal The pool of rte_rawdev structures."]
    pub static mut rte_rawdevs: *mut rte_rawdev;
}
#[doc = " Raw device information forward declaration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_rawdev_info {
    pub driver_name: *const ::std::os::raw::c_char,
    pub device: *mut rte_device,
    pub socket_id: ::std::os::raw::c_int,
    pub dev_private: rte_rawdev_obj_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_rawdev_buf {
    pub buf_addr: *mut ::std::os::raw::c_void,
}
extern "C" {
    #[doc = " Dump internal information about *dev_id* to the FILE* provided in *f*."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: on success"]
    #[doc = "   - <0: on failure."]
    pub fn rte_rawdev_dump(dev_id: u16, f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get an attribute value from implementation."]
    #[doc = " Attribute is an opaque handle agreed upon between application and PMD."]
    #[doc = ""]
    #[doc = " Implementations are expected to maintain an array of attribute-value pairs"]
    #[doc = " based on application calls. Memory management for this structure is"]
    #[doc = " shared responsibility of implementation and application."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device to configure."]
    #[doc = " @param attr_name"]
    #[doc = "   Opaque object representing an attribute in implementation."]
    #[doc = " @param attr_value [out]"]
    #[doc = "   Opaque response to the attribute value. In case of error, this remains"]
    #[doc = "   untouched. This is double pointer of void type."]
    #[doc = " @return"]
    #[doc = "   0 for success"]
    #[doc = "  !0 Error; attr_value remains untouched in case of error."]
    pub fn rte_rawdev_get_attr(
        dev_id: u16,
        attr_name: *const ::std::os::raw::c_char,
        attr_value: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set an attribute value."]
    #[doc = " Attribute is an opaque handle agreed upon between application and PMD."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device to configure."]
    #[doc = " @param attr_name"]
    #[doc = "   Opaque object representing an attribute in implementation."]
    #[doc = " @param attr_value"]
    #[doc = "   Value of the attribute represented by attr_name"]
    #[doc = " @return"]
    #[doc = "   0 for success"]
    #[doc = "  !0 Error"]
    pub fn rte_rawdev_set_attr(
        dev_id: u16,
        attr_name: *const ::std::os::raw::c_char,
        attr_value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enqueue a stream of buffers to the device."]
    #[doc = ""]
    #[doc = " Rather than specifying a queue, this API passes along an opaque object"]
    #[doc = " to the driver implementation. That object can be a queue or any other"]
    #[doc = " contextual information necessary for the device to enqueue buffers."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device to configure."]
    #[doc = " @param buffers"]
    #[doc = "   Collection of buffers for enqueuing"]
    #[doc = " @param count"]
    #[doc = "   Count of buffers to enqueue"]
    #[doc = " @param context"]
    #[doc = "   Opaque context information."]
    #[doc = " @return"]
    #[doc = "   >=0 for buffers enqueued"]
    #[doc = "  !0 for failure."]
    #[doc = "  Whether partial enqueue is failure or success is defined between app"]
    #[doc = "  and driver implementation."]
    pub fn rte_rawdev_enqueue_buffers(
        dev_id: u16,
        buffers: *mut *mut rte_rawdev_buf,
        count: ::std::os::raw::c_uint,
        context: rte_rawdev_obj_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dequeue a stream of buffers from the device."]
    #[doc = ""]
    #[doc = " Rather than specifying a queue, this API passes along an opaque object"]
    #[doc = " to the driver implementation. That object can be a queue or any other"]
    #[doc = " contextual information necessary for the device to dequeue buffers."]
    #[doc = ""]
    #[doc = " Application should have allocated enough space to store `count` response"]
    #[doc = " buffers."]
    #[doc = " Releasing buffers dequeued is responsibility of the application."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device to configure."]
    #[doc = " @param buffers"]
    #[doc = "   Collection of buffers dequeued"]
    #[doc = " @param count"]
    #[doc = "   Max buffers expected to be dequeued"]
    #[doc = " @param context"]
    #[doc = "   Opaque context information."]
    #[doc = " @return"]
    #[doc = "   >=0 for buffers dequeued"]
    #[doc = "  !0 for failure."]
    #[doc = "  Whether partial enqueue is failure or success is defined between app"]
    #[doc = "  and driver implementation."]
    pub fn rte_rawdev_dequeue_buffers(
        dev_id: u16,
        buffers: *mut *mut rte_rawdev_buf,
        count: ::std::os::raw::c_uint,
        context: rte_rawdev_obj_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " A name-key lookup element for extended statistics."]
#[doc = ""]
#[doc = " This structure is used to map between names and ID numbers"]
#[doc = " for extended ethdev statistics."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_rawdev_xstats_name {
    pub name: [::std::os::raw::c_char; 64usize],
}
extern "C" {
    #[doc = " Retrieve names of extended statistics of a raw device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the raw device."]
    #[doc = " @param[out] xstats_names"]
    #[doc = "   Block of memory to insert names into. Must be at least size in capacity."]
    #[doc = "   If set to NULL, function returns required capacity."]
    #[doc = " @param size"]
    #[doc = "   Capacity of xstats_names (number of names)."]
    #[doc = " @return"]
    #[doc = "   - positive value lower or equal to size: success. The return value"]
    #[doc = "     is the number of entries filled in the stats table."]
    #[doc = "   - positive value higher than size: error, the given statistics table"]
    #[doc = "     is too small. The return value corresponds to the size that should"]
    #[doc = "     be given to succeed. The entries in the table are not valid and"]
    #[doc = "     shall not be used by the caller."]
    #[doc = "   - negative value on error:"]
    #[doc = "        -ENODEV for invalid *dev_id*"]
    #[doc = "        -ENOTSUP if the device doesn't support this function."]
    pub fn rte_rawdev_xstats_names_get(
        dev_id: u16,
        xstats_names: *mut rte_rawdev_xstats_name,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve extended statistics of a raw device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param ids"]
    #[doc = "   The id numbers of the stats to get. The ids can be got from the stat"]
    #[doc = "   position in the stat list from rte_rawdev_get_xstats_names(), or"]
    #[doc = "   by using rte_rawdev_get_xstats_by_name()"]
    #[doc = " @param[out] values"]
    #[doc = "   The values for each stats request by ID."]
    #[doc = " @param n"]
    #[doc = "   The number of stats requested"]
    #[doc = " @return"]
    #[doc = "   - positive value: number of stat entries filled into the values array"]
    #[doc = "   - negative value on error:"]
    #[doc = "        -ENODEV for invalid *dev_id*"]
    #[doc = "        -ENOTSUP if the device doesn't support this function."]
    pub fn rte_rawdev_xstats_get(
        dev_id: u16,
        ids: *const ::std::os::raw::c_uint,
        values: *mut u64,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the value of a single stat by requesting it by name."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device"]
    #[doc = " @param name"]
    #[doc = "   The stat name to retrieve"]
    #[doc = " @param[out] id"]
    #[doc = "   If non-NULL, the numerical id of the stat will be returned, so that further"]
    #[doc = "   requests for the stat can be got using rte_rawdev_xstats_get, which will"]
    #[doc = "   be faster as it doesn't need to scan a list of names for the stat."]
    #[doc = "   If the stat cannot be found, the id returned will be (unsigned)-1."]
    #[doc = " @return"]
    #[doc = "   - positive value or zero: the stat value"]
    #[doc = "   - negative value: -EINVAL if stat not found, -ENOTSUP if not supported."]
    pub fn rte_rawdev_xstats_by_name_get(
        dev_id: u16,
        name: *const ::std::os::raw::c_char,
        id: *mut ::std::os::raw::c_uint,
    ) -> u64;
}
extern "C" {
    #[doc = " Reset the values of the xstats of the selected component in the device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device"]
    #[doc = " @param ids"]
    #[doc = "   Selects specific statistics to be reset. When NULL, all statistics"]
    #[doc = "   will be reset. If non-NULL, must point to array of at least"]
    #[doc = "   *nb_ids* size."]
    #[doc = " @param nb_ids"]
    #[doc = "   The number of ids available from the *ids* array. Ignored when ids is NULL."]
    #[doc = " @return"]
    #[doc = "   - zero: successfully reset the statistics to zero"]
    #[doc = "   - negative value: -EINVAL invalid parameters, -ENOTSUP if not supported."]
    pub fn rte_rawdev_xstats_reset(
        dev_id: u16,
        ids: *const u32,
        nb_ids: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get Firmware status of the device.."]
    #[doc = " Returns a memory allocated by driver/implementation containing status"]
    #[doc = " information block. It is responsibility of caller to release the buffer."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Raw device identifier"]
    #[doc = " @param status_info"]
    #[doc = "   Pointer to status information area. Caller is responsible for releasing"]
    #[doc = "   the memory associated."]
    #[doc = " @return"]
    #[doc = "   0 for success,"]
    #[doc = "  !0 for failure, `status_info` argument state is undefined"]
    pub fn rte_rawdev_firmware_status_get(
        dev_id: u16,
        status_info: rte_rawdev_obj_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get Firmware version of the device."]
    #[doc = " Returns a memory allocated by driver/implementation containing version"]
    #[doc = " information block. It is responsibility of caller to release the buffer."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Raw device identifier"]
    #[doc = " @param version_info"]
    #[doc = "   Pointer to version information area. Caller is responsible for releasing"]
    #[doc = "   the memory associated."]
    #[doc = " @return"]
    #[doc = "   0 for success,"]
    #[doc = "  !0 for failure, `version_info` argument state is undefined"]
    pub fn rte_rawdev_firmware_version_get(
        dev_id: u16,
        version_info: rte_rawdev_obj_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Load firmware on the device."]
    #[doc = " TODO: In future, methods like directly flashing from file too can be"]
    #[doc = " supported."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Raw device identifier"]
    #[doc = " @param firmware_image"]
    #[doc = "   Pointer to buffer containing image binary data"]
    #[doc = " @return"]
    #[doc = "   0 for successful load"]
    #[doc = "  !0 for failure to load the provided image, or image incorrect."]
    pub fn rte_rawdev_firmware_load(
        dev_id: u16,
        firmware_image: rte_rawdev_obj_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unload firmware from the device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   Raw device identifiers"]
    #[doc = " @return"]
    #[doc = "   0 for successful Unload"]
    #[doc = "  !0 for failure in unloading"]
    pub fn rte_rawdev_firmware_unload(dev_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Trigger the rawdev self test."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device"]
    #[doc = " @return"]
    #[doc = "   - 0: Selftest successful"]
    #[doc = "   - -ENOTSUP if the device doesn't support selftest"]
    #[doc = "   - other values < 0 on failure."]
    pub fn rte_rawdev_selftest(dev_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut librawdev_logtype: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_rawdev_global {
    pub nb_devs: u16,
}
#[doc = " Get device information of a device."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
#[doc = " @param dev_info"]
#[doc = "   Raw device information structure"]
#[doc = " @param dev_private_size"]
#[doc = "   The size of the structure pointed to by dev_info->dev_private"]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Returns 0 on success, negative error code on failure"]
pub type rawdev_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_rawdev,
        dev_info: rte_rawdev_obj_t,
        dev_private_size: size_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Configure a device."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
#[doc = " @param config"]
#[doc = "   Void object containing device specific configuration"]
#[doc = " @param config_size"]
#[doc = "   Size of the memory allocated for the configuration"]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Returns 0 on success"]
pub type rawdev_configure_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *const rte_rawdev,
        config: rte_rawdev_obj_t,
        config_size: size_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Start a configured device."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Returns 0 on success"]
pub type rawdev_start_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_rawdev) -> ::std::os::raw::c_int>;
#[doc = " Stop a configured device."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
pub type rawdev_stop_t = ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_rawdev)>;
#[doc = " Close a configured device."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
#[doc = ""]
#[doc = " @return"]
#[doc = " - 0 on success"]
#[doc = " - (-EAGAIN) if can't close as device is busy"]
pub type rawdev_close_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_rawdev) -> ::std::os::raw::c_int>;
#[doc = " Reset a configured device."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
#[doc = " @return"]
#[doc = "   0 for success"]
#[doc = "   !0 for failure"]
pub type rawdev_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_rawdev) -> ::std::os::raw::c_int>;
#[doc = " Retrieve the current raw queue configuration."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
#[doc = " @param queue_id"]
#[doc = "   Raw device queue index"]
#[doc = " @param[out] queue_conf"]
#[doc = "   Raw device queue configuration structure"]
#[doc = " @param queue_conf_size"]
#[doc = "   Size of the memory allocated for the configuration"]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Returns 0 on success, negative errno on failure"]
pub type rawdev_queue_conf_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_rawdev,
        queue_id: u16,
        queue_conf: rte_rawdev_obj_t,
        queue_conf_size: size_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Setup an raw queue."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
#[doc = " @param queue_id"]
#[doc = "   Rawqueue index"]
#[doc = " @param queue_conf"]
#[doc = "   Rawqueue configuration structure"]
#[doc = " @param queue_conf_size"]
#[doc = "   Size of the memory allocated for the configuration"]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Returns 0 on success."]
pub type rawdev_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_rawdev,
        queue_id: u16,
        queue_conf: rte_rawdev_obj_t,
        queue_conf_size: size_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Release resources allocated by given raw queue."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
#[doc = " @param queue_id"]
#[doc = "   Raw queue index"]
#[doc = ""]
pub type rawdev_queue_release_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_rawdev, queue_id: u16) -> ::std::os::raw::c_int,
>;
#[doc = " Get the count of number of queues configured on this device."]
#[doc = ""]
#[doc = " Another way to fetch this information is to fetch the device configuration."]
#[doc = " But, that assumes that the device configuration managed by the driver has"]
#[doc = " that kind of information."]
#[doc = ""]
#[doc = " This function helps in getting queue count supported, independently. It"]
#[doc = " can help in cases where iterator needs to be implemented."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
#[doc = " @return"]
#[doc = "   Number of queues; 0 is assumed to be a valid response."]
#[doc = ""]
pub type rawdev_queue_count_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_rawdev) -> u16>;
#[doc = " Enqueue an array of raw buffers to the device."]
#[doc = ""]
#[doc = " Buffer being used is opaque - it can be obtained from mempool or from"]
#[doc = " any other source. Interpretation of buffer is responsibility of driver."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
#[doc = " @param buffers"]
#[doc = "   array of buffers"]
#[doc = " @param count"]
#[doc = "   number of buffers passed"]
#[doc = " @param context"]
#[doc = "   an opaque object representing context of the call; for example, an"]
#[doc = "   application can pass information about the queues on which enqueue needs"]
#[doc = "   to be done. Or, the enqueue operation might be passed reference to an"]
#[doc = "   object containing a callback (agreed upon between application and driver)."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   >=0 Count of buffers successfully enqueued (0: no buffers enqueued)"]
#[doc = "   <0 Error count in case of error"]
pub type rawdev_enqueue_bufs_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_rawdev,
        buffers: *mut *mut rte_rawdev_buf,
        count: ::std::os::raw::c_uint,
        context: rte_rawdev_obj_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Dequeue an array of raw buffers from the device."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
#[doc = " @param buffers"]
#[doc = "   array of buffers"]
#[doc = " @param count"]
#[doc = "   Max buffers expected to be dequeued"]
#[doc = " @param context"]
#[doc = "   an opaque object representing context of the call. Based on this object,"]
#[doc = "   the application and driver can coordinate for dequeue operation involving"]
#[doc = "   agreed upon semantics. For example, queue information/id on which Dequeue"]
#[doc = "   needs to be performed."]
#[doc = " @return"]
#[doc = "   >0, ~0: Count of buffers returned"]
#[doc = "   <0: Error"]
#[doc = "   Whether short dequeue is success or failure is decided between app and"]
#[doc = "   driver."]
pub type rawdev_dequeue_bufs_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_rawdev,
        buffers: *mut *mut rte_rawdev_buf,
        count: ::std::os::raw::c_uint,
        context: rte_rawdev_obj_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Dump internal information"]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
#[doc = " @param f"]
#[doc = "   A pointer to a file for output"]
#[doc = " @return"]
#[doc = "   0 for success,"]
#[doc = "   !0 Error"]
#[doc = ""]
pub type rawdev_dump_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_rawdev, f: *mut FILE) -> ::std::os::raw::c_int,
>;
#[doc = " Get an attribute value from implementation."]
#[doc = " Attribute is an opaque handle agreed upon between application and PMD."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
#[doc = " @param attr_name"]
#[doc = "   Opaque object representing an attribute in implementation."]
#[doc = " @param attr_value [out]"]
#[doc = "   Opaque response to the attribute value. In case of error, this remains"]
#[doc = "   untouched. This is double pointer of void type."]
#[doc = " @return"]
#[doc = "   0 for success"]
#[doc = "  !0 Error; attr_value remains untouched in case of error."]
pub type rawdev_get_attr_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_rawdev,
        attr_name: *const ::std::os::raw::c_char,
        attr_value: *mut u64,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Set an attribute value."]
#[doc = " Attribute is an opaque handle agreed upon between application and PMD."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
#[doc = " @param attr_name"]
#[doc = "   Opaque object representing an attribute in implementation."]
#[doc = " @param attr_value"]
#[doc = "   Value of the attribute represented by attr_name"]
#[doc = " @return"]
#[doc = "   0 for success"]
#[doc = "  !0 Error"]
pub type rawdev_set_attr_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_rawdev,
        attr_name: *const ::std::os::raw::c_char,
        attr_value: u64,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Retrieve a set of statistics from device."]
#[doc = " Note: Being a raw device, the stats are specific to the device being"]
#[doc = " implemented thus represented as xstats."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
#[doc = " @param ids"]
#[doc = "   The stat ids to retrieve"]
#[doc = " @param values"]
#[doc = "   The returned stat values"]
#[doc = " @param n"]
#[doc = "   The number of id values and entries in the values array"]
#[doc = " @return"]
#[doc = "   The number of stat values successfully filled into the values array"]
pub type rawdev_xstats_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *const rte_rawdev,
        ids: *const ::std::os::raw::c_uint,
        values: *mut u64,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Resets the statistic values in xstats for the device."]
pub type rawdev_xstats_reset_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_rawdev,
        ids: *const u32,
        nb_ids: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Get names of extended stats of an raw device"]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
#[doc = " @param xstats_names"]
#[doc = "   Array of name values to be filled in"]
#[doc = " @param size"]
#[doc = "   Number of values in the xstats_names array"]
#[doc = " @return"]
#[doc = "   When size >= the number of stats, return the number of stat values filled"]
#[doc = "   into the array."]
#[doc = "   When size < the number of available stats, return the number of stats"]
#[doc = "   values, and do not fill in any data into xstats_names."]
pub type rawdev_xstats_get_names_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *const rte_rawdev,
        xstats_names: *mut rte_rawdev_xstats_name,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Get value of one stats and optionally return its id"]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
#[doc = " @param name"]
#[doc = "   The name of the stat to retrieve"]
#[doc = " @param id"]
#[doc = "   Pointer to an unsigned int where we store the stat-id."]
#[doc = "   This pointer may be null if the id is not required."]
#[doc = " @return"]
#[doc = "   The value of the stat, or (uint64_t)-1 if the stat is not found."]
#[doc = "   If the stat is not found, the id value will be returned as (unsigned)-1,"]
#[doc = "   if id pointer is non-NULL"]
pub type rawdev_xstats_get_by_name_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *const rte_rawdev,
        name: *const ::std::os::raw::c_char,
        id: *mut ::std::os::raw::c_uint,
    ) -> u64,
>;
#[doc = " Get firmware/device-stack status."]
#[doc = " Implementation to allocate buffer for returning information."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
#[doc = " @param status_info"]
#[doc = "   void block containing device specific status information"]
#[doc = " @return"]
#[doc = "   0 for success,"]
#[doc = "   !0 for failure, with undefined value in `status_info`"]
pub type rawdev_firmware_status_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_rawdev,
        status_info: rte_rawdev_obj_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Get firmware version information"]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
#[doc = " @param version_info"]
#[doc = "   void pointer to version information returned by device"]
#[doc = " @return"]
#[doc = "   0 for success,"]
#[doc = "   !0 for failure, with undefined value in `version_info`"]
pub type rawdev_firmware_version_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_rawdev,
        version_info: rte_rawdev_obj_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Load firmware from a buffer (DMA'able)"]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
#[doc = " @param firmware_buf"]
#[doc = "   Pointer to firmware image"]
#[doc = " @return"]
#[doc = "   >0, ~0: for successful load"]
#[doc = "   <0: for failure"]
#[doc = ""]
#[doc = " @see Application may use 'firmware_version_get` for ascertaining successful"]
#[doc = " load"]
pub type rawdev_firmware_load_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_rawdev,
        firmware_buf: rte_rawdev_obj_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Unload firmware"]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Raw device pointer"]
#[doc = " @return"]
#[doc = "   >0, ~0 for successful unloading"]
#[doc = "   <0 for failure in unloading"]
#[doc = ""]
#[doc = " Note: Application can use the `firmware_status_get` or"]
#[doc = " `firmware_version_get` to get result of unload."]
pub type rawdev_firmware_unload_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_rawdev) -> ::std::os::raw::c_int>;
#[doc = " Start rawdev selftest"]
#[doc = ""]
#[doc = " @return"]
#[doc = "   Return 0 on success"]
pub type rawdev_selftest_t =
    ::std::option::Option<unsafe extern "C" fn(dev_id: u16) -> ::std::os::raw::c_int>;
#[doc = " Rawdevice operations function pointer table"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_rawdev_ops {
    pub dev_info_get: rawdev_info_get_t,
    pub dev_configure: rawdev_configure_t,
    pub dev_start: rawdev_start_t,
    pub dev_stop: rawdev_stop_t,
    pub dev_close: rawdev_close_t,
    pub dev_reset: rawdev_reset_t,
    pub queue_def_conf: rawdev_queue_conf_get_t,
    pub queue_setup: rawdev_queue_setup_t,
    pub queue_release: rawdev_queue_release_t,
    pub queue_count: rawdev_queue_count_t,
    pub enqueue_bufs: rawdev_enqueue_bufs_t,
    #[doc = " TODO: Callback based enqueue and dequeue support"]
    pub dequeue_bufs: rawdev_dequeue_bufs_t,
    pub dump: rawdev_dump_t,
    pub attr_get: rawdev_get_attr_t,
    pub attr_set: rawdev_set_attr_t,
    pub xstats_get: rawdev_xstats_get_t,
    pub xstats_get_names: rawdev_xstats_get_names_t,
    pub xstats_get_by_name: rawdev_xstats_get_by_name_t,
    pub xstats_reset: rawdev_xstats_reset_t,
    pub firmware_status_get: rawdev_firmware_status_get_t,
    pub firmware_version_get: rawdev_firmware_version_get_t,
    pub firmware_load: rawdev_firmware_load_t,
    pub firmware_unload: rawdev_firmware_unload_t,
    pub dev_selftest: rawdev_selftest_t,
}
extern "C" {
    #[doc = " Allocates a new rawdev slot for an raw device and returns the pointer"]
    #[doc = " to that slot for the driver to use."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Unique identifier name for each device"]
    #[doc = " @param dev_private_size"]
    #[doc = "   Size of private data memory allocated within rte_rawdev object."]
    #[doc = "   Set to 0 to disable internal memory allocation and allow for"]
    #[doc = "   self-allocation."]
    #[doc = " @param socket_id"]
    #[doc = "   Socket to allocate resources on."]
    #[doc = " @return"]
    #[doc = "   - Slot in the rte_dev_devices array for a new device;"]
    pub fn rte_rawdev_pmd_allocate(
        name: *const ::std::os::raw::c_char,
        dev_private_size: size_t,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_rawdev;
}
extern "C" {
    #[doc = " Release the specified rawdev device."]
    #[doc = ""]
    #[doc = " @param rawdev"]
    #[doc = " The *rawdev* pointer is the address of the *rte_rawdev* structure."]
    #[doc = " @return"]
    #[doc = "   - 0 on success, negative on error"]
    pub fn rte_rawdev_pmd_release(rawdev: *mut rte_rawdev) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new raw device and returns the pointer to that device."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Pointer to a character array containing name of the device"]
    #[doc = " @param dev_private_size"]
    #[doc = "   Size of raw PMDs private data"]
    #[doc = " @param socket_id"]
    #[doc = "   Socket to allocate resources on."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - Raw device pointer if device is successfully created."]
    #[doc = "   - NULL if device cannot be created."]
    pub fn rte_rawdev_pmd_init(
        name: *const ::std::os::raw::c_char,
        dev_private_size: size_t,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_rawdev;
}
extern "C" {
    #[doc = " Destroy a raw device"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Name of the device"]
    #[doc = " @return"]
    #[doc = "   - 0 on success, negative on error"]
    pub fn rte_rawdev_pmd_uninit(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_reciprocal {
    pub m: u32,
    pub sh1: u8,
    pub sh2: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_reciprocal_u64 {
    pub m: u64,
    pub sh1: u8,
    pub sh2: u8,
}
extern "C" {
    pub fn rte_reciprocal_value(d: u32) -> rte_reciprocal;
}
extern "C" {
    pub fn rte_reciprocal_value_u64(d: u64) -> rte_reciprocal_u64;
}
extern "C" {
    pub static mut rte_regexdev_logtype: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Check if dev_id is ready."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The dev identifier of the RegEx device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 if device state is not in ready state."]
    #[doc = "   - 1 if device state is ready state."]
    pub fn rte_regexdev_is_valid_dev(dev_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Get the total number of RegEx devices that have been successfully"]
    #[doc = " initialised."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The total number of usable RegEx devices."]
    pub fn rte_regexdev_count() -> u8;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Get the device identifier for the named RegEx device."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   RegEx device name to select the RegEx device identifier."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Returns RegEx device identifier on success."]
    #[doc = "   - <0: Failure to find named RegEx device."]
    pub fn rte_regexdev_get_dev_id(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
#[doc = " RegEx device information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_regexdev_info {
    #[doc = "< RegEx driver name."]
    pub driver_name: *const ::std::os::raw::c_char,
    #[doc = "< Device information."]
    pub dev: *mut rte_device,
    pub max_matches: u16,
    pub max_queue_pairs: u16,
    pub max_payload_size: u16,
    pub max_rules_per_group: u32,
    pub max_groups: u16,
    pub regexdev_capa: u32,
    pub rule_flags: u64,
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Retrieve the contextual information of a RegEx device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = ""]
    #[doc = " @param[out] dev_info"]
    #[doc = "   A pointer to a structure of type *rte_regexdev_info* to be filled with the"]
    #[doc = "   contextual information of the device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success, driver updates the contextual information of the RegEx device"]
    #[doc = "   - <0: Error code returned by the driver info get function."]
    pub fn rte_regexdev_info_get(
        dev_id: u8,
        dev_info: *mut rte_regexdev_info,
    ) -> ::std::os::raw::c_int;
}
#[doc = " RegEx device configuration structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_regexdev_config {
    pub nb_max_matches: u16,
    pub nb_queue_pairs: u16,
    pub nb_rules_per_group: u32,
    pub nb_groups: u16,
    pub rule_db: *const ::std::os::raw::c_char,
    pub rule_db_len: u32,
    pub dev_cfg_flags: u32,
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Configure a RegEx device."]
    #[doc = ""]
    #[doc = " This function must be invoked first before any other function in the"]
    #[doc = " API. This function can also be re-invoked when a device is in the"]
    #[doc = " stopped state."]
    #[doc = ""]
    #[doc = " The caller may use rte_regexdev_info_get() to get the capability of each"]
    #[doc = " resources available for this regex device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device to configure."]
    #[doc = " @param cfg"]
    #[doc = "   The RegEx device configuration structure."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success, device configured. Otherwise negative errno is returned."]
    pub fn rte_regexdev_configure(
        dev_id: u8,
        cfg: *const rte_regexdev_config,
    ) -> ::std::os::raw::c_int;
}
pub type regexdev_stop_flush_t =
    ::std::option::Option<unsafe extern "C" fn(dev_id: u8, qp_id: u16, op: *mut rte_regex_ops)>;
#[doc = " RegEx queue pair configuration structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_regexdev_qp_conf {
    pub qp_conf_flags: u32,
    pub nb_desc: u16,
    pub cb: regexdev_stop_flush_t,
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Allocate and set up a RegEx queue pair for a RegEx device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param queue_pair_id"]
    #[doc = "   The index of the RegEx queue pair to setup. The value must be in the range"]
    #[doc = "   [0, nb_queue_pairs - 1] previously supplied to rte_regexdev_configure()."]
    #[doc = " @param qp_conf"]
    #[doc = "   The pointer to the configuration data to be used for the RegEx queue pair."]
    #[doc = "   NULL value is allowed, in which case default configuration\tused."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success. Otherwise negative errno is returned."]
    pub fn rte_regexdev_queue_pair_setup(
        dev_id: u8,
        queue_pair_id: u16,
        qp_conf: *const rte_regexdev_qp_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Start a RegEx device."]
    #[doc = ""]
    #[doc = " The device start step is the last one and consists of setting the RegEx"]
    #[doc = " queues to start accepting the pattern matching scan requests."]
    #[doc = ""]
    #[doc = " On success, all basic functions exported by the API (RegEx enqueue,"]
    #[doc = " RegEx dequeue and so on) can be invoked."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   RegEx device identifier."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success. Otherwise negative errno is returned."]
    pub fn rte_regexdev_start(dev_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Stop a RegEx device."]
    #[doc = ""]
    #[doc = " Stop a RegEx device. The device can be restarted with a call to"]
    #[doc = " rte_regexdev_start()."]
    #[doc = ""]
    #[doc = " This function causes all queued response regex ops to be drained in the"]
    #[doc = " response queue. While draining ops out of the device,"]
    #[doc = " struct rte_regexdev_qp_conf::cb will be invoked for each ops."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   RegEx device identifier."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success. Otherwise negative errno is returned."]
    pub fn rte_regexdev_stop(dev_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Close a RegEx device. The device cannot be restarted!"]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   RegEx device identifier"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success. Otherwise negative errno is returned."]
    pub fn rte_regexdev_close(dev_id: u8) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " Enumerates RegEx device attribute identifier"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_regexdev_attr_id {
    RTE_REGEXDEV_ATTR_SOCKET_ID = 0,
    RTE_REGEXDEV_ATTR_MAX_MATCHES = 1,
    RTE_REGEXDEV_ATTR_MAX_SCAN_TIMEOUT = 2,
    RTE_REGEXDEV_ATTR_MAX_PREFIX = 3,
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Get an attribute from a RegEx device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   RegEx device identifier."]
    #[doc = " @param attr_id"]
    #[doc = "   The attribute ID to retrieve."]
    #[doc = " @param attr_value"]
    #[doc = "   A pointer that will be filled in with the attribute"]
    #[doc = "   value if successful."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Successfully retrieved attribute value."]
    #[doc = "   - -EINVAL: Invalid device or  *attr_id* provided, or *attr_value* is NULL."]
    #[doc = "   - -ENOTSUP: if the device doesn't support specific *attr_id*."]
    pub fn rte_regexdev_attr_get(
        dev_id: u8,
        attr_id: rte_regexdev_attr_id,
        attr_value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Set an attribute to a RegEx device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   RegEx device identifier."]
    #[doc = " @param attr_id"]
    #[doc = "   The attribute ID to retrieve."]
    #[doc = " @param attr_value"]
    #[doc = "   Pointer that will be filled in with the attribute value"]
    #[doc = "   by the application."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Successfully applied the attribute value."]
    #[doc = "   - -EINVAL: Invalid device or  *attr_id* provided, or *attr_value* is NULL."]
    #[doc = "   - -ENOTSUP: if the device doesn't support specific *attr_id*."]
    pub fn rte_regexdev_attr_set(
        dev_id: u8,
        attr_id: rte_regexdev_attr_id,
        attr_value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " Enumerates RegEx rule operation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_regexdev_rule_op {
    RTE_REGEX_RULE_OP_ADD = 0,
    RTE_REGEX_RULE_OP_REMOVE = 1,
}
#[doc = " Structure to hold a RegEx rule attributes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_regexdev_rule {
    pub op: rte_regexdev_rule_op,
    pub group_id: u16,
    pub rule_id: u32,
    pub pcre_rule: *const ::std::os::raw::c_char,
    pub pcre_rule_len: u16,
    pub rule_flags: u64,
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Update the local rule set."]
    #[doc = " This functions only modify the rule set in memory."]
    #[doc = " In order for the changes to take effect, the function"]
    #[doc = " rte_regexdev_rule_db_compile_active must be called."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   RegEx device identifier."]
    #[doc = " @param rules"]
    #[doc = "   Points to an array of *nb_rules* objects of type *rte_regexdev_rule*"]
    #[doc = "   structure which contain the regex rules attributes to be updated"]
    #[doc = "   in rule database."]
    #[doc = " @param nb_rules"]
    #[doc = "   The number of PCRE rules to update the rule database."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The number of regex rules actually updated on the regex device's rule"]
    #[doc = "   database. The return value can be less than the value of the *nb_rules*"]
    #[doc = "   parameter when the regex devices fails to update the rule database or"]
    #[doc = "   if invalid parameters are specified in a *rte_regexdev_rule*."]
    #[doc = "   If the return value is less than *nb_rules*, the remaining PCRE rules"]
    #[doc = "   at the end of *rules* are not consumed and the caller has to take"]
    #[doc = "   care of them and rte_errno is set accordingly."]
    #[doc = "   Possible errno values include:"]
    #[doc = "   - -EINVAL:  Invalid device ID or rules is NULL"]
    #[doc = "   - -ENOTSUP: The last processed rule is not supported on this device."]
    #[doc = "   - -ENOSPC: No space available in rule database."]
    #[doc = ""]
    #[doc = " @see rte_regexdev_rule_db_import(), rte_regexdev_rule_db_export(),"]
    #[doc = "   rte_regexdev_rule_db_compile_activate()"]
    pub fn rte_regexdev_rule_db_update(
        dev_id: u8,
        rules: *const rte_regexdev_rule,
        nb_rules: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Compile local rule set and burn the complied result to the"]
    #[doc = " RegEx device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   RegEx device identifier."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, otherwise negative errno."]
    #[doc = ""]
    #[doc = " @see rte_regexdev_rule_db_import(), rte_regexdev_rule_db_export(),"]
    #[doc = "   rte_regexdev_rule_db_update()"]
    pub fn rte_regexdev_rule_db_compile_activate(dev_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Import a prebuilt rule database from a buffer to a RegEx device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   RegEx device identifier."]
    #[doc = " @param rule_db"]
    #[doc = "   Points to prebuilt rule database."]
    #[doc = " @param rule_db_len"]
    #[doc = "   Length of the rule database."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Successfully updated the prebuilt rule database."]
    #[doc = "   - -EINVAL:  Invalid device ID or rule_db is NULL"]
    #[doc = "   - -ENOTSUP: Rule database import is not supported on this device."]
    #[doc = "   - -ENOSPC: No space available in rule database."]
    #[doc = ""]
    #[doc = " @see rte_regexdev_rule_db_update(), rte_regexdev_rule_db_export()"]
    pub fn rte_regexdev_rule_db_import(
        dev_id: u8,
        rule_db: *const ::std::os::raw::c_char,
        rule_db_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Export the prebuilt rule database from a RegEx device to the buffer."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   RegEx device identifier."]
    #[doc = " @param[out] rule_db"]
    #[doc = "   Block of memory to insert the rule database. Must be at least size in"]
    #[doc = "   capacity. If set to NULL, function returns required capacity."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Successfully exported the prebuilt rule database."]
    #[doc = "   - size: If rule_db set to NULL then required capacity for *rule_db*"]
    #[doc = "   - -EINVAL:  Invalid device ID"]
    #[doc = "   - -ENOTSUP: Rule database export is not supported on this device."]
    #[doc = ""]
    #[doc = " @see rte_regexdev_rule_db_update(), rte_regexdev_rule_db_import()"]
    pub fn rte_regexdev_rule_db_export(
        dev_id: u8,
        rule_db: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " A name-key lookup element for extended statistics."]
#[doc = ""]
#[doc = " This structure is used to map between names and ID numbers"]
#[doc = " for extended RegEx device statistics."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_regexdev_xstats_map {
    pub id: u16,
    pub name: [::std::os::raw::c_char; 64usize],
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Retrieve names of extended statistics of a regex device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the regex device."]
    #[doc = " @param[out] xstats_map"]
    #[doc = "   Block of memory to insert id and names into. Must be at least size in"]
    #[doc = "   capacity. If set to NULL, function returns required capacity."]
    #[doc = " @return"]
    #[doc = "   - Positive value on success:"]
    #[doc = "        -The return value is the number of entries filled in the stats map."]
    #[doc = "        -If xstats_map set to NULL then required capacity for xstats_map."]
    #[doc = "   - Negative value on error:"]
    #[doc = "      -ENODEV for invalid *dev_id*"]
    #[doc = "      -ENOTSUP if the device doesn't support this function."]
    pub fn rte_regexdev_xstats_names_get(
        dev_id: u8,
        xstats_map: *mut rte_regexdev_xstats_map,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Retrieve extended statistics of an regex device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param ids"]
    #[doc = "   The id numbers of the stats to get. The ids can be got from the stat"]
    #[doc = "   position in the stat list from rte_regexdev_xstats_names_get(), or"]
    #[doc = "   by using rte_regexdev_xstats_by_name_get()."]
    #[doc = " @param values"]
    #[doc = "   The values for each stats request by ID."]
    #[doc = " @param nb_values"]
    #[doc = "   The number of stats requested."]
    #[doc = " @return"]
    #[doc = "   - Positive value: number of stat entries filled into the values array"]
    #[doc = "   - Negative value on error:"]
    #[doc = "      -ENODEV for invalid *dev_id*"]
    #[doc = "      -ENOTSUP if the device doesn't support this function."]
    pub fn rte_regexdev_xstats_get(
        dev_id: u8,
        ids: *const u16,
        values: *mut u64,
        nb_values: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Retrieve the value of a single stat by requesting it by name."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param name"]
    #[doc = "   The stat name to retrieve."]
    #[doc = " @param id"]
    #[doc = "   If non-NULL, the numerical id of the stat will be returned, so that further"]
    #[doc = "   requests for the stat can be got using rte_regexdev_xstats_get, which will"]
    #[doc = "   be faster as it doesn't need to scan a list of names for the stat."]
    #[doc = " @param[out] value"]
    #[doc = "   Must be non-NULL, retrieved xstat value will be stored in this address."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Successfully retrieved xstat value."]
    #[doc = "   - -EINVAL: invalid parameters"]
    #[doc = "   - -ENOTSUP: if not supported."]
    pub fn rte_regexdev_xstats_by_name_get(
        dev_id: u8,
        name: *const ::std::os::raw::c_char,
        id: *mut u16,
        value: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Reset the values of the xstats of the selected component in the device."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param ids"]
    #[doc = "   Selects specific statistics to be reset. When NULL, all statistics will be"]
    #[doc = "   reset. If non-NULL, must point to array of at least *nb_ids* size."]
    #[doc = " @param nb_ids"]
    #[doc = "   The number of ids available from the *ids* array. Ignored when ids is NULL."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Successfully reset the statistics to zero."]
    #[doc = "   - -EINVAL: invalid parameters."]
    #[doc = "   - -ENOTSUP: if not supported."]
    pub fn rte_regexdev_xstats_reset(
        dev_id: u8,
        ids: *const u16,
        nb_ids: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Trigger the RegEx device self test."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @return"]
    #[doc = "   - 0: Selftest successful."]
    #[doc = "   - -ENOTSUP if the device doesn't support selftest."]
    #[doc = "   - other values < 0 on failure."]
    pub fn rte_regexdev_selftest(dev_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Dump internal information about *dev_id* to the FILE* provided in *f*."]
    #[doc = ""]
    #[doc = " @param dev_id"]
    #[doc = "   The identifier of the device."]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, negative errno on failure."]
    pub fn rte_regexdev_dump(dev_id: u8, f: *mut FILE) -> ::std::os::raw::c_int;
}
#[doc = " The generic *rte_regexdev_match* structure to hold the RegEx match"]
#[doc = " attributes."]
#[doc = " @see struct rte_regex_ops::matches"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_regexdev_match {
    pub __bindgen_anon_1: rte_regexdev_match__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_regexdev_match__bindgen_ty_1 {
    pub u64_: u64,
    pub __bindgen_anon_1: rte_regexdev_match__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct rte_regexdev_match__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub start_offset: u16,
    pub __bindgen_anon_1: rte_regexdev_match__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_regexdev_match__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub len: u16,
    pub end_offset: u16,
}
impl rte_regexdev_match__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn rule_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_rule_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn group_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_group_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(rule_id: u32, group_id: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let rule_id: u32 = unsafe { ::std::mem::transmute(rule_id) };
            rule_id as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let group_id: u32 = unsafe { ::std::mem::transmute(group_id) };
            group_id as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " The generic *rte_regex_ops* structure to hold the RegEx attributes"]
#[doc = " for enqueue and dequeue operation."]
#[repr(C)]
pub struct rte_regex_ops {
    pub req_flags: u16,
    pub rsp_flags: u16,
    pub nb_actual_matches: u16,
    pub nb_matches: u16,
    #[doc = "< source mbuf, to search in."]
    pub mbuf: *mut rte_mbuf,
    pub group_id0: u16,
    pub group_id1: u16,
    pub group_id2: u16,
    pub group_id3: u16,
    pub __bindgen_anon_1: rte_regex_ops__bindgen_ty_1,
    pub __bindgen_anon_2: rte_regex_ops__bindgen_ty_2,
    pub matches: __IncompleteArrayField<rte_regexdev_match>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_regex_ops__bindgen_ty_1 {
    pub user_id: u64,
    pub user_ptr: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_regex_ops__bindgen_ty_2 {
    pub cross_buf_id: u64,
    pub cross_buf_ptr: *mut ::std::os::raw::c_void,
}
pub type regexdev_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_regexdev,
        info: *mut rte_regexdev_info,
    ) -> ::std::os::raw::c_int,
>;
pub type regexdev_configure_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_regexdev,
        cfg: *const rte_regexdev_config,
    ) -> ::std::os::raw::c_int,
>;
pub type regexdev_qp_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_regexdev,
        id: u16,
        qp_conf: *const rte_regexdev_qp_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type regexdev_start_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_regexdev) -> ::std::os::raw::c_int>;
pub type regexdev_stop_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_regexdev) -> ::std::os::raw::c_int>;
pub type regexdev_close_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_regexdev) -> ::std::os::raw::c_int>;
pub type regexdev_attr_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_regexdev,
        id: rte_regexdev_attr_id,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type regexdev_attr_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_regexdev,
        id: rte_regexdev_attr_id,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type regexdev_rule_db_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_regexdev,
        rules: *const rte_regexdev_rule,
        nb_rules: u16,
    ) -> ::std::os::raw::c_int,
>;
pub type regexdev_rule_db_compile_activate_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_regexdev) -> ::std::os::raw::c_int>;
pub type regexdev_rule_db_import_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_regexdev,
        rule_db: *const ::std::os::raw::c_char,
        rule_db_len: u32,
    ) -> ::std::os::raw::c_int,
>;
pub type regexdev_rule_db_export_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_regexdev,
        rule_db: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
pub type regexdev_xstats_names_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_regexdev,
        xstats_map: *mut rte_regexdev_xstats_map,
    ) -> ::std::os::raw::c_int,
>;
pub type regexdev_xstats_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_regexdev,
        ids: *const u16,
        values: *mut u64,
        nb_values: u16,
    ) -> ::std::os::raw::c_int,
>;
pub type regexdev_xstats_by_name_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_regexdev,
        name: *const ::std::os::raw::c_char,
        id: *mut u16,
        value: *mut u64,
    ) -> ::std::os::raw::c_int,
>;
pub type regexdev_xstats_reset_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_regexdev,
        ids: *const u16,
        nb_ids: u16,
    ) -> ::std::os::raw::c_int,
>;
pub type regexdev_selftest_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_regexdev) -> ::std::os::raw::c_int>;
pub type regexdev_dump_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_regexdev, f: *mut FILE) -> ::std::os::raw::c_int,
>;
pub type regexdev_enqueue_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_regexdev,
        qp_id: u16,
        ops: *mut *mut rte_regex_ops,
        nb_ops: u16,
    ) -> u16,
>;
pub type regexdev_dequeue_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_regexdev,
        qp_id: u16,
        ops: *mut *mut rte_regex_ops,
        nb_ops: u16,
    ) -> u16,
>;
#[doc = " RegEx device operations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_regexdev_ops {
    pub dev_info_get: regexdev_info_get_t,
    pub dev_configure: regexdev_configure_t,
    pub dev_qp_setup: regexdev_qp_setup_t,
    pub dev_start: regexdev_start_t,
    pub dev_stop: regexdev_stop_t,
    pub dev_close: regexdev_close_t,
    pub dev_attr_get: regexdev_attr_get_t,
    pub dev_attr_set: regexdev_attr_set_t,
    pub dev_rule_db_update: regexdev_rule_db_update_t,
    pub dev_rule_db_compile_activate: regexdev_rule_db_compile_activate_t,
    pub dev_db_import: regexdev_rule_db_import_t,
    pub dev_db_export: regexdev_rule_db_export_t,
    pub dev_xstats_names_get: regexdev_xstats_names_get_t,
    pub dev_xstats_get: regexdev_xstats_get_t,
    pub dev_xstats_by_name_get: regexdev_xstats_by_name_get_t,
    pub dev_xstats_reset: regexdev_xstats_reset_t,
    pub dev_selftest: regexdev_selftest_t,
    pub dev_dump: regexdev_dump_t,
}
#[repr(u32)]
#[doc = " Possible states of a RegEx device."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_regexdev_state {
    #[doc = "< Device is unused."]
    RTE_REGEXDEV_UNUSED = 0,
    RTE_REGEXDEV_REGISTERED = 1,
    RTE_REGEXDEV_READY = 2,
}
#[doc = " @internal"]
#[doc = " The data part, with no function pointers, associated with each RegEx device."]
#[doc = ""]
#[doc = " This structure is safe to place in shared memory to be common among different"]
#[doc = " processes in a multi-process configuration."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_regexdev_data {
    #[doc = "< PMD-specific private data."]
    pub dev_private: *mut ::std::os::raw::c_void,
    #[doc = "< Unique identifier name"]
    pub dev_name: [::std::os::raw::c_char; 64usize],
    #[doc = "< Device [external]  identifier."]
    pub dev_id: u16,
    #[doc = "< RegEx configuration."]
    pub dev_conf: rte_regexdev_config,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 15usize],
}
impl rte_regexdev_data {
    #[inline]
    pub fn dev_started(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dev_started(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(dev_started: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dev_started: u8 = unsafe { ::std::mem::transmute(dev_started) };
            dev_started as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @file"]
#[doc = ""]
#[doc = " RTE RegEx Device internal header."]
#[doc = ""]
#[doc = " This header contains internal data types, that are used by the RegEx devices"]
#[doc = " in order to expose their ops to the class."]
#[doc = ""]
#[doc = " Applications should not use these API directly."]
#[doc = ""]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_regexdev {
    pub enqueue: regexdev_enqueue_t,
    pub dequeue: regexdev_dequeue_t,
    pub dev_ops: *const rte_regexdev_ops,
    #[doc = "< Backing device"]
    pub device: *mut rte_device,
    #[doc = "< The device state."]
    pub state: rte_regexdev_state,
    #[doc = "< Pointer to device data."]
    pub data: *mut rte_regexdev_data,
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " The pool of *rte_regexdev* structures. The size of the pool"]
    #[doc = " is configured at compile-time in the <rte_regexdev.c> file."]
    pub static mut rte_regex_devices: [rte_regexdev; 0usize];
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Register a RegEx device slot for a RegEx device and return the"]
    #[doc = " pointer to that slot."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   RegEx device name."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   A pointer to the RegEx device slot case of success,"]
    #[doc = "   NULL otherwise."]
    pub fn rte_regexdev_register(name: *const ::std::os::raw::c_char) -> *mut rte_regexdev;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Unregister the specified regexdev port."]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "   Device to be released."]
    pub fn rte_regexdev_unregister(dev: *mut rte_regexdev);
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Return the RegEx device based on the device name."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The device name."]
    pub fn rte_regexdev_get_device_by_name(
        name: *const ::std::os::raw::c_char,
    ) -> *mut rte_regexdev;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_reorder_buffer {
    _unused: [u8; 0],
}
pub type rte_reorder_seqn_t = u32;
extern "C" {
    pub static mut rte_reorder_seqn_dynfield_offset: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new reorder buffer instance"]
    #[doc = ""]
    #[doc = " Allocate memory and initialize a new reorder buffer in that"]
    #[doc = " memory, returning the reorder buffer pointer to the user"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name to be given to the reorder buffer instance."]
    #[doc = " @param socket_id"]
    #[doc = "   The NUMA node on which the memory for the reorder buffer"]
    #[doc = "   instance is to be reserved."]
    #[doc = " @param size"]
    #[doc = "   Max number of elements that can be stored in the reorder buffer"]
    #[doc = " @return"]
    #[doc = "   The initialized reorder buffer instance, or NULL on error"]
    #[doc = "   On error case, rte_errno will be set appropriately:"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    #[doc = "    - EINVAL - invalid parameters"]
    pub fn rte_reorder_create(
        name: *const ::std::os::raw::c_char,
        socket_id: ::std::os::raw::c_uint,
        size: ::std::os::raw::c_uint,
    ) -> *mut rte_reorder_buffer;
}
extern "C" {
    #[doc = " Initializes given reorder buffer instance"]
    #[doc = ""]
    #[doc = " @param b"]
    #[doc = "   Reorder buffer instance to initialize"]
    #[doc = " @param bufsize"]
    #[doc = "   Size of the reorder buffer"]
    #[doc = " @param name"]
    #[doc = "   The name to be given to the reorder buffer"]
    #[doc = " @param size"]
    #[doc = "   Number of elements that can be stored in reorder buffer"]
    #[doc = " @return"]
    #[doc = "   The initialized reorder buffer instance, or NULL on error"]
    #[doc = "   On error case, rte_errno will be set appropriately:"]
    #[doc = "    - EINVAL - invalid parameters"]
    pub fn rte_reorder_init(
        b: *mut rte_reorder_buffer,
        bufsize: ::std::os::raw::c_uint,
        name: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> *mut rte_reorder_buffer;
}
extern "C" {
    #[doc = " Find an existing reorder buffer instance"]
    #[doc = " and return a pointer to it."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Name of the reorder buffer instance as passed to rte_reorder_create()"]
    #[doc = " @return"]
    #[doc = "   Pointer to reorder buffer instance or NULL if object not found with rte_errno"]
    #[doc = "   set appropriately. Possible rte_errno values include:"]
    #[doc = "    - ENOENT - required entry not available to return."]
    #[doc = "    reorder instance list"]
    pub fn rte_reorder_find_existing(
        name: *const ::std::os::raw::c_char,
    ) -> *mut rte_reorder_buffer;
}
extern "C" {
    #[doc = " Reset the given reorder buffer instance with initial values."]
    #[doc = ""]
    #[doc = " @param b"]
    #[doc = "   Reorder buffer instance which has to be reset"]
    pub fn rte_reorder_reset(b: *mut rte_reorder_buffer);
}
extern "C" {
    #[doc = " Free reorder buffer instance."]
    #[doc = ""]
    #[doc = " @param b"]
    #[doc = "   reorder buffer instance"]
    #[doc = " @return"]
    #[doc = "   None"]
    pub fn rte_reorder_free(b: *mut rte_reorder_buffer);
}
extern "C" {
    #[doc = " Insert given mbuf in reorder buffer in its correct position"]
    #[doc = ""]
    #[doc = " The given mbuf is to be reordered relative to other mbufs in the system."]
    #[doc = " The mbuf must contain a sequence number which is then used to place"]
    #[doc = " the buffer in the correct position in the reorder buffer. Reordered"]
    #[doc = " packets can later be taken from the buffer using the rte_reorder_drain()"]
    #[doc = " API."]
    #[doc = ""]
    #[doc = " @param b"]
    #[doc = "   Reorder buffer where the mbuf has to be inserted."]
    #[doc = " @param mbuf"]
    #[doc = "   mbuf of packet that needs to be inserted in reorder buffer."]
    #[doc = " @return"]
    #[doc = "   0 on success"]
    #[doc = "   -1 on error"]
    #[doc = "   On error case, rte_errno will be set appropriately:"]
    #[doc = "    - ENOSPC - Cannot move existing mbufs from reorder buffer to accommodate"]
    #[doc = "      early mbuf, but it can be accommodated by performing drain and then insert."]
    #[doc = "    - ERANGE - Too early or late mbuf which is vastly out of range of expected"]
    #[doc = "      window should be ignored without any handling."]
    pub fn rte_reorder_insert(
        b: *mut rte_reorder_buffer,
        mbuf: *mut rte_mbuf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fetch reordered buffers"]
    #[doc = ""]
    #[doc = " Returns a set of in-order buffers from the reorder buffer structure. Gaps"]
    #[doc = " may be present in the sequence numbers of the mbuf if packets have been"]
    #[doc = " delayed too long before reaching the reorder window, or have been previously"]
    #[doc = " dropped by the system."]
    #[doc = ""]
    #[doc = " @param b"]
    #[doc = "   Reorder buffer instance from which packets are to be drained"]
    #[doc = " @param mbufs"]
    #[doc = "   array of mbufs where reordered packets will be inserted from reorder buffer"]
    #[doc = " @param max_mbufs"]
    #[doc = "   the number of elements in the mbufs array."]
    #[doc = " @return"]
    #[doc = "   number of mbuf pointers written to mbufs. 0 <= N < max_mbufs."]
    pub fn rte_reorder_drain(
        b: *mut rte_reorder_buffer,
        mbufs: *mut *mut rte_mbuf,
        max_mbufs: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
pub const RTE_RIB6_GET_NXT_ALL: _bindgen_ty_27 = _bindgen_ty_27::RTE_RIB6_GET_NXT_ALL;
pub const RTE_RIB6_GET_NXT_COVER: _bindgen_ty_27 = _bindgen_ty_27::RTE_RIB6_GET_NXT_COVER;
#[repr(u32)]
#[doc = " rte_rib6_get_nxt() flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_27 {
    #[doc = " flag to get all subroutes in a RIB tree"]
    RTE_RIB6_GET_NXT_ALL = 0,
    #[doc = " flag to get first matched subroutes in a RIB tree"]
    RTE_RIB6_GET_NXT_COVER = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_rib6_node {
    _unused: [u8; 0],
}
#[doc = " RIB configuration structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_rib6_conf {
    #[doc = " Size of extension block inside rte_rib_node."]
    #[doc = " This space could be used to store additional user"]
    #[doc = " defined data."]
    pub ext_sz: size_t,
    pub max_nodes: ::std::os::raw::c_int,
}
extern "C" {
    #[doc = " Lookup an IP into the RIB structure"]
    #[doc = ""]
    #[doc = " @param rib"]
    #[doc = "  RIB object handle"]
    #[doc = " @param ip"]
    #[doc = "  IP to be looked up in the RIB"]
    #[doc = " @return"]
    #[doc = "  pointer to struct rte_rib6_node on success"]
    #[doc = "  NULL otherwise"]
    pub fn rte_rib6_lookup(rib: *mut rte_rib6, ip: *const u8) -> *mut rte_rib6_node;
}
extern "C" {
    #[doc = " Lookup less specific route into the RIB structure"]
    #[doc = ""]
    #[doc = " @param ent"]
    #[doc = "  Pointer to struct rte_rib6_node that represents target route"]
    #[doc = " @return"]
    #[doc = "  pointer to struct rte_rib6_node that represents"]
    #[doc = "   less specific route on success"]
    #[doc = "  NULL otherwise"]
    pub fn rte_rib6_lookup_parent(ent: *mut rte_rib6_node) -> *mut rte_rib6_node;
}
extern "C" {
    #[doc = " Provides exact mach lookup of the prefix into the RIB structure"]
    #[doc = ""]
    #[doc = " @param rib"]
    #[doc = "  RIB object handle"]
    #[doc = " @param ip"]
    #[doc = "  net to be looked up in the RIB"]
    #[doc = " @param depth"]
    #[doc = "  prefix length"]
    #[doc = " @return"]
    #[doc = "  pointer to struct rte_rib6_node on success"]
    #[doc = "  NULL otherwise"]
    pub fn rte_rib6_lookup_exact(
        rib: *mut rte_rib6,
        ip: *const u8,
        depth: u8,
    ) -> *mut rte_rib6_node;
}
extern "C" {
    #[doc = " Retrieve next more specific prefix from the RIB"]
    #[doc = " that is covered by ip/depth supernet in an ascending order"]
    #[doc = ""]
    #[doc = " @param rib"]
    #[doc = "  RIB object handle"]
    #[doc = " @param ip"]
    #[doc = "  net address of supernet prefix that covers returned more specific prefixes"]
    #[doc = " @param depth"]
    #[doc = "  supernet prefix length"]
    #[doc = " @param last"]
    #[doc = "   pointer to the last returned prefix to get next prefix"]
    #[doc = "   or"]
    #[doc = "   NULL to get first more specific prefix"]
    #[doc = " @param flag"]
    #[doc = "  -RTE_RIB6_GET_NXT_ALL"]
    #[doc = "   get all prefixes from subtrie"]
    #[doc = "  -RTE_RIB6_GET_NXT_COVER"]
    #[doc = "   get only first more specific prefix even if it have more specifics"]
    #[doc = " @return"]
    #[doc = "  pointer to the next more specific prefix"]
    #[doc = "  NULL if there is no prefixes left"]
    pub fn rte_rib6_get_nxt(
        rib: *mut rte_rib6,
        ip: *const u8,
        depth: u8,
        last: *mut rte_rib6_node,
        flag: ::std::os::raw::c_int,
    ) -> *mut rte_rib6_node;
}
extern "C" {
    #[doc = " Remove prefix from the RIB"]
    #[doc = ""]
    #[doc = " @param rib"]
    #[doc = "  RIB object handle"]
    #[doc = " @param ip"]
    #[doc = "  net to be removed from the RIB"]
    #[doc = " @param depth"]
    #[doc = "  prefix length"]
    pub fn rte_rib6_remove(rib: *mut rte_rib6, ip: *const u8, depth: u8);
}
extern "C" {
    #[doc = " Insert prefix into the RIB"]
    #[doc = ""]
    #[doc = " @param rib"]
    #[doc = "  RIB object handle"]
    #[doc = " @param ip"]
    #[doc = "  net to be inserted to the RIB"]
    #[doc = " @param depth"]
    #[doc = "  prefix length"]
    #[doc = " @return"]
    #[doc = "  pointer to new rte_rib6_node on success"]
    #[doc = "  NULL otherwise"]
    pub fn rte_rib6_insert(rib: *mut rte_rib6, ip: *const u8, depth: u8) -> *mut rte_rib6_node;
}
extern "C" {
    #[doc = " Get an ip from rte_rib6_node"]
    #[doc = ""]
    #[doc = " @param node"]
    #[doc = "  pointer to the rib6 node"]
    #[doc = " @param ip"]
    #[doc = "  pointer to the ipv6 to save"]
    #[doc = " @return"]
    #[doc = "  0 on success"]
    #[doc = "  -1 on failure with rte_errno indicating reason for failure."]
    pub fn rte_rib6_get_ip(node: *const rte_rib6_node, ip: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a depth from rte_rib6_node"]
    #[doc = ""]
    #[doc = " @param node"]
    #[doc = "  pointer to the rib6 node"]
    #[doc = " @param depth"]
    #[doc = "  pointer to the depth to save"]
    #[doc = " @return"]
    #[doc = "  0 on success"]
    #[doc = "  -1 on failure with rte_errno indicating reason for failure."]
    pub fn rte_rib6_get_depth(node: *const rte_rib6_node, depth: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get ext field from the rte_rib6_node"]
    #[doc = " It is caller responsibility to make sure there are necessary space"]
    #[doc = " for the ext field inside rib6 node."]
    #[doc = ""]
    #[doc = " @param node"]
    #[doc = "  pointer to the rte_rib6_node"]
    #[doc = " @return"]
    #[doc = "  pointer to the ext"]
    pub fn rte_rib6_get_ext(node: *mut rte_rib6_node) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get nexthop from the rte_rib6_node"]
    #[doc = ""]
    #[doc = " @param node"]
    #[doc = "  pointer to the rib6 node"]
    #[doc = " @param nh"]
    #[doc = "  pointer to the nexthop to save"]
    #[doc = " @return"]
    #[doc = "  0 on success"]
    #[doc = "  -1 on failure, with rte_errno indicating reason for failure."]
    pub fn rte_rib6_get_nh(node: *const rte_rib6_node, nh: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set nexthop into the rte_rib6_node"]
    #[doc = ""]
    #[doc = " @param node"]
    #[doc = "  pointer to the rib6 node"]
    #[doc = " @param nh"]
    #[doc = "  nexthop value to set to the rib6 node"]
    #[doc = " @return"]
    #[doc = "  0 on success"]
    #[doc = "  -1 on failure, with rte_errno indicating reason for failure."]
    pub fn rte_rib6_set_nh(node: *mut rte_rib6_node, nh: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create RIB"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "  RIB name"]
    #[doc = " @param socket_id"]
    #[doc = "  NUMA socket ID for RIB table memory allocation"]
    #[doc = " @param conf"]
    #[doc = "  Structure containing the configuration"]
    #[doc = " @return"]
    #[doc = "  Pointer to RIB object on success"]
    #[doc = "  NULL otherwise with rte_errno indicating reason for failure."]
    pub fn rte_rib6_create(
        name: *const ::std::os::raw::c_char,
        socket_id: ::std::os::raw::c_int,
        conf: *const rte_rib6_conf,
    ) -> *mut rte_rib6;
}
extern "C" {
    #[doc = " Find an existing RIB object and return a pointer to it."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "  Name of the rib object as passed to rte_rib_create()"]
    #[doc = " @return"]
    #[doc = "  Pointer to RIB object on success"]
    #[doc = "  NULL otherwise with rte_errno indicating reason for failure."]
    pub fn rte_rib6_find_existing(name: *const ::std::os::raw::c_char) -> *mut rte_rib6;
}
extern "C" {
    #[doc = " Free an RIB object."]
    #[doc = ""]
    #[doc = " @param rib"]
    #[doc = "   RIB object handle"]
    #[doc = " @return"]
    #[doc = "   None"]
    pub fn rte_rib6_free(rib: *mut rte_rib6);
}
pub const RTE_RIB_GET_NXT_ALL: _bindgen_ty_28 = _bindgen_ty_28::RTE_RIB_GET_NXT_ALL;
pub const RTE_RIB_GET_NXT_COVER: _bindgen_ty_28 = _bindgen_ty_28::RTE_RIB_GET_NXT_COVER;
#[repr(u32)]
#[doc = " rte_rib_get_nxt() flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_28 {
    #[doc = " flag to get all subroutes in a RIB tree"]
    RTE_RIB_GET_NXT_ALL = 0,
    #[doc = " flag to get first matched subroutes in a RIB tree"]
    RTE_RIB_GET_NXT_COVER = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_rib_node {
    _unused: [u8; 0],
}
#[doc = " RIB configuration structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_rib_conf {
    #[doc = " Size of extension block inside rte_rib_node."]
    #[doc = " This space could be used to store additional user"]
    #[doc = " defined data."]
    pub ext_sz: size_t,
    pub max_nodes: ::std::os::raw::c_int,
}
extern "C" {
    #[doc = " Lookup an IP into the RIB structure"]
    #[doc = ""]
    #[doc = " @param rib"]
    #[doc = "  RIB object handle"]
    #[doc = " @param ip"]
    #[doc = "  IP to be looked up in the RIB"]
    #[doc = " @return"]
    #[doc = "  pointer to struct rte_rib_node on success"]
    #[doc = "  NULL otherwise"]
    pub fn rte_rib_lookup(rib: *mut rte_rib, ip: u32) -> *mut rte_rib_node;
}
extern "C" {
    #[doc = " Lookup less specific route into the RIB structure"]
    #[doc = ""]
    #[doc = " @param ent"]
    #[doc = "  Pointer to struct rte_rib_node that represents target route"]
    #[doc = " @return"]
    #[doc = "  pointer to struct rte_rib_node that represents"]
    #[doc = "   less specific route on success"]
    #[doc = "  NULL otherwise"]
    pub fn rte_rib_lookup_parent(ent: *mut rte_rib_node) -> *mut rte_rib_node;
}
extern "C" {
    #[doc = " Lookup prefix into the RIB structure"]
    #[doc = ""]
    #[doc = " @param rib"]
    #[doc = "  RIB object handle"]
    #[doc = " @param ip"]
    #[doc = "  net to be looked up in the RIB"]
    #[doc = " @param depth"]
    #[doc = "  prefix length"]
    #[doc = " @return"]
    #[doc = "  pointer to struct rte_rib_node on success"]
    #[doc = "  NULL otherwise"]
    pub fn rte_rib_lookup_exact(rib: *mut rte_rib, ip: u32, depth: u8) -> *mut rte_rib_node;
}
extern "C" {
    #[doc = " Retrieve next more specific prefix from the RIB"]
    #[doc = " that is covered by ip/depth supernet in an ascending order"]
    #[doc = ""]
    #[doc = " @param rib"]
    #[doc = "  RIB object handle"]
    #[doc = " @param ip"]
    #[doc = "  net address of supernet prefix that covers returned more specific prefixes"]
    #[doc = " @param depth"]
    #[doc = "  supernet prefix length"]
    #[doc = " @param last"]
    #[doc = "   pointer to the last returned prefix to get next prefix"]
    #[doc = "   or"]
    #[doc = "   NULL to get first more specific prefix"]
    #[doc = " @param flag"]
    #[doc = "  -RTE_RIB_GET_NXT_ALL"]
    #[doc = "   get all prefixes from subtrie"]
    #[doc = "  -RTE_RIB_GET_NXT_COVER"]
    #[doc = "   get only first more specific prefix even if it have more specifics"]
    #[doc = " @return"]
    #[doc = "  pointer to the next more specific prefix"]
    #[doc = "  NULL if there is no prefixes left"]
    pub fn rte_rib_get_nxt(
        rib: *mut rte_rib,
        ip: u32,
        depth: u8,
        last: *mut rte_rib_node,
        flag: ::std::os::raw::c_int,
    ) -> *mut rte_rib_node;
}
extern "C" {
    #[doc = " Remove prefix from the RIB"]
    #[doc = ""]
    #[doc = " @param rib"]
    #[doc = "  RIB object handle"]
    #[doc = " @param ip"]
    #[doc = "  net to be removed from the RIB"]
    #[doc = " @param depth"]
    #[doc = "  prefix length"]
    pub fn rte_rib_remove(rib: *mut rte_rib, ip: u32, depth: u8);
}
extern "C" {
    #[doc = " Insert prefix into the RIB"]
    #[doc = ""]
    #[doc = " @param rib"]
    #[doc = "  RIB object handle"]
    #[doc = " @param ip"]
    #[doc = "  net to be inserted to the RIB"]
    #[doc = " @param depth"]
    #[doc = "  prefix length"]
    #[doc = " @return"]
    #[doc = "  pointer to new rte_rib_node on success"]
    #[doc = "  NULL otherwise"]
    pub fn rte_rib_insert(rib: *mut rte_rib, ip: u32, depth: u8) -> *mut rte_rib_node;
}
extern "C" {
    #[doc = " Get an ip from rte_rib_node"]
    #[doc = ""]
    #[doc = " @param node"]
    #[doc = "  pointer to the rib node"]
    #[doc = " @param ip"]
    #[doc = "  pointer to the ip to save"]
    #[doc = " @return"]
    #[doc = "  0 on success."]
    #[doc = "  -1 on failure with rte_errno indicating reason for failure."]
    pub fn rte_rib_get_ip(node: *const rte_rib_node, ip: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a depth from rte_rib_node"]
    #[doc = ""]
    #[doc = " @param node"]
    #[doc = "  pointer to the rib node"]
    #[doc = " @param depth"]
    #[doc = "  pointer to the depth to save"]
    #[doc = " @return"]
    #[doc = "  0 on success."]
    #[doc = "  -1 on failure with rte_errno indicating reason for failure."]
    pub fn rte_rib_get_depth(node: *const rte_rib_node, depth: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get ext field from the rib node"]
    #[doc = " It is caller responsibility to make sure there are necessary space"]
    #[doc = " for the ext field inside rib node."]
    #[doc = ""]
    #[doc = " @param node"]
    #[doc = "  pointer to the rib node"]
    #[doc = " @return"]
    #[doc = "  pointer to the ext"]
    pub fn rte_rib_get_ext(node: *mut rte_rib_node) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get nexthop from the rib node"]
    #[doc = ""]
    #[doc = " @param node"]
    #[doc = "  pointer to the rib node"]
    #[doc = " @param nh"]
    #[doc = "  pointer to the nexthop to save"]
    #[doc = " @return"]
    #[doc = "  0 on success."]
    #[doc = "  -1 on failure with rte_errno indicating reason for failure."]
    pub fn rte_rib_get_nh(node: *const rte_rib_node, nh: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set nexthop into the rib node"]
    #[doc = ""]
    #[doc = " @param node"]
    #[doc = "  pointer to the rib node"]
    #[doc = " @param nh"]
    #[doc = "  nexthop value to set to the rib node"]
    #[doc = " @return"]
    #[doc = "  0 on success."]
    #[doc = "  -1 on failure with rte_errno indicating reason for failure."]
    pub fn rte_rib_set_nh(node: *mut rte_rib_node, nh: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create RIB"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "  RIB name"]
    #[doc = " @param socket_id"]
    #[doc = "  NUMA socket ID for RIB table memory allocation"]
    #[doc = " @param conf"]
    #[doc = "  Structure containing the configuration"]
    #[doc = " @return"]
    #[doc = "  Handle to RIB object on success"]
    #[doc = "  NULL otherwise with rte_errno indicating reason for failure."]
    pub fn rte_rib_create(
        name: *const ::std::os::raw::c_char,
        socket_id: ::std::os::raw::c_int,
        conf: *const rte_rib_conf,
    ) -> *mut rte_rib;
}
extern "C" {
    #[doc = " Find an existing RIB object and return a pointer to it."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "  Name of the rib object as passed to rte_rib_create()"]
    #[doc = " @return"]
    #[doc = "  Pointer to RIB object on success"]
    #[doc = "  NULL otherwise with rte_errno indicating reason for failure."]
    pub fn rte_rib_find_existing(name: *const ::std::os::raw::c_char) -> *mut rte_rib;
}
extern "C" {
    #[doc = " Free an RIB object."]
    #[doc = ""]
    #[doc = " @param rib"]
    #[doc = "   RIB object handle"]
    #[doc = " @return"]
    #[doc = "   None"]
    pub fn rte_rib_free(rib: *mut rte_rib);
}
#[doc = " Signature of callback function to run a service."]
pub type rte_service_func =
    ::std::option::Option<unsafe extern "C" fn(args: *mut ::std::os::raw::c_void) -> i32>;
#[doc = " The specification of a service."]
#[doc = ""]
#[doc = " This struct contains metadata about the service itself, the callback"]
#[doc = " function to run one iteration of the service, a userdata pointer, flags etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_service_spec {
    #[doc = " The name of the service. This should be used by the application to"]
    #[doc = " understand what purpose this service provides."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = " The callback to invoke to run one iteration of the service."]
    pub callback: rte_service_func,
    #[doc = " The userdata pointer provided to the service callback."]
    pub callback_userdata: *mut ::std::os::raw::c_void,
    #[doc = " Flags to indicate the capabilities of this service. See defines in"]
    #[doc = " the public header file for values of RTE_SERVICE_CAP_*"]
    pub capabilities: u32,
    #[doc = " NUMA socket ID that this service is affinitized to"]
    pub socket_id: ::std::os::raw::c_int,
}
extern "C" {
    #[doc = " Register a new service."]
    #[doc = ""]
    #[doc = " A service represents a component that requires CPU time periodically to"]
    #[doc = " achieve its purpose."]
    #[doc = ""]
    #[doc = " For example the eventdev SW PMD requires CPU cycles to perform its"]
    #[doc = " scheduling. This can be achieved by registering it as a service, and the"]
    #[doc = " application can then assign CPU resources to that service."]
    #[doc = ""]
    #[doc = " Note that when a service component registers itself, it is not permitted to"]
    #[doc = " add or remove service-core threads, or modify lcore-to-service mappings. The"]
    #[doc = " only API that may be called by the service-component is"]
    #[doc = " *rte_service_component_runstate_set*, which indicates that the service"]
    #[doc = " component is ready to be executed."]
    #[doc = ""]
    #[doc = " If the service is known to be mapped to a single lcore, setting the"]
    #[doc = " capability of the service to RTE_SERVICE_CAP_MT_SAFE can achieve"]
    #[doc = " better performance."]
    #[doc = ""]
    #[doc = " @param spec The specification of the service to register"]
    #[doc = " @param[out] service_id A pointer to a uint32_t, which will be filled in"]
    #[doc = "             during registration of the service. It is set to the integers"]
    #[doc = "             service number given to the service. This parameter may be NULL."]
    #[doc = " @retval 0 Successfully registered the service."]
    #[doc = "         -EINVAL Attempted to register an invalid service (eg, no callback"]
    #[doc = "         set)"]
    pub fn rte_service_component_register(
        spec: *const rte_service_spec,
        service_id: *mut u32,
    ) -> i32;
}
extern "C" {
    #[doc = " Unregister a service component."]
    #[doc = ""]
    #[doc = " The service being removed must be stopped before calling this function."]
    #[doc = ""]
    #[doc = " @retval 0 The service was successfully unregistered."]
    #[doc = " @retval -EBUSY The service is currently running, stop the service before"]
    #[doc = "          calling unregister. No action has been taken."]
    pub fn rte_service_component_unregister(id: u32) -> i32;
}
extern "C" {
    #[doc = " Private function to allow EAL to initialized default mappings."]
    #[doc = ""]
    #[doc = " This function iterates all the services, and maps then to the available"]
    #[doc = " cores. Based on the capabilities of the services, they are set to run on the"]
    #[doc = " available cores in a round-robin manner."]
    #[doc = ""]
    #[doc = " @retval 0 Success"]
    #[doc = " @retval -ENOTSUP No service lcores in use"]
    #[doc = " @retval -EINVAL Error while iterating over services"]
    #[doc = " @retval -ENODEV Error in enabling service lcore on a service"]
    #[doc = " @retval -ENOEXEC Error when starting services"]
    pub fn rte_service_start_with_defaults() -> i32;
}
extern "C" {
    #[doc = " Set the backend runstate of a component."]
    #[doc = ""]
    #[doc = " This function allows services to be registered at startup, but not yet"]
    #[doc = " enabled to run by default. When the service has been configured (via the"]
    #[doc = " usual method; eg rte_eventdev_configure, the service can mark itself as"]
    #[doc = " ready to run. The differentiation between backend runstate and"]
    #[doc = " service_runstate is that the backend runstate is set by the service"]
    #[doc = " component while the service runstate is reserved for application usage."]
    #[doc = ""]
    #[doc = " @retval 0 Success"]
    pub fn rte_service_component_runstate_set(id: u32, runstate: u32) -> i32;
}
extern "C" {
    #[doc = " Initialize the service library."]
    #[doc = ""]
    #[doc = " In order to use the service library, it must be initialized. EAL initializes"]
    #[doc = " the library at startup."]
    #[doc = ""]
    #[doc = " @retval 0 Success"]
    #[doc = " @retval -EALREADY Service library is already initialized"]
    pub fn rte_service_init() -> i32;
}
extern "C" {
    #[doc = " @internal Free up the memory that has been initialized."]
    #[doc = " This routine is to be invoked prior to process termination."]
    #[doc = ""]
    #[doc = " @retval None"]
    pub fn rte_service_finalize();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_stack_lf_elem {
    #[doc = "< Data pointer"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< Next pointer"]
    pub next: *mut rte_stack_lf_elem,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_stack_lf_head {
    #[doc = "< Stack top"]
    pub top: *mut rte_stack_lf_elem,
    #[doc = "< Modification counter for avoiding ABA problem"]
    pub cnt: u64,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct rte_stack_lf_list {
    #[doc = " List head"]
    pub head: rte_stack_lf_head,
    #[doc = " List len"]
    pub len: u64,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug)]
pub struct rte_stack_lf {
    #[doc = " LIFO list of elements"]
    pub used: rte_stack_lf_list,
    pub __bindgen_padding_0: [u64; 4usize],
    #[doc = " LIFO list of free elements"]
    pub free: rte_stack_lf_list,
    pub __bindgen_padding_1: [u64; 4usize],
    #[doc = " LIFO elements"]
    pub elems: __IncompleteArrayField<rte_stack_lf_elem>,
}
#[repr(C)]
#[derive(Debug)]
pub struct rte_stack_std {
    #[doc = "< LIFO lock"]
    pub lock: rte_spinlock_t,
    #[doc = "< LIFO len"]
    pub len: u32,
    #[doc = "< LIFO pointer table"]
    pub objs: __IncompleteArrayField<*mut ::std::os::raw::c_void>,
}
#[repr(C)]
#[repr(align(64))]
pub struct rte_stack {
    #[doc = " Name of the stack."]
    pub name: [::std::os::raw::c_char; 28usize],
    #[doc = " Memzone containing the rte_stack structure."]
    pub memzone: *const rte_memzone,
    #[doc = "< Usable size of the stack."]
    pub capacity: u32,
    #[doc = "< Flags supplied at creation."]
    pub flags: u32,
    pub __bindgen_padding_0: [u64; 2usize],
    pub __bindgen_anon_1: rte_stack__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(64))]
pub struct rte_stack__bindgen_ty_1 {
    #[doc = "< Lock-free LIFO structure."]
    pub stack_lf: __BindgenUnionField<rte_stack_lf>,
    #[doc = "< LIFO structure."]
    pub stack_std: __BindgenUnionField<rte_stack_std>,
    pub bindgen_union_field: [u8; 128usize],
}
extern "C" {
    #[doc = " @internal Initialize a standard stack."]
    #[doc = ""]
    #[doc = " @param s"]
    #[doc = "   A pointer to the stack structure."]
    pub fn rte_stack_std_init(s: *mut rte_stack);
}
extern "C" {
    #[doc = " @internal Return the memory required for a standard stack."]
    #[doc = ""]
    #[doc = " @param count"]
    #[doc = "   The size of the stack."]
    #[doc = " @return"]
    #[doc = "   The bytes to allocate for a standard stack."]
    pub fn rte_stack_std_get_memsize(count: ::std::os::raw::c_uint) -> ssize_t;
}
extern "C" {
    #[doc = " @internal Initialize a lock-free stack."]
    #[doc = ""]
    #[doc = " @param s"]
    #[doc = "   A pointer to the stack structure."]
    #[doc = " @param count"]
    #[doc = "   The size of the stack."]
    pub fn rte_stack_lf_init(s: *mut rte_stack, count: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " @internal Return the memory required for a lock-free stack."]
    #[doc = ""]
    #[doc = " @param count"]
    #[doc = "   The size of the stack."]
    #[doc = " @return"]
    #[doc = "   The bytes to allocate for a lock-free stack."]
    pub fn rte_stack_lf_get_memsize(count: ::std::os::raw::c_uint) -> ssize_t;
}
extern "C" {
    #[doc = " Create a new stack named *name* in memory."]
    #[doc = ""]
    #[doc = " This function uses ``memzone_reserve()`` to allocate memory for a stack of"]
    #[doc = " size *count*. The behavior of the stack is controlled by the *flags*."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the stack."]
    #[doc = " @param count"]
    #[doc = "   The size of the stack."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in case of"]
    #[doc = "   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   An OR of the following:"]
    #[doc = "    - RTE_STACK_F_LF: If this flag is set, the stack uses lock-free"]
    #[doc = "      variants of the push and pop functions. Otherwise, it achieves"]
    #[doc = "      thread-safety using a lock."]
    #[doc = " @return"]
    #[doc = "   On success, the pointer to the new allocated stack. NULL on error with"]
    #[doc = "    rte_errno set appropriately. Possible errno values include:"]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a stack with the same name already exists"]
    #[doc = "    - ENOMEM - insufficient memory to create the stack"]
    #[doc = "    - ENAMETOOLONG - name size exceeds RTE_STACK_NAMESIZE"]
    #[doc = "    - ENOTSUP - platform does not support given flags combination."]
    pub fn rte_stack_create(
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: u32,
    ) -> *mut rte_stack;
}
extern "C" {
    #[doc = " Free all memory used by the stack."]
    #[doc = ""]
    #[doc = " @param s"]
    #[doc = "   Stack to free"]
    pub fn rte_stack_free(s: *mut rte_stack);
}
extern "C" {
    #[doc = " Lookup a stack by its name."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the stack."]
    #[doc = " @return"]
    #[doc = "   The pointer to the stack matching the name, or NULL if not found,"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - ENOENT - Stack with name *name* not found."]
    #[doc = "    - EINVAL - *name* pointer is NULL."]
    pub fn rte_stack_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_stack;
}
#[doc = " dummy structure type used by the rte_tailq APIs"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tailq_entry {
    #[doc = "< Pointer entries for a tailq list"]
    pub next: rte_tailq_entry__bindgen_ty_1,
    #[doc = "< Pointer to the data referenced by this tailq entry"]
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tailq_entry__bindgen_ty_1 {
    pub tqe_next: *mut rte_tailq_entry,
    pub tqe_prev: *mut *mut rte_tailq_entry,
}
#[doc = " dummy"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tailq_entry_head {
    pub tqh_first: *mut rte_tailq_entry,
    pub tqh_last: *mut *mut rte_tailq_entry,
}
#[doc = " The structure defining a tailq header entry for storing"]
#[doc = " in the rte_config structure in shared memory. Each tailq"]
#[doc = " is identified by name."]
#[doc = " Any library storing a set of objects e.g. rings, mempools, hash-tables,"]
#[doc = " is recommended to use an entry here, so as to make it easy for"]
#[doc = " a multi-process app to find already-created elements in shared memory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tailq_head {
    #[doc = "< NOTE: must be first element"]
    pub tailq_head: rte_tailq_entry_head,
    pub name: [::std::os::raw::c_char; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tailq_elem {
    #[doc = " Reference to head in shared mem, updated at init time by"]
    #[doc = " rte_eal_tailqs_init()"]
    pub head: *mut rte_tailq_head,
    pub next: rte_tailq_elem__bindgen_ty_1,
    pub name: [::std::os::raw::c_char; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tailq_elem__bindgen_ty_1 {
    pub tqe_next: *mut rte_tailq_elem,
    pub tqe_prev: *mut *mut rte_tailq_elem,
}
extern "C" {
    #[doc = " Dump tail queues to a file."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_dump_tailq(f: *mut FILE);
}
extern "C" {
    #[doc = " Lookup for a tail queue."]
    #[doc = ""]
    #[doc = " Get a pointer to a tail queue header of a tail"]
    #[doc = " queue identified by the name given as an argument."]
    #[doc = " Note: this function is not multi-thread safe, and should only be called from"]
    #[doc = " a single thread at a time"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the queue."]
    #[doc = " @return"]
    #[doc = "   A pointer to the tail queue head structure."]
    pub fn rte_eal_tailq_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_tailq_head;
}
extern "C" {
    #[doc = " Register a tail queue."]
    #[doc = ""]
    #[doc = " Register a tail queue from shared memory."]
    #[doc = " This function is mainly used by EAL_REGISTER_TAILQ macro which is used to"]
    #[doc = " register tailq from the different dpdk libraries. Since this macro is a"]
    #[doc = " constructor, the function has no access to dpdk shared memory, so the"]
    #[doc = " registered tailq can not be used before call to rte_eal_init() which calls"]
    #[doc = " rte_eal_tailqs_init()."]
    #[doc = ""]
    #[doc = " @param t"]
    #[doc = "   The tailq element which contains the name of the tailq you want to"]
    #[doc = "   create (/retrieve when in secondary process)."]
    #[doc = " @return"]
    #[doc = "   0 on success or -1 in case of an error."]
    pub fn rte_eal_tailq_register(t: *mut rte_tailq_elem) -> ::std::os::raw::c_int;
}
#[doc = " opaque structure used internally for managing data from callbacks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tel_data {
    _unused: [u8; 0],
}
#[repr(u32)]
#[doc = " The types of data that can be managed in arrays or dicts."]
#[doc = " For arrays, this must be specified at creation time, while for"]
#[doc = " dicts this is specified implicitly each time an element is added"]
#[doc = " via calling a type-specific function."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_tel_value_type {
    RTE_TEL_STRING_VAL = 0,
    #[doc = " a string value"]
    RTE_TEL_INT_VAL = 1,
    #[doc = " a signed 32-bit int value"]
    RTE_TEL_U64_VAL = 2,
    #[doc = " an unsigned 64-bit int value"]
    RTE_TEL_CONTAINER = 3,
}
extern "C" {
    #[doc = " Start an array of the specified type for returning from a callback"]
    #[doc = ""]
    #[doc = " @param d"]
    #[doc = "   The data structure passed to the callback"]
    #[doc = " @param type"]
    #[doc = "   The type of the array of data"]
    #[doc = " @return"]
    #[doc = "   0 on success, negative errno on error"]
    pub fn rte_tel_data_start_array(
        d: *mut rte_tel_data,
        type_: rte_tel_value_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start a dictionary of values for returning from a callback"]
    #[doc = ""]
    #[doc = " @param d"]
    #[doc = "   The data structure passed to the callback"]
    #[doc = " @return"]
    #[doc = "   0 on success, negative errno on error"]
    pub fn rte_tel_data_start_dict(d: *mut rte_tel_data) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set a string for returning from a callback"]
    #[doc = ""]
    #[doc = " @param d"]
    #[doc = "   The data structure passed to the callback"]
    #[doc = " @param str"]
    #[doc = "   The string to be returned in the data structure"]
    #[doc = " @return"]
    #[doc = "   0 on success, negative errno on error, E2BIG on string truncation"]
    pub fn rte_tel_data_string(
        d: *mut rte_tel_data,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a string to an array."]
    #[doc = " The array must have been started by rte_tel_data_start_array() with"]
    #[doc = " RTE_TEL_STRING_VAL as the type parameter."]
    #[doc = ""]
    #[doc = " @param d"]
    #[doc = "   The data structure passed to the callback"]
    #[doc = " @param str"]
    #[doc = "   The string to be returned in the array"]
    #[doc = " @return"]
    #[doc = "   0 on success, negative errno on error, E2BIG on string truncation"]
    pub fn rte_tel_data_add_array_string(
        d: *mut rte_tel_data,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add an int to an array."]
    #[doc = " The array must have been started by rte_tel_data_start_array() with"]
    #[doc = " RTE_TEL_INT_VAL as the type parameter."]
    #[doc = ""]
    #[doc = " @param d"]
    #[doc = "   The data structure passed to the callback"]
    #[doc = " @param x"]
    #[doc = "   The number to be returned in the array"]
    #[doc = " @return"]
    #[doc = "   0 on success, negative errno on error"]
    pub fn rte_tel_data_add_array_int(
        d: *mut rte_tel_data,
        x: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a uint64_t to an array."]
    #[doc = " The array must have been started by rte_tel_data_start_array() with"]
    #[doc = " RTE_TEL_U64_VAL as the type parameter."]
    #[doc = ""]
    #[doc = " @param d"]
    #[doc = "   The data structure passed to the callback"]
    #[doc = " @param x"]
    #[doc = "   The number to be returned in the array"]
    #[doc = " @return"]
    #[doc = "   0 on success, negative errno on error"]
    pub fn rte_tel_data_add_array_u64(d: *mut rte_tel_data, x: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a container to an array. A container is an existing telemetry data"]
    #[doc = " array. The array the container is to be added to must have been started by"]
    #[doc = " rte_tel_data_start_array() with RTE_TEL_CONTAINER as the type parameter."]
    #[doc = " The container type must be an array of type uint64_t/int/string."]
    #[doc = ""]
    #[doc = " @param d"]
    #[doc = "   The data structure passed to the callback"]
    #[doc = " @param val"]
    #[doc = "   The pointer to the container to be stored in the array."]
    #[doc = " @param keep"]
    #[doc = "   Flag to indicate that the container memory should not be automatically"]
    #[doc = "   freed by the telemetry library once it has finished with the data."]
    #[doc = "   1 = keep, 0 = free."]
    #[doc = " @return"]
    #[doc = "   0 on success, negative errno on error"]
    pub fn rte_tel_data_add_array_container(
        d: *mut rte_tel_data,
        val: *mut rte_tel_data,
        keep: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a string value to a dictionary."]
    #[doc = " The dict must have been started by rte_tel_data_start_dict()."]
    #[doc = ""]
    #[doc = " @param d"]
    #[doc = "   The data structure passed to the callback"]
    #[doc = " @param name"]
    #[doc = "   The name the value is to be stored under in the dict"]
    #[doc = " @param val"]
    #[doc = "   The string to be stored in the dict"]
    #[doc = " @return"]
    #[doc = "   0 on success, negative errno on error, E2BIG on string truncation of"]
    #[doc = "   either name or value."]
    pub fn rte_tel_data_add_dict_string(
        d: *mut rte_tel_data,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add an int value to a dictionary."]
    #[doc = " The dict must have been started by rte_tel_data_start_dict()."]
    #[doc = ""]
    #[doc = " @param d"]
    #[doc = "   The data structure passed to the callback"]
    #[doc = " @param name"]
    #[doc = "   The name the value is to be stored under in the dict"]
    #[doc = " @param val"]
    #[doc = "   The number to be stored in the dict"]
    #[doc = " @return"]
    #[doc = "   0 on success, negative errno on error, E2BIG on string truncation of name."]
    pub fn rte_tel_data_add_dict_int(
        d: *mut rte_tel_data,
        name: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a uint64_t value to a dictionary."]
    #[doc = " The dict must have been started by rte_tel_data_start_dict()."]
    #[doc = ""]
    #[doc = " @param d"]
    #[doc = "   The data structure passed to the callback"]
    #[doc = " @param name"]
    #[doc = "   The name the value is to be stored under in the dict"]
    #[doc = " @param val"]
    #[doc = "   The number to be stored in the dict"]
    #[doc = " @return"]
    #[doc = "   0 on success, negative errno on error, E2BIG on string truncation of name."]
    pub fn rte_tel_data_add_dict_u64(
        d: *mut rte_tel_data,
        name: *const ::std::os::raw::c_char,
        val: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a container to a dictionary. A container is an existing telemetry data"]
    #[doc = " array. The dict the container is to be added to must have been started by"]
    #[doc = " rte_tel_data_start_dict(). The container must be an array of type"]
    #[doc = " uint64_t/int/string."]
    #[doc = ""]
    #[doc = " @param d"]
    #[doc = "   The data structure passed to the callback"]
    #[doc = " @param name"]
    #[doc = "   The name the value is to be stored under in the dict."]
    #[doc = " @param val"]
    #[doc = "   The pointer to the container to be stored in the dict."]
    #[doc = " @param keep"]
    #[doc = "   Flag to indicate that the container memory should not be automatically"]
    #[doc = "   freed by the telemetry library once it has finished with the data."]
    #[doc = "   1 = keep, 0 = free."]
    #[doc = " @return"]
    #[doc = "   0 on success, negative errno on error"]
    pub fn rte_tel_data_add_dict_container(
        d: *mut rte_tel_data,
        name: *const ::std::os::raw::c_char,
        val: *mut rte_tel_data,
        keep: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " This telemetry callback is used when registering a telemetry command."]
#[doc = " It handles getting and formatting information to be returned to telemetry"]
#[doc = " when requested."]
#[doc = ""]
#[doc = " @param cmd"]
#[doc = " The cmd that was requested by the client."]
#[doc = " @param params"]
#[doc = " Contains data required by the callback function."]
#[doc = " @param info"]
#[doc = " The information to be returned to the caller."]
#[doc = ""]
#[doc = " @return"]
#[doc = " Length of buffer used on success."]
#[doc = " @return"]
#[doc = " Negative integer on error."]
pub type telemetry_cb = ::std::option::Option<
    unsafe extern "C" fn(
        cmd: *const ::std::os::raw::c_char,
        params: *const ::std::os::raw::c_char,
        info: *mut rte_tel_data,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Used for handling data received over a telemetry socket."]
#[doc = ""]
#[doc = " @param sock_id"]
#[doc = " ID for the socket to be used by the handler."]
#[doc = ""]
#[doc = " @return"]
#[doc = " Void."]
pub type handler = ::std::option::Option<
    unsafe extern "C" fn(sock_id: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    #[doc = " Used when registering a command and callback function with telemetry."]
    #[doc = ""]
    #[doc = " @param cmd"]
    #[doc = " The command to register with telemetry."]
    #[doc = " @param fn"]
    #[doc = " Callback function to be called when the command is requested."]
    #[doc = " @param help"]
    #[doc = " Help text for the command."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  0 on success."]
    #[doc = " @return"]
    #[doc = "  -EINVAL for invalid parameters failure."]
    #[doc = "  @return"]
    #[doc = "  -ENOMEM for mem allocation failure."]
    pub fn rte_telemetry_register_cmd(
        cmd: *const ::std::os::raw::c_char,
        fn_: telemetry_cb,
        help: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a pointer to a container with memory allocated. The container is to be"]
    #[doc = " used embedded within an existing telemetry dict/array."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  Pointer to a container."]
    pub fn rte_tel_data_alloc() -> *mut rte_tel_data;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Free a container that has memory allocated."]
    #[doc = ""]
    #[doc = " @param data"]
    #[doc = "  Pointer to container."]
    #[doc = "."]
    pub fn rte_tel_data_free(data: *mut rte_tel_data);
}
#[doc = " Structure to hold the parameters of a running cycle counter to assist"]
#[doc = " in converting cycles to nanoseconds."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_timecounter {
    #[doc = " Last cycle counter value read."]
    pub cycle_last: u64,
    #[doc = " Nanoseconds count."]
    pub nsec: u64,
    #[doc = " Bitmask separating nanosecond and sub-nanoseconds."]
    pub nsec_mask: u64,
    #[doc = " Sub-nanoseconds count."]
    pub nsec_frac: u64,
    #[doc = " Bitmask for two's complement subtraction of non-64 bit counters."]
    pub cc_mask: u64,
    #[doc = " Cycle to nanosecond divisor (power of two)."]
    pub cc_shift: u32,
}
#[repr(u32)]
#[doc = " Timer type: Periodic or single (one-shot)."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_timer_type {
    SINGLE = 0,
    PERIODICAL = 1,
}
#[doc = " Timer status: A union of the state (stopped, pending, running,"]
#[doc = " config) and an owner (the id of the lcore that owns the timer)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_timer_status {
    pub __bindgen_anon_1: rte_timer_status__bindgen_ty_1,
    #[doc = "< To atomic-set status + owner."]
    pub u32_: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_timer_status__bindgen_ty_1 {
    #[doc = "< Stop, pending, running, config."]
    pub state: u16,
    #[doc = "< The lcore that owns the timer."]
    pub owner: i16,
}
#[doc = " Callback function type for timer expiry."]
pub type rte_timer_cb_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut rte_timer, arg2: *mut ::std::os::raw::c_void),
>;
#[doc = " A structure describing a timer in RTE."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_timer {
    #[doc = "< Time when timer expire."]
    pub expire: u64,
    pub sl_next: [*mut rte_timer; 10usize],
    #[doc = "< Status of timer."]
    pub status: rte_timer_status,
    #[doc = "< Period of timer (0 if not periodic)."]
    pub period: u64,
    #[doc = "< Callback function."]
    pub f: rte_timer_cb_t,
    #[doc = "< Argument to callback function."]
    pub arg: *mut ::std::os::raw::c_void,
}
extern "C" {
    #[doc = " Allocate a timer data instance in shared memory to track a set of pending"]
    #[doc = " timer lists."]
    #[doc = ""]
    #[doc = " @param id_ptr"]
    #[doc = "   Pointer to variable into which to write the identifier of the allocated"]
    #[doc = "   timer data instance."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - -ENOSPC: maximum number of timer data instances already allocated"]
    pub fn rte_timer_data_alloc(id_ptr: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Deallocate a timer data instance."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "   Identifier of the timer data instance to deallocate."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - -EINVAL: invalid timer data instance identifier"]
    pub fn rte_timer_data_dealloc(id: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize the timer library."]
    #[doc = ""]
    #[doc = " Initializes internal variables (list, locks and so on) for the RTE"]
    #[doc = " timer library."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "   This function must be called in every process before using the library."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - -ENOMEM: Unable to allocate memory needed to initialize timer"]
    #[doc = "      subsystem"]
    #[doc = "   - -EALREADY: timer subsystem was already initialized. Not an error."]
    pub fn rte_timer_subsystem_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free timer subsystem resources."]
    pub fn rte_timer_subsystem_finalize();
}
extern "C" {
    #[doc = " Initialize a timer handle."]
    #[doc = ""]
    #[doc = " The rte_timer_init() function initializes the timer handle *tim*"]
    #[doc = " for use. No operations can be performed on a timer before it is"]
    #[doc = " initialized."]
    #[doc = ""]
    #[doc = " @param tim"]
    #[doc = "   The timer to initialize."]
    pub fn rte_timer_init(tim: *mut rte_timer);
}
extern "C" {
    #[doc = " Reset and start the timer associated with the timer handle."]
    #[doc = ""]
    #[doc = " The rte_timer_reset() function resets and starts the timer"]
    #[doc = " associated with the timer handle *tim*. When the timer expires after"]
    #[doc = " *ticks* HPET cycles, the function specified by *fct* will be called"]
    #[doc = " with the argument *arg* on core *tim_lcore*."]
    #[doc = ""]
    #[doc = " If the timer associated with the timer handle is already running"]
    #[doc = " (in the RUNNING state), the function will fail. The user has to check"]
    #[doc = " the return value of the function to see if there is a chance that the"]
    #[doc = " timer is in the RUNNING state."]
    #[doc = ""]
    #[doc = " If the timer is being configured on another core (the CONFIG state),"]
    #[doc = " it will also fail."]
    #[doc = ""]
    #[doc = " If the timer is pending or stopped, it will be rescheduled with the"]
    #[doc = " new parameters."]
    #[doc = ""]
    #[doc = " @param tim"]
    #[doc = "   The timer handle."]
    #[doc = " @param ticks"]
    #[doc = "   The number of cycles (see rte_get_hpet_hz()) before the callback"]
    #[doc = "   function is called."]
    #[doc = " @param type"]
    #[doc = "   The type can be either:"]
    #[doc = "   - PERIODICAL: The timer is automatically reloaded after execution"]
    #[doc = "     (returns to the PENDING state)"]
    #[doc = "   - SINGLE: The timer is one-shot, that is, the timer goes to a"]
    #[doc = "     STOPPED state after execution."]
    #[doc = " @param tim_lcore"]
    #[doc = "   The ID of the lcore where the timer callback function has to be"]
    #[doc = "   executed. If tim_lcore is LCORE_ID_ANY, the timer library will"]
    #[doc = "   launch it on a different core for each call (round-robin)."]
    #[doc = " @param fct"]
    #[doc = "   The callback function of the timer."]
    #[doc = " @param arg"]
    #[doc = "   The user argument of the callback function."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; the timer is scheduled."]
    #[doc = "   - (-1): Timer is in the RUNNING or CONFIG state."]
    pub fn rte_timer_reset(
        tim: *mut rte_timer,
        ticks: u64,
        type_: rte_timer_type,
        tim_lcore: ::std::os::raw::c_uint,
        fct: rte_timer_cb_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Loop until rte_timer_reset() succeeds."]
    #[doc = ""]
    #[doc = " Reset and start the timer associated with the timer handle. Always"]
    #[doc = " succeed. See rte_timer_reset() for details."]
    #[doc = ""]
    #[doc = " @param tim"]
    #[doc = "   The timer handle."]
    #[doc = " @param ticks"]
    #[doc = "   The number of cycles (see rte_get_hpet_hz()) before the callback"]
    #[doc = "   function is called."]
    #[doc = " @param type"]
    #[doc = "   The type can be either:"]
    #[doc = "   - PERIODICAL: The timer is automatically reloaded after execution"]
    #[doc = "     (returns to the PENDING state)"]
    #[doc = "   - SINGLE: The timer is one-shot, that is, the timer goes to a"]
    #[doc = "     STOPPED state after execution."]
    #[doc = " @param tim_lcore"]
    #[doc = "   The ID of the lcore where the timer callback function has to be"]
    #[doc = "   executed. If tim_lcore is LCORE_ID_ANY, the timer library will"]
    #[doc = "   launch it on a different core for each call (round-robin)."]
    #[doc = " @param fct"]
    #[doc = "   The callback function of the timer."]
    #[doc = " @param arg"]
    #[doc = "   The user argument of the callback function."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "   This API should not be called inside a timer's callback function to"]
    #[doc = "   reset another timer; doing so could hang in certain scenarios. Instead,"]
    #[doc = "   the rte_timer_reset() API can be called directly and its return code"]
    #[doc = "   can be checked for success or failure."]
    pub fn rte_timer_reset_sync(
        tim: *mut rte_timer,
        ticks: u64,
        type_: rte_timer_type,
        tim_lcore: ::std::os::raw::c_uint,
        fct: rte_timer_cb_t,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Stop a timer."]
    #[doc = ""]
    #[doc = " The rte_timer_stop() function stops the timer associated with the"]
    #[doc = " timer handle *tim*. It may fail if the timer is currently running or"]
    #[doc = " being configured."]
    #[doc = ""]
    #[doc = " If the timer is pending or stopped (for instance, already expired),"]
    #[doc = " the function will succeed. The timer handle tim must have been"]
    #[doc = " initialized using rte_timer_init(), otherwise, undefined behavior"]
    #[doc = " will occur."]
    #[doc = ""]
    #[doc = " This function can be called safely from a timer callback. If it"]
    #[doc = " succeeds, the timer is not referenced anymore by the timer library"]
    #[doc = " and the timer structure can be freed (even in the callback"]
    #[doc = " function)."]
    #[doc = ""]
    #[doc = " @param tim"]
    #[doc = "   The timer handle."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; the timer is stopped."]
    #[doc = "   - (-1): The timer is in the RUNNING or CONFIG state."]
    pub fn rte_timer_stop(tim: *mut rte_timer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Loop until rte_timer_stop() succeeds."]
    #[doc = ""]
    #[doc = " After a call to this function, the timer identified by *tim* is"]
    #[doc = " stopped. See rte_timer_stop() for details."]
    #[doc = ""]
    #[doc = " @param tim"]
    #[doc = "   The timer handle."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "   This API should not be called inside a timer's callback function to"]
    #[doc = "   stop another timer; doing so could hang in certain scenarios. Instead, the"]
    #[doc = "   rte_timer_stop() API can be called directly and its return code can"]
    #[doc = "   be checked for success or failure."]
    pub fn rte_timer_stop_sync(tim: *mut rte_timer);
}
extern "C" {
    #[doc = " Test if a timer is pending."]
    #[doc = ""]
    #[doc = " The rte_timer_pending() function tests the PENDING status"]
    #[doc = " of the timer handle *tim*. A PENDING timer is one that has been"]
    #[doc = " scheduled and whose function has not yet been called."]
    #[doc = ""]
    #[doc = " @param tim"]
    #[doc = "   The timer handle."]
    #[doc = " @return"]
    #[doc = "   - 0: The timer is not pending."]
    #[doc = "   - 1: The timer is pending."]
    pub fn rte_timer_pending(tim: *mut rte_timer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Time until the next timer on the current lcore"]
    #[doc = " This function gives the ticks until the next timer will be active."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - -EINVAL: invalid timer data instance identifier"]
    #[doc = "   - -ENOENT: no timer pending"]
    #[doc = "   - 0: a timer is pending and will run at next rte_timer_manage()"]
    #[doc = "   - >0: ticks until the next timer is ready"]
    pub fn rte_timer_next_ticks() -> i64;
}
extern "C" {
    #[doc = " Manage the timer list and execute callback functions."]
    #[doc = ""]
    #[doc = " This function must be called periodically from EAL lcores"]
    #[doc = " main_loop(). It browses the list of pending timers and runs all"]
    #[doc = " timers that are expired."]
    #[doc = ""]
    #[doc = " The precision of the timer depends on the call frequency of this"]
    #[doc = " function. However, the more often the function is called, the more"]
    #[doc = " CPU resources it will use."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - -EINVAL: timer subsystem not yet initialized"]
    pub fn rte_timer_manage() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump statistics about timers."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - -EINVAL: timer subsystem not yet initialized"]
    pub fn rte_timer_dump_stats(f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function is the same as rte_timer_reset(), except that it allows a"]
    #[doc = " caller to specify the rte_timer_data instance containing the list to which"]
    #[doc = " the timer should be added."]
    #[doc = ""]
    #[doc = " @see rte_timer_reset()"]
    #[doc = ""]
    #[doc = " @param timer_data_id"]
    #[doc = "   An identifier indicating which instance of timer data should be used for"]
    #[doc = "   this operation."]
    #[doc = " @param tim"]
    #[doc = "   The timer handle."]
    #[doc = " @param ticks"]
    #[doc = "   The number of cycles (see rte_get_hpet_hz()) before the callback"]
    #[doc = "   function is called."]
    #[doc = " @param type"]
    #[doc = "   The type can be either:"]
    #[doc = "   - PERIODICAL: The timer is automatically reloaded after execution"]
    #[doc = "     (returns to the PENDING state)"]
    #[doc = "   - SINGLE: The timer is one-shot, that is, the timer goes to a"]
    #[doc = "     STOPPED state after execution."]
    #[doc = " @param tim_lcore"]
    #[doc = "   The ID of the lcore where the timer callback function has to be"]
    #[doc = "   executed. If tim_lcore is LCORE_ID_ANY, the timer library will"]
    #[doc = "   launch it on a different core for each call (round-robin)."]
    #[doc = " @param fct"]
    #[doc = "   The callback function of the timer. This parameter can be NULL if (and"]
    #[doc = "   only if) rte_timer_alt_manage() will be used to manage this timer."]
    #[doc = " @param arg"]
    #[doc = "   The user argument of the callback function."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; the timer is scheduled."]
    #[doc = "   - (-1): Timer is in the RUNNING or CONFIG state."]
    #[doc = "   - -EINVAL: invalid timer_data_id"]
    pub fn rte_timer_alt_reset(
        timer_data_id: u32,
        tim: *mut rte_timer,
        ticks: u64,
        type_: rte_timer_type,
        tim_lcore: ::std::os::raw::c_uint,
        fct: rte_timer_cb_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function is the same as rte_timer_stop(), except that it allows a"]
    #[doc = " caller to specify the rte_timer_data instance containing the list from which"]
    #[doc = " this timer should be removed."]
    #[doc = ""]
    #[doc = " @see rte_timer_stop()"]
    #[doc = ""]
    #[doc = " @param timer_data_id"]
    #[doc = "   An identifier indicating which instance of timer data should be used for"]
    #[doc = "   this operation."]
    #[doc = " @param tim"]
    #[doc = "   The timer handle."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; the timer is stopped."]
    #[doc = "   - (-1): The timer is in the RUNNING or CONFIG state."]
    #[doc = "   - -EINVAL: invalid timer_data_id"]
    pub fn rte_timer_alt_stop(timer_data_id: u32, tim: *mut rte_timer) -> ::std::os::raw::c_int;
}
#[doc = " Callback function type for rte_timer_alt_manage()."]
pub type rte_timer_alt_manage_cb_t =
    ::std::option::Option<unsafe extern "C" fn(tim: *mut rte_timer)>;
extern "C" {
    #[doc = " Manage a set of timer lists and execute the specified callback function for"]
    #[doc = " all expired timers. This function is similar to rte_timer_manage(), except"]
    #[doc = " that it allows a caller to specify the timer_data instance that should"]
    #[doc = " be operated on, as well as a set of lcore IDs identifying which timer lists"]
    #[doc = " should be processed.  Callback functions of individual timers are ignored."]
    #[doc = ""]
    #[doc = " @see rte_timer_manage()"]
    #[doc = ""]
    #[doc = " @param timer_data_id"]
    #[doc = "   An identifier indicating which instance of timer data should be used for"]
    #[doc = "   this operation."]
    #[doc = " @param poll_lcores"]
    #[doc = "   An array of lcore ids identifying the timer lists that should be processed."]
    #[doc = "   NULL is allowed - if NULL, the timer list corresponding to the lcore"]
    #[doc = "   calling this routine is processed (same as rte_timer_manage())."]
    #[doc = " @param n_poll_lcores"]
    #[doc = "   The size of the poll_lcores array. If 'poll_lcores' is NULL, this parameter"]
    #[doc = "   is ignored."]
    #[doc = " @param f"]
    #[doc = "   The callback function which should be called for all expired timers."]
    #[doc = " @return"]
    #[doc = "   - 0: success"]
    #[doc = "   - -EINVAL: invalid timer_data_id"]
    pub fn rte_timer_alt_manage(
        timer_data_id: u32,
        poll_lcores: *mut ::std::os::raw::c_uint,
        n_poll_lcores: ::std::os::raw::c_int,
        f: rte_timer_alt_manage_cb_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Callback function type for rte_timer_stop_all()."]
pub type rte_timer_stop_all_cb_t = ::std::option::Option<
    unsafe extern "C" fn(tim: *mut rte_timer, arg: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Walk the pending timer lists for the specified lcore IDs, and for each timer"]
    #[doc = " that is encountered, stop it and call the specified callback function to"]
    #[doc = " process it further."]
    #[doc = ""]
    #[doc = " @param timer_data_id"]
    #[doc = "   An identifier indicating which instance of timer data should be used for"]
    #[doc = "   this operation."]
    #[doc = " @param walk_lcores"]
    #[doc = "   An array of lcore ids identifying the timer lists that should be processed."]
    #[doc = " @param nb_walk_lcores"]
    #[doc = "   The size of the walk_lcores array."]
    #[doc = " @param f"]
    #[doc = "   The callback function which should be called for each timers. Can be NULL."]
    #[doc = " @param f_arg"]
    #[doc = "   An arbitrary argument that will be passed to f, if it is called."]
    #[doc = " @return"]
    #[doc = "   - 0: success"]
    #[doc = "   - EINVAL: invalid timer_data_id"]
    pub fn rte_timer_stop_all(
        timer_data_id: u32,
        walk_lcores: *mut ::std::os::raw::c_uint,
        nb_walk_lcores: ::std::os::raw::c_int,
        f: rte_timer_stop_all_cb_t,
        f_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function is the same as rte_timer_dump_stats(), except that it allows"]
    #[doc = " the caller to specify the rte_timer_data instance that should be used."]
    #[doc = ""]
    #[doc = " @see rte_timer_dump_stats()"]
    #[doc = ""]
    #[doc = " @param timer_data_id"]
    #[doc = "   An identifier indicating which instance of timer data should be used for"]
    #[doc = "   this operation."]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    #[doc = " @return"]
    #[doc = "   - 0: success"]
    #[doc = "   - -EINVAL: invalid timer_data_id"]
    pub fn rte_timer_alt_dump_stats(timer_data_id: u32, f: *mut FILE) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " Node statistics counter type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_tm_stats_type {
    #[doc = " Number of packets scheduled from current node."]
    RTE_TM_STATS_N_PKTS = 1,
    #[doc = " Number of bytes scheduled from current node."]
    RTE_TM_STATS_N_BYTES = 2,
    #[doc = " Number of green packets dropped by current leaf node."]
    RTE_TM_STATS_N_PKTS_GREEN_DROPPED = 4,
    #[doc = " Number of yellow packets dropped by current leaf node."]
    RTE_TM_STATS_N_PKTS_YELLOW_DROPPED = 8,
    #[doc = " Number of red packets dropped by current leaf node."]
    RTE_TM_STATS_N_PKTS_RED_DROPPED = 16,
    #[doc = " Number of green bytes dropped by current leaf node."]
    RTE_TM_STATS_N_BYTES_GREEN_DROPPED = 32,
    #[doc = " Number of yellow bytes dropped by current leaf node."]
    RTE_TM_STATS_N_BYTES_YELLOW_DROPPED = 64,
    #[doc = " Number of red bytes dropped by current leaf node."]
    RTE_TM_STATS_N_BYTES_RED_DROPPED = 128,
    #[doc = " Number of packets currently waiting in the packet queue of current"]
    #[doc = " leaf node."]
    RTE_TM_STATS_N_PKTS_QUEUED = 256,
    #[doc = " Number of bytes currently waiting in the packet queue of current"]
    #[doc = " leaf node."]
    RTE_TM_STATS_N_BYTES_QUEUED = 512,
}
#[doc = " Node statistics counters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tm_node_stats {
    #[doc = " Number of packets scheduled from current node."]
    pub n_pkts: u64,
    #[doc = " Number of bytes scheduled from current node."]
    pub n_bytes: u64,
    pub leaf: rte_tm_node_stats__bindgen_ty_1,
}
#[doc = " Statistics counters for leaf nodes only."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tm_node_stats__bindgen_ty_1 {
    #[doc = " Number of packets dropped by current leaf node per each"]
    #[doc = " color."]
    pub n_pkts_dropped: [u64; 3usize],
    #[doc = " Number of bytes dropped by current leaf node per each"]
    #[doc = " color."]
    pub n_bytes_dropped: [u64; 3usize],
    #[doc = " Number of packets currently waiting in the packet queue of"]
    #[doc = " current leaf node."]
    pub n_pkts_queued: u64,
    #[doc = " Number of bytes currently waiting in the packet queue of"]
    #[doc = " current leaf node."]
    pub n_bytes_queued: u64,
}
#[repr(u32)]
#[doc = " Traffic manager dynamic updates"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_tm_dynamic_update_type {
    #[doc = " Dynamic parent node update. The new parent node is located on same"]
    #[doc = " hierarchy level as the former parent node. Consequently, the node"]
    #[doc = " whose parent is changed preserves its hierarchy level."]
    RTE_TM_UPDATE_NODE_PARENT_KEEP_LEVEL = 1,
    #[doc = " Dynamic parent node update. The new parent node is located on"]
    #[doc = " different hierarchy level than the former parent node. Consequently,"]
    #[doc = " the node whose parent is changed also changes its hierarchy level."]
    RTE_TM_UPDATE_NODE_PARENT_CHANGE_LEVEL = 2,
    #[doc = " Dynamic node add/delete."]
    RTE_TM_UPDATE_NODE_ADD_DELETE = 4,
    #[doc = " Suspend/resume nodes."]
    RTE_TM_UPDATE_NODE_SUSPEND_RESUME = 8,
    #[doc = " Dynamic switch between byte-based and packet-based WFQ weights."]
    RTE_TM_UPDATE_NODE_WFQ_WEIGHT_MODE = 16,
    #[doc = " Dynamic update on number of SP priorities."]
    RTE_TM_UPDATE_NODE_N_SP_PRIORITIES = 32,
    #[doc = " Dynamic update of congestion management mode for leaf nodes."]
    RTE_TM_UPDATE_NODE_CMAN = 64,
    #[doc = " Dynamic update of the set of enabled stats counter types."]
    RTE_TM_UPDATE_NODE_STATS = 128,
}
#[doc = " Traffic manager capabilities"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tm_capabilities {
    #[doc = " Maximum number of nodes."]
    pub n_nodes_max: u32,
    #[doc = " Maximum number of levels (i.e. number of nodes connecting the root"]
    #[doc = " node with any leaf node, including the root and the leaf)."]
    pub n_levels_max: u32,
    #[doc = " When non-zero, this flag indicates that all the non-leaf nodes"]
    #[doc = " (with the exception of the root node) have identical capability set."]
    pub non_leaf_nodes_identical: ::std::os::raw::c_int,
    #[doc = " When non-zero, this flag indicates that all the leaf nodes have"]
    #[doc = " identical capability set."]
    pub leaf_nodes_identical: ::std::os::raw::c_int,
    #[doc = " Maximum number of shapers, either private or shared. In case the"]
    #[doc = " implementation does not share any resources between private and"]
    #[doc = " shared shapers, it is typically equal to the sum of"]
    #[doc = " *shaper_private_n_max* and *shaper_shared_n_max*. The"]
    #[doc = " value of zero indicates that traffic shaping is not supported."]
    pub shaper_n_max: u32,
    #[doc = " Maximum number of private shapers. Indicates the maximum number of"]
    #[doc = " nodes that can concurrently have their private shaper enabled. The"]
    #[doc = " value of zero indicates that private shapers are not supported."]
    pub shaper_private_n_max: u32,
    #[doc = " Maximum number of private shapers that support dual rate shaping."]
    #[doc = " Indicates the maximum number of nodes that can concurrently have"]
    #[doc = " their private shaper enabled with dual rate support. Only valid when"]
    #[doc = " private shapers are supported. The value of zero indicates that dual"]
    #[doc = " rate shaping is not available for private shapers. The maximum value"]
    #[doc = " is *shaper_private_n_max*."]
    pub shaper_private_dual_rate_n_max: ::std::os::raw::c_int,
    #[doc = " Minimum committed/peak rate (bytes per second) for any private"]
    #[doc = " shaper. Valid only when private shapers are supported."]
    pub shaper_private_rate_min: u64,
    #[doc = " Maximum committed/peak rate (bytes per second) for any private"]
    #[doc = " shaper. Valid only when private shapers are supported."]
    pub shaper_private_rate_max: u64,
    #[doc = " Shaper private packet mode supported. When non-zero, this parameter"]
    #[doc = " indicates that there is at least one node that can be configured"]
    #[doc = " with packet mode in its private shaper. When shaper is configured"]
    #[doc = " in packet mode, committed/peak rate provided is interpreted"]
    #[doc = " in packets per second."]
    pub shaper_private_packet_mode_supported: ::std::os::raw::c_int,
    #[doc = " Shaper private byte mode supported. When non-zero, this parameter"]
    #[doc = " indicates that there is at least one node that can be configured"]
    #[doc = " with byte mode in its private shaper. When shaper is configured"]
    #[doc = " in byte mode, committed/peak rate provided is interpreted in"]
    #[doc = " bytes per second."]
    pub shaper_private_byte_mode_supported: ::std::os::raw::c_int,
    #[doc = " Maximum number of shared shapers. The value of zero indicates that"]
    #[doc = " shared shapers are not supported."]
    pub shaper_shared_n_max: u32,
    #[doc = " Maximum number of nodes that can share the same shared shaper."]
    #[doc = " Only valid when shared shapers are supported."]
    pub shaper_shared_n_nodes_per_shaper_max: u32,
    #[doc = " Maximum number of shared shapers a node can be part of. This"]
    #[doc = " parameter indicates that there is at least one node that can be"]
    #[doc = " configured with this many shared shapers, which might not be true for"]
    #[doc = " all the nodes. Only valid when shared shapers are supported, in which"]
    #[doc = " case it ranges from 1 to *shaper_shared_n_max*."]
    pub shaper_shared_n_shapers_per_node_max: u32,
    #[doc = " Maximum number of shared shapers that can be configured with dual"]
    #[doc = " rate shaping. The value of zero indicates that dual rate shaping"]
    #[doc = " support is not available for shared shapers."]
    pub shaper_shared_dual_rate_n_max: u32,
    #[doc = " Minimum committed/peak rate (bytes per second) for any shared"]
    #[doc = " shaper. Only valid when shared shapers are supported."]
    pub shaper_shared_rate_min: u64,
    #[doc = " Maximum committed/peak rate (bytes per second) for any shared"]
    #[doc = " shaper. Only valid when shared shapers are supported."]
    pub shaper_shared_rate_max: u64,
    #[doc = " Shaper shared packet mode supported. When non-zero, this parameter"]
    #[doc = " indicates a shared shaper can be configured with packet mode."]
    #[doc = " When shared shaper is configured in packet mode, committed/peak rate"]
    #[doc = " provided is interpreted in packets per second."]
    pub shaper_shared_packet_mode_supported: ::std::os::raw::c_int,
    #[doc = " Shaper shared byte mode supported. When non-zero, this parameter"]
    #[doc = " indicates that a shared shaper can be configured with byte mode."]
    #[doc = " When shared shaper is configured in byte mode, committed/peak rate"]
    #[doc = " provided is interpreted in bytes per second."]
    pub shaper_shared_byte_mode_supported: ::std::os::raw::c_int,
    #[doc = " Minimum value allowed for packet length adjustment for any private"]
    #[doc = " or shared shaper."]
    pub shaper_pkt_length_adjust_min: ::std::os::raw::c_int,
    #[doc = " Maximum value allowed for packet length adjustment for any private"]
    #[doc = " or shared shaper."]
    pub shaper_pkt_length_adjust_max: ::std::os::raw::c_int,
    #[doc = " Maximum number of children nodes. This parameter indicates that"]
    #[doc = " there is at least one non-leaf node that can be configured with this"]
    #[doc = " many children nodes, which might not be true for all the non-leaf"]
    #[doc = " nodes."]
    pub sched_n_children_max: u32,
    #[doc = " Maximum number of supported priority levels. This parameter"]
    #[doc = " indicates that there is at least one non-leaf node that can be"]
    #[doc = " configured with this many priority levels for managing its children"]
    #[doc = " nodes, which might not be true for all the non-leaf nodes. The value"]
    #[doc = " of zero is invalid. The value of 1 indicates that only priority 0 is"]
    #[doc = " supported, which essentially means that Strict Priority (SP)"]
    #[doc = " algorithm is not supported."]
    pub sched_sp_n_priorities_max: u32,
    #[doc = " Maximum number of sibling nodes that can have the same priority at"]
    #[doc = " any given time, i.e. maximum size of the WFQ sibling node group. This"]
    #[doc = " parameter indicates there is at least one non-leaf node that meets"]
    #[doc = " this condition, which might not be true for all the non-leaf nodes."]
    #[doc = " The value of zero is invalid. The value of 1 indicates that WFQ"]
    #[doc = " algorithm is not supported. The maximum value is"]
    #[doc = " *sched_n_children_max*."]
    pub sched_wfq_n_children_per_group_max: u32,
    #[doc = " Maximum number of priority levels that can have more than one child"]
    #[doc = " node at any given time, i.e. maximum number of WFQ sibling node"]
    #[doc = " groups that have two or more members. This parameter indicates there"]
    #[doc = " is at least one non-leaf node that meets this condition, which might"]
    #[doc = " not be true for all the non-leaf nodes. The value of zero states that"]
    #[doc = " WFQ algorithm is not supported. The value of 1 indicates that"]
    #[doc = " (*sched_sp_n_priorities_max* - 1) priority levels have at most one"]
    #[doc = " child node, so there can be only one priority level with two or"]
    #[doc = " more sibling nodes making up a WFQ group. The maximum value is:"]
    #[doc = " min(floor(*sched_n_children_max* / 2), *sched_sp_n_priorities_max*)."]
    pub sched_wfq_n_groups_max: u32,
    #[doc = " Maximum WFQ weight. The value of 1 indicates that all sibling nodes"]
    #[doc = " with same priority have the same WFQ weight, so WFQ is reduced to FQ."]
    pub sched_wfq_weight_max: u32,
    #[doc = " WFQ packet mode supported. When non-zero, this parameter indicates"]
    #[doc = " that there is at least one non-leaf node that supports packet mode"]
    #[doc = " for WFQ among its children. WFQ weights will be applied against"]
    #[doc = " packet count for scheduling children when a non-leaf node"]
    #[doc = " is configured appropriately."]
    pub sched_wfq_packet_mode_supported: ::std::os::raw::c_int,
    #[doc = " WFQ byte mode supported. When non-zero, this parameter indicates"]
    #[doc = " that there is at least one non-leaf node that supports byte mode"]
    #[doc = " for WFQ among its children. WFQ weights will be applied against"]
    #[doc = " bytes for scheduling children when a non-leaf node is configured"]
    #[doc = " appropriately."]
    pub sched_wfq_byte_mode_supported: ::std::os::raw::c_int,
    #[doc = " WRED packet mode support. When non-zero, this parameter indicates"]
    #[doc = " that there is at least one leaf node that supports the WRED packet"]
    #[doc = " mode, which might not be true for all the leaf nodes. In packet"]
    #[doc = " mode, the WRED thresholds specify the queue length in packets, as"]
    #[doc = " opposed to bytes."]
    pub cman_wred_packet_mode_supported: ::std::os::raw::c_int,
    #[doc = " WRED byte mode support. When non-zero, this parameter indicates that"]
    #[doc = " there is at least one leaf node that supports the WRED byte mode,"]
    #[doc = " which might not be true for all the leaf nodes. In byte mode, the"]
    #[doc = " WRED thresholds specify the queue length in bytes, as opposed to"]
    #[doc = " packets."]
    pub cman_wred_byte_mode_supported: ::std::os::raw::c_int,
    #[doc = " Head drop algorithm support. When non-zero, this parameter"]
    #[doc = " indicates that there is at least one leaf node that supports the head"]
    #[doc = " drop algorithm, which might not be true for all the leaf nodes."]
    pub cman_head_drop_supported: ::std::os::raw::c_int,
    #[doc = " Maximum number of WRED contexts, either private or shared. In case"]
    #[doc = " the implementation does not share any resources between private and"]
    #[doc = " shared WRED contexts, it is typically equal to the sum of"]
    #[doc = " *cman_wred_context_private_n_max* and"]
    #[doc = " *cman_wred_context_shared_n_max*. The value of zero indicates that"]
    #[doc = " WRED is not supported."]
    pub cman_wred_context_n_max: u32,
    #[doc = " Maximum number of private WRED contexts. Indicates the maximum"]
    #[doc = " number of leaf nodes that can concurrently have their private WRED"]
    #[doc = " context enabled. The value of zero indicates that private WRED"]
    #[doc = " contexts are not supported."]
    pub cman_wred_context_private_n_max: u32,
    #[doc = " Maximum number of shared WRED contexts. The value of zero"]
    #[doc = " indicates that shared WRED contexts are not supported."]
    pub cman_wred_context_shared_n_max: u32,
    #[doc = " Maximum number of leaf nodes that can share the same WRED context."]
    #[doc = " Only valid when shared WRED contexts are supported."]
    pub cman_wred_context_shared_n_nodes_per_context_max: u32,
    #[doc = " Maximum number of shared WRED contexts a leaf node can be part of."]
    #[doc = " This parameter indicates that there is at least one leaf node that"]
    #[doc = " can be configured with this many shared WRED contexts, which might"]
    #[doc = " not be true for all the leaf nodes. Only valid when shared WRED"]
    #[doc = " contexts are supported, in which case it ranges from 1 to"]
    #[doc = " *cman_wred_context_shared_n_max*."]
    pub cman_wred_context_shared_n_contexts_per_node_max: u32,
    #[doc = " Support for VLAN DEI packet marking (per color)."]
    pub mark_vlan_dei_supported: [::std::os::raw::c_int; 3usize],
    #[doc = " Support for IPv4/IPv6 ECN marking of TCP packets (per color)."]
    pub mark_ip_ecn_tcp_supported: [::std::os::raw::c_int; 3usize],
    #[doc = " Support for IPv4/IPv6 ECN marking of SCTP packets (per color)."]
    pub mark_ip_ecn_sctp_supported: [::std::os::raw::c_int; 3usize],
    #[doc = " Support for IPv4/IPv6 DSCP packet marking (per color)."]
    pub mark_ip_dscp_supported: [::std::os::raw::c_int; 3usize],
    #[doc = " Set of supported dynamic update operations."]
    #[doc = " @see enum rte_tm_dynamic_update_type"]
    pub dynamic_update_mask: u64,
    #[doc = " Set of supported statistics counter types."]
    #[doc = " @see enum rte_tm_stats_type"]
    pub stats_mask: u64,
}
#[doc = " Traffic manager level capabilities"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_tm_level_capabilities {
    #[doc = " Maximum number of nodes for the current hierarchy level."]
    pub n_nodes_max: u32,
    #[doc = " Maximum number of non-leaf nodes for the current hierarchy level."]
    #[doc = " The value of 0 indicates that current level only supports leaf"]
    #[doc = " nodes. The maximum value is *n_nodes_max*."]
    pub n_nodes_nonleaf_max: u32,
    #[doc = " Maximum number of leaf nodes for the current hierarchy level. The"]
    #[doc = " value of 0 indicates that current level only supports non-leaf"]
    #[doc = " nodes. The maximum value is *n_nodes_max*."]
    pub n_nodes_leaf_max: u32,
    #[doc = " When non-zero, this flag indicates that all the non-leaf nodes on"]
    #[doc = " this level have identical capability set. Valid only when"]
    #[doc = " *n_nodes_nonleaf_max* is non-zero."]
    pub non_leaf_nodes_identical: ::std::os::raw::c_int,
    #[doc = " When non-zero, this flag indicates that all the leaf nodes on this"]
    #[doc = " level have identical capability set. Valid only when"]
    #[doc = " *n_nodes_leaf_max* is non-zero."]
    pub leaf_nodes_identical: ::std::os::raw::c_int,
    pub __bindgen_anon_1: rte_tm_level_capabilities__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_tm_level_capabilities__bindgen_ty_1 {
    pub nonleaf: rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1,
    pub leaf: rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2,
}
#[doc = " Items valid only for the non-leaf nodes on this level."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Private shaper support. When non-zero, it indicates"]
    #[doc = " there is at least one non-leaf node on this level"]
    #[doc = " with private shaper support, which may not be the"]
    #[doc = " case for all the non-leaf nodes on this level."]
    pub shaper_private_supported: ::std::os::raw::c_int,
    #[doc = " Dual rate support for private shaper. Valid only"]
    #[doc = " when private shaper is supported for the non-leaf"]
    #[doc = " nodes on the current level. When non-zero, it"]
    #[doc = " indicates there is at least one non-leaf node on this"]
    #[doc = " level with dual rate private shaper support, which"]
    #[doc = " may not be the case for all the non-leaf nodes on"]
    #[doc = " this level."]
    pub shaper_private_dual_rate_supported: ::std::os::raw::c_int,
    #[doc = " Minimum committed/peak rate (bytes per second) for"]
    #[doc = " private shapers of the non-leaf nodes of this level."]
    #[doc = " Valid only when private shaper is supported on this"]
    #[doc = " level."]
    pub shaper_private_rate_min: u64,
    #[doc = " Maximum committed/peak rate (bytes per second) for"]
    #[doc = " private shapers of the non-leaf nodes on this level."]
    #[doc = " Valid only when private shaper is supported on this"]
    #[doc = " level."]
    pub shaper_private_rate_max: u64,
    #[doc = " Shaper private packet mode supported. When non-zero,"]
    #[doc = " this parameter indicates there is at least one"]
    #[doc = " non-leaf node at this level that can be configured"]
    #[doc = " with packet mode in its private shaper. When private"]
    #[doc = " shaper is configured in packet mode, committed/peak"]
    #[doc = " rate provided is interpreted in packets per second."]
    pub shaper_private_packet_mode_supported: ::std::os::raw::c_int,
    #[doc = " Shaper private byte mode supported. When non-zero,"]
    #[doc = " this parameter indicates there is at least one"]
    #[doc = " non-leaf node at this level that can be configured"]
    #[doc = " with byte mode in its private shaper. When private"]
    #[doc = " shaper is configured in byte mode, committed/peak"]
    #[doc = " rate provided is interpreted in bytes per second."]
    pub shaper_private_byte_mode_supported: ::std::os::raw::c_int,
    #[doc = " Maximum number of shared shapers that any non-leaf"]
    #[doc = " node on this level can be part of. The value of zero"]
    #[doc = " indicates that shared shapers are not supported by"]
    #[doc = " the non-leaf nodes on this level. When non-zero, it"]
    #[doc = " indicates there is at least one non-leaf node on this"]
    #[doc = " level that meets this condition, which may not be the"]
    #[doc = " case for all the non-leaf nodes on this level."]
    pub shaper_shared_n_max: u32,
    #[doc = " Shaper shared packet mode supported. When non-zero,"]
    #[doc = " this parameter indicates that there is at least one"]
    #[doc = " non-leaf node on this level that can be part of"]
    #[doc = " shared shapers which work in packet mode."]
    pub shaper_shared_packet_mode_supported: ::std::os::raw::c_int,
    #[doc = " Shaper shared byte mode supported. When non-zero,"]
    #[doc = " this parameter indicates that there is at least one"]
    #[doc = " non-leaf node on this level that can be part of"]
    #[doc = " shared shapers which work in byte mode."]
    pub shaper_shared_byte_mode_supported: ::std::os::raw::c_int,
    #[doc = " Maximum number of children nodes. This parameter"]
    #[doc = " indicates that there is at least one non-leaf node on"]
    #[doc = " this level that can be configured with this many"]
    #[doc = " children nodes, which might not be true for all the"]
    #[doc = " non-leaf nodes on this level."]
    pub sched_n_children_max: u32,
    #[doc = " Maximum number of supported priority levels. This"]
    #[doc = " parameter indicates that there is at least one"]
    #[doc = " non-leaf node on this level that can be configured"]
    #[doc = " with this many priority levels for managing its"]
    #[doc = " children nodes, which might not be true for all the"]
    #[doc = " non-leaf nodes on this level. The value of zero is"]
    #[doc = " invalid. The value of 1 indicates that only priority"]
    #[doc = " 0 is supported, which essentially means that Strict"]
    #[doc = " Priority (SP) algorithm is not supported on this"]
    #[doc = " level."]
    pub sched_sp_n_priorities_max: u32,
    #[doc = " Maximum number of sibling nodes that can have the"]
    #[doc = " same priority at any given time, i.e. maximum size of"]
    #[doc = " the WFQ sibling node group. This parameter indicates"]
    #[doc = " there is at least one non-leaf node on this level"]
    #[doc = " that meets this condition, which may not be true for"]
    #[doc = " all the non-leaf nodes on this level. The value of"]
    #[doc = " zero is invalid. The value of 1 indicates that WFQ"]
    #[doc = " algorithm is not supported on this level. The maximum"]
    #[doc = " value is *sched_n_children_max*."]
    pub sched_wfq_n_children_per_group_max: u32,
    #[doc = " Maximum number of priority levels that can have"]
    #[doc = " more than one child node at any given time, i.e."]
    #[doc = " maximum number of WFQ sibling node groups that"]
    #[doc = " have two or more members. This parameter indicates"]
    #[doc = " there is at least one non-leaf node on this level"]
    #[doc = " that meets this condition, which might not be true"]
    #[doc = " for all the non-leaf nodes. The value of zero states"]
    #[doc = " that WFQ algorithm is not supported on this level."]
    #[doc = " The value of 1 indicates that"]
    #[doc = " (*sched_sp_n_priorities_max* - 1) priority levels on"]
    #[doc = " this level have at most one child node, so there can"]
    #[doc = " be only one priority level with two or more sibling"]
    #[doc = " nodes making up a WFQ group on this level. The"]
    #[doc = " maximum value is:"]
    #[doc = " min(floor(*sched_n_children_max* / 2),"]
    #[doc = " *sched_sp_n_priorities_max*)."]
    pub sched_wfq_n_groups_max: u32,
    #[doc = " Maximum WFQ weight. The value of 1 indicates that"]
    #[doc = " all sibling nodes on this level with same priority"]
    #[doc = " have the same WFQ weight, so on this level WFQ is"]
    #[doc = " reduced to FQ."]
    pub sched_wfq_weight_max: u32,
    #[doc = " WFQ packet mode supported. When non-zero, this"]
    #[doc = " parameter indicates that there is at least one"]
    #[doc = " non-leaf node at this level that supports packet"]
    #[doc = " mode for WFQ among its children. WFQ weights will"]
    #[doc = " be applied against packet count for scheduling"]
    #[doc = " children when a non-leaf node is configured"]
    #[doc = " appropriately."]
    pub sched_wfq_packet_mode_supported: ::std::os::raw::c_int,
    #[doc = " WFQ byte mode supported. When non-zero, this"]
    #[doc = " parameter indicates that there is at least one"]
    #[doc = " non-leaf node at this level that supports byte"]
    #[doc = " mode for WFQ among its children. WFQ weights will"]
    #[doc = " be applied against bytes for scheduling children"]
    #[doc = " when a non-leaf node is configured appropriately."]
    pub sched_wfq_byte_mode_supported: ::std::os::raw::c_int,
    #[doc = " Mask of statistics counter types supported by the"]
    #[doc = " non-leaf nodes on this level. Every supported"]
    #[doc = " statistics counter type is supported by at least one"]
    #[doc = " non-leaf node on this level, which may not be true"]
    #[doc = " for all the non-leaf nodes on this level."]
    #[doc = " @see enum rte_tm_stats_type"]
    pub stats_mask: u64,
}
#[doc = " Items valid only for the leaf nodes on this level."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " Private shaper support. When non-zero, it indicates"]
    #[doc = " there is at least one leaf node on this level with"]
    #[doc = " private shaper support, which may not be the case for"]
    #[doc = " all the leaf nodes on this level."]
    pub shaper_private_supported: ::std::os::raw::c_int,
    #[doc = " Dual rate support for private shaper. Valid only"]
    #[doc = " when private shaper is supported for the leaf nodes"]
    #[doc = " on this level. When non-zero, it indicates there is"]
    #[doc = " at least one leaf node on this level with dual rate"]
    #[doc = " private shaper support, which may not be the case for"]
    #[doc = " all the leaf nodes on this level."]
    pub shaper_private_dual_rate_supported: ::std::os::raw::c_int,
    #[doc = " Minimum committed/peak rate (bytes per second) for"]
    #[doc = " private shapers of the leaf nodes of this level."]
    #[doc = " Valid only when private shaper is supported for the"]
    #[doc = " leaf nodes on this level."]
    pub shaper_private_rate_min: u64,
    #[doc = " Maximum committed/peak rate (bytes per second) for"]
    #[doc = " private shapers of the leaf nodes on this level."]
    #[doc = " Valid only when private shaper is supported for the"]
    #[doc = " leaf nodes on this level."]
    pub shaper_private_rate_max: u64,
    #[doc = " Shaper private packet mode supported. When non-zero,"]
    #[doc = " this parameter indicates there is at least one leaf"]
    #[doc = " node at this level that can be configured with"]
    #[doc = " packet mode in its private shaper. When private"]
    #[doc = " shaper is configured in packet mode, committed/peak"]
    #[doc = " rate provided is interpreted in packets per second."]
    pub shaper_private_packet_mode_supported: ::std::os::raw::c_int,
    #[doc = " Shaper private byte mode supported. When non-zero,"]
    #[doc = " this parameter indicates there is at least one leaf"]
    #[doc = " node at this level that can be configured with"]
    #[doc = " byte mode in its private shaper. When private shaper"]
    #[doc = " is configured in byte mode, committed/peak rate"]
    #[doc = " provided is interpreted in bytes per second."]
    pub shaper_private_byte_mode_supported: ::std::os::raw::c_int,
    #[doc = " Maximum number of shared shapers that any leaf node"]
    #[doc = " on this level can be part of. The value of zero"]
    #[doc = " indicates that shared shapers are not supported by"]
    #[doc = " the leaf nodes on this level. When non-zero, it"]
    #[doc = " indicates there is at least one leaf node on this"]
    #[doc = " level that meets this condition, which may not be the"]
    #[doc = " case for all the leaf nodes on this level."]
    pub shaper_shared_n_max: u32,
    #[doc = " Shaper shared packet mode supported. When non-zero,"]
    #[doc = " this parameter indicates that there is at least one"]
    #[doc = " leaf node on this level that can be part of"]
    #[doc = " shared shapers which work in packet mode."]
    pub shaper_shared_packet_mode_supported: ::std::os::raw::c_int,
    #[doc = " Shaper shared byte mode supported. When non-zero,"]
    #[doc = " this parameter indicates that there is at least one"]
    #[doc = " leaf node on this level that can be part of"]
    #[doc = " shared shapers which work in byte mode."]
    pub shaper_shared_byte_mode_supported: ::std::os::raw::c_int,
    #[doc = " WRED packet mode support. When non-zero, this"]
    #[doc = " parameter indicates that there is at least one leaf"]
    #[doc = " node on this level that supports the WRED packet"]
    #[doc = " mode, which might not be true for all the leaf"]
    #[doc = " nodes. In packet mode, the WRED thresholds specify"]
    #[doc = " the queue length in packets, as opposed to bytes."]
    pub cman_wred_packet_mode_supported: ::std::os::raw::c_int,
    #[doc = " WRED byte mode support. When non-zero, this"]
    #[doc = " parameter indicates that there is at least one leaf"]
    #[doc = " node on this level that supports the WRED byte mode,"]
    #[doc = " which might not be true for all the leaf nodes. In"]
    #[doc = " byte mode, the WRED thresholds specify the queue"]
    #[doc = " length in bytes, as opposed to packets."]
    pub cman_wred_byte_mode_supported: ::std::os::raw::c_int,
    #[doc = " Head drop algorithm support. When non-zero, this"]
    #[doc = " parameter indicates that there is at least one leaf"]
    #[doc = " node on this level that supports the head drop"]
    #[doc = " algorithm, which might not be true for all the leaf"]
    #[doc = " nodes on this level."]
    pub cman_head_drop_supported: ::std::os::raw::c_int,
    #[doc = " Private WRED context support. When non-zero, it"]
    #[doc = " indicates there is at least one node on this level"]
    #[doc = " with private WRED context support, which may not be"]
    #[doc = " true for all the leaf nodes on this level."]
    pub cman_wred_context_private_supported: ::std::os::raw::c_int,
    #[doc = " Maximum number of shared WRED contexts that any"]
    #[doc = " leaf node on this level can be part of. The value of"]
    #[doc = " zero indicates that shared WRED contexts are not"]
    #[doc = " supported by the leaf nodes on this level. When"]
    #[doc = " non-zero, it indicates there is at least one leaf"]
    #[doc = " node on this level that meets this condition, which"]
    #[doc = " may not be the case for all the leaf nodes on this"]
    #[doc = " level."]
    pub cman_wred_context_shared_n_max: u32,
    #[doc = " Mask of statistics counter types supported by the"]
    #[doc = " leaf nodes on this level. Every supported statistics"]
    #[doc = " counter type is supported by at least one leaf node"]
    #[doc = " on this level, which may not be true for all the leaf"]
    #[doc = " nodes on this level."]
    #[doc = " @see enum rte_tm_stats_type"]
    pub stats_mask: u64,
}
#[doc = " Traffic manager node capabilities"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_tm_node_capabilities {
    #[doc = " Private shaper support for the current node."]
    pub shaper_private_supported: ::std::os::raw::c_int,
    #[doc = " Dual rate shaping support for private shaper of current node."]
    #[doc = " Valid only when private shaper is supported by the current node."]
    pub shaper_private_dual_rate_supported: ::std::os::raw::c_int,
    #[doc = " Minimum committed/peak rate (bytes per second) for private"]
    #[doc = " shaper of current node. Valid only when private shaper is supported"]
    #[doc = " by the current node."]
    pub shaper_private_rate_min: u64,
    #[doc = " Maximum committed/peak rate (bytes per second) for private"]
    #[doc = " shaper of current node. Valid only when private shaper is supported"]
    #[doc = " by the current node."]
    pub shaper_private_rate_max: u64,
    #[doc = " Shaper private packet mode supported. When non-zero, this parameter"]
    #[doc = " indicates private shaper of current node can be configured with"]
    #[doc = " packet mode. When configured in packet mode, committed/peak rate"]
    #[doc = " provided is interpreted in packets per second."]
    pub shaper_private_packet_mode_supported: ::std::os::raw::c_int,
    #[doc = " Shaper private byte mode supported. When non-zero, this parameter"]
    #[doc = " indicates private shaper of current node can be configured with"]
    #[doc = " byte mode. When configured in byte mode, committed/peak rate"]
    #[doc = " provided is interpreted in bytes per second."]
    pub shaper_private_byte_mode_supported: ::std::os::raw::c_int,
    #[doc = " Maximum number of shared shapers the current node can be part of."]
    #[doc = " The value of zero indicates that shared shapers are not supported by"]
    #[doc = " the current node."]
    pub shaper_shared_n_max: u32,
    #[doc = " Shaper shared packet mode supported. When non-zero,"]
    #[doc = " this parameter indicates that current node can be part of"]
    #[doc = " shared shapers which work in packet mode."]
    pub shaper_shared_packet_mode_supported: ::std::os::raw::c_int,
    #[doc = " Shaper shared byte mode supported. When non-zero,"]
    #[doc = " this parameter indicates that current node can be part of"]
    #[doc = " shared shapers which work in byte mode."]
    pub shaper_shared_byte_mode_supported: ::std::os::raw::c_int,
    pub __bindgen_anon_1: rte_tm_node_capabilities__bindgen_ty_1,
    #[doc = " Mask of statistics counter types supported by the current node."]
    #[doc = " @see enum rte_tm_stats_type"]
    pub stats_mask: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_tm_node_capabilities__bindgen_ty_1 {
    pub nonleaf: rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_1,
    pub leaf: rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_2,
}
#[doc = " Items valid only for non-leaf nodes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Maximum number of children nodes."]
    pub sched_n_children_max: u32,
    #[doc = " Maximum number of supported priority levels. The"]
    #[doc = " value of zero is invalid. The value of 1 indicates"]
    #[doc = " that only priority 0 is supported, which essentially"]
    #[doc = " means that Strict Priority (SP) algorithm is not"]
    #[doc = " supported."]
    pub sched_sp_n_priorities_max: u32,
    #[doc = " Maximum number of sibling nodes that can have the"]
    #[doc = " same priority at any given time, i.e. maximum size"]
    #[doc = " of the WFQ sibling node group. The value of zero"]
    #[doc = " is invalid. The value of 1 indicates that WFQ"]
    #[doc = " algorithm is not supported. The maximum value is"]
    #[doc = " *sched_n_children_max*."]
    pub sched_wfq_n_children_per_group_max: u32,
    #[doc = " Maximum number of priority levels that can have"]
    #[doc = " more than one child node at any given time, i.e."]
    #[doc = " maximum number of WFQ sibling node groups that have"]
    #[doc = " two or more members. The value of zero states that"]
    #[doc = " WFQ algorithm is not supported. The value of 1"]
    #[doc = " indicates that (*sched_sp_n_priorities_max* - 1)"]
    #[doc = " priority levels have at most one child node, so there"]
    #[doc = " can be only one priority level with two or more"]
    #[doc = " sibling nodes making up a WFQ group. The maximum"]
    #[doc = " value is: min(floor(*sched_n_children_max* / 2),"]
    #[doc = " *sched_sp_n_priorities_max*)."]
    pub sched_wfq_n_groups_max: u32,
    #[doc = " Maximum WFQ weight. The value of 1 indicates that"]
    #[doc = " all sibling nodes with same priority have the same"]
    #[doc = " WFQ weight, so WFQ is reduced to FQ."]
    pub sched_wfq_weight_max: u32,
    #[doc = " WFQ packet mode supported. When non-zero, this"]
    #[doc = " parameter indicates that current node supports packet"]
    #[doc = " mode for WFQ among its children. WFQ weights will be"]
    #[doc = " applied against packet count for scheduling children"]
    #[doc = " when configured appropriately."]
    pub sched_wfq_packet_mode_supported: ::std::os::raw::c_int,
    #[doc = " WFQ byte mode supported. When non-zero, this"]
    #[doc = " parameter indicates that current node supports byte"]
    #[doc = " mode for WFQ among its children. WFQ weights will be"]
    #[doc = " applied against  bytes for scheduling children when"]
    #[doc = " configured appropriately."]
    pub sched_wfq_byte_mode_supported: ::std::os::raw::c_int,
}
#[doc = " Items valid only for leaf nodes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " WRED packet mode support for current node."]
    pub cman_wred_packet_mode_supported: ::std::os::raw::c_int,
    #[doc = " WRED byte mode support for current node."]
    pub cman_wred_byte_mode_supported: ::std::os::raw::c_int,
    #[doc = " Head drop algorithm support for current node."]
    pub cman_head_drop_supported: ::std::os::raw::c_int,
    #[doc = " Private WRED context support for current node."]
    pub cman_wred_context_private_supported: ::std::os::raw::c_int,
    #[doc = " Maximum number of shared WRED contexts the current"]
    #[doc = " node can be part of. The value of zero indicates that"]
    #[doc = " shared WRED contexts are not supported by the current"]
    #[doc = " node."]
    pub cman_wred_context_shared_n_max: u32,
}
#[repr(u32)]
#[doc = " Congestion management (CMAN) mode"]
#[doc = ""]
#[doc = " This is used for controlling the admission of packets into a packet queue or"]
#[doc = " group of packet queues on congestion. On request of writing a new packet"]
#[doc = " into the current queue while the queue is full, the *tail drop* algorithm"]
#[doc = " drops the new packet while leaving the queue unmodified, as opposed to *head"]
#[doc = " drop* algorithm, which drops the packet at the head of the queue (the oldest"]
#[doc = " packet waiting in the queue) and admits the new packet at the tail of the"]
#[doc = " queue."]
#[doc = ""]
#[doc = " The *Random Early Detection (RED)* algorithm works by proactively dropping"]
#[doc = " more and more input packets as the queue occupancy builds up. When the queue"]
#[doc = " is full or almost full, RED effectively works as *tail drop*. The *Weighted"]
#[doc = " RED* algorithm uses a separate set of RED thresholds for each packet color."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_tm_cman_mode {
    #[doc = "< Tail drop"]
    RTE_TM_CMAN_TAIL_DROP = 0,
    #[doc = "< Head drop"]
    RTE_TM_CMAN_HEAD_DROP = 1,
    #[doc = "< Weighted Random Early Detection (WRED)"]
    RTE_TM_CMAN_WRED = 2,
}
#[doc = " Random Early Detection (RED) profile"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tm_red_params {
    #[doc = " Minimum queue threshold"]
    pub min_th: u64,
    #[doc = " Maximum queue threshold"]
    pub max_th: u64,
    #[doc = " Inverse of packet marking probability maximum value (maxp), i.e."]
    #[doc = " maxp_inv = 1 / maxp"]
    pub maxp_inv: u16,
    #[doc = " Negated log2 of queue weight (wq), i.e. wq = 1 / (2 ^ wq_log2)"]
    pub wq_log2: u16,
}
#[doc = " Weighted RED (WRED) profile"]
#[doc = ""]
#[doc = " Multiple WRED contexts can share the same WRED profile. Each leaf node with"]
#[doc = " WRED enabled as its congestion management mode has zero or one private WRED"]
#[doc = " context (only one leaf node using it) and/or zero, one or several shared"]
#[doc = " WRED contexts (multiple leaf nodes use the same WRED context). A private"]
#[doc = " WRED context is used to perform congestion management for a single leaf"]
#[doc = " node, while a shared WRED context is used to perform congestion management"]
#[doc = " for a group of leaf nodes."]
#[doc = ""]
#[doc = " @see struct rte_tm_capabilities::cman_wred_packet_mode_supported"]
#[doc = " @see struct rte_tm_capabilities::cman_wred_byte_mode_supported"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tm_wred_params {
    #[doc = " One set of RED parameters per packet color"]
    pub red_params: [rte_tm_red_params; 3usize],
    #[doc = " When non-zero, the *min_th* and *max_th* thresholds are specified"]
    #[doc = " in packets (WRED packet mode). When zero, the *min_th* and *max_th*"]
    #[doc = " thresholds are specified in bytes (WRED byte mode)"]
    pub packet_mode: ::std::os::raw::c_int,
}
#[doc = " Token bucket"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tm_token_bucket {
    #[doc = " Token bucket rate (bytes per second or packets per second)"]
    pub rate: u64,
    #[doc = " Token bucket size (bytes or packets), a.k.a. max burst size"]
    pub size: u64,
}
#[doc = " Shaper (rate limiter) profile"]
#[doc = ""]
#[doc = " Multiple shaper instances can share the same shaper profile. Each node has"]
#[doc = " zero or one private shaper (only one node using it) and/or zero, one or"]
#[doc = " several shared shapers (multiple nodes use the same shaper instance)."]
#[doc = " A private shaper is used to perform traffic shaping for a single node, while"]
#[doc = " a shared shaper is used to perform traffic shaping for a group of nodes."]
#[doc = ""]
#[doc = " Single rate shapers use a single token bucket. A single rate shaper can be"]
#[doc = " configured by setting the rate of the committed bucket to zero, which"]
#[doc = " effectively disables this bucket. The peak bucket is used to limit the rate"]
#[doc = " and the burst size for the current shaper."]
#[doc = ""]
#[doc = " Dual rate shapers use both the committed and the peak token buckets. The"]
#[doc = " rate of the peak bucket has to be bigger than zero, as well as greater than"]
#[doc = " or equal to the rate of the committed bucket."]
#[doc = ""]
#[doc = " @see struct rte_tm_capabilities::shaper_private_packet_mode_supported"]
#[doc = " @see struct rte_tm_capabilities::shaper_private_byte_mode_supported"]
#[doc = " @see struct rte_tm_capabilities::shaper_shared_packet_mode_supported"]
#[doc = " @see struct rte_tm_capabilities::shaper_shared_byte_mode_supported"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tm_shaper_params {
    #[doc = " Committed token bucket"]
    pub committed: rte_tm_token_bucket,
    #[doc = " Peak token bucket"]
    pub peak: rte_tm_token_bucket,
    #[doc = " Signed value to be added to the length of each packet for the"]
    #[doc = " purpose of shaping. Can be used to correct the packet length with"]
    #[doc = " the framing overhead bytes that are also consumed on the wire (e.g."]
    #[doc = " RTE_TM_ETH_FRAMING_OVERHEAD_FCS)."]
    #[doc = " This field is ignored when the profile enables packet mode."]
    pub pkt_length_adjust: i32,
    #[doc = " When zero, the byte mode is enabled for the current profile, so the"]
    #[doc = " *rate* and *size* fields in both the committed and peak token buckets"]
    #[doc = " are specified in bytes per second and bytes, respectively."]
    #[doc = " When non-zero, the packet mode is enabled for the current profile,"]
    #[doc = " so the *rate* and *size* fields in both the committed and peak token"]
    #[doc = " buckets are specified in packets per second and packets,"]
    #[doc = " respectively."]
    pub packet_mode: ::std::os::raw::c_int,
}
#[doc = " Node parameters"]
#[doc = ""]
#[doc = " Each non-leaf node has multiple inputs (its children nodes) and single output"]
#[doc = " (which is input to its parent node). It arbitrates its inputs using Strict"]
#[doc = " Priority (SP) and Weighted Fair Queuing (WFQ) algorithms to schedule input"]
#[doc = " packets to its output while observing its shaping (rate limiting)"]
#[doc = " constraints."]
#[doc = ""]
#[doc = " Algorithms such as Weighted Round Robin (WRR), Byte-level WRR, Deficit WRR"]
#[doc = " (DWRR), etc. are considered approximations of the WFQ ideal and are"]
#[doc = " assimilated to WFQ, although an associated implementation-dependent trade-off"]
#[doc = " on accuracy, performance and resource usage might exist."]
#[doc = ""]
#[doc = " Children nodes with different priorities are scheduled using the SP algorithm"]
#[doc = " based on their priority, with zero (0) as the highest priority. Children with"]
#[doc = " the same priority are scheduled using the WFQ algorithm according to their"]
#[doc = " weights. The WFQ weight of a given child node is relative to the sum of the"]
#[doc = " weights of all its sibling nodes that have the same priority, with one (1) as"]
#[doc = " the lowest weight. For each SP priority, the WFQ weight mode can be set as"]
#[doc = " either byte-based or packet-based."]
#[doc = ""]
#[doc = " Each leaf node sits on top of a Tx queue of the current Ethernet port. Hence,"]
#[doc = " the leaf nodes are predefined, with their node IDs set to 0 .. (N-1), where N"]
#[doc = " is the number of Tx queues configured for the current Ethernet port. The"]
#[doc = " non-leaf nodes have their IDs generated by the application."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_tm_node_params {
    #[doc = " Shaper profile for the private shaper. The absence of the private"]
    #[doc = " shaper for the current node is indicated by setting this parameter"]
    #[doc = " to RTE_TM_SHAPER_PROFILE_ID_NONE."]
    pub shaper_profile_id: u32,
    #[doc = " User allocated array of valid shared shaper IDs."]
    pub shared_shaper_id: *mut u32,
    #[doc = " Number of shared shaper IDs in the *shared_shaper_id* array."]
    pub n_shared_shapers: u32,
    pub __bindgen_anon_1: rte_tm_node_params__bindgen_ty_1,
    #[doc = " Mask of statistics counter types to be enabled for this node. This"]
    #[doc = " needs to be a subset of the statistics counter types available for"]
    #[doc = " the current node. Any statistics counter type not included in this"]
    #[doc = " set is to be disabled for the current node."]
    #[doc = " @see enum rte_tm_stats_type"]
    pub stats_mask: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_tm_node_params__bindgen_ty_1 {
    pub nonleaf: rte_tm_node_params__bindgen_ty_1__bindgen_ty_1,
    pub leaf: rte_tm_node_params__bindgen_ty_1__bindgen_ty_2,
}
#[doc = " Parameters only valid for non-leaf nodes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tm_node_params__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " WFQ weight mode for each SP priority. When NULL, it"]
    #[doc = " indicates that WFQ is to be used for all priorities."]
    #[doc = " When non-NULL, it points to a pre-allocated array of"]
    #[doc = " *n_sp_priorities* values, with non-zero value for"]
    #[doc = " byte-mode and zero for packet-mode."]
    #[doc = " @see struct rte_tm_node_capabilities::sched_wfq_packet_mode_supported"]
    #[doc = " @see struct rte_tm_node_capabilities::sched_wfq_byte_mode_supported"]
    pub wfq_weight_mode: *mut ::std::os::raw::c_int,
    #[doc = " Number of SP priorities."]
    pub n_sp_priorities: u32,
}
#[doc = " Parameters only valid for leaf nodes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tm_node_params__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " Congestion management mode"]
    pub cman: rte_tm_cman_mode,
    pub wred: rte_tm_node_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[doc = " WRED parameters (only valid when *cman* is set to"]
#[doc = " WRED)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tm_node_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[doc = " WRED profile for private WRED context. The"]
    #[doc = " absence of a private WRED context for the"]
    #[doc = " current leaf node is indicated by value"]
    #[doc = " RTE_TM_WRED_PROFILE_ID_NONE."]
    pub wred_profile_id: u32,
    #[doc = " User allocated array of shared WRED context"]
    #[doc = " IDs. When set to NULL, it indicates that the"]
    #[doc = " current leaf node should not currently be"]
    #[doc = " part of any shared WRED contexts."]
    pub shared_wred_context_id: *mut u32,
    #[doc = " Number of elements in the"]
    #[doc = " *shared_wred_context_id* array. Only valid"]
    #[doc = " when *shared_wred_context_id* is non-NULL,"]
    #[doc = " in which case it should be non-zero."]
    pub n_shared_wred_contexts: u32,
}
#[repr(u32)]
#[doc = " Verbose error types."]
#[doc = ""]
#[doc = " Most of them provide the type of the object referenced by struct"]
#[doc = " rte_tm_error::cause."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_tm_error_type {
    #[doc = "< No error."]
    RTE_TM_ERROR_TYPE_NONE = 0,
    #[doc = "< Cause unspecified."]
    RTE_TM_ERROR_TYPE_UNSPECIFIED = 1,
    RTE_TM_ERROR_TYPE_CAPABILITIES = 2,
    RTE_TM_ERROR_TYPE_LEVEL_ID = 3,
    RTE_TM_ERROR_TYPE_WRED_PROFILE = 4,
    RTE_TM_ERROR_TYPE_WRED_PROFILE_GREEN = 5,
    RTE_TM_ERROR_TYPE_WRED_PROFILE_YELLOW = 6,
    RTE_TM_ERROR_TYPE_WRED_PROFILE_RED = 7,
    RTE_TM_ERROR_TYPE_WRED_PROFILE_ID = 8,
    RTE_TM_ERROR_TYPE_SHARED_WRED_CONTEXT_ID = 9,
    RTE_TM_ERROR_TYPE_SHAPER_PROFILE = 10,
    RTE_TM_ERROR_TYPE_SHAPER_PROFILE_COMMITTED_RATE = 11,
    RTE_TM_ERROR_TYPE_SHAPER_PROFILE_COMMITTED_SIZE = 12,
    RTE_TM_ERROR_TYPE_SHAPER_PROFILE_PEAK_RATE = 13,
    RTE_TM_ERROR_TYPE_SHAPER_PROFILE_PEAK_SIZE = 14,
    RTE_TM_ERROR_TYPE_SHAPER_PROFILE_PKT_ADJUST_LEN = 15,
    RTE_TM_ERROR_TYPE_SHAPER_PROFILE_PACKET_MODE = 16,
    RTE_TM_ERROR_TYPE_SHAPER_PROFILE_ID = 17,
    RTE_TM_ERROR_TYPE_SHARED_SHAPER_ID = 18,
    RTE_TM_ERROR_TYPE_NODE_PARENT_NODE_ID = 19,
    RTE_TM_ERROR_TYPE_NODE_PRIORITY = 20,
    RTE_TM_ERROR_TYPE_NODE_WEIGHT = 21,
    RTE_TM_ERROR_TYPE_NODE_PARAMS = 22,
    RTE_TM_ERROR_TYPE_NODE_PARAMS_SHAPER_PROFILE_ID = 23,
    RTE_TM_ERROR_TYPE_NODE_PARAMS_SHARED_SHAPER_ID = 24,
    RTE_TM_ERROR_TYPE_NODE_PARAMS_N_SHARED_SHAPERS = 25,
    RTE_TM_ERROR_TYPE_NODE_PARAMS_WFQ_WEIGHT_MODE = 26,
    RTE_TM_ERROR_TYPE_NODE_PARAMS_N_SP_PRIORITIES = 27,
    RTE_TM_ERROR_TYPE_NODE_PARAMS_CMAN = 28,
    RTE_TM_ERROR_TYPE_NODE_PARAMS_WRED_PROFILE_ID = 29,
    RTE_TM_ERROR_TYPE_NODE_PARAMS_SHARED_WRED_CONTEXT_ID = 30,
    RTE_TM_ERROR_TYPE_NODE_PARAMS_N_SHARED_WRED_CONTEXTS = 31,
    RTE_TM_ERROR_TYPE_NODE_PARAMS_STATS = 32,
    RTE_TM_ERROR_TYPE_NODE_ID = 33,
}
#[doc = " Verbose error structure definition."]
#[doc = ""]
#[doc = " This object is normally allocated by applications and set by PMDs, the"]
#[doc = " message points to a constant string which does not need to be freed by"]
#[doc = " the application, however its pointer can be considered valid only as long"]
#[doc = " as its associated DPDK port remains configured. Closing the underlying"]
#[doc = " device or unloading the PMD invalidates it."]
#[doc = ""]
#[doc = " Both cause and message may be NULL regardless of the error type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tm_error {
    #[doc = "< Cause field and error type."]
    pub type_: rte_tm_error_type,
    #[doc = "< Object responsible for the error."]
    pub cause: *const ::std::os::raw::c_void,
    #[doc = "< Human-readable error message."]
    pub message: *const ::std::os::raw::c_char,
}
extern "C" {
    #[doc = " Traffic manager get number of leaf nodes"]
    #[doc = ""]
    #[doc = " Each leaf node sits on top of a Tx queue of the current Ethernet port."]
    #[doc = " Therefore, the set of leaf nodes is predefined, their number is always equal"]
    #[doc = " to N (where N is the number of Tx queues configured for the current port)"]
    #[doc = " and their IDs are 0 .. (N-1)."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[out] n_leaf_nodes"]
    #[doc = "   Number of leaf nodes for the current port."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    pub fn rte_tm_get_number_of_leaf_nodes(
        port_id: u16,
        n_leaf_nodes: *mut u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager node ID validate and type (i.e. leaf or non-leaf) get"]
    #[doc = ""]
    #[doc = " The leaf nodes have predefined IDs in the range of 0 .. (N-1), where N is"]
    #[doc = " the number of Tx queues of the current Ethernet port. The non-leaf nodes"]
    #[doc = " have their IDs generated by the application outside of the above range,"]
    #[doc = " which is reserved for leaf nodes."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] node_id"]
    #[doc = "   Node ID value. Needs to be valid."]
    #[doc = " @param[out] is_leaf"]
    #[doc = "   Set to non-zero value when node is leaf and to zero otherwise (non-leaf)."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    pub fn rte_tm_node_type_get(
        port_id: u16,
        node_id: u32,
        is_leaf: *mut ::std::os::raw::c_int,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager capabilities get"]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[out] cap"]
    #[doc = "   Traffic manager capabilities. Needs to be pre-allocated and valid."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    pub fn rte_tm_capabilities_get(
        port_id: u16,
        cap: *mut rte_tm_capabilities,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager level capabilities get"]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] level_id"]
    #[doc = "   The hierarchy level identifier. The value of 0 identifies the level of the"]
    #[doc = "   root node."]
    #[doc = " @param[out] cap"]
    #[doc = "   Traffic manager level capabilities. Needs to be pre-allocated and valid."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    pub fn rte_tm_level_capabilities_get(
        port_id: u16,
        level_id: u32,
        cap: *mut rte_tm_level_capabilities,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager node capabilities get"]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] node_id"]
    #[doc = "   Node ID. Needs to be valid."]
    #[doc = " @param[out] cap"]
    #[doc = "   Traffic manager node capabilities. Needs to be pre-allocated and valid."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    pub fn rte_tm_node_capabilities_get(
        port_id: u16,
        node_id: u32,
        cap: *mut rte_tm_node_capabilities,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager WRED profile add"]
    #[doc = ""]
    #[doc = " Create a new WRED profile with ID set to *wred_profile_id*. The new profile"]
    #[doc = " is used to create one or several WRED contexts."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] wred_profile_id"]
    #[doc = "   WRED profile ID for the new profile. Needs to be unused."]
    #[doc = " @param[in] profile"]
    #[doc = "   WRED profile parameters. Needs to be pre-allocated and valid."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see struct rte_tm_capabilities::cman_wred_context_n_max"]
    pub fn rte_tm_wred_profile_add(
        port_id: u16,
        wred_profile_id: u32,
        profile: *mut rte_tm_wred_params,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager WRED profile delete"]
    #[doc = ""]
    #[doc = " Delete an existing WRED profile. This operation fails when there is"]
    #[doc = " currently at least one user (i.e. WRED context) of this WRED profile."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] wred_profile_id"]
    #[doc = "   WRED profile ID. Needs to be the valid."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see struct rte_tm_capabilities::cman_wred_context_n_max"]
    pub fn rte_tm_wred_profile_delete(
        port_id: u16,
        wred_profile_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager shared WRED context add or update"]
    #[doc = ""]
    #[doc = " When *shared_wred_context_id* is invalid, a new WRED context with this ID is"]
    #[doc = " created by using the WRED profile identified by *wred_profile_id*."]
    #[doc = ""]
    #[doc = " When *shared_wred_context_id* is valid, this WRED context is no longer using"]
    #[doc = " the profile previously assigned to it and is updated to use the profile"]
    #[doc = " identified by *wred_profile_id*."]
    #[doc = ""]
    #[doc = " A valid shared WRED context can be assigned to several hierarchy leaf nodes"]
    #[doc = " configured to use WRED as the congestion management mode."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] shared_wred_context_id"]
    #[doc = "   Shared WRED context ID"]
    #[doc = " @param[in] wred_profile_id"]
    #[doc = "   WRED profile ID. Needs to be the valid."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see struct rte_tm_capabilities::cman_wred_context_shared_n_max"]
    pub fn rte_tm_shared_wred_context_add_update(
        port_id: u16,
        shared_wred_context_id: u32,
        wred_profile_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager shared WRED context delete"]
    #[doc = ""]
    #[doc = " Delete an existing shared WRED context. This operation fails when there is"]
    #[doc = " currently at least one user (i.e. hierarchy leaf node) of this shared WRED"]
    #[doc = " context."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] shared_wred_context_id"]
    #[doc = "   Shared WRED context ID. Needs to be the valid."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see struct rte_tm_capabilities::cman_wred_context_shared_n_max"]
    pub fn rte_tm_shared_wred_context_delete(
        port_id: u16,
        shared_wred_context_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager shaper profile add"]
    #[doc = ""]
    #[doc = " Create a new shaper profile with ID set to *shaper_profile_id*. The new"]
    #[doc = " shaper profile is used to create one or several shapers."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] shaper_profile_id"]
    #[doc = "   Shaper profile ID for the new profile. Needs to be unused."]
    #[doc = " @param[in] profile"]
    #[doc = "   Shaper profile parameters. Needs to be pre-allocated and valid."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see struct rte_tm_capabilities::shaper_n_max"]
    pub fn rte_tm_shaper_profile_add(
        port_id: u16,
        shaper_profile_id: u32,
        profile: *mut rte_tm_shaper_params,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager shaper profile delete"]
    #[doc = ""]
    #[doc = " Delete an existing shaper profile. This operation fails when there is"]
    #[doc = " currently at least one user (i.e. shaper) of this shaper profile."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] shaper_profile_id"]
    #[doc = "   Shaper profile ID. Needs to be the valid."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see struct rte_tm_capabilities::shaper_n_max"]
    pub fn rte_tm_shaper_profile_delete(
        port_id: u16,
        shaper_profile_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager shared shaper add or update"]
    #[doc = ""]
    #[doc = " When *shared_shaper_id* is not a valid shared shaper ID, a new shared shaper"]
    #[doc = " with this ID is created using the shaper profile identified by"]
    #[doc = " *shaper_profile_id*."]
    #[doc = ""]
    #[doc = " When *shared_shaper_id* is a valid shared shaper ID, this shared shaper is"]
    #[doc = " no longer using the shaper profile previously assigned to it and is updated"]
    #[doc = " to use the shaper profile identified by *shaper_profile_id*."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] shared_shaper_id"]
    #[doc = "   Shared shaper ID"]
    #[doc = " @param[in] shaper_profile_id"]
    #[doc = "   Shaper profile ID. Needs to be the valid."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see struct rte_tm_capabilities::shaper_shared_n_max"]
    pub fn rte_tm_shared_shaper_add_update(
        port_id: u16,
        shared_shaper_id: u32,
        shaper_profile_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager shared shaper delete"]
    #[doc = ""]
    #[doc = " Delete an existing shared shaper. This operation fails when there is"]
    #[doc = " currently at least one user (i.e. hierarchy node) of this shared shaper."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] shared_shaper_id"]
    #[doc = "   Shared shaper ID. Needs to be the valid."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see struct rte_tm_capabilities::shaper_shared_n_max"]
    pub fn rte_tm_shared_shaper_delete(
        port_id: u16,
        shared_shaper_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager node add"]
    #[doc = ""]
    #[doc = " Create new node and connect it as child of an existing node. The new node is"]
    #[doc = " further identified by *node_id*, which needs to be unused by any of the"]
    #[doc = " existing nodes. The parent node is identified by *parent_node_id*, which"]
    #[doc = " needs to be the valid ID of an existing non-leaf node. The parent node is"]
    #[doc = " going to use the provided SP *priority* and WFQ *weight* to schedule its new"]
    #[doc = " child node."]
    #[doc = ""]
    #[doc = " This function has to be called for both leaf and non-leaf nodes. In the case"]
    #[doc = " of leaf nodes (i.e. *node_id* is within the range of 0 .. (N-1), with N as"]
    #[doc = " the number of configured Tx queues of the current port), the leaf node is"]
    #[doc = " configured rather than created (as the set of leaf nodes is predefined) and"]
    #[doc = " it is also connected as child of an existing node."]
    #[doc = ""]
    #[doc = " The first node that is added becomes the root node and all the nodes that"]
    #[doc = " are subsequently added have to be added as descendants of the root node. The"]
    #[doc = " parent of the root node has to be specified as RTE_TM_NODE_ID_NULL and there"]
    #[doc = " can only be one node with this parent ID (i.e. the root node). Further"]
    #[doc = " restrictions for root node: needs to be non-leaf, its private shaper profile"]
    #[doc = " needs to be valid and single rate, cannot use any shared shapers."]
    #[doc = ""]
    #[doc = " When called before rte_tm_hierarchy_commit() invocation, this function is"]
    #[doc = " typically used to define the initial start-up hierarchy for the port."]
    #[doc = " Provided that dynamic hierarchy updates are supported by the current port (as"]
    #[doc = " advertised in the port capability set), this function can be also called"]
    #[doc = " after the rte_tm_hierarchy_commit() invocation."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] node_id"]
    #[doc = "   Node ID. Needs to be unused by any of the existing nodes."]
    #[doc = " @param[in] parent_node_id"]
    #[doc = "   Parent node ID. Needs to be the valid."]
    #[doc = " @param[in] priority"]
    #[doc = "   Node priority. The highest node priority is zero. Used by the SP algorithm"]
    #[doc = "   running on the parent of the current node for scheduling this child node."]
    #[doc = " @param[in] weight"]
    #[doc = "   Node weight. The node weight is relative to the weight sum of all siblings"]
    #[doc = "   that have the same priority. The lowest weight is one. Used by the WFQ"]
    #[doc = "   algorithm running on the parent of the current node for scheduling this"]
    #[doc = "   child node."]
    #[doc = " @param[in] level_id"]
    #[doc = "   Level ID that should be met by this node. The hierarchy level of the"]
    #[doc = "   current node is already fully specified through its parent node (i.e. the"]
    #[doc = "   level of this node is equal to the level of its parent node plus one),"]
    #[doc = "   therefore the reason for providing this parameter is to enable the"]
    #[doc = "   application to perform step-by-step checking of the node level during"]
    #[doc = "   successive invocations of this function. When not desired, this check can"]
    #[doc = "   be disabled by assigning value RTE_TM_NODE_LEVEL_ID_ANY to this parameter."]
    #[doc = " @param[in] params"]
    #[doc = "   Node parameters. Needs to be pre-allocated and valid."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see rte_tm_hierarchy_commit()"]
    #[doc = " @see RTE_TM_UPDATE_NODE_ADD_DELETE"]
    #[doc = " @see RTE_TM_NODE_LEVEL_ID_ANY"]
    #[doc = " @see struct rte_tm_capabilities"]
    pub fn rte_tm_node_add(
        port_id: u16,
        node_id: u32,
        parent_node_id: u32,
        priority: u32,
        weight: u32,
        level_id: u32,
        params: *mut rte_tm_node_params,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager node delete"]
    #[doc = ""]
    #[doc = " Delete an existing node. This operation fails when this node currently has"]
    #[doc = " at least one user (i.e. child node)."]
    #[doc = ""]
    #[doc = " When called before rte_tm_hierarchy_commit() invocation, this function is"]
    #[doc = " typically used to define the initial start-up hierarchy for the port."]
    #[doc = " Provided that dynamic hierarchy updates are supported by the current port (as"]
    #[doc = " advertised in the port capability set), this function can be also called"]
    #[doc = " after the rte_tm_hierarchy_commit() invocation."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] node_id"]
    #[doc = "   Node ID. Needs to be valid."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see RTE_TM_UPDATE_NODE_ADD_DELETE"]
    pub fn rte_tm_node_delete(
        port_id: u16,
        node_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager node suspend"]
    #[doc = ""]
    #[doc = " Suspend an existing node. While the node is in suspended state, no packet is"]
    #[doc = " scheduled from this node and its descendants. The node exits the suspended"]
    #[doc = " state through the node resume operation."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] node_id"]
    #[doc = "   Node ID. Needs to be valid."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see rte_tm_node_resume()"]
    #[doc = " @see RTE_TM_UPDATE_NODE_SUSPEND_RESUME"]
    pub fn rte_tm_node_suspend(
        port_id: u16,
        node_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager node resume"]
    #[doc = ""]
    #[doc = " Resume an existing node that is currently in suspended state. The node"]
    #[doc = " entered the suspended state as result of a previous node suspend operation."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] node_id"]
    #[doc = "   Node ID. Needs to be valid."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see rte_tm_node_suspend()"]
    #[doc = " @see RTE_TM_UPDATE_NODE_SUSPEND_RESUME"]
    pub fn rte_tm_node_resume(
        port_id: u16,
        node_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager hierarchy commit"]
    #[doc = ""]
    #[doc = " This function is called during the port initialization phase (before the"]
    #[doc = " Ethernet port is started) to freeze the start-up hierarchy."]
    #[doc = ""]
    #[doc = " This function typically performs the following steps:"]
    #[doc = "    a) It validates the start-up hierarchy that was previously defined for the"]
    #[doc = "       current port through successive rte_tm_node_add() invocations;"]
    #[doc = "    b) Assuming successful validation, it performs all the necessary port"]
    #[doc = "       specific configuration operations to install the specified hierarchy on"]
    #[doc = "       the current port, with immediate effect once the port is started."]
    #[doc = ""]
    #[doc = " This function fails when the currently configured hierarchy is not supported"]
    #[doc = " by the Ethernet port, in which case the user can abort or try out another"]
    #[doc = " hierarchy configuration (e.g. a hierarchy with less leaf nodes), which can be"]
    #[doc = " build from scratch (when *clear_on_fail* is enabled) or by modifying the"]
    #[doc = " existing hierarchy configuration (when *clear_on_fail* is disabled)."]
    #[doc = ""]
    #[doc = " Note that this function can still fail due to other causes (e.g. not enough"]
    #[doc = " memory available in the system, etc), even though the specified hierarchy is"]
    #[doc = " supported in principle by the current port."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] clear_on_fail"]
    #[doc = "   On function call failure, hierarchy is cleared when this parameter is"]
    #[doc = "   non-zero and preserved when this parameter is equal to zero."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see rte_tm_node_add()"]
    #[doc = " @see rte_tm_node_delete()"]
    pub fn rte_tm_hierarchy_commit(
        port_id: u16,
        clear_on_fail: ::std::os::raw::c_int,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager node parent update"]
    #[doc = ""]
    #[doc = " This function may be used to move a node and its children to a different"]
    #[doc = " parent.  Additionally, if the new parent is the same as the current parent,"]
    #[doc = " this function will update the priority/weight of an existing node."]
    #[doc = ""]
    #[doc = " Restriction for root node: its parent cannot be changed."]
    #[doc = ""]
    #[doc = " This function can only be called after the rte_tm_hierarchy_commit()"]
    #[doc = " invocation. Its success depends on the port support for this operation, as"]
    #[doc = " advertised through the port capability set."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] node_id"]
    #[doc = "   Node ID. Needs to be valid."]
    #[doc = " @param[in] parent_node_id"]
    #[doc = "   Node ID for the new parent. Needs to be valid."]
    #[doc = " @param[in] priority"]
    #[doc = "   Node priority. The highest node priority is zero. Used by the SP algorithm"]
    #[doc = "   running on the parent of the current node for scheduling this child node."]
    #[doc = " @param[in] weight"]
    #[doc = "   Node weight. The node weight is relative to the weight sum of all siblings"]
    #[doc = "   that have the same priority. The lowest weight is zero. Used by the WFQ"]
    #[doc = "   algorithm running on the parent of the current node for scheduling this"]
    #[doc = "   child node."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see RTE_TM_UPDATE_NODE_PARENT_KEEP_LEVEL"]
    #[doc = " @see RTE_TM_UPDATE_NODE_PARENT_CHANGE_LEVEL"]
    pub fn rte_tm_node_parent_update(
        port_id: u16,
        node_id: u32,
        parent_node_id: u32,
        priority: u32,
        weight: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager node private shaper update"]
    #[doc = ""]
    #[doc = " Restriction for the root node: its private shaper profile needs to be valid"]
    #[doc = " and single rate."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] node_id"]
    #[doc = "   Node ID. Needs to be valid."]
    #[doc = " @param[in] shaper_profile_id"]
    #[doc = "   Shaper profile ID for the private shaper of the current node. Needs to be"]
    #[doc = "   either valid shaper profile ID or RTE_TM_SHAPER_PROFILE_ID_NONE, with"]
    #[doc = "   the latter disabling the private shaper of the current node."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see struct rte_tm_capabilities::shaper_private_n_max"]
    pub fn rte_tm_node_shaper_update(
        port_id: u16,
        node_id: u32,
        shaper_profile_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager node shared shapers update"]
    #[doc = ""]
    #[doc = " Restriction for root node: cannot use any shared rate shapers."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] node_id"]
    #[doc = "   Node ID. Needs to be valid."]
    #[doc = " @param[in] shared_shaper_id"]
    #[doc = "   Shared shaper ID. Needs to be valid."]
    #[doc = " @param[in] add"]
    #[doc = "   Set to non-zero value to add this shared shaper to current node or to zero"]
    #[doc = "   to delete this shared shaper from current node."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see struct rte_tm_capabilities::shaper_shared_n_max"]
    pub fn rte_tm_node_shared_shaper_update(
        port_id: u16,
        node_id: u32,
        shared_shaper_id: u32,
        add: ::std::os::raw::c_int,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager node enabled statistics counters update"]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] node_id"]
    #[doc = "   Node ID. Needs to be valid."]
    #[doc = " @param[in] stats_mask"]
    #[doc = "   Mask of statistics counter types to be enabled for the current node. This"]
    #[doc = "   needs to be a subset of the statistics counter types available for the"]
    #[doc = "   current node. Any statistics counter type not included in this set is to"]
    #[doc = "   be disabled for the current node."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see enum rte_tm_stats_type"]
    #[doc = " @see RTE_TM_UPDATE_NODE_STATS"]
    pub fn rte_tm_node_stats_update(
        port_id: u16,
        node_id: u32,
        stats_mask: u64,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager node WFQ weight mode update"]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] node_id"]
    #[doc = "   Node ID. Needs to be valid non-leaf node ID."]
    #[doc = " @param[in] wfq_weight_mode"]
    #[doc = "   WFQ weight mode for each SP priority. When NULL, it indicates that WFQ is"]
    #[doc = "   to be used for all priorities. When non-NULL, it points to a pre-allocated"]
    #[doc = "   array of *n_sp_priorities* values, with non-zero value for byte-mode and"]
    #[doc = "   zero for packet-mode."]
    #[doc = " @param[in] n_sp_priorities"]
    #[doc = "   Number of SP priorities."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see RTE_TM_UPDATE_NODE_WFQ_WEIGHT_MODE"]
    #[doc = " @see RTE_TM_UPDATE_NODE_N_SP_PRIORITIES"]
    pub fn rte_tm_node_wfq_weight_mode_update(
        port_id: u16,
        node_id: u32,
        wfq_weight_mode: *mut ::std::os::raw::c_int,
        n_sp_priorities: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager node congestion management mode update"]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] node_id"]
    #[doc = "   Node ID. Needs to be valid leaf node ID."]
    #[doc = " @param[in] cman"]
    #[doc = "   Congestion management mode."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see RTE_TM_UPDATE_NODE_CMAN"]
    pub fn rte_tm_node_cman_update(
        port_id: u16,
        node_id: u32,
        cman: rte_tm_cman_mode,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager node private WRED context update"]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] node_id"]
    #[doc = "   Node ID. Needs to be valid leaf node ID."]
    #[doc = " @param[in] wred_profile_id"]
    #[doc = "   WRED profile ID for the private WRED context of the current node. Needs to"]
    #[doc = "   be either valid WRED profile ID or RTE_TM_WRED_PROFILE_ID_NONE, with the"]
    #[doc = "   latter disabling the private WRED context of the current node."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see struct rte_tm_capabilities::cman_wred_context_private_n_max"]
    pub fn rte_tm_node_wred_context_update(
        port_id: u16,
        node_id: u32,
        wred_profile_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager node shared WRED context update"]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] node_id"]
    #[doc = "   Node ID. Needs to be valid leaf node ID."]
    #[doc = " @param[in] shared_wred_context_id"]
    #[doc = "   Shared WRED context ID. Needs to be valid."]
    #[doc = " @param[in] add"]
    #[doc = "   Set to non-zero value to add this shared WRED context to current node or"]
    #[doc = "   to zero to delete this shared WRED context from current node."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see struct rte_tm_capabilities::cman_wred_context_shared_n_max"]
    pub fn rte_tm_node_shared_wred_context_update(
        port_id: u16,
        node_id: u32,
        shared_wred_context_id: u32,
        add: ::std::os::raw::c_int,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager node statistics counters read"]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] node_id"]
    #[doc = "   Node ID. Needs to be valid."]
    #[doc = " @param[out] stats"]
    #[doc = "   When non-NULL, it contains the current value for the statistics counters"]
    #[doc = "   enabled for the current node."]
    #[doc = " @param[out] stats_mask"]
    #[doc = "   When non-NULL, it contains the mask of statistics counter types that are"]
    #[doc = "   currently enabled for this node, indicating which of the counters"]
    #[doc = "   retrieved with the *stats* structure are valid."]
    #[doc = " @param[in] clear"]
    #[doc = "   When this parameter has a non-zero value, the statistics counters are"]
    #[doc = "   cleared (i.e. set to zero) immediately after they have been read,"]
    #[doc = "   otherwise the statistics counters are left untouched."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see enum rte_tm_stats_type"]
    pub fn rte_tm_node_stats_read(
        port_id: u16,
        node_id: u32,
        stats: *mut rte_tm_node_stats,
        stats_mask: *mut u64,
        clear: ::std::os::raw::c_int,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager packet marking - VLAN DEI (IEEE 802.1Q)"]
    #[doc = ""]
    #[doc = " IEEE 802.1p maps the traffic class to the VLAN Priority Code Point (PCP)"]
    #[doc = " field (3 bits), while IEEE 802.1q maps the drop priority to the VLAN Drop"]
    #[doc = " Eligible Indicator (DEI) field (1 bit), which was previously named Canonical"]
    #[doc = " Format Indicator (CFI)."]
    #[doc = ""]
    #[doc = " All VLAN frames of a given color get their DEI bit set if marking is enabled"]
    #[doc = " for this color; otherwise, their DEI bit is left as is (either set or not)."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] mark_green"]
    #[doc = "   Set to non-zero value to enable marking of green packets and to zero to"]
    #[doc = "   disable it."]
    #[doc = " @param[in] mark_yellow"]
    #[doc = "   Set to non-zero value to enable marking of yellow packets and to zero to"]
    #[doc = "   disable it."]
    #[doc = " @param[in] mark_red"]
    #[doc = "   Set to non-zero value to enable marking of red packets and to zero to"]
    #[doc = "   disable it."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see struct rte_tm_capabilities::mark_vlan_dei_supported"]
    pub fn rte_tm_mark_vlan_dei(
        port_id: u16,
        mark_green: ::std::os::raw::c_int,
        mark_yellow: ::std::os::raw::c_int,
        mark_red: ::std::os::raw::c_int,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager packet marking - IPv4 / IPv6 ECN (IETF RFC 3168)"]
    #[doc = ""]
    #[doc = " IETF RFCs 2474 and 3168 reorganize the IPv4 Type of Service (TOS) field"]
    #[doc = " (8 bits) and the IPv6 Traffic Class (TC) field (8 bits) into Differentiated"]
    #[doc = " Services Codepoint (DSCP) field (6 bits) and Explicit Congestion"]
    #[doc = " Notification (ECN) field (2 bits). The DSCP field is typically used to"]
    #[doc = " encode the traffic class and/or drop priority (RFC 2597), while the ECN"]
    #[doc = " field is used by RFC 3168 to implement a congestion notification mechanism"]
    #[doc = " to be leveraged by transport layer protocols such as TCP and SCTP that have"]
    #[doc = " congestion control mechanisms."]
    #[doc = ""]
    #[doc = " When congestion is experienced, as alternative to dropping the packet,"]
    #[doc = " routers can change the ECN field of input packets from 2'b01 or 2'b10"]
    #[doc = " (values indicating that source endpoint is ECN-capable) to 2'b11 (meaning"]
    #[doc = " that congestion is experienced). The destination endpoint can use the"]
    #[doc = " ECN-Echo (ECE) TCP flag to relay the congestion indication back to the"]
    #[doc = " source endpoint, which acknowledges it back to the destination endpoint with"]
    #[doc = " the Congestion Window Reduced (CWR) TCP flag."]
    #[doc = ""]
    #[doc = " All IPv4/IPv6 packets of a given color with ECN set to 2b01 or 2b10"]
    #[doc = " carrying TCP or SCTP have their ECN set to 2b11 if the marking feature is"]
    #[doc = " enabled for the current color, otherwise the ECN field is left as is."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] mark_green"]
    #[doc = "   Set to non-zero value to enable marking of green packets and to zero to"]
    #[doc = "   disable it."]
    #[doc = " @param[in] mark_yellow"]
    #[doc = "   Set to non-zero value to enable marking of yellow packets and to zero to"]
    #[doc = "   disable it."]
    #[doc = " @param[in] mark_red"]
    #[doc = "   Set to non-zero value to enable marking of red packets and to zero to"]
    #[doc = "   disable it."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see struct rte_tm_capabilities::mark_ip_ecn_tcp_supported"]
    #[doc = " @see struct rte_tm_capabilities::mark_ip_ecn_sctp_supported"]
    pub fn rte_tm_mark_ip_ecn(
        port_id: u16,
        mark_green: ::std::os::raw::c_int,
        mark_yellow: ::std::os::raw::c_int,
        mark_red: ::std::os::raw::c_int,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traffic manager packet marking - IPv4 / IPv6 DSCP (IETF RFC 2597)"]
    #[doc = ""]
    #[doc = " IETF RFC 2597 maps the traffic class and the drop priority to the IPv4/IPv6"]
    #[doc = " Differentiated Services Codepoint (DSCP) field (6 bits). Here are the DSCP"]
    #[doc = " values proposed by this RFC:"]
    #[doc = ""]
    #[doc = " <pre>                   Class 1    Class 2    Class 3    Class 4   </pre>"]
    #[doc = " <pre>                 +----------+----------+----------+----------+</pre>"]
    #[doc = " <pre>Low Drop Prec    |  001010  |  010010  |  011010  |  100010  |</pre>"]
    #[doc = " <pre>Medium Drop Prec |  001100  |  010100  |  011100  |  100100  |</pre>"]
    #[doc = " <pre>High Drop Prec   |  001110  |  010110  |  011110  |  100110  |</pre>"]
    #[doc = " <pre>                 +----------+----------+----------+----------+</pre>"]
    #[doc = ""]
    #[doc = " There are 4 traffic classes (classes 1 .. 4) encoded by DSCP bits 1 and 2,"]
    #[doc = " as well as 3 drop priorities (low/medium/high) encoded by DSCP bits 3 and 4."]
    #[doc = ""]
    #[doc = " All IPv4/IPv6 packets have their color marked into DSCP bits 3 and 4 as"]
    #[doc = " follows: green mapped to Low Drop Precedence (2b01), yellow to Medium"]
    #[doc = " (2b10) and red to High (2b11). Marking needs to be explicitly enabled"]
    #[doc = " for each color; when not enabled for a given color, the DSCP field of all"]
    #[doc = " packets with that color is left as is."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[in] mark_green"]
    #[doc = "   Set to non-zero value to enable marking of green packets and to zero to"]
    #[doc = "   disable it."]
    #[doc = " @param[in] mark_yellow"]
    #[doc = "   Set to non-zero value to enable marking of yellow packets and to zero to"]
    #[doc = "   disable it."]
    #[doc = " @param[in] mark_red"]
    #[doc = "   Set to non-zero value to enable marking of red packets and to zero to"]
    #[doc = "   disable it."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details. Filled in only on error, when not NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, non-zero error code otherwise."]
    #[doc = ""]
    #[doc = " @see struct rte_tm_capabilities::mark_ip_dscp_supported"]
    pub fn rte_tm_mark_ip_dscp(
        port_id: u16,
        mark_green: ::std::os::raw::c_int,
        mark_yellow: ::std::os::raw::c_int,
        mark_red: ::std::os::raw::c_int,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @internal Traffic manager node ID validate and type get"]
pub type rte_tm_node_type_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        node_id: u32,
        is_leaf: *mut ::std::os::raw::c_int,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager capabilities get"]
pub type rte_tm_capabilities_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        cap: *mut rte_tm_capabilities,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager level capabilities get"]
pub type rte_tm_level_capabilities_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        level_id: u32,
        cap: *mut rte_tm_level_capabilities,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager node capabilities get"]
pub type rte_tm_node_capabilities_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        node_id: u32,
        cap: *mut rte_tm_node_capabilities,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager WRED profile add"]
pub type rte_tm_wred_profile_add_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        wred_profile_id: u32,
        profile: *mut rte_tm_wred_params,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager WRED profile delete"]
pub type rte_tm_wred_profile_delete_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        wred_profile_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager shared WRED context add"]
pub type rte_tm_shared_wred_context_add_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        shared_wred_context_id: u32,
        wred_profile_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager shared WRED context delete"]
pub type rte_tm_shared_wred_context_delete_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        shared_wred_context_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager shaper profile add"]
pub type rte_tm_shaper_profile_add_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        shaper_profile_id: u32,
        profile: *mut rte_tm_shaper_params,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager shaper profile delete"]
pub type rte_tm_shaper_profile_delete_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        shaper_profile_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager shared shaper add/update"]
pub type rte_tm_shared_shaper_add_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        shared_shaper_id: u32,
        shaper_profile_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager shared shaper delete"]
pub type rte_tm_shared_shaper_delete_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        shared_shaper_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager node add"]
pub type rte_tm_node_add_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        node_id: u32,
        parent_node_id: u32,
        priority: u32,
        weight: u32,
        level_id: u32,
        params: *mut rte_tm_node_params,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager node delete"]
pub type rte_tm_node_delete_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        node_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager node suspend"]
pub type rte_tm_node_suspend_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        node_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager node resume"]
pub type rte_tm_node_resume_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        node_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager hierarchy commit"]
pub type rte_tm_hierarchy_commit_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        clear_on_fail: ::std::os::raw::c_int,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager node parent update"]
pub type rte_tm_node_parent_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        node_id: u32,
        parent_node_id: u32,
        priority: u32,
        weight: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager node shaper update"]
pub type rte_tm_node_shaper_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        node_id: u32,
        shaper_profile_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager node shaper update"]
pub type rte_tm_node_shared_shaper_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        node_id: u32,
        shared_shaper_id: u32,
        add: i32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager node stats update"]
pub type rte_tm_node_stats_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        node_id: u32,
        stats_mask: u64,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager node WFQ weight mode update"]
pub type rte_tm_node_wfq_weight_mode_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        node_id: u32,
        wfq_weight_mode: *mut ::std::os::raw::c_int,
        n_sp_priorities: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager node congestion management mode update"]
pub type rte_tm_node_cman_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        node_id: u32,
        cman: rte_tm_cman_mode,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager node WRED context update"]
pub type rte_tm_node_wred_context_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        node_id: u32,
        wred_profile_id: u32,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager node WRED context update"]
pub type rte_tm_node_shared_wred_context_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        node_id: u32,
        shared_wred_context_id: u32,
        add: ::std::os::raw::c_int,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager read stats counters for specific node"]
pub type rte_tm_node_stats_read_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        node_id: u32,
        stats: *mut rte_tm_node_stats,
        stats_mask: *mut u64,
        clear: ::std::os::raw::c_int,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager packet marking - VLAN DEI"]
pub type rte_tm_mark_vlan_dei_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mark_green: ::std::os::raw::c_int,
        mark_yellow: ::std::os::raw::c_int,
        mark_red: ::std::os::raw::c_int,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager packet marking - IPv4/IPv6 ECN"]
pub type rte_tm_mark_ip_ecn_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mark_green: ::std::os::raw::c_int,
        mark_yellow: ::std::os::raw::c_int,
        mark_red: ::std::os::raw::c_int,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Traffic manager packet marking - IPv4/IPv6 DSCP"]
pub type rte_tm_mark_ip_dscp_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mark_green: ::std::os::raw::c_int,
        mark_yellow: ::std::os::raw::c_int,
        mark_red: ::std::os::raw::c_int,
        error: *mut rte_tm_error,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tm_ops {
    #[doc = " Traffic manager node type get"]
    pub node_type_get: rte_tm_node_type_get_t,
    #[doc = " Traffic manager capabilities_get"]
    pub capabilities_get: rte_tm_capabilities_get_t,
    #[doc = " Traffic manager level capabilities_get"]
    pub level_capabilities_get: rte_tm_level_capabilities_get_t,
    #[doc = " Traffic manager node capabilities get"]
    pub node_capabilities_get: rte_tm_node_capabilities_get_t,
    #[doc = " Traffic manager WRED profile add"]
    pub wred_profile_add: rte_tm_wred_profile_add_t,
    #[doc = " Traffic manager WRED profile delete"]
    pub wred_profile_delete: rte_tm_wred_profile_delete_t,
    #[doc = " Traffic manager shared WRED context add/update"]
    pub shared_wred_context_add_update: rte_tm_shared_wred_context_add_update_t,
    #[doc = " Traffic manager shared WRED context delete"]
    pub shared_wred_context_delete: rte_tm_shared_wred_context_delete_t,
    #[doc = " Traffic manager shaper profile add"]
    pub shaper_profile_add: rte_tm_shaper_profile_add_t,
    #[doc = " Traffic manager shaper profile delete"]
    pub shaper_profile_delete: rte_tm_shaper_profile_delete_t,
    #[doc = " Traffic manager shared shaper add/update"]
    pub shared_shaper_add_update: rte_tm_shared_shaper_add_update_t,
    #[doc = " Traffic manager shared shaper delete"]
    pub shared_shaper_delete: rte_tm_shared_shaper_delete_t,
    #[doc = " Traffic manager node add"]
    pub node_add: rte_tm_node_add_t,
    #[doc = " Traffic manager node delete"]
    pub node_delete: rte_tm_node_delete_t,
    #[doc = " Traffic manager node suspend"]
    pub node_suspend: rte_tm_node_suspend_t,
    #[doc = " Traffic manager node resume"]
    pub node_resume: rte_tm_node_resume_t,
    #[doc = " Traffic manager hierarchy commit"]
    pub hierarchy_commit: rte_tm_hierarchy_commit_t,
    #[doc = " Traffic manager node parent update"]
    pub node_parent_update: rte_tm_node_parent_update_t,
    #[doc = " Traffic manager node shaper update"]
    pub node_shaper_update: rte_tm_node_shaper_update_t,
    #[doc = " Traffic manager node shared shaper update"]
    pub node_shared_shaper_update: rte_tm_node_shared_shaper_update_t,
    #[doc = " Traffic manager node stats update"]
    pub node_stats_update: rte_tm_node_stats_update_t,
    #[doc = " Traffic manager node WFQ weight mode update"]
    pub node_wfq_weight_mode_update: rte_tm_node_wfq_weight_mode_update_t,
    #[doc = " Traffic manager node congestion management mode update"]
    pub node_cman_update: rte_tm_node_cman_update_t,
    #[doc = " Traffic manager node WRED context update"]
    pub node_wred_context_update: rte_tm_node_wred_context_update_t,
    #[doc = " Traffic manager node shared WRED context update"]
    pub node_shared_wred_context_update: rte_tm_node_shared_wred_context_update_t,
    #[doc = " Traffic manager read statistics counters for current node"]
    pub node_stats_read: rte_tm_node_stats_read_t,
    #[doc = " Traffic manager packet marking - VLAN DEI"]
    pub mark_vlan_dei: rte_tm_mark_vlan_dei_t,
    #[doc = " Traffic manager packet marking - IPv4/IPv6 ECN"]
    pub mark_ip_ecn: rte_tm_mark_ip_ecn_t,
    #[doc = " Traffic manager packet marking - IPv4/IPv6 DSCP"]
    pub mark_ip_dscp: rte_tm_mark_ip_dscp_t,
}
extern "C" {
    #[doc = " Get generic traffic manager operations structure from a port"]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param[out] error"]
    #[doc = "   Error details"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The traffic manager operations structure associated with port_id on"]
    #[doc = "   success, NULL otherwise."]
    pub fn rte_tm_ops_get(port_id: u16, error: *mut rte_tm_error) -> *const rte_tm_ops;
}
extern "C" {
    #[doc = "  Test if trace is enabled."]
    #[doc = ""]
    #[doc = "  @return"]
    #[doc = "     true if trace is enabled, false otherwise."]
    pub fn rte_trace_is_enabled() -> bool;
}
#[repr(u32)]
#[doc = " Enumerate trace mode operation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rte_trace_mode {
    #[doc = " In this mode, when no space is left in the trace buffer, the"]
    #[doc = " subsequent events overwrite the old events."]
    RTE_TRACE_MODE_OVERWRITE = 0,
    #[doc = " In this mode, when no space is left in the trace buffer, the"]
    #[doc = " subsequent events shall not be recorded."]
    RTE_TRACE_MODE_DISCARD = 1,
}
extern "C" {
    #[doc = " Set the trace mode."]
    #[doc = ""]
    #[doc = " @param mode"]
    #[doc = "   Trace mode."]
    pub fn rte_trace_mode_set(mode: rte_trace_mode);
}
extern "C" {
    #[doc = " Get the trace mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The current trace mode."]
    pub fn rte_trace_mode_get() -> rte_trace_mode;
}
extern "C" {
    #[doc = " Enable/Disable a set of tracepoints based on globbing pattern."]
    #[doc = ""]
    #[doc = " @param pattern"]
    #[doc = "   The globbing pattern identifying the tracepoint."]
    #[doc = " @param enable"]
    #[doc = "   true to enable tracepoint, false to disable the tracepoint, upon match."]
    #[doc = " @return"]
    #[doc = "   - 0: Success and no pattern match."]
    #[doc = "   - 1: Success and found pattern match."]
    #[doc = "   - (-ERANGE): Tracepoint object is not registered."]
    pub fn rte_trace_pattern(
        pattern: *const ::std::os::raw::c_char,
        enable: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable/Disable a set of tracepoints based on regular expression."]
    #[doc = ""]
    #[doc = " @param regex"]
    #[doc = "   A regular expression identifying the tracepoint."]
    #[doc = " @param enable"]
    #[doc = "   true to enable tracepoint, false to disable the tracepoint, upon match."]
    #[doc = " @return"]
    #[doc = "   - 0: Success and no pattern match."]
    #[doc = "   - 1: Success and found pattern match."]
    #[doc = "   - (-ERANGE): Tracepoint object is not registered."]
    #[doc = "   - (-EINVAL): Invalid regular expression rule."]
    pub fn rte_trace_regexp(
        regex: *const ::std::os::raw::c_char,
        enable: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Save the trace buffer to the trace directory."]
    #[doc = ""]
    #[doc = " By default, trace directory will be created at $HOME directory and this can"]
    #[doc = " be overridden by --trace-dir EAL parameter."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - <0 : Failure."]
    pub fn rte_trace_save() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump the trace metadata to a file."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - <0 : Failure."]
    pub fn rte_trace_metadata_dump(f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump the trace subsystem status to a file."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_trace_dump(f: *mut FILE);
}
extern "C" {
    #[doc = " Function to return DPDK version prefix string"]
    pub fn rte_version_prefix() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Function to return DPDK version year"]
    pub fn rte_version_year() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Function to return DPDK version month"]
    pub fn rte_version_month() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Function to return DPDK minor version number"]
    pub fn rte_version_minor() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Function to return DPDK version suffix for any release candidates"]
    pub fn rte_version_suffix() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Function to return DPDK version release candidate value"]
    pub fn rte_version_release() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Function returning version string"]
    #[doc = " @return"]
    #[doc = "     DPDK version string"]
    pub fn rte_version() -> *const ::std::os::raw::c_char;
}
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_info_cap_header {
    pub id: __u16,
    pub version: __u16,
    pub next: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_group_status {
    pub argsz: __u32,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_device_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub num_regions: __u32,
    pub num_irqs: __u32,
    pub cap_offset: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_region_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub index: __u32,
    pub cap_offset: __u32,
    pub size: __u64,
    pub offset: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_region_sparse_mmap_area {
    pub offset: __u64,
    pub size: __u64,
}
#[repr(C)]
#[derive(Debug)]
pub struct vfio_region_info_cap_sparse_mmap {
    pub header: vfio_info_cap_header,
    pub nr_areas: __u32,
    pub reserved: __u32,
    pub areas: __IncompleteArrayField<vfio_region_sparse_mmap_area>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_region_info_cap_type {
    pub header: vfio_info_cap_header,
    pub type_: __u32,
    pub subtype: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_region_gfx_edid {
    pub edid_offset: __u32,
    pub edid_max_size: __u32,
    pub edid_size: __u32,
    pub max_xres: __u32,
    pub max_yres: __u32,
    pub link_state: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_device_migration_info {
    pub device_state: __u32,
    pub reserved: __u32,
    pub pending_bytes: __u64,
    pub data_offset: __u64,
    pub data_size: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_region_info_cap_nvlink2_ssatgt {
    pub header: vfio_info_cap_header,
    pub tgt: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_region_info_cap_nvlink2_lnkspd {
    pub header: vfio_info_cap_header,
    pub link_speed: __u32,
    pub __pad: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_irq_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub index: __u32,
    pub count: __u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct vfio_irq_set {
    pub argsz: __u32,
    pub flags: __u32,
    pub index: __u32,
    pub start: __u32,
    pub count: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
pub const VFIO_PCI_BAR0_REGION_INDEX: _bindgen_ty_29 = _bindgen_ty_29::VFIO_PCI_BAR0_REGION_INDEX;
pub const VFIO_PCI_BAR1_REGION_INDEX: _bindgen_ty_29 = _bindgen_ty_29::VFIO_PCI_BAR1_REGION_INDEX;
pub const VFIO_PCI_BAR2_REGION_INDEX: _bindgen_ty_29 = _bindgen_ty_29::VFIO_PCI_BAR2_REGION_INDEX;
pub const VFIO_PCI_BAR3_REGION_INDEX: _bindgen_ty_29 = _bindgen_ty_29::VFIO_PCI_BAR3_REGION_INDEX;
pub const VFIO_PCI_BAR4_REGION_INDEX: _bindgen_ty_29 = _bindgen_ty_29::VFIO_PCI_BAR4_REGION_INDEX;
pub const VFIO_PCI_BAR5_REGION_INDEX: _bindgen_ty_29 = _bindgen_ty_29::VFIO_PCI_BAR5_REGION_INDEX;
pub const VFIO_PCI_ROM_REGION_INDEX: _bindgen_ty_29 = _bindgen_ty_29::VFIO_PCI_ROM_REGION_INDEX;
pub const VFIO_PCI_CONFIG_REGION_INDEX: _bindgen_ty_29 =
    _bindgen_ty_29::VFIO_PCI_CONFIG_REGION_INDEX;
pub const VFIO_PCI_VGA_REGION_INDEX: _bindgen_ty_29 = _bindgen_ty_29::VFIO_PCI_VGA_REGION_INDEX;
pub const VFIO_PCI_NUM_REGIONS: _bindgen_ty_29 = _bindgen_ty_29::VFIO_PCI_NUM_REGIONS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_29 {
    VFIO_PCI_BAR0_REGION_INDEX = 0,
    VFIO_PCI_BAR1_REGION_INDEX = 1,
    VFIO_PCI_BAR2_REGION_INDEX = 2,
    VFIO_PCI_BAR3_REGION_INDEX = 3,
    VFIO_PCI_BAR4_REGION_INDEX = 4,
    VFIO_PCI_BAR5_REGION_INDEX = 5,
    VFIO_PCI_ROM_REGION_INDEX = 6,
    VFIO_PCI_CONFIG_REGION_INDEX = 7,
    VFIO_PCI_VGA_REGION_INDEX = 8,
    VFIO_PCI_NUM_REGIONS = 9,
}
pub const VFIO_PCI_INTX_IRQ_INDEX: _bindgen_ty_30 = _bindgen_ty_30::VFIO_PCI_INTX_IRQ_INDEX;
pub const VFIO_PCI_MSI_IRQ_INDEX: _bindgen_ty_30 = _bindgen_ty_30::VFIO_PCI_MSI_IRQ_INDEX;
pub const VFIO_PCI_MSIX_IRQ_INDEX: _bindgen_ty_30 = _bindgen_ty_30::VFIO_PCI_MSIX_IRQ_INDEX;
pub const VFIO_PCI_ERR_IRQ_INDEX: _bindgen_ty_30 = _bindgen_ty_30::VFIO_PCI_ERR_IRQ_INDEX;
pub const VFIO_PCI_REQ_IRQ_INDEX: _bindgen_ty_30 = _bindgen_ty_30::VFIO_PCI_REQ_IRQ_INDEX;
pub const VFIO_PCI_NUM_IRQS: _bindgen_ty_30 = _bindgen_ty_30::VFIO_PCI_NUM_IRQS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_30 {
    VFIO_PCI_INTX_IRQ_INDEX = 0,
    VFIO_PCI_MSI_IRQ_INDEX = 1,
    VFIO_PCI_MSIX_IRQ_INDEX = 2,
    VFIO_PCI_ERR_IRQ_INDEX = 3,
    VFIO_PCI_REQ_IRQ_INDEX = 4,
    VFIO_PCI_NUM_IRQS = 5,
}
pub const VFIO_CCW_CONFIG_REGION_INDEX: _bindgen_ty_31 =
    _bindgen_ty_31::VFIO_CCW_CONFIG_REGION_INDEX;
pub const VFIO_CCW_NUM_REGIONS: _bindgen_ty_31 = _bindgen_ty_31::VFIO_CCW_NUM_REGIONS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_31 {
    VFIO_CCW_CONFIG_REGION_INDEX = 0,
    VFIO_CCW_NUM_REGIONS = 1,
}
pub const VFIO_CCW_IO_IRQ_INDEX: _bindgen_ty_32 = _bindgen_ty_32::VFIO_CCW_IO_IRQ_INDEX;
pub const VFIO_CCW_CRW_IRQ_INDEX: _bindgen_ty_32 = _bindgen_ty_32::VFIO_CCW_CRW_IRQ_INDEX;
pub const VFIO_CCW_NUM_IRQS: _bindgen_ty_32 = _bindgen_ty_32::VFIO_CCW_NUM_IRQS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_32 {
    VFIO_CCW_IO_IRQ_INDEX = 0,
    VFIO_CCW_CRW_IRQ_INDEX = 1,
    VFIO_CCW_NUM_IRQS = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_pci_dependent_device {
    pub group_id: __u32,
    pub segment: __u16,
    pub bus: __u8,
    pub devfn: __u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct vfio_pci_hot_reset_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub count: __u32,
    pub devices: __IncompleteArrayField<vfio_pci_dependent_device>,
}
#[repr(C)]
#[derive(Debug)]
pub struct vfio_pci_hot_reset {
    pub argsz: __u32,
    pub flags: __u32,
    pub count: __u32,
    pub group_fds: __IncompleteArrayField<__s32>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vfio_device_gfx_plane_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub drm_plane_type: __u32,
    pub drm_format: __u32,
    pub drm_format_mod: __u64,
    pub width: __u32,
    pub height: __u32,
    pub stride: __u32,
    pub size: __u32,
    pub x_pos: __u32,
    pub y_pos: __u32,
    pub x_hot: __u32,
    pub y_hot: __u32,
    pub __bindgen_anon_1: vfio_device_gfx_plane_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vfio_device_gfx_plane_info__bindgen_ty_1 {
    pub region_index: __u32,
    pub dmabuf_id: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_device_ioeventfd {
    pub argsz: __u32,
    pub flags: __u32,
    pub offset: __u64,
    pub data: __u64,
    pub fd: __s32,
}
#[repr(C)]
#[derive(Debug)]
pub struct vfio_device_feature {
    pub argsz: __u32,
    pub flags: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iommu_type1_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub iova_pgsizes: __u64,
    pub cap_offset: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iova_range {
    pub start: __u64,
    pub end: __u64,
}
#[repr(C)]
#[derive(Debug)]
pub struct vfio_iommu_type1_info_cap_iova_range {
    pub header: vfio_info_cap_header,
    pub nr_iovas: __u32,
    pub reserved: __u32,
    pub iova_ranges: __IncompleteArrayField<vfio_iova_range>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iommu_type1_info_cap_migration {
    pub header: vfio_info_cap_header,
    pub flags: __u32,
    pub pgsize_bitmap: __u64,
    pub max_dirty_bitmap_size: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iommu_type1_info_dma_avail {
    pub header: vfio_info_cap_header,
    pub avail: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iommu_type1_dma_map {
    pub argsz: __u32,
    pub flags: __u32,
    pub vaddr: __u64,
    pub iova: __u64,
    pub size: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_bitmap {
    pub pgsize: __u64,
    pub size: __u64,
    pub data: *mut __u64,
}
#[repr(C)]
#[derive(Debug)]
pub struct vfio_iommu_type1_dma_unmap {
    pub argsz: __u32,
    pub flags: __u32,
    pub iova: __u64,
    pub size: __u64,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Debug)]
pub struct vfio_iommu_type1_dirty_bitmap {
    pub argsz: __u32,
    pub flags: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iommu_type1_dirty_bitmap_get {
    pub iova: __u64,
    pub size: __u64,
    pub bitmap: vfio_bitmap,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iommu_spapr_tce_ddw_info {
    pub pgsizes: __u64,
    pub max_dynamic_windows_supported: __u32,
    pub levels: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iommu_spapr_tce_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub dma32_window_start: __u32,
    pub dma32_window_size: __u32,
    pub ddw: vfio_iommu_spapr_tce_ddw_info,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_eeh_pe_err {
    pub type_: __u32,
    pub func: __u32,
    pub addr: __u64,
    pub mask: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vfio_eeh_pe_op {
    pub argsz: __u32,
    pub flags: __u32,
    pub op: __u32,
    pub __bindgen_anon_1: vfio_eeh_pe_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vfio_eeh_pe_op__bindgen_ty_1 {
    pub err: vfio_eeh_pe_err,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iommu_spapr_register_memory {
    pub argsz: __u32,
    pub flags: __u32,
    pub vaddr: __u64,
    pub size: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iommu_spapr_tce_create {
    pub argsz: __u32,
    pub flags: __u32,
    pub page_shift: __u32,
    pub __resv1: __u32,
    pub window_size: __u64,
    pub levels: __u32,
    pub __resv2: __u32,
    pub start_addr: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iommu_spapr_tce_remove {
    pub argsz: __u32,
    pub flags: __u32,
    pub start_addr: __u64,
}
extern "C" {
    #[doc = " Setup vfio_cfg for the device identified by its address."]
    #[doc = " It discovers the configured I/O MMU groups or sets a new one for the device."]
    #[doc = " If a new groups is assigned, the DMA mapping is performed."]
    #[doc = ""]
    #[doc = " This function is only relevant to linux and will return"]
    #[doc = " an error on BSD."]
    #[doc = ""]
    #[doc = " @param sysfs_base"]
    #[doc = "   sysfs path prefix."]
    #[doc = ""]
    #[doc = " @param dev_addr"]
    #[doc = "   device location."]
    #[doc = ""]
    #[doc = " @param vfio_dev_fd"]
    #[doc = "   VFIO fd."]
    #[doc = ""]
    #[doc = " @param device_info"]
    #[doc = "   Device information."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success."]
    #[doc = "   <0 on failure."]
    #[doc = "   >1 if the device cannot be managed this way."]
    pub fn rte_vfio_setup_device(
        sysfs_base: *const ::std::os::raw::c_char,
        dev_addr: *const ::std::os::raw::c_char,
        vfio_dev_fd: *mut ::std::os::raw::c_int,
        device_info: *mut vfio_device_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release a device mapped to a VFIO-managed I/O MMU group."]
    #[doc = ""]
    #[doc = " This function is only relevant to linux and will return"]
    #[doc = " an error on BSD."]
    #[doc = ""]
    #[doc = " @param sysfs_base"]
    #[doc = "   sysfs path prefix."]
    #[doc = ""]
    #[doc = " @param dev_addr"]
    #[doc = "   device location."]
    #[doc = ""]
    #[doc = " @param fd"]
    #[doc = "   VFIO fd."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success."]
    #[doc = "   <0 on failure."]
    pub fn rte_vfio_release_device(
        sysfs_base: *const ::std::os::raw::c_char,
        dev_addr: *const ::std::os::raw::c_char,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable a VFIO-related kmod."]
    #[doc = ""]
    #[doc = " This function is only relevant to linux and will return"]
    #[doc = " an error on BSD."]
    #[doc = ""]
    #[doc = " @param modname"]
    #[doc = "   kernel module name."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success."]
    #[doc = "   <0 on failure."]
    pub fn rte_vfio_enable(modname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check whether a VFIO-related kmod is enabled."]
    #[doc = ""]
    #[doc = " This function is only relevant to Linux."]
    #[doc = ""]
    #[doc = " @param modname"]
    #[doc = "   kernel module name."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   1 if true."]
    #[doc = "   0 otherwise."]
    pub fn rte_vfio_is_enabled(modname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Whether VFIO NOIOMMU mode is enabled."]
    #[doc = ""]
    #[doc = " This function is only relevant to Linux."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   1 if true."]
    #[doc = "   0 if false."]
    #[doc = "   <0 for errors."]
    pub fn rte_vfio_noiommu_is_enabled() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove group fd from internal VFIO group fd array/"]
    #[doc = ""]
    #[doc = " This function is only relevant to linux and will return"]
    #[doc = " an error on BSD."]
    #[doc = ""]
    #[doc = " @param vfio_group_fd"]
    #[doc = "   VFIO Group FD."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success."]
    #[doc = "   <0 on failure."]
    pub fn rte_vfio_clear_group(vfio_group_fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse IOMMU group number for a device"]
    #[doc = ""]
    #[doc = " This function is only relevant to linux and will return"]
    #[doc = " an error on BSD."]
    #[doc = ""]
    #[doc = " @param sysfs_base"]
    #[doc = "   sysfs path prefix."]
    #[doc = ""]
    #[doc = " @param dev_addr"]
    #[doc = "   device location."]
    #[doc = ""]
    #[doc = " @param iommu_group_num"]
    #[doc = "   iommu group number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  >0 on success"]
    #[doc = "   0 for non-existent group or VFIO"]
    #[doc = "  <0 for errors"]
    pub fn rte_vfio_get_group_num(
        sysfs_base: *const ::std::os::raw::c_char,
        dev_addr: *const ::std::os::raw::c_char,
        iommu_group_num: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Open a new VFIO container fd"]
    #[doc = ""]
    #[doc = " This function is only relevant to linux and will return"]
    #[doc = " an error on BSD."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  > 0 container fd"]
    #[doc = "  < 0 for errors"]
    pub fn rte_vfio_get_container_fd() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Open VFIO group fd or get an existing one"]
    #[doc = ""]
    #[doc = " This function is only relevant to linux and will return"]
    #[doc = " an error on BSD."]
    #[doc = ""]
    #[doc = " @param iommu_group_num"]
    #[doc = "   iommu group number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  > 0 group fd"]
    #[doc = "  < 0 for errors"]
    pub fn rte_vfio_get_group_fd(iommu_group_num: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new container for device binding."]
    #[doc = ""]
    #[doc = " @note Any newly allocated DPDK memory will not be mapped into these"]
    #[doc = "       containers by default, user needs to manage DMA mappings for"]
    #[doc = "       any container created by this API."]
    #[doc = ""]
    #[doc = " @note When creating containers using this API, the container will only be"]
    #[doc = "       available in the process that has created it. Sharing containers and"]
    #[doc = "       devices between multiple processes is not supported."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   the container fd if successful"]
    #[doc = "   <0 if failed"]
    pub fn rte_vfio_container_create() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy the container, unbind all vfio groups within it."]
    #[doc = ""]
    #[doc = " @param container_fd"]
    #[doc = "   the container fd to destroy"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    0 if successful"]
    #[doc = "   <0 if failed"]
    pub fn rte_vfio_container_destroy(container_fd: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Bind a IOMMU group to a container."]
    #[doc = ""]
    #[doc = " @param container_fd"]
    #[doc = "   the container's fd"]
    #[doc = ""]
    #[doc = " @param iommu_group_num"]
    #[doc = "   the iommu group number to bind to container"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   group fd if successful"]
    #[doc = "   <0 if failed"]
    pub fn rte_vfio_container_group_bind(
        container_fd: ::std::os::raw::c_int,
        iommu_group_num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unbind a IOMMU group from a container."]
    #[doc = ""]
    #[doc = " @param container_fd"]
    #[doc = "   the container fd of container"]
    #[doc = ""]
    #[doc = " @param iommu_group_num"]
    #[doc = "   the iommu group number to delete from container"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    0 if successful"]
    #[doc = "   <0 if failed"]
    pub fn rte_vfio_container_group_unbind(
        container_fd: ::std::os::raw::c_int,
        iommu_group_num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Perform DMA mapping for devices in a container."]
    #[doc = ""]
    #[doc = " @param container_fd"]
    #[doc = "   the specified container fd. Use RTE_VFIO_DEFAULT_CONTAINER_FD to"]
    #[doc = "   use the default container."]
    #[doc = ""]
    #[doc = " @param vaddr"]
    #[doc = "   Starting virtual address of memory to be mapped."]
    #[doc = ""]
    #[doc = " @param iova"]
    #[doc = "   Starting IOVA address of memory to be mapped."]
    #[doc = ""]
    #[doc = " @param len"]
    #[doc = "   Length of memory segment being mapped."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    0 if successful"]
    #[doc = "   <0 if failed"]
    pub fn rte_vfio_container_dma_map(
        container_fd: ::std::os::raw::c_int,
        vaddr: u64,
        iova: u64,
        len: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Perform DMA unmapping for devices in a container."]
    #[doc = ""]
    #[doc = " @param container_fd"]
    #[doc = "   the specified container fd. Use RTE_VFIO_DEFAULT_CONTAINER_FD to"]
    #[doc = "   use the default container."]
    #[doc = ""]
    #[doc = " @param vaddr"]
    #[doc = "   Starting virtual address of memory to be unmapped."]
    #[doc = ""]
    #[doc = " @param iova"]
    #[doc = "   Starting IOVA address of memory to be unmapped."]
    #[doc = ""]
    #[doc = " @param len"]
    #[doc = "   Length of memory segment being unmapped."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    0 if successful"]
    #[doc = "   <0 if failed"]
    pub fn rte_vfio_container_dma_unmap(
        container_fd: ::std::os::raw::c_int,
        vaddr: u64,
        iova: u64,
        len: u64,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[doc = "< Opaque item handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_flex_handle {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_event_timer_adapter_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_timer_adapter_ops {
    pub _address: u8,
}
